/* THIS FILE IS CURRENTLY IGNORED! We are using the generated core-java.js instead, for now. */
/* Generated from Java with JSweet 3.2.0-SNAPSHOT - http://www.jsweet.org */
namespace org.w3c.dom {
    export interface Element extends org.w3c.dom.Node {
        getOwnerDocument(): org.w3c.dom.Document;

        setAttribute(name: string, value: string);

        getElementsByTagName(name: string): org.w3c.dom.NodeList;

        setAttributeNS(namespaceURI: string, qualifiedName: string, value: string);

        getAttribute(name: string): string;

        setTextContent(text: string);

        getUserData(key: string): any;
    }
}
namespace org.w3c.dom {
    export interface Text extends org.w3c.dom.Node {    }
}
namespace org.w3c.dom {
    export interface Node {
        appendChild(newChild: Node): Node;

        getChildNodes(): org.w3c.dom.NodeList;

        getTextContent(): string;

        getLocalName(): string;
    }
}
namespace org.w3c.dom {
    export interface Document {
        createElement(name: string): org.w3c.dom.Element;

        createTextNode(data: string): org.w3c.dom.Text;

        importNode(importedNode: org.w3c.dom.Node, deep: boolean): org.w3c.dom.Node;
    }
}
namespace org.w3c.dom {
    export interface NodeList {
        item(index: number): org.w3c.dom.Node;

        getLength(): number;
    }
}
namespace java.util {
    export class UUID {
        /*private*/ value: string;

        constructor(s: string) {
            if (this.value === undefined) { this.value = null; }
            this.value = s;
        }

        public static randomUUID(): UUID {
            return new UUID(/* toString */(''+(Math.random())).substring(2));
        }

        public toString(): string {
            return this.value;
        }

        public static fromString(s: string): UUID {
            return new UUID(s);
        }
    }
    UUID["__class"] = "java.util.UUID";

}
namespace java.util {
    export class Properties {
        public getProperty(key: string): string {
            return "";
        }

        public load(inStream: java.io.InputStream) {
        }

        public isEmpty(): boolean {
            return true;
        }
    }
    Properties["__class"] = "java.util.Properties";

}
namespace java.io {
    export class File {
        public constructor(parent: File, name: string) {
        }

        public exists(): boolean {
            return false;
        }

        public getAbsolutePath(): string {
            return null;
        }

        public getName(): string {
            return null;
        }

        public getParentFile(): File {
            return null;
        }
    }
    File["__class"] = "java.io.File";

}
namespace java.io {
    export class StringWriter extends java.io.Writer {
        /*private*/ baos: java.io.ByteArrayOutputStream;

        /*private*/ w: java.io.OutputStreamWriter;

        public constructor() {
            super();
            if (this.baos === undefined) { this.baos = null; }
            if (this.w === undefined) { this.w = null; }
            this.baos = new java.io.ByteArrayOutputStream();
            this.w = new java.io.OutputStreamWriter(this.baos);
        }

        public toString(): string {
            return this.baos.toString();
        }

        public flush() {
            try {
                this.w.flush();
            } catch(e) {
                console.error(e.message, e);
            }
        }

        public close() {
            try {
                this.w.close();
            } catch(e) {
                console.error(e.message, e);
            }
        }

        public write(cbuf: string[], off: number, len: number) {
            try {
                this.w.write(cbuf, off, len);
            } catch(e) {
                console.error(e.message, e);
            }
        }
    }
    StringWriter["__class"] = "java.io.StringWriter";
    StringWriter["__interfaces"] = ["java.lang.Appendable","java.io.Closeable","java.lang.AutoCloseable","java.io.Flushable"];


}
namespace java.io {
    export class PrintWriter extends java.io.Writer {
        /*private*/ w: java.io.Writer;

        public constructor(w: java.io.Writer) {
            super();
            if (this.w === undefined) { this.w = null; }
            this.w = w;
        }

        public flush() {
            try {
                this.w.flush();
            } catch(e) {
                console.error(e.message, e);
            }
        }

        public close() {
            try {
                this.w.close();
            } catch(e) {
                console.error(e.message, e);
            }
        }

        public write$char_A$int$int(cbuf: string[], off: number, len: number) {
            try {
                this.w.write(cbuf, off, len);
            } catch(e) {
                console.error(e.message, e);
            }
        }

        public write(cbuf?: any, off?: any, len?: any) {
            if (((cbuf != null && cbuf instanceof <any>Array && (cbuf.length == 0 || cbuf[0] == null ||(typeof cbuf[0] === 'string'))) || cbuf === null) && ((typeof off === 'number') || off === null) && ((typeof len === 'number') || len === null)) {
                return <any>this.write$char_A$int$int(cbuf, off, len);
            } else if (((typeof cbuf === 'string') || cbuf === null) && off === undefined && len === undefined) {
                return <any>this.write$java_lang_String(cbuf);
            } else throw new Error('invalid overload');
        }

        public write$java_lang_String(str: string) {
            try {
                this.w.write(str);
            } catch(e) {
                console.error(e.message, e);
            }
        }

        public println$() {
            this.print("\n");
        }

        public print(x: any) {
            if (!(typeof x === 'string'))x = x.toString();
            const chars: string[] = /* toCharArray */((<string>x)).split('');
            this.write$char_A$int$int(chars, 0, chars.length);
        }

        public println$java_lang_Object(x: any) {
            this.print(x);
            this.println$();
        }

        public println(x?: any) {
            if (((x != null) || x === null)) {
                return <any>this.println$java_lang_Object(x);
            } else if (x === undefined) {
                return <any>this.println$();
            } else throw new Error('invalid overload');
        }
    }
    PrintWriter["__class"] = "java.io.PrintWriter";
    PrintWriter["__interfaces"] = ["java.lang.Appendable","java.io.Closeable","java.lang.AutoCloseable","java.io.Flushable"];


}
namespace java.beans {
    export class PropertyChangeEvent extends java.util.EventObject {
        static __java_beans_PropertyChangeEvent_serialVersionUID: number = 7042693688939648123;

        public constructor(source: any, propertyName: string, oldValue: any, newValue: any) {
            super(source);
            if (this.propertyName === undefined) { this.propertyName = null; }
            if (this.newValue === undefined) { this.newValue = null; }
            if (this.oldValue === undefined) { this.oldValue = null; }
            if (this.propagationId === undefined) { this.propagationId = null; }
            this.propertyName = propertyName;
            this.newValue = newValue;
            this.oldValue = oldValue;
        }

        public getPropertyName(): string {
            return this.propertyName;
        }

        public getNewValue(): any {
            return this.newValue;
        }

        public getOldValue(): any {
            return this.oldValue;
        }

        public setPropagationId(propagationId: any) {
            this.propagationId = propagationId;
        }

        public getPropagationId(): any {
            return this.propagationId;
        }

        /*private*/ propertyName: string;

        /*private*/ newValue: any;

        /*private*/ oldValue: any;

        /*private*/ propagationId: any;

        public toString(): string {
            const sb: java.lang.StringBuilder = new java.lang.StringBuilder(/* getName */(c => typeof c === 'string' ? c : c["__class"] ? c["__class"] : c["name"])((<any>this.constructor)));
            sb.append("[propertyName=").append(this.getPropertyName());
            this.appendTo(sb);
            sb.append("; oldValue=").append(this.getOldValue());
            sb.append("; newValue=").append(this.getNewValue());
            sb.append("; propagationId=").append(this.getPropagationId());
            sb.append("; source=").append(this.getSource());
            return sb.append("]").toString();
        }

        appendTo(sb: java.lang.StringBuilder) {
        }
    }
    PropertyChangeEvent["__class"] = "java.beans.PropertyChangeEvent";
    PropertyChangeEvent["__interfaces"] = ["java.io.Serializable"];


}
namespace java.beans {
    export abstract class ChangeListenerMap<L extends java.util.EventListener> {
        /*private*/ map: java.util.Map<string, L[]>;

        abstract newArray(length: number): L[];

        abstract newProxy(name: string, listener: L): L;

        public add(name: string, listener: L) {
            if (this.map == null){
                this.map = <any>(new java.util.HashMap<any, any>());
            }
            const array: L[] = this.map.get(name);
            const size: number = (array != null) ? array.length : 0;
            const clone: L[] = this.newArray(size + 1);
            clone[size] = listener;
            if (array != null){
                java.lang.System.arraycopy(array, 0, clone, 0, size);
            }
            this.map.put(name, clone);
        }

        public remove(name: string, listener: L) {
            if (this.map != null){
                const array: L[] = this.map.get(name);
                if (array != null){
                    for(let i: number = 0; i < array.length; i++) {{
                        if (listener.equals(array[i])){
                            const size: number = array.length - 1;
                            if (size > 0){
                                const clone: L[] = this.newArray(size);
                                java.lang.System.arraycopy(array, 0, clone, 0, i);
                                java.lang.System.arraycopy(array, i + 1, clone, i, size - i);
                                this.map.put(name, clone);
                            } else {
                                this.map.remove(name);
                                if (this.map.isEmpty()){
                                    this.map = null;
                                }
                            }
                            break;
                        }
                    };}
                }
            }
        }

        /**
         * Returns the list of listeners for the specified property.
         * 
         * @param {string} name
         * the name of the property
         * @return {L[]} the corresponding list of listeners
         */
        public get(name: string): L[] {
            return (this.map != null) ? this.map.get(name) : null;
        }

        /**
         * Sets new list of listeners for the specified property.
         * 
         * @param {string} name
         * the name of the property
         * @param {L[]} listeners
         * new list of listeners
         */
        public set(name: string, listeners: L[]) {
            if (listeners != null){
                if (this.map == null){
                    this.map = <any>(new java.util.HashMap<any, any>());
                }
                this.map.put(name, listeners);
            } else if (this.map != null){
                this.map.remove(name);
                if (this.map.isEmpty()){
                    this.map = null;
                }
            }
        }

        public getListeners$(): L[] {
            if (this.map == null){
                return this.newArray(0);
            }
            const list: java.util.List<L> = <any>(new java.util.ArrayList<any>());
            const listeners: L[] = this.map.get(null);
            if (listeners != null){
                for(let index = 0; index < listeners.length; index++) {
                    let listener = listeners[index];
                    {
                        list.add(listener);
                    }
                }
            }
            for(let index=this.map.entrySet().iterator();index.hasNext();) {
                let entry = index.next();
                {
                    const name: string = entry.getKey();
                    if (name != null){
                        {
                            let array = entry.getValue();
                            for(let index = 0; index < array.length; index++) {
                                let listener = array[index];
                                {
                                    list.add(this.newProxy(name, listener));
                                }
                            }
                        }
                    }
                }
            }
            return list.toArray<any>(this.newArray(list.size()));
        }

        public getListeners$java_lang_String(name: string): L[] {
            if (name != null){
                const listeners: L[] = this.get(name);
                if (listeners != null){
                    return (listeners).slice(0);
                }
            }
            return this.newArray(0);
        }

        /**
         * Returns listeners that have been associated with the named property.
         * 
         * @param {string} name
         * the name of the property
         * @return {L[]} an array of listeners for the named property
         */
        public getListeners(name?: any): L[] {
            if (((typeof name === 'string') || name === null)) {
                return <any>this.getListeners$java_lang_String(name);
            } else if (name === undefined) {
                return <any>this.getListeners$();
            } else throw new Error('invalid overload');
        }

        /**
         * Indicates whether the map contains at least one listener to be notified.
         * 
         * @param {string} name
         * the name of the property
         * @return {boolean} {@code true} if at least one listener exists or {@code false}
         * otherwise
         */
        public hasListeners(name: string): boolean {
            if (this.map == null){
                return false;
            }
            const array: L[] = this.map.get(null);
            return (array != null) || ((name != null) && (null != this.map.get(name)));
        }

        /**
         * Returns a set of entries from the map. Each entry is a pair consisted of
         * the property name and the corresponding list of listeners.
         * 
         * @return {*} a set of entries from the map
         */
        public getEntries(): java.util.Set<java.util.Map.Entry<string, L[]>> {
            return (this.map != null) ? this.map.entrySet() : java.util.Collections.emptySet<java.util.Map.Entry<string, L[]>>();
        }

        /**
         * Extracts a real listener from the proxy listener. It is necessary because
         * default proxy class is not serializable.
         * 
         * @return {*} a real listener
         * @param {*} listener
         */
        public abstract extract(listener: L): L;

        constructor() {
            if (this.map === undefined) { this.map = null; }
        }
    }
    ChangeListenerMap["__class"] = "java.beans.ChangeListenerMap";

}
namespace java.beans {
    export interface PropertyChangeListener extends java.util.EventListener {
        propertyChange(evt: java.beans.PropertyChangeEvent);
    }
}
namespace java.beans {
    /**
     * Constructor which binds the {@code PropertyChangeListener}
     * to a specific property.
     * 
     * @param {string} propertyName  the name of the property to listen on
     * @param {*} listener      the listener object
     * @class
     * @extends java.util.EventListenerProxy
     */
    export class PropertyChangeListenerProxy extends java.util.EventListenerProxy<java.beans.PropertyChangeListener> implements java.beans.PropertyChangeListener {
        /*private*/ propertyName: string;

        public constructor(propertyName: string, listener: java.beans.PropertyChangeListener) {
            super(listener);
            if (this.propertyName === undefined) { this.propertyName = null; }
            this.propertyName = propertyName;
        }

        /**
         * Forwards the property change event to the listener delegate.
         * 
         * @param {java.beans.PropertyChangeEvent} event  the property change event
         */
        public propertyChange(event: java.beans.PropertyChangeEvent) {
            this.getListener().propertyChange(event);
        }

        /**
         * Returns the name of the named property associated with the listener.
         * 
         * @return {string} the name of the named property associated with the listener
         */
        public getPropertyName(): string {
            return this.propertyName;
        }
    }
    PropertyChangeListenerProxy["__class"] = "java.beans.PropertyChangeListenerProxy";
    PropertyChangeListenerProxy["__interfaces"] = ["java.util.EventListener","java.beans.PropertyChangeListener"];


}
namespace java.nio {
    export class FloatBuffer {
        public put(offset: number, x: number) {
        }
    }
    FloatBuffer["__class"] = "java.nio.FloatBuffer";

}
namespace java.awt.geom {
    export class GeneralPath {
        /*private*/ xs: java.util.ArrayList<any>;

        /*private*/ ys: java.util.ArrayList<any>;

        /*private*/ actions: java.util.ArrayList<any>;

        public moveTo(x: number, y: number) {
            this.xs.add(x);
            this.ys.add(y);
            this.actions.add(java.awt.geom.PathIterator.SEG_MOVETO);
        }

        public lineTo(x: number, y: number) {
            this.xs.add(x);
            this.ys.add(y);
            this.actions.add(java.awt.geom.PathIterator.SEG_LINETO);
        }

        public closePath() {
            this.xs.add(0);
            this.ys.add(0);
            this.actions.add(java.awt.geom.PathIterator.SEG_CLOSE);
        }

        public getPathIterator(at: any): java.awt.geom.PathIterator {
            return new GeneralPath.GeneralPath$0(this);
        }

        constructor() {
            this.xs = <any>(new java.util.ArrayList());
            this.ys = <any>(new java.util.ArrayList());
            this.actions = <any>(new java.util.ArrayList());
        }
    }
    GeneralPath["__class"] = "java.awt.geom.GeneralPath";


    export namespace GeneralPath {

        export class GeneralPath$0 implements java.awt.geom.PathIterator {
            public __parent: any;
            index: number;

            public isDone(): boolean {
                return this.index === this.__parent.actions.size();
            }

            public currentSegment(coords: number[]): number {
                coords[0] = <number>this.__parent.xs.get(this.index);
                coords[1] = <number>this.__parent.ys.get(this.index);
                return (<number>this.__parent.actions.get(this.index)|0);
            }

            public next() {
                ++this.index;
            }

            constructor(__parent: any) {
                this.__parent = __parent;
                this.index = 0;
            }
        }
        GeneralPath$0["__interfaces"] = ["java.awt.geom.PathIterator"];


    }

}
namespace java.awt.geom {
    export interface PathIterator {
        isDone(): boolean;

        currentSegment(coords: number[]): number;

        next();
    }

    export namespace PathIterator {

        export const SEG_MOVETO: number = 0;

        export const SEG_LINETO: number = 1;

        export const SEG_CLOSE: number = 4;
    }

}
namespace java.awt.geom {
    export abstract class Rectangle2D {
        public abstract getWidth(): number;

        public abstract getHeight(): number;
    }
    Rectangle2D["__class"] = "java.awt.geom.Rectangle2D";


    export namespace Rectangle2D {

        export class Float extends java.awt.geom.Rectangle2D {
            public width: number;

            public height: number;

            public constructor(x: number, y: number, w: number, h: number) {
                super();
                if (this.width === undefined) { this.width = 0; }
                if (this.height === undefined) { this.height = 0; }
                this.width = w;
                this.height = h;
            }

            public getWidth(): number {
                return <number>this.width;
            }

            public getHeight(): number {
                return <number>this.height;
            }
        }
        Float["__class"] = "java.awt.geom.Rectangle2D.Float";

    }

}
namespace java.awt {
    export class Dimension {
        /*private*/ width: number;

        /*private*/ height: number;

        public constructor(width: number, height: number) {
            if (this.width === undefined) { this.width = 0; }
            if (this.height === undefined) { this.height = 0; }
            this.width = width;
            this.height = height;
        }
    }
    Dimension["__class"] = "java.awt.Dimension";

}
namespace java.awt {
    export class Color {
        public static WHITE: Color; public static WHITE_$LI$(): Color { if (Color.WHITE == null) { Color.WHITE = new Color(255, 255, 255); }  return Color.WHITE; }

        public static BLACK: Color; public static BLACK_$LI$(): Color { if (Color.BLACK == null) { Color.BLACK = new Color(0, 0, 0); }  return Color.BLACK; }

        /*private*/ value: number;

        public constructor(r?: any, g?: any, b?: any, a?: any) {
            if (((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null) && ((typeof a === 'number') || a === null)) {
                let __args = arguments;
                if (this.value === undefined) { this.value = 0; } 
                this.value = ((a & 255) << 24) | ((r & 255) << 16) | ((g & 255) << 8) | ((b & 255) << 0);
            } else if (((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null) && a === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let a: any = 255;
                    if (this.value === undefined) { this.value = 0; } 
                    this.value = ((a & 255) << 24) | ((r & 255) << 16) | ((g & 255) << 8) | ((b & 255) << 0);
                }
            } else if (((typeof r === 'number') || r === null) && g === undefined && b === undefined && a === undefined) {
                let __args = arguments;
                let rgb: any = __args[0];
                if (this.value === undefined) { this.value = 0; } 
                this.value = -16777216 | rgb;
            } else throw new Error('invalid overload');
        }

        public getRed(): number {
            return (this.value >> 16) & 255;
        }

        public getGreen(): number {
            return (this.value >> 8) & 255;
        }

        public getBlue(): number {
            return (this.value >> 0) & 255;
        }

        public getRGB(): number {
            return this.value;
        }

        public getRGBColorComponents(compArray: number[]): number[] {
            const f: number[] = [0, 0, 0];
            f[0] = (<any>Math).fround((<number>this.getRed()) / 255.0);
            f[1] = (<any>Math).fround((<number>this.getGreen()) / 255.0);
            f[2] = (<any>Math).fround((<number>this.getBlue()) / 255.0);
            return f;
        }
    }
    Color["__class"] = "java.awt.Color";

}
namespace java.text {
    export class NumberFormat {
        public static getNumberInstance(us: java.util.Locale): NumberFormat {
            return new NumberFormat();
        }

        public static getInstance(): NumberFormat {
            return new NumberFormat();
        }

        public setMaximumFractionDigits(i: number) {
        }

        public setMinimumFractionDigits(i: number) {
        }

        public format(x: number): string {
            return /* toString */(''+(x));
        }

        public setGroupingUsed(newValue: boolean) {
        }
    }
    NumberFormat["__class"] = "java.text.NumberFormat";

}
namespace com.vzome.jsweet {
    export class JsSelection implements com.vzome.core.editor.api.Selection {
        /*private*/ adapter: Object;

        /*private*/ field: com.vzome.jsweet.JsAlgebraicField;

        public constructor(field: com.vzome.jsweet.JsAlgebraicField, adapter: Object) {
            if (this.adapter === undefined) { this.adapter = null; }
            if (this.field === undefined) { this.field = null; }
            this.field = field;
            this.adapter = adapter;
        }

        setAdapter(adapter: Object) {
            this.adapter = adapter;
        }

        /**
         * 
         * @return {*}
         */
        public iterator(): java.util.Iterator<com.vzome.core.model.Manifestation> {
            if (this.adapter == null)return java.util.Collections.emptyIterator<any>();
            const f: Function = <any>(this.adapter["selectedIterator"]);
            const jSiterator: Iterator<number[][][]> = <Iterator<number[][][]>>f.apply(this.adapter);
            return new JsSelection.JsSelection$0(this, jSiterator);
        }

        /**
         * 
         */
        public clear() {
            (<any>(this.adapter["clearSelection"])).apply(this.adapter);
        }

        /**
         * 
         * @param {*} man
         * @return {boolean}
         */
        public manifestationSelected(man: com.vzome.core.model.Manifestation): boolean {
            const vectors: number[][][] = (<com.vzome.jsweet.JsManifestation><any>man).getVectors();
            return <boolean>(<any>(this.adapter["manifestationSelected"])).apply(this.adapter, [vectors]);
        }

        /**
         * 
         * @param {*} man
         */
        public select(man: com.vzome.core.model.Manifestation) {
            const vectors: number[][][] = (<com.vzome.jsweet.JsManifestation><any>man).getVectors();
            (<any>(this.adapter["select"])).apply(this.adapter, [vectors]);
        }

        /**
         * 
         * @param {*} man
         */
        public unselect(man: com.vzome.core.model.Manifestation) {
            const vectors: number[][][] = (<com.vzome.jsweet.JsManifestation><any>man).getVectors();
            (<any>(this.adapter["unselect"])).apply(this.adapter, [vectors]);
        }

        /**
         * 
         * @return {number}
         */
        public size(): number {
            return (<number>(<any>(this.adapter["selectionSize"])).apply(this.adapter)|0);
        }

        /**
         * 
         */
        public gatherGroup() {
            (<any>(this.adapter["createGroup"])).apply(this.adapter);
        }

        /**
         * 
         */
        public scatterGroup() {
            (<any>(this.adapter["disbandGroup"])).apply(this.adapter);
        }

        /**
         * 
         */
        public gatherGroup211() {
            (<any>(this.adapter["createLegacyGroup"])).apply(this.adapter);
        }

        /**
         * 
         */
        public scatterGroup211() {
            (<any>(this.adapter["disbandLegacyGroup"])).apply(this.adapter);
        }

        /**
         * 
         * @param {*} man
         */
        public selectWithGrouping(man: com.vzome.core.model.Manifestation) {
            if (man == null)return;
            const vectors: number[][][] = (<com.vzome.jsweet.JsManifestation><any>man).getVectors();
            (<any>(this.adapter["selectWithGrouping"])).apply(this.adapter, [vectors]);
        }

        /**
         * 
         * @param {*} man
         */
        public unselectWithGrouping(man: com.vzome.core.model.Manifestation) {
            if (man == null)return;
            const vectors: number[][][] = (<com.vzome.jsweet.JsManifestation><any>man).getVectors();
            (<any>(this.adapter["unselectWithGrouping"])).apply(this.adapter, [vectors]);
        }

        /**
         * 
         * @return {boolean}
         */
        public isSelectionAGroup(): boolean {
            return <boolean>(<any>(this.adapter["selectionIsGroup"])).apply(this.adapter);
        }

        /**
         * 
         * @param {java.lang.Class} class1
         * @return {*}
         */
        public getSingleSelection(class1: any): com.vzome.core.model.Manifestation {
            throw new java.lang.RuntimeException("unimplemented getSingleSelection");
        }

        /**
         * 
         * @param {*} bookmarkedSelection
         */
        public copy(bookmarkedSelection: java.util.List<com.vzome.core.model.Manifestation>) {
            throw new java.lang.RuntimeException("unimplemented");
        }
    }
    JsSelection["__class"] = "com.vzome.jsweet.JsSelection";
    JsSelection["__interfaces"] = ["com.vzome.core.editor.api.Selection","java.lang.Iterable"];



    export namespace JsSelection {

        export class JsSelection$0 implements java.util.Iterator<com.vzome.core.model.Manifestation> {
            public __parent: any;
            peek: IteratorResult<number[][][]>;

            /**
             * 
             * @return {boolean}
             */
            public hasNext(): boolean {
                return !this.peek.done;
            }

            /**
             * 
             * @return {*}
             */
            public next(): com.vzome.core.model.Manifestation {
                const result: com.vzome.core.model.Manifestation = com.vzome.jsweet.JsManifestation.manifest(this.peek.value, this.__parent.field, this.__parent.adapter);
                this.peek = this.jSiterator.next();
                return result;
            }

            constructor(__parent: any, private jSiterator: any) {
                this.__parent = __parent;
                this.peek = this.jSiterator.next();
            }
        }
        JsSelection$0["__interfaces"] = ["java.util.Iterator"];


    }

}
namespace com.vzome.jsweet {
    export class JsEditContext implements com.vzome.core.editor.api.Context {
        public constructor() {
        }

        /**
         * 
         * @param {*} xml
         * @return {com.vzome.core.editor.api.UndoableEdit}
         */
        public createEdit(xml: org.w3c.dom.Element): com.vzome.core.editor.api.UndoableEdit {
            throw new java.lang.RuntimeException("unimplemented createEdit");
        }

        /**
         * 
         * @param {com.vzome.core.editor.api.UndoableEdit} edit
         */
        public performAndRecord(edit: com.vzome.core.editor.api.UndoableEdit) {
            throw new java.lang.RuntimeException("unimplemented performAndRecord");
        }

        /**
         * 
         * @param {string} cmdName
         * @return {*}
         */
        public createLegacyCommand(cmdName: string): com.vzome.core.commands.Command {
            throw new java.lang.RuntimeException("unimplemented createLegacyCommand");
        }

        /**
         * 
         * @param {string} action
         * @param {*} props
         * @return {boolean}
         */
        public doEdit(action: string, props: java.util.Map<string, any>): boolean {
            throw new java.lang.RuntimeException("unimplemented doEdit");
        }
    }
    JsEditContext["__class"] = "com.vzome.jsweet.JsEditContext";
    JsEditContext["__interfaces"] = ["com.vzome.core.editor.api.Context"];


}
namespace com.vzome.jsweet {
    export class JsRealizedModel implements com.vzome.core.model.RealizedModel {
        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        /*private*/ adapter: Object;

        public constructor(field: com.vzome.core.algebra.AlgebraicField, adapter: Object) {
            if (this.field === undefined) { this.field = null; }
            if (this.adapter === undefined) { this.adapter = null; }
            this.field = field;
            this.adapter = adapter;
        }

        setAdapter(adapter: Object) {
            this.adapter = adapter;
        }

        /**
         * 
         * @return {*}
         */
        public iterator(): java.util.Iterator<com.vzome.core.model.Manifestation> {
            const f: Function = <any>(this.adapter["allIterator"]);
            const jSiterator: Iterator<number[][][]> = <Iterator<number[][][]>>f.apply(this.adapter);
            return new JsRealizedModel.JsRealizedModel$0(this, jSiterator);
        }

        /**
         * 
         * @return {*}
         */
        public getField(): com.vzome.core.algebra.AlgebraicField {
            return this.field;
        }

        /**
         * 
         * @param {com.vzome.core.construction.Construction} c
         * @return {*}
         */
        public findConstruction(c: com.vzome.core.construction.Construction): com.vzome.core.model.Manifestation {
            if (c == null)return null;
            let vectors: number[][][] = com.vzome.jsweet.JsManifestation.canonicalizeConstruction(c);
            if (vectors == null)return null;
            vectors = <number[][][]>(<any>(this.adapter["findOrCreateManifestation"])).apply(this.adapter, [vectors]);
            if (vectors == null)return null;
            return com.vzome.jsweet.JsManifestation.manifest(vectors, this.field, this.adapter);
        }

        /**
         * 
         * @param {*} man
         */
        public remove(man: com.vzome.core.model.Manifestation) {
            const vectors: number[][][] = (<com.vzome.jsweet.JsManifestation><any>man).getVectors();
            (<any>(this.adapter["delete"])).apply(this.adapter, [vectors]);
        }

        /**
         * 
         * @param {com.vzome.core.construction.Construction} c
         * @return {*}
         */
        public getManifestation(c: com.vzome.core.construction.Construction): com.vzome.core.model.Manifestation {
            return this.findConstruction(c);
        }

        /**
         * 
         * @param {*} man
         */
        public show(man: com.vzome.core.model.Manifestation) {
            const vectors: number[][][] = (<com.vzome.jsweet.JsManifestation><any>man).getVectors();
            (<any>(this.adapter["showManifestation"])).apply(this.adapter, [vectors]);
        }

        /**
         * 
         * @param {*} man
         */
        public hide(man: com.vzome.core.model.Manifestation) {
            const vectors: number[][][] = (<com.vzome.jsweet.JsManifestation><any>man).getVectors();
            (<any>(this.adapter["hideManifestation"])).apply(this.adapter, [vectors]);
        }

        /**
         * 
         * @param {*} man
         * @param {com.vzome.core.construction.Color} color
         */
        public setColor(man: com.vzome.core.model.Manifestation, color: com.vzome.core.construction.Color) {
            (<com.vzome.jsweet.JsManifestation><any>man).setColor(color);
        }

        /**
         * 
         * @param {*} man
         * @param {string} label
         */
        public setLabel(man: com.vzome.core.model.Manifestation, label: string) {
            (<com.vzome.jsweet.JsManifestation><any>man).setLabel(label);
        }

        /**
         * 
         * @param {*} man
         */
        public add(man: com.vzome.core.model.Manifestation) {
            const vectors: number[][][] = (<com.vzome.jsweet.JsManifestation><any>man).getVectors();
            (<any>(this.adapter["showManifestation"])).apply(this.adapter, [vectors]);
        }

        /**
         * 
         * @param {string} signature
         * @return {*}
         */
        public findPerEditManifestation(signature: string): com.vzome.core.model.Manifestation {
            return null;
        }

        /**
         * 
         * @param {string} signature
         * @param {*} m
         */
        public addPerEditManifestation(signature: string, m: com.vzome.core.model.Manifestation) {
        }

        /**
         * 
         */
        public clearPerEditManifestations() {
        }

        /**
         * 
         * @param {com.vzome.core.construction.Construction} c
         * @return {*}
         */
        public removeConstruction(c: com.vzome.core.construction.Construction): com.vzome.core.model.Manifestation {
            throw new java.lang.RuntimeException("unimplemented");
        }

        /**
         * 
         * @return {number}
         */
        public size(): number {
            throw new java.lang.RuntimeException("unimplemented");
        }
    }
    JsRealizedModel["__class"] = "com.vzome.jsweet.JsRealizedModel";
    JsRealizedModel["__interfaces"] = ["com.vzome.core.model.RealizedModel","java.lang.Iterable"];



    export namespace JsRealizedModel {

        export class JsRealizedModel$0 implements java.util.Iterator<com.vzome.core.model.Manifestation> {
            public __parent: any;
            peek: IteratorResult<number[][][]>;

            /**
             * 
             * @return {boolean}
             */
            public hasNext(): boolean {
                return !this.peek.done;
            }

            /**
             * 
             * @return {*}
             */
            public next(): com.vzome.core.model.Manifestation {
                const result: com.vzome.core.model.Manifestation = com.vzome.jsweet.JsManifestation.manifest(this.peek.value, this.__parent.field, this.__parent.adapter);
                this.peek = this.jSiterator.next();
                return result;
            }

            constructor(__parent: any, private jSiterator: any) {
                this.__parent = __parent;
                this.peek = this.jSiterator.next();
            }
        }
        JsRealizedModel$0["__interfaces"] = ["java.util.Iterator"];


    }

}
namespace com.vzome.jsweet {
    export class JsAlgebraicField implements com.vzome.core.algebra.AlgebraicField {
        /* Default method injected from com.vzome.core.algebra.AlgebraicField */
        supportsSubfield(fieldName: string): boolean {
            if (fieldName === this.getName())return true;
            return (fieldName === ("golden")) && this.getGoldenRatio() != null;
        }
        /*private*/ delegate: Object;

        /**
         * Positive powers of the irrationals.
         */
        /*private*/ positivePowers: java.util.ArrayList<com.vzome.core.algebra.AlgebraicNumber>[];

        /**
         * Negative powers of the irrationals.
         */
        /*private*/ negativePowers: java.util.ArrayList<com.vzome.core.algebra.AlgebraicNumber>[];

        public constructor(delegate: Object) {
            if (this.delegate === undefined) { this.delegate = null; }
            if (this.positivePowers === undefined) { this.positivePowers = null; }
            if (this.negativePowers === undefined) { this.negativePowers = null; }
            if (this.zomicModule === undefined) { this.zomicModule = null; }
            if (this.vzomePkg === undefined) { this.vzomePkg = null; }
            this.delegate = delegate;
            const order: number = <any>(delegate["order"]);
            this.positivePowers = (s => { let a=[]; while(s-->0) a.push(null); return a; })(order - 1);
            this.negativePowers = (s => { let a=[]; while(s-->0) a.push(null); return a; })(order - 1);
        }

        /**
         * 
         * @return {string}
         */
        public getName(): string {
            return <any>(this.delegate["name"]);
        }

        /**
         * 
         * @return {number}
         */
        public getOrder(): number {
            return <any>(this.delegate["order"]);
        }

        /**
         * 
         * @return {*}
         */
        public getAffineScalar(): com.vzome.core.algebra.AlgebraicNumber {
            const scalar: number = <any>(this.delegate["scalarTerm"]);
            return this.getUnitTerm(scalar);
        }

        /**
         * 
         * @return {number}
         */
        public getNumIrrationals(): number {
            return this.getOrder() - 1;
        }

        /**
         * 
         * @return {number}
         */
        public getNumMultipliers(): number {
            return this.getNumIrrationals();
        }

        add(v1: number[], v2: number[]): number[] {
            const f: Function = <any>(this.delegate["plus"]);
            return <any>(f(<any>((<any>(v1))), <any>((<any>(v2)))));
        }

        subtract(v1: number[], v2: number[]): number[] {
            const f: Function = <any>(this.delegate["minus"]);
            return <any>(f(<any>((<any>(v1))), <any>((<any>(v2)))));
        }

        multiply(v1: number[], v2: number[]): number[] {
            const f: Function = <any>(this.delegate["times"]);
            return <any>(f(<any>((<any>(v1))), <any>((<any>(v2)))));
        }

        evaluateNumber(factors: number[]): number {
            const f: Function = <any>(this.delegate["embed"]);
            return <any>(f(<any>((<any>(factors)))));
        }

        reciprocal(factors: number[]): number[] {
            const f: Function = <any>(this.delegate["reciprocal"]);
            return <any>(f(<any>((<any>(factors)))));
        }

        negate(factors: number[]): number[] {
            const f: Function = <any>(this.delegate["negate"]);
            return <any>(f(<any>((<any>(factors)))));
        }

        toString(factors: number[], format: number): string {
            const f: Function = <any>(this.delegate["toString"]);
            return <any>(f(<any>((<any>(factors))), <any>((<any>(format)))));
        }

        public getMathML(v1: number[]): string {
            const f: Function = <any>(this.delegate["toString"]);
            return <any>(f(<any>((<any>(v1))), <any>((<any>(4)))));
        }

        /**
         * 
         * @return {*}
         */
        public zero(): com.vzome.core.algebra.AlgebraicNumber {
            return new com.vzome.jsweet.JsAlgebraicNumber(this, <any>(this.delegate["zero"]));
        }

        /**
         * 
         * @return {*}
         */
        public one(): com.vzome.core.algebra.AlgebraicNumber {
            return new com.vzome.jsweet.JsAlgebraicNumber(this, <any>(this.delegate["one"]));
        }

        /**
         * 
         * @param {int[][]} nums
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public createVector(nums: number[][]): com.vzome.core.algebra.AlgebraicVector {
            const x: com.vzome.core.algebra.AlgebraicNumber = this.createAlgebraicNumberFromPairs(nums[0]);
            const y: com.vzome.core.algebra.AlgebraicNumber = this.createAlgebraicNumberFromPairs(nums[1]);
            const z: com.vzome.core.algebra.AlgebraicNumber = this.createAlgebraicNumberFromPairs(nums[2]);
            return new com.vzome.core.algebra.AlgebraicVector(x, y, z);
        }

        /**
         * 
         * @param {int[][]} nums
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public createVectorFromTDs(nums: number[][]): com.vzome.core.algebra.AlgebraicVector {
            const dims: number = nums.length;
            const coords: com.vzome.core.algebra.AlgebraicNumber[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(dims);
            for(let c: number = 0; c < coords.length; c++) {{
                coords[c] = this.createAlgebraicNumberFromTD(nums[c]);
            };}
            return new com.vzome.core.algebra.AlgebraicVector(coords);
        }

        /**
         * 
         * @param {number} dims
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public origin(dims: number): com.vzome.core.algebra.AlgebraicVector {
            const zero: com.vzome.core.algebra.AlgebraicNumber = this.zero();
            switch((dims)) {
            case 1:
                return new com.vzome.core.algebra.AlgebraicVector(zero);
            case 2:
                return new com.vzome.core.algebra.AlgebraicVector(zero, zero);
            case 3:
                return new com.vzome.core.algebra.AlgebraicVector(zero, zero, zero);
            case 4:
                return new com.vzome.core.algebra.AlgebraicVector(zero, zero, zero, zero);
            case 5:
                return new com.vzome.core.algebra.AlgebraicVector(zero, zero, zero, zero, zero);
            default:
                return null;
            }
        }

        /**
         * 
         * @return {boolean}
         */
        public scale4dRoots(): boolean {
            return false;
        }

        /**
         * 
         * @return {boolean}
         */
        public doubleFrameVectors(): boolean {
            return false;
        }

        /**
         * 
         * @param {number} dims
         * @param {number} axis
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public basisVector(dims: number, axis: number): com.vzome.core.algebra.AlgebraicVector {
            const result: com.vzome.core.algebra.AlgebraicVector = this.origin(dims);
            return result.setComponent(axis, this.one());
        }

        public createPower$int(power: number): com.vzome.core.algebra.AlgebraicNumber {
            return this.createPower$int$int(power, 1);
        }

        public createPower$int$int(power: number, irr: number): com.vzome.core.algebra.AlgebraicNumber {
            const one: com.vzome.core.algebra.AlgebraicNumber = this.one();
            if (power === 0 || irr === 0)return one;
            irr -= 1;
            if (power > 0){
                if (this.positivePowers[irr] == null)this.positivePowers[irr] = <any>(new java.util.ArrayList<any>(8));
                if (power >= this.positivePowers[irr].size()){
                    if (this.positivePowers[irr].isEmpty()){
                        this.positivePowers[irr].add(one);
                        this.positivePowers[irr].add(this.getUnitTerm(irr + 1));
                    }
                    const size: number = this.positivePowers[irr].size();
                    const irrat: com.vzome.core.algebra.AlgebraicNumber = this.positivePowers[irr].get(1);
                    let last: com.vzome.core.algebra.AlgebraicNumber = this.positivePowers[irr].get(size - 1);
                    for(let i: number = size; i <= power; i++) {{
                        const next: com.vzome.core.algebra.AlgebraicNumber = last['times$com_vzome_core_algebra_AlgebraicNumber'](irrat);
                        this.positivePowers[irr].add(next);
                        last = next;
                    };}
                }
                return this.positivePowers[irr].get(power);
            } else {
                power = -power;
                if (this.negativePowers[irr] == null)this.negativePowers[irr] = <any>(new java.util.ArrayList<any>(8));
                if (power >= this.negativePowers[irr].size()){
                    if (this.negativePowers[irr].isEmpty()){
                        this.negativePowers[irr].add(one);
                        this.negativePowers[irr].add(this.getUnitTerm(irr + 1).reciprocal());
                    }
                    const size: number = this.negativePowers[irr].size();
                    const irrat: com.vzome.core.algebra.AlgebraicNumber = this.negativePowers[irr].get(1);
                    let last: com.vzome.core.algebra.AlgebraicNumber = this.negativePowers[irr].get(size - 1);
                    for(let i: number = size; i <= power; i++) {{
                        const next: com.vzome.core.algebra.AlgebraicNumber = last['times$com_vzome_core_algebra_AlgebraicNumber'](irrat);
                        this.negativePowers[irr].add(next);
                        last = next;
                    };}
                }
                return this.negativePowers[irr].get(power);
            }
        }

        /**
         * 
         * @param {number} power
         * @param {number} irr
         * @return {*}
         */
        public createPower(power?: any, irr?: any): com.vzome.core.algebra.AlgebraicNumber {
            if (((typeof power === 'number') || power === null) && ((typeof irr === 'number') || irr === null)) {
                return <any>this.createPower$int$int(power, irr);
            } else if (((typeof power === 'number') || power === null) && irr === undefined) {
                return <any>this.createPower$int(power);
            } else throw new Error('invalid overload');
        }

        /**
         * @param {number} n specifies the ordinal of the term in the AlgebraicNumber which will be set to one.
         * When {@code n == 0}, the result is the same as {@code createRational(1)}.
         * When {@code n == 1}, the result is the same as {@code createPower(1)}.
         * When {@code n < 0}, the result will be {@code zero()}.
         * When {@code n >= getOrder()}, an IndexOutOfBoundsException will be thrown.
         * @return {*} an AlgebraicNumber with the factor specified by {@code n} set to one.
         */
        public getUnitTerm(n: number): com.vzome.core.algebra.AlgebraicNumber {
            if (n < 0){
                return this.zero();
            }
            const factors: number[] = this.zero().toTrailingDivisor();
            factors[n] = factors[factors.length - 1];
            return new com.vzome.jsweet.JsAlgebraicNumber(this, factors);
        }

        public createRational$long(wholeNumber: number): com.vzome.core.algebra.AlgebraicNumber {
            return this.createRational$long$long(wholeNumber, 1);
        }

        /**
         * 
         * @param {int[]} trailingDivisorForm
         * @return {*}
         */
        public createAlgebraicNumberFromTD(trailingDivisorForm: number[]): com.vzome.core.algebra.AlgebraicNumber {
            const f: Function = <any>(this.delegate["createNumber"]);
            const simplified: number[] = <any>(f(<any>((<any>(trailingDivisorForm)))));
            return new com.vzome.jsweet.JsAlgebraicNumber(this, simplified);
        }

        public createAlgebraicNumberFromPairs(pairs: number[]): com.vzome.core.algebra.AlgebraicNumber {
            const f: Function = <any>(this.delegate["createNumberFromPairs"]);
            const simplified: number[] = <any>(f(<any>((<any>(pairs)))));
            return new com.vzome.jsweet.JsAlgebraicNumber(this, simplified);
        }

        public createRational$long$long(numerator: number, denominator: number): com.vzome.core.algebra.AlgebraicNumber {
            const f: Function = <any>(this.delegate["createNumberFromPairs"]);
            const simplified: number[] = <any>(f(<any>((<any>([numerator, denominator])))));
            return new com.vzome.jsweet.JsAlgebraicNumber(this, simplified);
        }

        /**
         * 
         * @param {number} numerator
         * @param {number} denominator
         * @return {*}
         */
        public createRational(numerator?: any, denominator?: any): com.vzome.core.algebra.AlgebraicNumber {
            if (((typeof numerator === 'number') || numerator === null) && ((typeof denominator === 'number') || denominator === null)) {
                return <any>this.createRational$long$long(numerator, denominator);
            } else if (((typeof numerator === 'number') || numerator === null) && denominator === undefined) {
                return <any>this.createRational$long(numerator);
            } else throw new Error('invalid overload');
        }

        public createAlgebraicNumber$int_A(terms: number[]): com.vzome.core.algebra.AlgebraicNumber {
            return this.createAlgebraicNumber$int_A$int(terms, 1);
        }

        public createAlgebraicNumber$int_A$int(numerators: number[], denominator: number): com.vzome.core.algebra.AlgebraicNumber {
            const factors: number[] = this.zero().toTrailingDivisor();
            java.lang.System.arraycopy(numerators, 0, factors, 0, numerators.length);
            factors[numerators.length] = denominator;
            return this.createAlgebraicNumberFromTD(factors);
        }

        /**
         * 
         * @return {*}
         */
        public getGoldenRatio(): com.vzome.core.algebra.AlgebraicNumber {
            const value: number[] = <any>(this.delegate["goldenRatio"]);
            if (value == null)return null;
            return new com.vzome.jsweet.JsAlgebraicNumber(this, value);
        }

        /**
         * 
         * @param {number} dims
         * @return {com.vzome.core.algebra.AlgebraicMatrix}
         */
        public identityMatrix(dims: number): com.vzome.core.algebra.AlgebraicMatrix {
            const columns: com.vzome.core.algebra.AlgebraicVector[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(dims);
            for(let i: number = 0; i < columns.length; i++) {{
                columns[i] = this.basisVector(dims, i);
            };}
            return new com.vzome.core.algebra.AlgebraicMatrix(columns);
        }

        /**
         * Modeled after AbstractAlgebraicField, with a switch from BigRationals to int[]s.
         * @param {string} string
         * @param {boolean} isRational
         * @return {*}
         */
        public parseVefNumber(string: string, isRational: boolean): com.vzome.core.algebra.AlgebraicNumber {
            const pairs: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.getOrder() + 1);
            if ((!isRational) && /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(string, "(") && /* endsWith */((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(string, ")")){
                const tokens: java.util.StringTokenizer = new java.util.StringTokenizer(string.substring(1, string.length - 1), ",");
                const numStack: java.util.Stack<number> = <any>(new java.util.Stack<any>());
                const denomStack: java.util.Stack<number> = <any>(new java.util.Stack<any>());
                while((tokens.hasMoreTokens())) {{
                    if (numStack.size() >= this.getOrder()){
                        throw new java.lang.RuntimeException("VEF format error: \"" + string + "\" has too many factors for " + this.getName() + " field");
                    }
                    const parts: string[] = tokens.nextToken().split("/");
                    numStack.push(javaemul.internal.IntegerHelper.parseInt(parts[0]));
                    denomStack.push((parts.length > 1) ? javaemul.internal.IntegerHelper.parseInt(parts[1]) : 1);
                }};
                let i: number = 0;
                while((!numStack.empty())) {{
                    pairs[i++] = numStack.pop();
                    pairs[i++] = denomStack.pop();
                }};
            } else {
                const parts: string[] = string.split("/");
                pairs[0] = javaemul.internal.IntegerHelper.parseInt(parts[0]);
                pairs[1] = (parts.length > 1) ? javaemul.internal.IntegerHelper.parseInt(parts[1]) : 1;
            }
            return this.createAlgebraicNumberFromPairs(pairs);
        }

        /**
         * Drop one coordinate from the 4D vector. If wFirst (the usual), then drop
         * the first coordinate, taking the "imaginary part" of the vector. If
         * !wFirst (for old VEF import, etc.), drop the last coordinate.
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} source
         * @param {boolean} wFirst
         * @return
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public projectTo3d(source: com.vzome.core.algebra.AlgebraicVector, wFirst: boolean): com.vzome.core.algebra.AlgebraicVector {
            if (source.dimension() === 3)return source; else {
                const result: com.vzome.core.algebra.AlgebraicVector = this.origin(3);
                for(let i: number = 0; i < 3; i++) {result.setComponent(i, source.getComponent(wFirst ? i + 1 : i));}
                return result;
            }
        }

        public createAlgebraicNumber$int$int$int$int(ones: number, irrat: number, denominator: number, scalePower: number): com.vzome.core.algebra.AlgebraicNumber {
            const result: com.vzome.core.algebra.AlgebraicNumber = this.createAlgebraicNumberFromTD([ones, irrat, denominator]);
            if (scalePower !== 0){
                const multiplier: com.vzome.core.algebra.AlgebraicNumber = this.createPower$int(scalePower);
                return result['times$com_vzome_core_algebra_AlgebraicNumber'](multiplier);
            } else return result;
        }

        /**
         * 
         * @param {number} ones
         * @param {number} irrat
         * @param {number} denominator
         * @param {number} scalePower
         * @return {*}
         */
        public createAlgebraicNumber(ones?: any, irrat?: any, denominator?: any, scalePower?: any): com.vzome.core.algebra.AlgebraicNumber {
            if (((typeof ones === 'number') || ones === null) && ((typeof irrat === 'number') || irrat === null) && ((typeof denominator === 'number') || denominator === null) && ((typeof scalePower === 'number') || scalePower === null)) {
                return <any>this.createAlgebraicNumber$int$int$int$int(ones, irrat, denominator, scalePower);
            } else if (((ones != null && ones instanceof <any>Array && (ones.length == 0 || ones[0] == null ||(typeof ones[0] === 'number'))) || ones === null) && ((typeof irrat === 'number') || irrat === null) && denominator === undefined && scalePower === undefined) {
                return <any>this.createAlgebraicNumber$int_A$int(ones, irrat);
            } else if (((ones != null && ones instanceof <any>Array && (ones.length == 0 || ones[0] == null ||(typeof ones[0] === 'number'))) || ones === null) && irrat === undefined && denominator === undefined && scalePower === undefined) {
                return <any>this.createAlgebraicNumber$int_A(ones);
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {string} nums
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public parseVector(nums: string): com.vzome.core.algebra.AlgebraicVector {
            const noLF: string = /* replace */nums.split('\n').join(' ');
            const noCRLF: string = /* replace */noLF.split('\r').join(' ');
            const tokens: java.util.StringTokenizer = new java.util.StringTokenizer(noCRLF, " ");
            const numToks: number = tokens.countTokens();
            if (numToks % this.getOrder() !== 0)throw new java.lang.IllegalStateException("Field order (" + this.getOrder() + ") does not divide token count: " + numToks + ", for \'" + noCRLF + "\'");
            const dims: number = (numToks / this.getOrder()|0);
            const coords: com.vzome.core.algebra.AlgebraicNumber[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(dims);
            for(let i: number = 0; i < dims; i++) {{
                coords[i] = this.parseNumber$java_util_StringTokenizer(tokens);
            };}
            return new com.vzome.core.algebra.AlgebraicVector(coords);
        }

        public parseNumber$java_lang_String(nums: string): com.vzome.core.algebra.AlgebraicNumber {
            const tokens: java.util.StringTokenizer = new java.util.StringTokenizer(nums, " ");
            return this.parseNumber$java_util_StringTokenizer(tokens);
        }

        /**
         * 
         * @param {string} nums
         * @return {*}
         */
        public parseNumber(nums?: any): com.vzome.core.algebra.AlgebraicNumber {
            if (((typeof nums === 'string') || nums === null)) {
                return <any>this.parseNumber$java_lang_String(nums);
            } else if (((nums != null && nums instanceof <any>java.util.StringTokenizer) || nums === null)) {
                return <any>this.parseNumber$java_util_StringTokenizer(nums);
            } else throw new Error('invalid overload');
        }

        /*private*/ parseNumber$java_util_StringTokenizer(tokens: java.util.StringTokenizer): com.vzome.core.algebra.AlgebraicNumber {
            const order: number = this.getOrder();
            const pairs: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(order * 2);
            for(let i: number = 0; i < order; i++) {{
                const digit: string = tokens.nextToken();
                const parts: string[] = digit.split("/");
                pairs[i * 2] = javaemul.internal.IntegerHelper.parseInt(parts[0]);
                if (parts.length > 1)pairs[i * 2 + 1] = javaemul.internal.IntegerHelper.parseInt(parts[1]); else pairs[i * 2 + 1] = 1;
            };}
            return this.createAlgebraicNumberFromPairs(pairs);
        }

        /**
         * 
         * @param {string} string
         * @return {*}
         */
        public parseLegacyNumber(string: string): com.vzome.core.algebra.AlgebraicNumber {
            let div: number = 1;
            if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(string, "(")){
                const closeParen: number = string.indexOf(')');
                div = javaemul.internal.IntegerHelper.parseInt(string.substring(closeParen + 2));
                string = string.substring(1, closeParen);
            }
            let phis: number = 0;
            const phiIndex: number = string.indexOf("phi");
            if (phiIndex >= 0){
                const part: string = string.substring(0, phiIndex);
                if (part.length === 0)phis = 1; else if (part === ("-"))phis = -1; else phis = javaemul.internal.IntegerHelper.parseInt(part);
                string = string.substring(phiIndex + 3);
            }
            let ones: number;
            if (string.length === 0)ones = 0; else {
                if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(string, "+"))string = string.substring(1);
                ones = javaemul.internal.IntegerHelper.parseInt(string);
            }
            return this.createAlgebraicNumber$int$int$int$int(ones, phis, div, 0);
        }

        public getIrrational$int$int(i: number, format: number): string {
            const f: Function = <any>(this.delegate["getIrrational"]);
            return <any>(f(<any>((<any>(i)))));
        }

        /**
         * 
         * @param {number} i
         * @param {number} format
         * @return {string}
         */
        public getIrrational(i?: any, format?: any): string {
            if (((typeof i === 'number') || i === null) && ((typeof format === 'number') || format === null)) {
                return <any>this.getIrrational$int$int(i, format);
            } else if (((typeof i === 'number') || i === null) && format === undefined) {
                return <any>this.getIrrational$int(i);
            } else throw new Error('invalid overload');
        }

        public getIrrational$int(which: number): string {
            return this.getIrrational$int$int(which, 0);
        }

        /*private*/ zomicModule: Object;

        /*private*/ vzomePkg: Object;

        public setInterpreterModule(module: Object, vzomePkg: Object) {
            this.zomicModule = module;
            this.vzomePkg = vzomePkg;
        }

        public interpretScript(script: string, language: string, offset: com.vzome.core.construction.Point, symmetry: com.vzome.core.math.symmetry.Symmetry, effects: com.vzome.core.construction.ConstructionChanges) {
            if (this.zomicModule == null)throw new Error("The Zomic module was not loaded.");
            const f: Function = <any>(this.zomicModule["interpretScript"]);
            f(<any>((<any>(script))), <any>((<any>(language))), <any>((<any>(offset))), <any>((<any>(symmetry))), <any>((<any>(effects))), <any>((<any>(this.vzomePkg))));
        }

        public getNumberByName(name: string): com.vzome.core.algebra.AlgebraicNumber {
            throw new java.lang.RuntimeException("unimplemented JsAlgebraicField.getNumberByName");
        }

        scaleBy(factors: number[], whichIrrational: number): number[] {
            throw new java.lang.RuntimeException("unimplemented JsAlgebraicField.scaleBy");
        }

        /**
         * 
         * @param {com.vzome.core.math.RealVector} target
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public nearestAlgebraicVector(target: com.vzome.core.math.RealVector): com.vzome.core.algebra.AlgebraicVector {
            throw new java.lang.RuntimeException("unimplemented JsAlgebraicField.nearestAlgebraicVector");
        }

        /**
         * 
         * @param {int[][]} nums
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public createIntegerVector(nums: number[][]): com.vzome.core.algebra.AlgebraicVector {
            throw new java.lang.RuntimeException("unimplemented JsAlgebraicField.createIntegerVector");
        }

        /**
         * 
         * @param {int[][][]} data
         * @return {com.vzome.core.algebra.AlgebraicMatrix}
         */
        public createMatrix(data: number[][][]): com.vzome.core.algebra.AlgebraicMatrix {
            throw new java.lang.RuntimeException("unimplemented JsAlgebraicField.createMatrix");
        }
    }
    JsAlgebraicField["__class"] = "com.vzome.jsweet.JsAlgebraicField";
    JsAlgebraicField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];


}
namespace com.vzome.jsweet {
    export abstract class JsManifestation implements com.vzome.core.model.Manifestation {
        vectors: number[][][];

        field: com.vzome.core.algebra.AlgebraicField;

        adapter: Object;

        public constructor(field: com.vzome.core.algebra.AlgebraicField, adapter: Object, vectors: number[][][]) {
            if (this.vectors === undefined) { this.vectors = null; }
            if (this.field === undefined) { this.field = null; }
            if (this.adapter === undefined) { this.adapter = null; }
            this.field = field;
            this.adapter = adapter;
            this.vectors = vectors;
        }

        public getVectors(): number[][][] {
            return this.vectors;
        }

        /**
         * 
         * @return {com.vzome.core.construction.Color}
         */
        public getColor(): com.vzome.core.construction.Color {
            const colorful: boolean = <boolean>(<any>(this.adapter["manifestationHasColor"])).apply(this.adapter, [this.vectors]);
            if (!colorful)return null;
            const rgb: number = (<number>(<any>(this.adapter["manifestationColor"])).apply(this.adapter, [this.vectors])|0);
            return new com.vzome.core.construction.Color(rgb);
        }

        /**
         * 
         * @return {string}
         */
        public getLabel(): string {
            return null;
        }

        /**
         * 
         * @param {string} label
         */
        public setLabel(label: string) {
        }

        /**
         * 
         * @param {com.vzome.core.construction.Color} color
         */
        public setColor(color: com.vzome.core.construction.Color) {
            if (color != null)(<any>(this.adapter["setManifestationColor"])).apply(this.adapter, [this.vectors, color.getRGB()]);
        }

        /**
         * 
         * @return {boolean}
         */
        public isRendered(): boolean {
            return <boolean>(<any>(this.adapter["manifestationRendered"])).apply(this.adapter, [this.vectors]);
        }

        /**
         * 
         * @param {com.vzome.core.construction.Construction} mConstruction
         */
        public addConstruction(mConstruction: com.vzome.core.construction.Construction) {
        }

        /**
         * 
         * @param {com.vzome.core.construction.Construction} mConstruction
         */
        public removeConstruction(mConstruction: com.vzome.core.construction.Construction) {
        }

        /**
         * 
         * @return {boolean}
         */
        public isUnnecessary(): boolean {
            return true;
        }

        /**
         * 
         * @return {com.vzome.core.construction.Construction}
         */
        public getFirstConstruction(): com.vzome.core.construction.Construction {
            return this.toConstruction();
        }

        public static canonicalizeNumbers(...ns: com.vzome.core.algebra.AlgebraicNumber[]): number[][] {
            return <number[][]>java.util.Arrays.stream<any>(ns).map<any>((n) => n.toTrailingDivisor()).toArray();
        }

        /**
         * Note: this does NOT order the vectors canonically in the outermost array
         * @param {com.vzome.core.algebra.AlgebraicVector[]} vs
         * @return
         * @return {int[][][]}
         */
        public static canonicalizeVectors(...vs: com.vzome.core.algebra.AlgebraicVector[]): number[][][] {
            return <number[][][]>java.util.Arrays.stream<any>(vs).map<any>((v) => JsManifestation.canonicalizeNumbers.apply(this, v.getComponents())).toArray();
        }

        public static canonicalizeConstruction(c: com.vzome.core.construction.Construction): number[][][] {
            if (c != null && c instanceof <any>com.vzome.core.construction.Point){
                const p: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>c;
                return JsManifestation.canonicalizeVectors(p.getLocation());
            } else if (c != null && c instanceof <any>com.vzome.core.construction.Segment){
                const s: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>c;
                return JsManifestation.canonicalizeVectors(s.getStart(), s.getEnd());
            } else if (c != null && c instanceof <any>com.vzome.core.construction.Polygon){
                return JsManifestation.canonicalizeVectors.apply(this, (<com.vzome.core.construction.Polygon>c).getVertices());
            }
            return null;
        }

        public static manifest(vectors: number[][][], field: com.vzome.core.algebra.AlgebraicField, adapter: Object): com.vzome.core.model.Manifestation {
            switch((vectors.length)) {
            case 1:
                return new com.vzome.jsweet.JsBall(field, adapter, vectors);
            case 2:
                const strut: com.vzome.jsweet.JsStrut = new com.vzome.jsweet.JsStrut(field, adapter, vectors);
                if (strut.getOffset().isOrigin())return null; else return strut;
            default:
                return new com.vzome.jsweet.JsPanel(field, adapter, vectors);
            }
        }

        /**
         * 
         * @param {boolean} b
         */
        public setHidden(b: boolean) {
        }

        /**
         * 
         * @return {boolean}
         */
        public isHidden(): boolean {
            return <boolean>(<any>(this.adapter["manifestationHidden"])).apply(this.adapter, [this.vectors]);
        }

        /**
         * 
         * @param {com.vzome.core.model.Group} container
         */
        public setContainer(container: com.vzome.core.model.Group) {
            throw new java.lang.RuntimeException("unimplemented");
        }

        /**
         * 
         * @return {com.vzome.core.model.Group}
         */
        public getContainer(): com.vzome.core.model.Group {
            const members: number[][][][] = <number[][][][]>(<any>(this.adapter["getLargestGroup"])).apply(this.adapter, [this.vectors]);
            if (members == null)return null;
            const group: com.vzome.core.model.Group = new com.vzome.core.model.Group();
            for(let i: number = 0; i < members.length; i++) {{
                group.add(JsManifestation.manifest(members[i], this.field, this.adapter));
            };}
            return group;
        }

        /**
         * 
         * @param {*} renderedObject
         */
        public setRenderedObject(renderedObject: com.vzome.core.model.RenderedObject) {
        }

        /**
         * 
         * @return {*}
         */
        public getConstructions(): java.util.Iterator<com.vzome.core.construction.Construction> {
            throw new java.lang.RuntimeException("unimplemented");
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            throw new java.lang.RuntimeException("unimplemented");
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getCentroid(): com.vzome.core.algebra.AlgebraicVector {
            throw new java.lang.RuntimeException("unimplemented");
        }

        public abstract getLocation(): any;
        public abstract toConstruction(): any;    }
    JsManifestation["__class"] = "com.vzome.jsweet.JsManifestation";
    JsManifestation["__interfaces"] = ["com.vzome.core.model.GroupElement","com.vzome.core.model.Manifestation"];


}
namespace com.vzome.jsweet {
    export class JsAlgebraicNumber implements com.vzome.core.algebra.AlgebraicNumber {
        /*private*/ field: com.vzome.jsweet.JsAlgebraicField;

        /*private*/ factors: number[];

        public constructor(field: com.vzome.jsweet.JsAlgebraicField, factors: number[]) {
            if (this.field === undefined) { this.field = null; }
            if (this.factors === undefined) { this.factors = null; }
            this.field = field;
            this.factors = <any>((<any>(factors).slice()));
        }

        /**
         * 
         * @return {*}
         */
        public getField(): com.vzome.core.algebra.AlgebraicField {
            return this.field;
        }

        /**
         * 
         * @return {number}
         */
        public evaluate(): number {
            return this.field.evaluateNumber(this.factors);
        }

        /**
         * 
         * @return {int[]}
         */
        public toTrailingDivisor(): number[] {
            return <any>((<any>(this.factors).slice()));
        }

        /**
         * 
         * @param {number} n is the value to be added
         * @return {*} this + n
         */
        public plusInt(n: number): com.vzome.core.algebra.AlgebraicNumber {
            return n === 0 ? this : this.plus$com_vzome_core_algebra_AlgebraicNumber(this.field.createRational$long(n));
        }

        /**
         * 
         * @param {number} num is the numerator of the rational value to be added
         * @param {number} den is the denominator of the rational value to be added
         * @return {*} this + (num / den)
         */
        public plusRational(num: number, den: number): com.vzome.core.algebra.AlgebraicNumber {
            return this.plus$com_vzome_core_algebra_AlgebraicNumber(this.field.createRational$long$long(num, den));
        }

        public plus$com_vzome_core_algebra_AlgebraicNumber(that: com.vzome.core.algebra.AlgebraicNumber): com.vzome.core.algebra.AlgebraicNumber {
            const factors: number[] = this.field.add(this.factors, (<JsAlgebraicNumber><any>that).factors);
            return new JsAlgebraicNumber(this.field, factors);
        }

        /**
         * 
         * @param {*} that
         * @return {*}
         */
        public plus(that?: any): any {
            if (((that != null && (that.constructor != null && that.constructor["__interfaces"] != null && that.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || that === null)) {
                return <any>this.plus$com_vzome_core_algebra_AlgebraicNumber(that);
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {number} n
         * @return {*}
         */
        public minusInt(n: number): com.vzome.core.algebra.AlgebraicNumber {
            return n === 0 ? this : this.minus$com_vzome_core_algebra_AlgebraicNumber(this.field.createRational$long(n));
        }

        /**
         * 
         * @param {number} num
         * @param {number} den
         * @return {*}
         */
        public minusRational(num: number, den: number): com.vzome.core.algebra.AlgebraicNumber {
            return this.minus$com_vzome_core_algebra_AlgebraicNumber(this.field.createRational$long$long(num, den));
        }

        public minus$com_vzome_core_algebra_AlgebraicNumber(that: com.vzome.core.algebra.AlgebraicNumber): com.vzome.core.algebra.AlgebraicNumber {
            const factors: number[] = this.field.subtract(this.factors, (<JsAlgebraicNumber><any>that).factors);
            return new JsAlgebraicNumber(this.field, factors);
        }

        /**
         * 
         * @param {*} that
         * @return {*}
         */
        public minus(that?: any): any {
            if (((that != null && (that.constructor != null && that.constructor["__interfaces"] != null && that.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || that === null)) {
                return <any>this.minus$com_vzome_core_algebra_AlgebraicNumber(that);
            } else throw new Error('invalid overload');
        }

        public times$com_vzome_core_algebra_AlgebraicNumber(that: com.vzome.core.algebra.AlgebraicNumber): com.vzome.core.algebra.AlgebraicNumber {
            const factors: number[] = this.field.multiply(this.factors, (<JsAlgebraicNumber><any>that).factors);
            return new JsAlgebraicNumber(this.field, factors);
        }

        /**
         * 
         * @param {*} that
         * @return {*}
         */
        public times(that?: any): any {
            if (((that != null && (that.constructor != null && that.constructor["__interfaces"] != null && that.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || that === null)) {
                return <any>this.times$com_vzome_core_algebra_AlgebraicNumber(that);
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {number} divisor
         * @return {*}
         */
        public dividedByInt(divisor: number): com.vzome.core.algebra.AlgebraicNumber {
            return divisor === 1 ? this : this.times$com_vzome_core_algebra_AlgebraicNumber(this.field.createRational$long$long(1, divisor));
        }

        /**
         * 
         * @param {number} num
         * @param {number} den
         * @return {*}
         */
        public dividedByRational(num: number, den: number): com.vzome.core.algebra.AlgebraicNumber {
            return this.times$com_vzome_core_algebra_AlgebraicNumber(this.field.createRational$long$long(den, num));
        }

        /**
         * 
         * @param {*} that
         * @return {*}
         */
        public dividedBy(that: com.vzome.core.algebra.AlgebraicNumber): com.vzome.core.algebra.AlgebraicNumber {
            const recip: number[] = this.field.reciprocal((<JsAlgebraicNumber><any>that).factors);
            const factors: number[] = this.field.multiply(this.factors, recip);
            return new JsAlgebraicNumber(this.field, factors);
        }

        public equals(that: com.vzome.core.algebra.AlgebraicNumber): boolean {
            return java.util.Arrays.equals(this.factors, (<JsAlgebraicNumber><any>that).factors);
        }

        /**
         * 
         * @return {*}
         */
        public negate(): com.vzome.core.algebra.AlgebraicNumber {
            const factors: number[] = this.field.negate(this.factors);
            return new JsAlgebraicNumber(this.field, factors);
        }

        /**
         * 
         * @return {boolean}
         */
        public isZero(): boolean {
            return this.equals(this.field.zero());
        }

        /**
         * 
         * @return {boolean}
         */
        public isOne(): boolean {
            return this.equals(this.field.one());
        }

        /**
         * 
         * @return {*}
         */
        public reciprocal(): com.vzome.core.algebra.AlgebraicNumber {
            return new JsAlgebraicNumber(this.field, (<com.vzome.jsweet.JsAlgebraicField>this.field).reciprocal(this.factors));
        }

        /**
         * @param {java.lang.StringBuffer} buf
         * @param {number} format must be one of the following values.
         * The result is formatted as follows:
         * <br>
         * {@code DEFAULT_FORMAT    // 4 + 3φ}<br>
         * {@code EXPRESSION_FORMAT // 4 +3*phi}<br>
         * {@code ZOMIC_FORMAT      // 4 3}<br>
         * {@code VEF_FORMAT        // (3,4)}<br>
         */
        public getNumberExpression(buf: java.lang.StringBuffer, format: number) {
            buf.append(this.toString(format));
        }

        /**
         * @param {number} format must be one of the following values.
         * The result is formatted as follows:
         * <br>
         * {@code DEFAULT_FORMAT    // 4 + 3φ}<br>
         * {@code EXPRESSION_FORMAT // 4 +3*phi}<br>
         * {@code ZOMIC_FORMAT      // 4 3}<br>
         * {@code VEF_FORMAT        // (3,4)}
         * @return {string}
         */
        public toString(format: number): string {
            return this.field.toString(this.factors, format);
        }

        /**
         * 
         * @return {string}
         */
        public getMathML(): string {
            return this.field.getMathML(this.factors);
        }

        /**
         * 
         * @param {*} other
         * @return {number}
         */
        public compareTo(other: com.vzome.core.algebra.AlgebraicNumber): number {
            if (this === other){
                return 0;
            }
            if (/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(other,this))){
                return 0;
            }
            const d1: number = this.evaluate();
            const d2: number = other.evaluate();
            return /* compareTo */(<any>((o1: any, o2: any) => { if (o1 && o1.compareTo) { return o1.compareTo(o2); } else { return o1 < o2 ? -1 : o2 < o1 ? 1 : 0; } })(d1,d2));
        }

        /**
         * 
         * @param {*} other
         * @return {boolean}
         */
        public greaterThan(other: com.vzome.core.algebra.AlgebraicNumber): boolean {
            return this.compareTo(other) > 0;
        }

        /**
         * 
         * @param {*} other
         * @return {boolean}
         */
        public lessThan(other: com.vzome.core.algebra.AlgebraicNumber): boolean {
            return this.compareTo(other) < 0;
        }

        /**
         * 
         * @param {*} other
         * @return {boolean}
         */
        public greaterThanOrEqualTo(other: com.vzome.core.algebra.AlgebraicNumber): boolean {
            return this.compareTo(other) >= 0;
        }

        /**
         * 
         * @param {*} other
         * @return {boolean}
         */
        public lessThanOrEqualTo(other: com.vzome.core.algebra.AlgebraicNumber): boolean {
            return this.compareTo(other) <= 0;
        }

        /**
         * 
         * @return {number}
         */
        public signum(): number {
            return /* intValue */(javaemul.internal.DoubleHelper.valueOf(/* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(this.evaluate()))|0);
        }

        /**
         * 
         * @param {number} n
         * @return {*}
         */
        public timesInt(n: number): com.vzome.core.algebra.AlgebraicNumber {
            throw new java.lang.RuntimeException("unimplemented JsAlgebraicNumber.timesInt");
        }

        /**
         * 
         * @param {number} num
         * @param {number} den
         * @return {*}
         */
        public timesRational(num: number, den: number): com.vzome.core.algebra.AlgebraicNumber {
            throw new java.lang.RuntimeException("unimplemented JsAlgebraicNumber.times");
        }

        /**
         * 
         * @return {boolean}
         */
        public isRational(): boolean {
            throw new java.lang.RuntimeException("unimplemented JsAlgebraicNumber.isRational");
        }
    }
    JsAlgebraicNumber["__class"] = "com.vzome.jsweet.JsAlgebraicNumber";
    JsAlgebraicNumber["__interfaces"] = ["com.vzome.core.algebra.Fields.Element","com.vzome.core.algebra.AlgebraicNumber","java.lang.Comparable"];


}
namespace com.vzome.jsweet {
    export class JsEditorModel implements com.vzome.core.editor.api.EditorModel, com.vzome.core.editor.api.LegacyEditorModel, com.vzome.core.editor.api.SymmetryAware {
        /*private*/ realizedModel: com.vzome.core.model.RealizedModel;

        /*private*/ selection: com.vzome.core.editor.api.Selection;

        /*private*/ kind: com.vzome.core.math.symmetry.Symmetries4D;

        /*private*/ symmetrySegment: com.vzome.core.construction.Segment;

        /*private*/ symmetryCenter: com.vzome.core.construction.Point;

        /*private*/ symmetries: com.vzome.core.editor.api.OrbitSource;

        /*private*/ symmetrySystems: Object;

        /*private*/ selectionSummary: com.vzome.core.editor.SelectionSummary;

        public constructor(realizedModel: com.vzome.core.model.RealizedModel, selection: com.vzome.core.editor.api.Selection, kind: com.vzome.core.math.symmetry.Symmetries4D, symmetries: com.vzome.core.editor.api.OrbitSource, symmetrySystems: Object) {
            if (this.realizedModel === undefined) { this.realizedModel = null; }
            if (this.selection === undefined) { this.selection = null; }
            if (this.kind === undefined) { this.kind = null; }
            if (this.symmetrySegment === undefined) { this.symmetrySegment = null; }
            if (this.symmetryCenter === undefined) { this.symmetryCenter = null; }
            if (this.symmetries === undefined) { this.symmetries = null; }
            if (this.symmetrySystems === undefined) { this.symmetrySystems = null; }
            if (this.selectionSummary === undefined) { this.selectionSummary = null; }
            this.realizedModel = realizedModel;
            this.selection = selection;
            this.kind = kind;
            this.symmetries = symmetries;
            this.symmetrySystems = symmetrySystems;
            this.symmetryCenter = new com.vzome.core.construction.FreePoint(realizedModel.getField().origin(3));
            this.selectionSummary = new com.vzome.core.editor.SelectionSummary(this.selection);
            (<com.vzome.core.editor.SelectionImpl><any>this.selection).addListener(this.selectionSummary);
        }

        public setAdapter(adapter: Object) {
        }

        /**
         * 
         * @return {*}
         */
        public getRealizedModel(): com.vzome.core.model.RealizedModel {
            return this.realizedModel;
        }

        /**
         * 
         * @return {*}
         */
        public getSelection(): com.vzome.core.editor.api.Selection {
            return this.selection;
        }

        /**
         * 
         * @return {*}
         */
        public get4dSymmetries(): com.vzome.core.math.symmetry.Symmetries4D {
            return this.kind;
        }

        /**
         * 
         * @return {com.vzome.core.construction.Segment}
         */
        public getSymmetrySegment(): com.vzome.core.construction.Segment {
            return this.symmetrySegment;
        }

        /**
         * 
         * @return {com.vzome.core.construction.Point}
         */
        public getCenterPoint(): com.vzome.core.construction.Point {
            return this.symmetryCenter;
        }

        /**
         * 
         * @param {com.vzome.core.construction.Construction} cons
         * @return {boolean}
         */
        public hasFailedConstruction(cons: com.vzome.core.construction.Construction): boolean {
            return false;
        }

        public getSymmetrySystem$(): com.vzome.core.editor.api.OrbitSource {
            return this.symmetries;
        }

        public getSymmetrySystem$java_lang_String(name: string): com.vzome.core.editor.api.OrbitSource {
            return <any>(this.symmetrySystems[name]);
        }

        /**
         * 
         * @param {string} name
         * @return {*}
         */
        public getSymmetrySystem(name?: any): com.vzome.core.editor.api.OrbitSource {
            if (((typeof name === 'string') || name === null)) {
                return <any>this.getSymmetrySystem$java_lang_String(name);
            } else if (name === undefined) {
                return <any>this.getSymmetrySystem$();
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {com.vzome.core.construction.Construction} cons
         */
        public addFailedConstruction(cons: com.vzome.core.construction.Construction) {
        }

        /**
         * 
         * @param {com.vzome.core.construction.Construction} point
         */
        public setCenterPoint(point: com.vzome.core.construction.Construction) {
            this.symmetryCenter = <com.vzome.core.construction.Point>point;
        }

        /**
         * 
         * @param {com.vzome.core.construction.Segment} segment
         */
        public setSymmetrySegment(segment: com.vzome.core.construction.Segment) {
            this.symmetrySegment = segment;
        }

        /**
         * 
         * @param {*} listener
         */
        public addSelectionSummaryListener(listener: com.vzome.core.editor.SelectionSummary.Listener) {
            this.selectionSummary.addListener(listener);
        }

        public notifyListeners() {
            this.selectionSummary.notifyListeners();
        }

        /**
         * 
         * @param {java.lang.Class} kind
         * @return {com.vzome.core.construction.Construction}
         */
        public getSelectedConstruction(kind: any): com.vzome.core.construction.Construction {
            let manifestationClass: any;
            if (kind === com.vzome.core.construction.Point)manifestationClass = "com.vzome.core.model.Connector"; else if (kind === com.vzome.core.construction.Segment)manifestationClass = "com.vzome.core.model.Strut"; else return null;
            const focus: com.vzome.core.model.Manifestation = this.selection.getSingleSelection(manifestationClass);
            if (focus != null)return focus.getFirstConstruction();
            return null;
        }
    }
    JsEditorModel["__class"] = "com.vzome.jsweet.JsEditorModel";
    JsEditorModel["__interfaces"] = ["com.vzome.core.editor.api.EditorModel","com.vzome.core.editor.api.LegacyEditorModel","com.vzome.core.editor.api.ImplicitSymmetryParameters","com.vzome.core.editor.api.SymmetryAware"];


}
namespace com.vzome.jsweet {
    export class JsAdapter {
        public static mapVectorToJava(vector: number[][], field: com.vzome.jsweet.JsAlgebraicField): com.vzome.core.algebra.AlgebraicVector {
            const ans: com.vzome.core.algebra.AlgebraicNumber[] = <com.vzome.core.algebra.AlgebraicNumber[]>java.util.stream.Stream.of<any>(vector).map<any>((ints) => new com.vzome.jsweet.JsAlgebraicNumber(field, ints)).toArray();
            return new com.vzome.core.algebra.AlgebraicVector(ans);
        }

        public static mapVectorToJavascript(vector: com.vzome.core.algebra.AlgebraicVector): number[][] {
            return <number[][]>java.util.stream.Stream.of<any>(vector.getComponents()).map<any>((an) => an.toTrailingDivisor()).toArray();
        }

        public static getZoneGrid(orbits: com.vzome.core.editor.api.OrbitSource, planeNormal: number[][]): Object {
            const field: com.vzome.jsweet.JsAlgebraicField = <com.vzome.jsweet.JsAlgebraicField><any>orbits.getSymmetry().getField();
            const normal: com.vzome.core.algebra.AlgebraicVector = JsAdapter.mapVectorToJava(planeNormal, field);
            const planeColor: string = orbits.getVectorColor(normal).toWebString();
            const planeName: string = orbits.getSymmetry()['getAxis$com_vzome_core_algebra_AlgebraicVector'](normal).getOrbit().getName();
            const zonesList: java.util.ArrayList<Object> = <any>(new java.util.ArrayList<any>());
            const planeOrbits: com.vzome.core.math.symmetry.PlaneOrbitSet = new com.vzome.core.math.symmetry.PlaneOrbitSet(orbits.getOrbits(), normal);
            for(const iterator: java.util.Iterator<com.vzome.core.math.symmetry.Axis> = planeOrbits.zones(); iterator.hasNext(); ) {{
                const zone: com.vzome.core.math.symmetry.Axis = <com.vzome.core.math.symmetry.Axis>iterator.next();
                const orbit: com.vzome.core.math.symmetry.Direction = zone.getDirection();
                if (!orbit.isStandard())continue;
                const gridPoints: java.util.ArrayList<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>());
                const zoneNormal: com.vzome.core.algebra.AlgebraicVector = zone.normal();
                const zoneColor: string = orbits.getVectorColor(zoneNormal).toWebString();
                let scale: com.vzome.core.algebra.AlgebraicNumber = orbit.getUnitLength();
                for(let i: number = 0; i < 5; i++) {{
                    scale = scale['times$com_vzome_core_algebra_AlgebraicNumber'](field.createPower$int(1));
                    const gridPoint: com.vzome.core.algebra.AlgebraicVector = zoneNormal.scale(scale);
                    gridPoints.add(gridPoint);
                };}
                const vectors: com.vzome.core.algebra.AlgebraicVector[] = gridPoints.stream().toArray<any>((size) => (s => { let a=[]; while(s-->0) a.push(null); return a; })(size));
                const zoneObj: Object = ((target:Object) => {
                    target["color"] = zoneColor;
                    target["vectors"] = vectors;
                    return target;

                })(new Object());
                zonesList.add(zoneObj);
            };}
            const zones: Object[] = zonesList.stream().toArray<any>((size) => (s => { let a=[]; while(s-->0) a.push(null); return a; })(size));
            return ((target:Object) => {
                target["color"] = planeColor;
                target["zones"] = zones;
                return target;

            })(new Object());
        }
    }
    JsAdapter["__class"] = "com.vzome.jsweet.JsAdapter";

}
namespace com.vzome.core.kinds {
    export abstract class AbstractSymmetryPerspective implements com.vzome.core.editor.SymmetryPerspective {
        symmetry: com.vzome.core.math.symmetry.Symmetry;

        /*private*/ geometries: java.util.List<com.vzome.core.editor.api.Shapes>;

        /*private*/ defaultShapes: com.vzome.core.editor.api.Shapes;

        public constructor(symmetry: com.vzome.core.math.symmetry.Symmetry) {
            if (this.symmetry === undefined) { this.symmetry = null; }
            this.geometries = <any>(new java.util.ArrayList<any>());
            this.defaultShapes = null;
            this.symmetry = symmetry;
        }

        /**
         * 
         * @return {*}
         */
        public getSymmetry(): com.vzome.core.math.symmetry.Symmetry {
            return this.symmetry;
        }

        /**
         * 
         * @return {string}
         */
        public getName(): string {
            return this.getSymmetry().getName();
        }

        /**
         * 
         * @return {string}
         */
        public getLabel(): string {
            return this.getSymmetry().getName();
        }

        addShapes(shapes: com.vzome.core.editor.api.Shapes) {
            const old: com.vzome.core.editor.api.Shapes = this.getGeometry(shapes.getName());
            if (old != null){
                this.geometries.remove(old);
            }
            this.geometries.add(shapes);
        }

        clearShapes() {
            this.geometries.clear();
            this.defaultShapes = null;
        }

        /**
         * 
         * @return {*}
         */
        public getGeometries(): java.util.List<com.vzome.core.editor.api.Shapes> {
            return this.geometries;
        }

        /*private*/ getGeometry(name: string): com.vzome.core.editor.api.Shapes {
            for(let index=this.geometries.iterator();index.hasNext();) {
                let shapes = index.next();
                {
                    if (shapes.getName() === name){
                        return shapes;
                    }
                }
            }
            return null;
        }

        public setDefaultGeometry(shapes: com.vzome.core.editor.api.Shapes) {
            this.defaultShapes = shapes;
            this.addShapes(shapes);
        }

        /**
         * 
         * @return {*}
         */
        public getDefaultGeometry(): com.vzome.core.editor.api.Shapes {
            return this.defaultShapes;
        }

        /**
         * 
         * @param {string} action
         * @return {*}
         */
        public getLegacyCommand(action: string): com.vzome.core.commands.Command {
            switch((action)) {
            case "octasymm":
                {
                    let octaSymm: com.vzome.core.math.symmetry.Symmetry = this.getSymmetry();
                    if (!(octaSymm != null && octaSymm instanceof <any>com.vzome.core.math.symmetry.OctahedralSymmetry)){
                        octaSymm = new com.vzome.core.math.symmetry.OctahedralSymmetry(octaSymm.getField());
                    }
                    return new com.vzome.core.commands.CommandSymmetry(octaSymm);
                };
            case "tetrasymm":
                {
                    const symmetry: com.vzome.core.math.symmetry.Symmetry = this.getSymmetry();
                    const closure: number[] = symmetry.subgroup(com.vzome.core.math.symmetry.Symmetry.TETRAHEDRAL);
                    return new com.vzome.core.commands.CommandTetrahedralSymmetry(symmetry);
                };
            default:
                return null;
            }
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Direction} orbit
         * @return {boolean}
         */
        public orbitIsStandard(orbit: com.vzome.core.math.symmetry.Direction): boolean {
            return orbit.isStandard();
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Direction} orbit
         * @return {boolean}
         */
        public orbitIsBuildDefault(orbit: com.vzome.core.math.symmetry.Direction): boolean {
            const zone0: com.vzome.core.math.symmetry.Axis = orbit.getAxis$int$int(0, 0);
            return zone0.getRotationPermutation() != null;
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Direction} orbit
         * @return {*}
         */
        public getOrbitUnitLength(orbit: com.vzome.core.math.symmetry.Direction): com.vzome.core.algebra.AlgebraicNumber {
            return orbit.getUnitLength();
        }

        public abstract createToolFactories(kind?: any, model?: any): any;
        public abstract getModelResourcePath(): any;
        public abstract predefineTools(kind?: any, model?: any): any;    }
    AbstractSymmetryPerspective["__class"] = "com.vzome.core.kinds.AbstractSymmetryPerspective";
    AbstractSymmetryPerspective["__interfaces"] = ["com.vzome.core.editor.SymmetryPerspective"];


}
namespace com.vzome.core.kinds {
    export class DefaultFieldApplication implements com.vzome.core.editor.FieldApplication {
        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        /*private*/ octahedralPerspective: com.vzome.core.editor.SymmetryPerspective;

        /*private*/ groups4d: java.util.Map<string, com.vzome.core.math.symmetry.CoxeterGroup>;

        /*private*/ pointsymm: com.vzome.core.commands.Command;

        /*private*/ mirrorsymm: com.vzome.core.commands.Command;

        /*private*/ translate: com.vzome.core.commands.Command;

        /*private*/ centroid: com.vzome.core.commands.Command;

        /*private*/ hideball: com.vzome.core.commands.Command;

        /*private*/ hide: com.vzome.core.commands.Command;

        /*private*/ panel: com.vzome.core.commands.Command;

        /*private*/ midpoint: com.vzome.core.commands.Command;

        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            if (this.field === undefined) { this.field = null; }
            if (this.octahedralPerspective === undefined) { this.octahedralPerspective = null; }
            this.groups4d = <any>(new java.util.HashMap<string, com.vzome.core.math.symmetry.CoxeterGroup>());
            this.pointsymm = new com.vzome.core.commands.CommandCentralSymmetry();
            this.mirrorsymm = new com.vzome.core.commands.CommandMirrorSymmetry();
            this.translate = new com.vzome.core.commands.CommandTranslate();
            this.centroid = new com.vzome.core.commands.CommandCentroid();
            this.hideball = new com.vzome.core.commands.CommandHide();
            this.hide = new com.vzome.core.commands.CommandHide();
            this.panel = new com.vzome.core.commands.CommandPolygon();
            this.midpoint = new com.vzome.core.commands.CommandMidpoint();
            this.field = field;
        }

        /**
         * 
         * @return {string}
         */
        public getName(): string {
            return this.field.getName();
        }

        /**
         * 
         * @return {string}
         */
        public getLabel(): string {
            return null;
        }

        /**
         * 
         * @return {*}
         */
        public getField(): com.vzome.core.algebra.AlgebraicField {
            return this.field;
        }

        /**
         * 
         * @return {*}
         */
        public getDefaultSymmetryPerspective(): com.vzome.core.editor.SymmetryPerspective {
            return this.getSymmetryPerspective("octahedral");
        }

        /**
         * 
         * @return {*}
         */
        public getSymmetryPerspectives(): java.util.Collection<com.vzome.core.editor.SymmetryPerspective> {
            return java.util.Arrays.asList<any>(this.getDefaultSymmetryPerspective());
        }

        /**
         * 
         * @param {string} symmName
         * @return {*}
         */
        public getSymmetryPerspective(symmName: string): com.vzome.core.editor.SymmetryPerspective {
            switch((symmName)) {
            case "octahedral":
                if (this.octahedralPerspective == null){
                    this.octahedralPerspective = new com.vzome.core.kinds.OctahedralSymmetryPerspective(this.field);
                }
                return this.octahedralPerspective;
            default:
                return null;
            }
        }

        /**
         * 
         * @param {string} name
         * @return {com.vzome.core.math.symmetry.QuaternionicSymmetry}
         */
        public getQuaternionSymmetry(name: string): com.vzome.core.math.symmetry.QuaternionicSymmetry {
            return null;
        }

        /**
         * 
         * @param {*} toolFactories
         * @param {com.vzome.core.editor.ToolsModel} tools
         */
        public registerToolFactories(toolFactories: java.util.Map<string, com.vzome.api.Tool.Factory>, tools: com.vzome.core.editor.ToolsModel) {
            toolFactories.put("SymmetryTool", new com.vzome.core.tools.OctahedralToolFactory(tools, null));
            toolFactories.put("RotationTool", new com.vzome.core.tools.RotationToolFactory(tools, null));
            toolFactories.put("ScalingTool", new com.vzome.core.tools.ScalingToolFactory(tools, null));
            toolFactories.put("InversionTool", new com.vzome.core.tools.InversionToolFactory(tools));
            toolFactories.put("LineReflectionTool", new com.vzome.core.tools.LineReflectionToolFactory(tools));
            toolFactories.put("MirrorTool", new com.vzome.core.tools.MirrorToolFactory(tools));
            toolFactories.put("TranslationTool", new com.vzome.core.tools.TranslationToolFactory(tools));
            toolFactories.put("ProjectionTool", new com.vzome.core.tools.ProjectionToolFactory(tools));
            toolFactories.put("PerspectiveProjectionTool", new com.vzome.core.tools.PerspectiveProjectionToolFactory(tools));
            toolFactories.put("BookmarkTool", new com.vzome.core.tools.BookmarkToolFactory(tools));
            toolFactories.put("LinearTransformTool", new com.vzome.core.tools.LinearMapToolFactory(tools, null, false));
            toolFactories.put("LinearMapTool", new com.vzome.core.tools.LinearMapToolFactory(tools, null, true));
            toolFactories.put("ModuleTool", new com.vzome.core.tools.ModuleToolFactory(tools));
            toolFactories.put("PlaneSelectionTool", new com.vzome.core.tools.PlaneSelectionToolFactory(tools));
        }

        /**
         * 
         * @param {string} groupName
         * @param {number} index
         * @param {number} edgesToRender
         * @param {com.vzome.core.algebra.AlgebraicNumber[]} edgeScales
         * @param {*} listener
         */
        public constructPolytope(groupName: string, index: number, edgesToRender: number, edgeScales: com.vzome.core.algebra.AlgebraicNumber[], listener: com.vzome.core.math.symmetry.WythoffConstruction.Listener) {
            let group: com.vzome.core.math.symmetry.CoxeterGroup = this.groups4d.get(groupName);
            if (group == null){
                switch((groupName)) {
                case "A4":
                    group = new com.vzome.core.math.symmetry.A4Group(this.field);
                    break;
                case "D4":
                    group = new com.vzome.core.math.symmetry.D4Group(this.field);
                    break;
                case "F4":
                    group = new com.vzome.core.math.symmetry.F4Group(this.field);
                    break;
                default:
                    group = new com.vzome.core.math.symmetry.B4Group(this.field);
                    break;
                }
                this.groups4d.put(groupName, group);
            }
            com.vzome.core.math.symmetry.WythoffConstruction.constructPolytope(group, index, edgesToRender, edgeScales, group, listener);
        }

        /**
         * 
         * @param {string} action
         * @return {*}
         */
        public getLegacyCommand(action: string): com.vzome.core.commands.Command {
            switch((action)) {
            case "pointsymm":
                return this.pointsymm;
            case "mirrorsymm":
                return this.mirrorsymm;
            case "translate":
                return this.translate;
            case "centroid":
                return this.centroid;
            case "hideball":
                return this.hideball;
            case "hide":
                return this.hide;
            case "panel":
                return this.panel;
            case "midpoint":
                return this.midpoint;
            case "octasymm":
                return this.getDefaultSymmetryPerspective().getLegacyCommand(action);
            default:
                return null;
            }
        }
    }
    DefaultFieldApplication["__class"] = "com.vzome.core.kinds.DefaultFieldApplication";
    DefaultFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D","com.vzome.core.editor.FieldApplication"];


}
namespace com.vzome.core.exporters {
    export interface DocumentExporterIntf {
        /**
         * Subclasses can override this if they need to export history, the lesson model, or the selection.
         * @param {*} doc
         * @param {java.io.File} file
         * @param {java.io.Writer} writer
         * @param {number} height
         * @param {number} width
         */
        exportDocument(doc: com.vzome.core.exporters.DocumentIntf, file: java.io.File, writer: java.io.Writer, height: number, width: number);
    }
}
namespace com.vzome.core.exporters {
    export interface DocumentIntf {
        getCameraModel(): com.vzome.core.viewing.CameraIntf;

        getSceneLighting(): com.vzome.core.viewing.Lights;

        getRenderedModel(): com.vzome.core.render.RenderedModel;

        getToolsModel(): com.vzome.core.editor.ToolsModel;

        getDetailsXml(dom: org.w3c.dom.Document, b: boolean): org.w3c.dom.Element;

        getEditorModel(): com.vzome.core.editor.api.EditorModel;
    }
}
namespace com.vzome.core.exporters {
    export class GitHubShare {
        /*private*/ designName: string;

        /*private*/ date: string;

        /*private*/ time: string;

        /*private*/ xml: string;

        /*private*/ png: string;

        /*private*/ shapesJson: string;

        /*private*/ handler: GitHubShare.EntryHandler;

        public constructor(fileName: string, date: string, time: string, xml: string, png: string, shapesJson: string) {
            if (this.designName === undefined) { this.designName = null; }
            if (this.date === undefined) { this.date = null; }
            if (this.time === undefined) { this.time = null; }
            if (this.xml === undefined) { this.xml = null; }
            if (this.png === undefined) { this.png = null; }
            if (this.shapesJson === undefined) { this.shapesJson = null; }
            if (this.handler === undefined) { this.handler = null; }
            this.date = date;
            this.time = time;
            this.xml = xml;
            this.png = png;
            this.shapesJson = shapesJson;
            this.designName = /* replaceAll */fileName.trim().replace(new RegExp(" ", 'g'),"-");
            const index: number = this.designName.toLowerCase().lastIndexOf(".vZome".toLowerCase());
            if (index > 0)this.designName = this.designName.substring(0, index);
            while((/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(this.designName, "-"))) {this.designName = this.designName.substring(1)};
            while((/* endsWith */((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(this.designName, "-"))) {this.designName = this.designName.substring(0, this.designName.lastIndexOf('-'))};
        }

        public getDesignName(): string {
            return this.designName;
        }

        public setEntryHandler(handler: GitHubShare.EntryHandler) {
            this.handler = handler;
        }

        public generateContent(orgName: string, repoName: string, branchName: string, title: string, description: string, blog: boolean, publish: boolean, style: string): string {
            const dateFolder: string = /* replace */this.date.split('-').join('/');
            const postSrcPath: string = "_posts/" + this.date + "-" + this.designName + "-" + this.time + ".md";
            const postPath: string = dateFolder + "/" + this.designName + "-" + this.time + ".html";
            const assetPath: string = dateFolder + "/" + this.time + "-" + this.designName + "/";
            const designPath: string = assetPath + this.designName + ".vZome";
            const imagePath: string = assetPath + this.designName + ".png";
            this.handler.addEntry(designPath, this.xml, "utf-8");
            this.handler.addEntry(imagePath, this.png, "base64");
            this.handler.addEntry(assetPath + this.designName + ".shapes.json", this.shapesJson, "utf-8");
            const viewerTemplate: string = com.vzome.xml.ResourceLoader.loadStringResource("com/vzome/core/exporters/github/viewerTemplate.md");
            const instructionsTemplate: string = com.vzome.xml.ResourceLoader.loadStringResource("com/vzome/core/exporters/github/instructionsTemplate.md");
            let viewerControls: string = "";
            let viewerParameters: string = "";
            let viewerScript: string = "";
            let componentTemplate: string = viewerTemplate;
            let postLayout: string = "vzome";
            let simpleLayout: string = "design";
            switch((style)) {
            case "indexed":
                {
                    viewerControls = "<div style=\'display:flex;\'><div style=\'margin: auto;\'><vzome-viewer-previous label=\'prev step\'></vzome-viewer-previous><vzome-viewer-next label=\'next step\'></vzome-viewer-next></div></div>";
                    viewerParameters = "indexed=\'true\'";
                    break;
                };
            case "indexed (load-camera)":
                {
                    viewerControls = "<div style=\'display:flex;\'><div style=\'margin: auto;\'><vzome-viewer-previous load-camera=\'true\' label=\'prev step\'></vzome-viewer-previous><vzome-viewer-next load-camera=\'true\' label=\'next step\'></vzome-viewer-next></div></div>";
                    viewerParameters = "indexed=\'true\'";
                    break;
                };
            case "menu":
            case "menu (named)":
                {
                    viewerParameters = "show-scenes=\'named\'";
                    break;
                };
            case "menu (all)":
                {
                    viewerParameters = "show-scenes=\'all\'";
                    break;
                };
            case "javascript":
                {
                    viewerParameters = "id=\'vzome-viewer\' reactive=\'false\'";
                    viewerScript = "<script type=\'module\'>\n  const viewer = document.querySelector( \'#vzome-viewer\' );\n  // viewer.scene = \'your scene\';\n  viewer.update();\n</script>\n";
                    break;
                };
            case "zometool":
                {
                    componentTemplate = instructionsTemplate;
                    postLayout = "zometool";
                    simpleLayout = "zometool";
                };
            default:
            }
            const siteUrl: string = "https://" + orgName + ".github.io/" + repoName;
            const repoUrl: string = "https://github.com/" + orgName + "/" + repoName;
            const gitUrl: string = repoUrl + "/tree/" + branchName + "/" + assetPath;
            const rawUrl: string = "https://raw.githubusercontent.com/" + orgName + "/" + repoName + "/" + branchName + "/" + designPath;
            const postUrl: string = siteUrl + "/" + postPath;
            const postSrcUrl: string = repoUrl + "/edit/" + branchName + "/" + postSrcPath;
            const indexSrcUrl: string = repoUrl + "/edit/" + branchName + "/" + assetPath + "index.md";
            const descriptionClean: string = /* replace *//* replace */description.split('\n').join(' ').split('\r').join(' ');
            const viewerComponent: string = /* replace *//* replace *//* replace *//* replace *//* replace */componentTemplate.split("${siteUrl}").join(siteUrl).split("${imagePath}").join(imagePath).split("${designPath}").join(designPath).split("${viewerControls}").join(viewerControls).split("${viewerParameters}").join(viewerParameters);
            const indexTemplate: string = com.vzome.xml.ResourceLoader.loadStringResource("com/vzome/core/exporters/github/indexTemplate.md");
            let indexMd: string = /* replace *//* replace *//* replace *//* replace *//* replace *//* replace *//* replace */indexTemplate.split("${simpleLayout}").join(simpleLayout).split("${viewerComponent}").join(viewerComponent).split("${title}").join(title).split("${description}").join(descriptionClean).split("${siteUrl}").join(siteUrl).split("${imagePath}").join(imagePath).split("${assetsUrl}").join(gitUrl);
            if (viewerScript !== "")indexMd = indexMd + viewerScript;
            this.handler.addEntry(assetPath + "index.md", indexMd, "utf-8");
            const readmeTemplate: string = com.vzome.xml.ResourceLoader.loadStringResource("com/vzome/core/exporters/github/readmeTemplate.md");
            let readmeMd: string = /* replace *//* replace *//* replace *//* replace *//* replace *//* replace *//* replace *//* replace */readmeTemplate.split("${viewerComponent}").join(viewerComponent).split("${imageFile}").join(this.designName + ".png").split("${siteUrl}").join(siteUrl).split("${assetPath}").join(assetPath).split("${imagePath}").join(imagePath).split("${viewerScript}").join(viewerScript).split("${indexSrcUrl}").join(indexSrcUrl).split("${rawUrl}").join(rawUrl);
            if (blog){
                const githubReadmeBlogPrefixTemplate: string = com.vzome.xml.ResourceLoader.loadStringResource("com/vzome/core/exporters/github/readmeBlogPrefixTemplate.md");
                const blogPostPrefix: string = /* replace *//* replace */githubReadmeBlogPrefixTemplate.split("${postUrl}").join(postUrl).split("${postSrcUrl}").join(postSrcUrl);
                readmeMd = blogPostPrefix + readmeMd;
                const postTemplate: string = com.vzome.xml.ResourceLoader.loadStringResource("com/vzome/core/exporters/github/postTemplate.md");
                let postMd: string = /* replace *//* replace *//* replace *//* replace *//* replace *//* replace *//* replace *//* replace *//* replace */postTemplate.split("${viewerComponent}").join(viewerComponent).split("${postLayout}").join(postLayout).split("${title}").join(title).split("${description}").join(descriptionClean).split("${published}").join((<boolean>publish).toString()).split("${siteUrl}").join(siteUrl).split("${postPath}").join(postPath).split("${imagePath}").join(imagePath).split("${assetsUrl}").join(gitUrl);
                if (viewerScript !== "")postMd = postMd + viewerScript;
                this.handler.addEntry(postSrcPath, postMd, "utf-8");
            }
            this.handler.addEntry(assetPath + "README.md", readmeMd, "utf-8");
            return gitUrl;
        }
    }
    GitHubShare["__class"] = "com.vzome.core.exporters.GitHubShare";


    export namespace GitHubShare {

        export interface EntryHandler {
            addEntry(path: string, content: string, encoding: string);
        }
    }

}
namespace com.vzome.core.exporters {
    export abstract class GeometryExporter {
        output: java.io.PrintWriter;

        mColors: com.vzome.core.render.Colors;

        mModel: com.vzome.core.render.RenderedModel;

        public constructor() {
            if (this.output === undefined) { this.output = null; }
            if (this.mColors === undefined) { this.mColors = null; }
            if (this.mModel === undefined) { this.mModel = null; }
        }

        /**
         * This is what most subclasses override.
         * @param {java.io.File} file
         * @param {java.io.Writer} writer
         * @param {number} height
         * @param {number} width
         */
        public abstract doExport(file: java.io.File, writer: java.io.Writer, height: number, width: number);

        public abstract getFileExtension(): string;

        public getContentType(): string {
            return "text/plain";
        }

        /**
         * Subclasses can override this if they don't rely on Manifestations and therefore can operate on article pages
         * See the comments below DocumentModel.getNaiveExporter() for a more complete explanation.
         * @return {boolean}
         */
        public needsManifestations(): boolean {
            return true;
        }

        getBoilerplate(resourcePath: string): string {
            return com.vzome.xml.ResourceLoader.loadStringResource(resourcePath);
        }

        public exportGeometry(model: com.vzome.core.render.RenderedModel, file: java.io.File, writer: java.io.Writer, height: number, width: number) {
            this.mModel = model;
            this.doExport(file, writer, height, width);
            this.mModel = null;
        }
    }
    GeometryExporter["__class"] = "com.vzome.core.exporters.GeometryExporter";

}
namespace com.vzome.core.render {
    export class Colors implements java.lang.Iterable<string> {
        public constructor(props: java.util.Properties) {
            this.mColors = <any>(new java.util.TreeMap<any, any>());
            this.mListeners = <any>(new java.util.ArrayList<any>());
            if (this.properties === undefined) { this.properties = null; }
            this.mNextNewColor = 3221;
            this.STEP = 73;
            this.properties = props;
        }

        public static RGB_CUSTOM: string = "rgb.custom";

        public static RGB_ORBIT: string = "rgb.orbit";

        public static PREFIX: string = "";

        public static BACKGROUND: string; public static BACKGROUND_$LI$(): string { if (Colors.BACKGROUND == null) { Colors.BACKGROUND = Colors.PREFIX + "background"; }  return Colors.BACKGROUND; }

        public static PANEL: string; public static PANEL_$LI$(): string { if (Colors.PANEL == null) { Colors.PANEL = Colors.PREFIX + "panel"; }  return Colors.PANEL; }

        public static HIGHLIGHT: string; public static HIGHLIGHT_$LI$(): string { if (Colors.HIGHLIGHT == null) { Colors.HIGHLIGHT = Colors.PREFIX + "highlight"; }  return Colors.HIGHLIGHT; }

        public static HIGHLIGHT_MAC: string; public static HIGHLIGHT_MAC_$LI$(): string { if (Colors.HIGHLIGHT_MAC == null) { Colors.HIGHLIGHT_MAC = Colors.HIGHLIGHT_$LI$() + ".mac"; }  return Colors.HIGHLIGHT_MAC; }

        public static CONNECTOR: string; public static CONNECTOR_$LI$(): string { if (Colors.CONNECTOR == null) { Colors.CONNECTOR = Colors.PREFIX + "connector"; }  return Colors.CONNECTOR; }

        public static DIRECTION: string; public static DIRECTION_$LI$(): string { if (Colors.DIRECTION == null) { Colors.DIRECTION = Colors.PREFIX + "direction."; }  return Colors.DIRECTION; }

        public static PLANE: string; public static PLANE_$LI$(): string { if (Colors.PLANE == null) { Colors.PLANE = Colors.DIRECTION_$LI$() + "plane."; }  return Colors.PLANE; }

        /*private*/ mColors: java.util.Map<string, com.vzome.core.construction.Color>;

        /*private*/ mListeners: java.util.List<Colors.Changes>;

        /*private*/ properties: java.util.Properties;

        public addColor(name: string, color: com.vzome.core.construction.Color) {
            this.mColors.put(name, color);
            for(let index=this.mListeners.iterator();index.hasNext();) {
                let next = index.next();
                {
                    next.colorAdded(name, color);
                }
            }
        }

        public setColor(name: string, color: com.vzome.core.construction.Color) {
            this.mColors.put(name, color);
            for(let index=this.mListeners.iterator();index.hasNext();) {
                let next = index.next();
                {
                    next.colorChanged(name, color);
                }
            }
        }

        public addListener(changes: Colors.Changes) {
            this.mListeners.add(changes);
        }

        public removeListener(changes: Colors.Changes) {
            this.mListeners.remove(changes);
        }

        /*private*/ mNextNewColor: number;

        /*private*/ STEP: number;

        static NO_VECTOR: number[]; public static NO_VECTOR_$LI$(): number[] { if (Colors.NO_VECTOR == null) { Colors.NO_VECTOR = [0.0, 0.0, 0.0]; }  return Colors.NO_VECTOR; }

        public getVectorPref(name: string): number[] {
            let result: number[] = Colors.NO_VECTOR_$LI$();
            const pref: string = this.properties.getProperty(name);
            if (pref == null || (pref === ("")))return result;
            result = /* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(result);
            const tokens: java.util.StringTokenizer = new java.util.StringTokenizer(pref, ", ");
            let i: number = 0;
            while((tokens.hasMoreTokens())) {result[i++] = javaemul.internal.FloatHelper.parseFloat(tokens.nextToken())};
            return result;
        }

        public getColorPref(name: string): com.vzome.core.construction.Color {
            const percents: number[] = this.getVectorPref("color.percent." + name);
            if (percents !== Colors.NO_VECTOR_$LI$()){
                return new com.vzome.core.construction.Color(Math.round((<any>Math).fround((<any>Math).fround(percents[0] * 255) / 100)), Math.round((<any>Math).fround((<any>Math).fround(percents[1] * 255) / 100)), Math.round((<any>Math).fround((<any>Math).fround(percents[2] * 255) / 100)));
            }
            const pref: string = this.properties.getProperty("color." + name);
            return Colors.parseColor(pref);
        }

        public static parseColor(colorString: string): com.vzome.core.construction.Color {
            if (colorString == null || (colorString === ("")))return com.vzome.core.construction.Color.WHITE_$LI$();
            const tokens: java.util.StringTokenizer = new java.util.StringTokenizer(colorString, ", ");
            const rgb: number[] = [0, 0, 0];
            let i: number = 0;
            while((tokens.hasMoreTokens())) {rgb[i++] = javaemul.internal.IntegerHelper.parseInt(tokens.nextToken())};
            return new com.vzome.core.construction.Color(rgb[0], rgb[1], rgb[2]);
        }

        public static getColorName(color: com.vzome.core.construction.Color): string {
            return Colors.RGB_ORBIT + " " + color.getRed() + " " + color.getGreen() + " " + color.getBlue();
        }

        public getColor(name: string): com.vzome.core.construction.Color {
            let color: com.vzome.core.construction.Color = this.mColors.get(name);
            if (color == null){
                if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(name, Colors.DIRECTION_$LI$())){
                    const prefName: string = name.substring(Colors.DIRECTION_$LI$().length);
                    color = this.getColorPref(prefName);
                } else if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(name, Colors.PLANE_$LI$())){
                    const prefName: string = name.substring(Colors.PLANE_$LI$().length);
                    color = this.getColorPref(prefName);
                    color = color.getPastel();
                } else if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(name, Colors.RGB_ORBIT) || /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(name, Colors.RGB_CUSTOM)){
                    const tokens: java.util.StringTokenizer = new java.util.StringTokenizer(name);
                    tokens.nextToken();
                    const r: number = javaemul.internal.IntegerHelper.parseInt(tokens.nextToken());
                    const g: number = javaemul.internal.IntegerHelper.parseInt(tokens.nextToken());
                    const b: number = javaemul.internal.IntegerHelper.parseInt(tokens.nextToken());
                    color = new com.vzome.core.construction.Color(r, g, b);
                } else if (name === Colors.CONNECTOR_$LI$())color = this.getColorPref("white"); else if (name === Colors.HIGHLIGHT_$LI$())color = this.getColorPref("highlight"); else if (name === Colors.HIGHLIGHT_MAC_$LI$())color = this.getColorPref("highlight.mac"); else if (name === Colors.PANEL_$LI$())color = this.getColorPref("panels"); else if (name === Colors.BACKGROUND_$LI$())color = this.getColorPref("background");
                if (color == null){
                    this.mNextNewColor = (this.mNextNewColor + this.STEP) % 4096;
                    let i: number = this.mNextNewColor;
                    const r: number = 135 + ((i % 16) << 3);
                    i = i >> 4;
                    const g: number = 135 + ((i % 16) << 3);
                    i = i >> 4;
                    const b: number = 135 + ((i % 16) << 3);
                    i = i >> 4;
                    color = new com.vzome.core.construction.Color(r, g, b);
                }
                this.addColor(name, color);
            }
            return color;
        }

        /**
         * 
         * @return {*}
         */
        public iterator(): java.util.Iterator<string> {
            return this.mColors.keySet().iterator();
        }

        public reset() {
        }
    }
    Colors["__class"] = "com.vzome.core.render.Colors";
    Colors["__interfaces"] = ["java.lang.Iterable"];



    export namespace Colors {

        /**
         * @author Scott Vorthmann
         * @class
         */
        export interface Changes {
            colorAdded(name: string, color: com.vzome.core.construction.Color);

            colorChanged(name: string, newColor: com.vzome.core.construction.Color);
        }
    }

}
namespace com.vzome.core.render {
    export interface RenderingChanges {
        reset();

        manifestationAdded(manifestation: com.vzome.core.render.RenderedManifestation);

        manifestationRemoved(manifestation: com.vzome.core.render.RenderedManifestation);

        /**
         * Given two RMs that both render the same underlying Manifestation,
         * switch the associated graphics object's userData.
         * @param {com.vzome.core.render.RenderedManifestation} from
         * @param {com.vzome.core.render.RenderedManifestation} to
         */
        manifestationSwitched(from: com.vzome.core.render.RenderedManifestation, to: com.vzome.core.render.RenderedManifestation);

        glowChanged(manifestation: com.vzome.core.render.RenderedManifestation);

        colorChanged(manifestation: com.vzome.core.render.RenderedManifestation);

        locationChanged(manifestation: com.vzome.core.render.RenderedManifestation);

        orientationChanged(manifestation: com.vzome.core.render.RenderedManifestation);

        shapeChanged(manifestation: com.vzome.core.render.RenderedManifestation);

        labelChanged(manifestation: com.vzome.core.render.RenderedManifestation);

        /**
         * Change shapes all at once, if supported.
         * @param {*} shapes
         * @return {boolean} true if the rendering mechanism can support this
         */
        shapesChanged(shapes: com.vzome.core.editor.api.Shapes): boolean;
    }
}
namespace com.vzome.core.render {
    /**
     * @author Scott Vorthmann
     * @param {*} m
     * @param {*} orbitSource
     * @class
     */
    export class RenderedManifestation implements com.vzome.core.model.RenderedObject {
        /*private*/ mManifestation: com.vzome.core.model.Manifestation;

        /*private*/ mShape: com.vzome.core.math.Polyhedron;

        /*private*/ color: com.vzome.core.construction.Color;

        /*private*/ mOrientation: com.vzome.core.algebra.AlgebraicMatrix;

        /*private*/ mGlow: number;

        /*private*/ mTransparency: number;

        /*private*/ mGraphicsObject: any;

        /*private*/ mPickable: boolean;

        /*private*/ isOffset: boolean;

        /*private*/ location: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ fixedLocation: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ strutZone: number;

        /*private*/ strutLength: com.vzome.core.algebra.AlgebraicNumber;

        /*private*/ strutOrbit: com.vzome.core.math.symmetry.Direction;

        /*private*/ strutSense: number;

        /*private*/ guid: java.util.UUID;

        static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (RenderedManifestation.logger == null) { RenderedManifestation.logger = java.util.logging.Logger.getLogger("com.vzome.core.render.RenderedManifestation"); }  return RenderedManifestation.logger; }

        /*private*/ orbitSource: com.vzome.core.editor.api.OrbitSource;

        /*private*/ label: string;

        public constructor(m: com.vzome.core.model.Manifestation, orbitSource: com.vzome.core.editor.api.OrbitSource) {
            if (this.mManifestation === undefined) { this.mManifestation = null; }
            if (this.mShape === undefined) { this.mShape = null; }
            this.color = null;
            if (this.mOrientation === undefined) { this.mOrientation = null; }
            this.mGlow = 0.0;
            this.mTransparency = 0.0;
            if (this.mGraphicsObject === undefined) { this.mGraphicsObject = null; }
            this.mPickable = true;
            this.isOffset = false;
            if (this.location === undefined) { this.location = null; }
            if (this.fixedLocation === undefined) { this.fixedLocation = null; }
            this.strutZone = -1;
            this.strutLength = null;
            this.strutOrbit = null;
            if (this.strutSense === undefined) { this.strutSense = 0; }
            this.guid = java.util.UUID.randomUUID();
            if (this.orbitSource === undefined) { this.orbitSource = null; }
            if (this.label === undefined) { this.label = null; }
            this.mManifestation = m;
            this.orbitSource = orbitSource;
            if (m != null)this.location = m.getLocation();
            this.fixedLocation = this.location;
            this.mOrientation = null;
        }

        /**
         * 
         * @return {string}
         */
        public toString(): string {
            return this.mManifestation.toString();
        }

        public getGuid(): java.util.UUID {
            return this.guid;
        }

        public setGraphicsObject(go: any) {
            this.mGraphicsObject = go;
        }

        public getGraphicsObject(): any {
            return this.mGraphicsObject;
        }

        public setGlow(glow: number) {
            this.mGlow = glow;
        }

        public getGlow(): number {
            return this.mGlow;
        }

        public setTransparency(trans: number) {
            this.mTransparency = trans;
        }

        public getTransparency(): number {
            return this.mTransparency;
        }

        public getShapeId(): java.util.UUID {
            return this.mShape.getGuid();
        }

        public getShape(): com.vzome.core.math.Polyhedron {
            return this.mShape;
        }

        public setPickable(value: boolean) {
            this.mPickable = value;
        }

        public isPickable(): boolean {
            return this.mPickable;
        }

        public getManifestation(): com.vzome.core.model.Manifestation {
            return this.mManifestation;
        }

        public getColor(): com.vzome.core.construction.Color {
            return this.color;
        }

        public getColorWeb(): string {
            return this.color.toWebString();
        }

        public setColor(color: com.vzome.core.construction.Color) {
            this.color = color;
        }

        public setOrientation(m: com.vzome.core.algebra.AlgebraicMatrix) {
            this.mOrientation = m;
        }

        public getOrientation(): com.vzome.core.algebra.AlgebraicMatrix {
            return this.mOrientation;
        }

        public getLocation(): com.vzome.core.math.RealVector {
            if (this.location != null)return this.getEmbedding().embedInR3(this.location); else return new com.vzome.core.math.RealVector(0.0, 0.0, 0.0);
        }

        public getLocationAV(): com.vzome.core.algebra.AlgebraicVector {
            return this.location;
        }

        public getEmbedding(): com.vzome.core.math.symmetry.Embedding {
            return this.orbitSource.getSymmetry();
        }

        /**
         * 
         * @return {number}
         */
        public hashCode(): number {
            return /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})(this.guid));
        }

        /**
         * 
         * @param {*} obj
         * @return {boolean}
         */
        public equals(obj: any): boolean {
            if (this === obj){
                return true;
            }
            if (obj == null){
                return false;
            }
            if ((<any>this.constructor) !== (<any>obj.constructor)){
                return false;
            }
            const other: RenderedManifestation = <RenderedManifestation>obj;
            if (this.fixedLocation == null){
                if (other.fixedLocation != null){
                    return false;
                }
            } else if (!this.fixedLocation.equals(other.fixedLocation)){
                return false;
            }
            if (this.isOffset !== other.isOffset){
                return false;
            }
            if (this.mOrientation == null){
                if (other.mOrientation != null){
                    return false;
                }
            } else if (!this.mOrientation.equals(other.mOrientation)){
                return false;
            }
            if (this.mShape == null){
                if (other.mShape != null){
                    return false;
                }
            } else if (!this.mShape.equals(other.mShape)){
                return false;
            }
            if (this.strutSense !== other.strutSense){
                return false;
            }
            return true;
        }

        public copy(): RenderedManifestation {
            const copy: RenderedManifestation = new RenderedManifestation(null, this.orbitSource);
            copy.location = this.location;
            copy.fixedLocation = this.fixedLocation;
            copy.color = this.color;
            copy.mGlow = this.mGlow;
            copy.mOrientation = this.mOrientation;
            copy.mShape = this.mShape;
            copy.mTransparency = this.mTransparency;
            copy.strutLength = this.strutLength;
            copy.strutZone = this.strutZone;
            copy.label = this.label;
            return copy;
        }

        public setStrut(orbit: com.vzome.core.math.symmetry.Direction, zone: number, sense: number, length: com.vzome.core.algebra.AlgebraicNumber) {
            this.strutOrbit = orbit;
            this.strutZone = zone;
            this.strutSense = sense;
            this.strutLength = length;
        }

        public getStrutZone(): number {
            return this.strutZone;
        }

        public getStrutSense(): number {
            return this.strutSense;
        }

        public getStrutLength(): com.vzome.core.algebra.AlgebraicNumber {
            return this.strutLength;
        }

        public getStrutOrbit(): com.vzome.core.math.symmetry.Direction {
            return this.strutOrbit;
        }

        offsetLocation() {
            if (this.mManifestation != null){
                const strut: com.vzome.core.model.Strut = <com.vzome.core.model.Strut><any>this.mManifestation;
                this.location = strut.getEnd();
                this.isOffset = true;
            }
        }

        resetLocation() {
            if (this.mManifestation != null){
                this.location = this.mManifestation.getLocation();
                this.isOffset = false;
            }
        }

        public getSymmetryShapes(): string {
            return this.orbitSource.getName() + ":" + this.orbitSource.getShapes().getName();
        }

        public resetAttributes(oneSidedPanels: boolean, colorPanels: boolean) {
            const label: string = this.mManifestation.getLabel();
            if (null != label){
                this.setLabel(label);
            }
            if (this.mManifestation != null && (this.mManifestation.constructor != null && this.mManifestation.constructor["__interfaces"] != null && this.mManifestation.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                this.resetPanelAttributes(oneSidedPanels, colorPanels);
            } else if (this.orbitSource.getShapes() == null){
                return;
            } else if (this.mManifestation != null && (this.mManifestation.constructor != null && this.mManifestation.constructor["__interfaces"] != null && this.mManifestation.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                this.resetConnectorAttributes(<com.vzome.core.model.Connector><any>this.mManifestation);
            } else if (this.mManifestation != null && (this.mManifestation.constructor != null && this.mManifestation.constructor["__interfaces"] != null && this.mManifestation.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                const strut: com.vzome.core.model.Strut = <com.vzome.core.model.Strut><any>this.mManifestation;
                this.resetStrutAttributes(strut);
            } else throw new java.lang.UnsupportedOperationException("only strut, ball, and panel shapes currently supported");
        }

        /*private*/ resetPanelAttributes(oneSidedPanels: boolean, colorPanels: boolean) {
            const shapes: com.vzome.core.editor.api.Shapes = this.orbitSource.getShapes();
            const panel: com.vzome.core.model.Panel = <com.vzome.core.model.Panel><any>this.mManifestation;
            this.location = panel.getFirstVertex();
            const relativeVertices: java.util.List<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>());
            for(let index=panel.iterator();index.hasNext();) {
                let vertex = index.next();
                {
                    relativeVertices.add(vertex.minus(this.location));
                }
            }
            const normal: com.vzome.core.algebra.AlgebraicVector = panel['getNormal$']();
            if (normal.isOrigin())return;
            const zone: com.vzome.core.math.symmetry.Axis = this.orbitSource.getAxis(normal);
            const shape: com.vzome.core.math.Polyhedron = shapes.getPanelShape(panel.getVertexCount(), panel.getQuadrea(), zone, relativeVertices, oneSidedPanels);
            if (shape == null)return;
            this.mShape = shape;
            if (zone == null){
                this.setColor(com.vzome.core.construction.Color.WHITE_$LI$());
                return;
            }
            const orn: number = zone.getOrientation();
            const orientation: com.vzome.core.algebra.AlgebraicMatrix = shapes.getSymmetry().getMatrix(orn);
            this.setOrientation(orientation);
            this.strutZone = zone.getOrientation();
            if (!colorPanels)return;
            try {
                panel.setZoneVector(zone.normal());
                const orbit: com.vzome.core.math.symmetry.Direction = zone.getDirection();
                let color: com.vzome.core.construction.Color = this.mManifestation.getColor();
                if (color == null){
                    color = this.orbitSource.getColor(orbit);
                    if (color != null)color = color.getPastel();
                }
                this.setColor(color);
            } catch(e) {
                if (RenderedManifestation.logger_$LI$().isLoggable(java.util.logging.Level.WARNING))RenderedManifestation.logger_$LI$().warning("Unable to set color for panel, normal = " + normal.toString());
            }
        }

        resetStrutAttributes(strut: com.vzome.core.model.Strut) {
            const shapes: com.vzome.core.editor.api.Shapes = this.orbitSource.getShapes();
            const offset: com.vzome.core.algebra.AlgebraicVector = strut.getOffset();
            if (offset.isOrigin())return;
            const axis: com.vzome.core.math.symmetry.Axis = this.orbitSource.getAxis(offset);
            if (axis == null)return;
            strut.setZoneVector(axis.normal());
            const orbit: com.vzome.core.math.symmetry.Direction = axis.getDirection();
            const len: com.vzome.core.algebra.AlgebraicNumber = axis.getLength(offset);
            const prototypeLengthShape: com.vzome.core.math.Polyhedron = shapes.getStrutShape(orbit, len);
            if (prototypeLengthShape == null)return;
            this.mShape = prototypeLengthShape;
            const orn: number = axis.getOrientation();
            const orientation: com.vzome.core.algebra.AlgebraicMatrix = shapes.getSymmetry().getMatrix(orn);
            const reflection: com.vzome.core.algebra.AlgebraicMatrix = this.orbitSource.getSymmetry().getPrincipalReflection();
            if (reflection != null){
                if (RenderedManifestation.logger_$LI$().isLoggable(java.util.logging.Level.FINE)){
                    RenderedManifestation.logger_$LI$().fine("rendering " + offset + " as " + axis);
                }
                if (axis.getSense() === com.vzome.core.math.symmetry.Axis.MINUS){
                    if (RenderedManifestation.logger_$LI$().isLoggable(java.util.logging.Level.FINER)){
                        RenderedManifestation.logger_$LI$().finer("mirroring orientation " + orn);
                    }
                    this.mShape = prototypeLengthShape.getEvilTwin(reflection);
                }
                if (!axis.isOutbound()){
                    this.offsetLocation();
                } else this.resetLocation();
            } else {
                if (axis.getSense() === com.vzome.core.math.symmetry.Axis.MINUS){
                    this.offsetLocation();
                } else this.resetLocation();
            }
            this.setStrut(orbit, orn, axis.getSense(), len);
            this.setOrientation(orientation);
            let color: com.vzome.core.construction.Color = this.getManifestation().getColor();
            if (color == null)color = shapes.getColor(orbit);
            if (color == null)color = this.orbitSource.getColor(orbit);
            this.setColor(color);
        }

        resetConnectorAttributes(m: com.vzome.core.model.Connector) {
            const shapes: com.vzome.core.editor.api.Shapes = this.orbitSource.getShapes();
            this.mShape = shapes.getConnectorShape();
            let color: com.vzome.core.construction.Color = this.getManifestation().getColor();
            if (color == null)color = shapes.getColor(null);
            if (color == null)color = this.orbitSource.getColor(null);
            this.setColor(color);
            this.setOrientation(this.orbitSource.getSymmetry().getField().identityMatrix(3));
        }

        public setOrbitSource(orbitSource: com.vzome.core.editor.api.OrbitSource) {
            this.orbitSource = orbitSource;
        }

        public getOrbitSource(): com.vzome.core.editor.api.OrbitSource {
            return this.orbitSource;
        }

        public getLabel(): string {
            return this.label;
        }

        public setLabel(label: string) {
            this.label = label;
        }
    }
    RenderedManifestation["__class"] = "com.vzome.core.render.RenderedManifestation";
    RenderedManifestation["__interfaces"] = ["com.vzome.core.model.RenderedObject"];


}
namespace com.vzome.core.render {
    /**
     * @author vorth
     * @class
     */
    export interface ZomicEventHandler {
        step(axis: com.vzome.core.math.symmetry.Axis, length: com.vzome.core.algebra.AlgebraicNumber);

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Axis} axis
         * @param {number} steps
         */
        rotate(axis: com.vzome.core.math.symmetry.Axis, steps: number);

        /**
         * Reflect through a blue axis, or through the current location point
         * if blueAxis == null.
         * @param {com.vzome.core.math.symmetry.Axis} blueAxis
         */
        reflect(blueAxis: com.vzome.core.math.symmetry.Axis);

        permute(permutation: com.vzome.core.math.symmetry.Permutation, sense: number);

        scale(scale: com.vzome.core.algebra.AlgebraicNumber);

        action(action: number);

        save(variables: number): ZomicEventHandler;

        restore(changes: ZomicEventHandler, variables: number);
    }

    export namespace ZomicEventHandler {

        /**
         * Constants for use with save();
         */
        export const ALL: number = 15;

        /**
         * Constants for use with save();
         */
        export const LOCATION: number = 1;

        /**
         * Constants for use with save();
         */
        export const SCALE: number = 2;

        /**
         * Constants for use with save();
         */
        export const ORIENTATION: number = 4;

        /**
         * Constants for use with save();
         */
        export const ACTION: number = 8;

        /**
         * Constants for use with action().
         */
        export const JUST_MOVE: number = 0;

        /**
         * Constants for use with action().
         */
        export const BUILD: number = 1;

        /**
         * Constants for use with action().
         */
        export const DESTROY: number = 2;
    }

}
namespace com.vzome.core.render {
    export class RenderedModel implements com.vzome.core.model.ManifestationChanges, java.lang.Iterable<com.vzome.core.render.RenderedManifestation> {
        mListeners: java.util.List<com.vzome.core.render.RenderingChanges>;

        /*private*/ mPolyhedra: com.vzome.core.editor.api.Shapes;

        /*private*/ mSelectionGlow: number;

        mRendered: java.util.HashSet<com.vzome.core.render.RenderedManifestation>;

        byID: java.util.HashMap<string, com.vzome.core.render.RenderedManifestation>;

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        /*private*/ orbitSource: com.vzome.core.editor.api.OrbitSource;

        /*private*/ oneSidedPanels: boolean;

        /*private*/ mainListener: com.vzome.core.render.RenderingChanges;

        /*private*/ enabled: boolean;

        /*private*/ colorPanels: boolean;

        public constructor(field?: any, orbitSource?: any) {
            if (((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((orbitSource != null && (orbitSource.constructor != null && orbitSource.constructor["__interfaces"] != null && orbitSource.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.OrbitSource") >= 0)) || orbitSource === null)) {
                let __args = arguments;
                if (this.mPolyhedra === undefined) { this.mPolyhedra = null; } 
                if (this.field === undefined) { this.field = null; } 
                if (this.orbitSource === undefined) { this.orbitSource = null; } 
                if (this.mainListener === undefined) { this.mainListener = null; } 
                this.mListeners = <any>(new java.util.ArrayList<any>());
                this.mSelectionGlow = 0.8;
                this.mRendered = <any>(new java.util.HashSet<any>());
                this.byID = <any>(new java.util.HashMap<any, any>());
                this.oneSidedPanels = false;
                this.enabled = true;
                this.colorPanels = true;
                this.field = field;
                this.orbitSource = orbitSource;
                this.mPolyhedra = (orbitSource == null) ? null : orbitSource.getShapes();
            } else if (((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || field === null) && orbitSource === undefined) {
                let __args = arguments;
                let symmetry: any = __args[0];
                {
                    let __args = arguments;
                    let field: any = symmetry.getField();
                    let orbitSource: any = new RenderedModel.SymmetryOrbitSource(symmetry);
                    if (this.mPolyhedra === undefined) { this.mPolyhedra = null; } 
                    if (this.field === undefined) { this.field = null; } 
                    if (this.orbitSource === undefined) { this.orbitSource = null; } 
                    if (this.mainListener === undefined) { this.mainListener = null; } 
                    this.mListeners = <any>(new java.util.ArrayList<any>());
                    this.mSelectionGlow = 0.8;
                    this.mRendered = <any>(new java.util.HashSet<any>());
                    this.byID = <any>(new java.util.HashMap<any, any>());
                    this.oneSidedPanels = false;
                    this.enabled = true;
                    this.colorPanels = true;
                    this.field = field;
                    this.orbitSource = orbitSource;
                    this.mPolyhedra = (orbitSource == null) ? null : orbitSource.getShapes();
                }
                (() => {
                    this.enabled = false;
                })();
            } else throw new Error('invalid overload');
        }

        public withColorPanels(setting: boolean): RenderedModel {
            this.colorPanels = setting;
            return this;
        }

        public getField(): com.vzome.core.algebra.AlgebraicField {
            return this.field;
        }

        public addListener(listener: com.vzome.core.render.RenderingChanges) {
            if (this.mainListener == null)this.mainListener = listener; else this.mListeners.add(listener);
        }

        public removeListener(listener: com.vzome.core.render.RenderingChanges) {
            if (this.mainListener === listener)this.mainListener = null; else this.mListeners.remove(listener);
        }

        public render(manifestation: com.vzome.core.model.Manifestation): com.vzome.core.render.RenderedManifestation {
            const rm: com.vzome.core.render.RenderedManifestation = new com.vzome.core.render.RenderedManifestation(manifestation, this.orbitSource);
            rm.resetAttributes(this.oneSidedPanels, this.colorPanels);
            return rm;
        }

        /**
         * 
         * @param {*} m
         */
        public manifestationAdded(m: com.vzome.core.model.Manifestation) {
            if (!this.enabled){
                m.setRenderedObject(new com.vzome.core.render.RenderedManifestation(m, this.orbitSource));
                return;
            }
            const rm: com.vzome.core.render.RenderedManifestation = this.render(m);
            const poly: com.vzome.core.math.Polyhedron = rm.getShape();
            if (poly == null)return;
            m.setRenderedObject(rm);
            this.mRendered.add(rm);
            this.byID.put(rm.getGuid().toString(), rm);
            if (this.mainListener != null)this.mainListener.manifestationAdded(rm);
            for(let index=this.mListeners.iterator();index.hasNext();) {
                let listener = index.next();
                {
                    listener.manifestationAdded(rm);
                }
            }
        }

        /**
         * 
         * @param {*} m
         */
        public manifestationRemoved(m: com.vzome.core.model.Manifestation) {
            if (!this.enabled){
                m.setRenderedObject(null);
                return;
            }
            const rendered: com.vzome.core.render.RenderedManifestation = <com.vzome.core.render.RenderedManifestation><any>(<com.vzome.core.model.HasRenderedObject><any>m).getRenderedObject();
            if (rendered == null)return;
            for(let index=this.mListeners.iterator();index.hasNext();) {
                let listener = index.next();
                {
                    listener.manifestationRemoved(rendered);
                }
            }
            if (this.mainListener != null)this.mainListener.manifestationRemoved(rendered);
            if (!this.mRendered.remove(rendered))throw new java.lang.IllegalStateException("unable to remove RenderedManifestation");
            this.byID.remove(rendered.getGuid().toString());
            m.setRenderedObject(null);
        }

        public getRenderedManifestation(guid: string): com.vzome.core.render.RenderedManifestation {
            return this.byID.get(guid);
        }

        public setManifestationGlow(m: com.vzome.core.model.Manifestation, on: boolean) {
            const rendered: com.vzome.core.render.RenderedManifestation = <com.vzome.core.render.RenderedManifestation><any>(<com.vzome.core.model.HasRenderedObject><any>m).getRenderedObject();
            if (rendered == null)return;
            rendered.setGlow(on ? this.mSelectionGlow : 0.0);
            if (this.mainListener != null)this.mainListener.glowChanged(rendered);
            for(let index=this.mListeners.iterator();index.hasNext();) {
                let listener = index.next();
                {
                    listener.glowChanged(rendered);
                }
            }
        }

        public setManifestationColor(m: com.vzome.core.model.Manifestation, color: com.vzome.core.construction.Color) {
            const rendered: com.vzome.core.render.RenderedManifestation = <com.vzome.core.render.RenderedManifestation><any>(<com.vzome.core.model.HasRenderedObject><any>m).getRenderedObject();
            if (rendered == null)return;
            rendered.setColor(color);
            if (this.mainListener != null)this.mainListener.colorChanged(rendered);
            for(let index=this.mListeners.iterator();index.hasNext();) {
                let listener = index.next();
                {
                    listener.colorChanged(rendered);
                }
            }
        }

        public setManifestationLabel(m: com.vzome.core.model.Manifestation, label: string) {
            const rendered: com.vzome.core.render.RenderedManifestation = <com.vzome.core.render.RenderedManifestation><any>(<com.vzome.core.model.HasRenderedObject><any>m).getRenderedObject();
            if (rendered == null)return;
            rendered.setLabel(label);
            if (this.mainListener != null)this.mainListener.labelChanged(rendered);
            for(let index=this.mListeners.iterator();index.hasNext();) {
                let listener = index.next();
                {
                    listener.labelChanged(rendered);
                }
            }
        }

        public setManifestationTransparency(m: com.vzome.core.model.Manifestation, on: boolean) {
            const rendered: com.vzome.core.render.RenderedManifestation = <com.vzome.core.render.RenderedManifestation><any>(<com.vzome.core.model.HasRenderedObject><any>m).getRenderedObject();
            if (rendered == null)return;
            rendered.setTransparency(on ? this.mSelectionGlow : 0.0);
            if (this.mainListener != null)this.mainListener.colorChanged(rendered);
            for(let index=this.mListeners.iterator();index.hasNext();) {
                let listener = index.next();
                {
                    listener.colorChanged(rendered);
                }
            }
        }

        /**
         * 
         * @return {*}
         */
        public iterator(): java.util.Iterator<com.vzome.core.render.RenderedManifestation> {
            return this.mRendered.iterator();
        }

        public getOrbitSource(): com.vzome.core.editor.api.OrbitSource {
            return this.orbitSource;
        }

        public setShapes(shapes: com.vzome.core.editor.api.Shapes) {
            const supported: boolean = this.mainListener.shapesChanged(shapes);
            if (!supported)this.setOrbitSource(this.orbitSource);
        }

        public setOrbitSource(orbitSource: com.vzome.core.editor.api.OrbitSource) {
            this.orbitSource = orbitSource;
            this.enabled = true;
            this.mPolyhedra = orbitSource.getShapes();
            if (this.mPolyhedra == null)return;
            {
                const newSet: java.util.HashSet<com.vzome.core.render.RenderedManifestation> = <any>(new java.util.HashSet<any>());
                for(const rms: java.util.Iterator<com.vzome.core.render.RenderedManifestation> = this.mRendered.iterator(); rms.hasNext(); ) {{
                    const rendered: com.vzome.core.render.RenderedManifestation = rms.next();
                    rms.remove();
                    const m: com.vzome.core.model.Manifestation = rendered.getManifestation();
                    if (m.isHidden())continue;
                    if (rendered.getShape() != null){
                        if (this.mainListener != null){
                            this.mainListener.manifestationRemoved(rendered);
                        }
                        for(let index=this.mListeners.iterator();index.hasNext();) {
                            let listener = index.next();
                            {
                                listener.manifestationRemoved(rendered);
                            }
                        }
                    }
                    rendered.setOrbitSource(this.orbitSource);
                    rendered.resetAttributes(this.oneSidedPanels, this.colorPanels);
                    newSet.add(rendered);
                    const glow: number = rendered.getGlow();
                    if (rendered.getShape() != null){
                        if (this.mainListener != null){
                            this.mainListener.manifestationAdded(rendered);
                            if (glow !== 0.0)this.mainListener.glowChanged(rendered);
                        }
                        for(let index=this.mListeners.iterator();index.hasNext();) {
                            let listener = index.next();
                            {
                                listener.manifestationAdded(rendered);
                                if (glow !== 0.0)listener.glowChanged(rendered);
                            }
                        }
                    }
                };}
                this.mRendered.addAll(newSet);
                for(let index=newSet.iterator();index.hasNext();) {
                    let rm = index.next();
                    {
                        this.byID.put(rm.getGuid().toString(), rm);
                    }
                }
            };
        }

        /**
         * 
         * @param {*} m
         * @param {com.vzome.core.construction.Color} color
         */
        public manifestationColored(m: com.vzome.core.model.Manifestation, color: com.vzome.core.construction.Color) {
            if (this.enabled)this.setManifestationColor(m, color);
        }

        /**
         * 
         * @param {*} m
         * @param {string} label
         */
        public manifestationLabeled(m: com.vzome.core.model.Manifestation, label: string) {
            if (this.enabled)this.setManifestationLabel(m, label);
        }

        public snapshot(): RenderedModel {
            const snapshot: RenderedModel = new RenderedModel(this.orbitSource.getSymmetry());
            for(let index=this.mRendered.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    const copy: com.vzome.core.render.RenderedManifestation = rm.copy();
                    snapshot.mRendered.add(copy);
                }
            }
            return snapshot;
        }

        /**
         * Switch a scene graph (changes) from rendering one RenderedModel to another one.
         * For RenderedManifestations that show the same object in both, just update the
         * attributes.
         * When "from" is empty, this is the initial rendering of the "to" RenderedModel.
         * @param {com.vzome.core.render.RenderedModel} from is an empty RenderedModel in some cases
         * @param {com.vzome.core.render.RenderedModel} to
         * @param {*} changes is a scene graph
         */
        public static renderChange(from: RenderedModel, to: RenderedModel, changes: com.vzome.core.render.RenderingChanges) {
            const toRemove: java.util.HashSet<com.vzome.core.render.RenderedManifestation> = <any>(new java.util.HashSet<any>(from.mRendered));
            toRemove.removeAll(to.mRendered);
            for(let index=toRemove.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    changes.manifestationRemoved(rm);
                }
            }
            const toAdd: java.util.HashSet<com.vzome.core.render.RenderedManifestation> = <any>(new java.util.HashSet<any>(to.mRendered));
            toAdd.removeAll(from.mRendered);
            for(let index=toAdd.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    changes.manifestationAdded(rm);
                }
            }
            for(let index=from.mRendered.iterator();index.hasNext();) {
                let fromRm = index.next();
                {
                    for(let index=to.mRendered.iterator();index.hasNext();) {
                        let toRm = index.next();
                        {
                            if (fromRm.equals(toRm)){
                                changes.manifestationSwitched(fromRm, toRm);
                                if (javaemul.internal.FloatHelper.floatToIntBits(fromRm.getGlow()) !== javaemul.internal.FloatHelper.floatToIntBits(toRm.getGlow()))changes.glowChanged(toRm);
                                const fromColor: com.vzome.core.construction.Color = fromRm.getColor();
                                const toColor: com.vzome.core.construction.Color = toRm.getColor();
                                if (fromColor == null && toColor == null)continue;
                                if ((fromColor == null && toColor != null) || (fromColor != null && toColor == null) || !fromColor.equals(toColor))changes.colorChanged(toRm);
                            }
                        }
                    }
                }
            }
        }

        public renderVector(av: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.math.RealVector {
            if (av != null)return this.getEmbedding().embedInR3(av); else return new com.vzome.core.math.RealVector(0.0, 0.0, 0.0);
        }

        public renderVectorDouble(av: com.vzome.core.algebra.AlgebraicVector): number[] {
            if (av != null)return this.getEmbedding().embedInR3Double(av); else return [0.0, 0.0, 0.0];
        }

        public getEmbedding(): com.vzome.core.math.symmetry.Embedding {
            return this.orbitSource.getSymmetry();
        }

        public measureDistanceCm(c1: com.vzome.core.model.Connector, c2: com.vzome.core.model.Connector): number {
            return this.measureLengthCm$com_vzome_core_math_RealVector(this.renderVector(c1.getLocation().minus(c2.getLocation())));
        }

        public getCmScaling(): number {
            return this.mPolyhedra.getCmScaling();
        }

        public measureLengthCm$com_vzome_core_math_RealVector(rv: com.vzome.core.math.RealVector): number {
            return rv.length() * this.mPolyhedra.getCmScaling();
        }

        public measureLengthCm(rv?: any): number {
            if (((rv != null && rv instanceof <any>com.vzome.core.math.RealVector) || rv === null)) {
                return <any>this.measureLengthCm$com_vzome_core_math_RealVector(rv);
            } else if (((rv != null && (rv.constructor != null && rv.constructor["__interfaces"] != null && rv.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || rv === null)) {
                return <any>this.measureLengthCm$com_vzome_core_model_Strut(rv);
            } else throw new Error('invalid overload');
        }

        public measureLengthCm$com_vzome_core_model_Strut(strut: com.vzome.core.model.Strut): number {
            return this.measureLengthCm$com_vzome_core_math_RealVector(this.renderVector(strut.getOffset()));
        }

        public measureDihedralAngle(p1: com.vzome.core.model.Panel, p2: com.vzome.core.model.Panel): number {
            const v1: com.vzome.core.math.RealVector = p1['getNormal$com_vzome_core_math_symmetry_Embedding'](this.getEmbedding());
            const v2: com.vzome.core.math.RealVector = p2['getNormal$com_vzome_core_math_symmetry_Embedding'](this.getEmbedding());
            return RenderedModel.safeAcos(v1, v2);
        }

        public measureAngle(s1: com.vzome.core.model.Strut, s2: com.vzome.core.model.Strut): number {
            const v1: com.vzome.core.math.RealVector = this.renderVector(s1.getOffset());
            const v2: com.vzome.core.math.RealVector = this.renderVector(s2.getOffset());
            return RenderedModel.safeAcos(v1, v2);
        }

        public static safeAcos(v1: com.vzome.core.math.RealVector, v2: com.vzome.core.math.RealVector): number {
            let cosine: number = v1.dot(v2) / (v1.length() * v2.length());
            cosine = Math.min(1.0, cosine);
            cosine = Math.max(-1.0, cosine);
            return Math.acos(cosine);
        }

        public getNearbyBall(location: com.vzome.core.math.RealVector, tolerance: number): com.vzome.core.render.RenderedManifestation {
            for(let index=this.mRendered.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    if (rm.getManifestation() != null && (rm.getManifestation().constructor != null && rm.getManifestation().constructor["__interfaces"] != null && rm.getManifestation().constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        const ballLoc: com.vzome.core.math.RealVector = rm.getLocation();
                        const distance: number = ballLoc.minus(location).length();
                        if (distance < tolerance)return rm;
                    }
                }
            }
            return null;
        }

        public getManifestations(): java.lang.Iterable<com.vzome.core.model.Manifestation> {
            return <any>(this.mRendered.stream().map<any>((rm) => rm.getManifestation()).collect<any, any>(java.util.stream.Collectors.toList<any>()));
        }
    }
    RenderedModel["__class"] = "com.vzome.core.render.RenderedModel";
    RenderedModel["__interfaces"] = ["com.vzome.core.model.ManifestationChanges","java.lang.Iterable"];



    export namespace RenderedModel {

        export class SymmetryOrbitSource implements com.vzome.core.editor.api.OrbitSource {
            /* Default method injected from com.vzome.core.editor.api.OrbitSource */
            getOrientations$(): number[][] {
                return this.getOrientations(false);
            }
            /* Default method injected from com.vzome.core.editor.api.OrbitSource */
            getEmbedding(): number[] {
                const symmetry: com.vzome.core.math.symmetry.Symmetry = this.getSymmetry();
                const field: com.vzome.core.algebra.AlgebraicField = symmetry.getField();
                const embedding: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(16);
                for(let i: number = 0; i < 3; i++) {{
                    const columnSelect: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, i);
                    const colRV: com.vzome.core.math.RealVector = symmetry.embedInR3(columnSelect);
                    embedding[i * 4 + 0] = colRV.x;
                    embedding[i * 4 + 1] = colRV.y;
                    embedding[i * 4 + 2] = colRV.z;
                    embedding[i * 4 + 3] = 0.0;
                };}
                embedding[12] = 0.0;
                embedding[13] = 0.0;
                embedding[14] = 0.0;
                embedding[15] = 1.0;
                return embedding;
            }
            /* Default method injected from com.vzome.core.editor.api.OrbitSource */
            getZone(orbit: string, orientation: number): com.vzome.core.math.symmetry.Axis {
                return this.getSymmetry().getDirection(orbit).getAxis(com.vzome.core.math.symmetry.Symmetry.PLUS, orientation);
            }
            /* Default method injected from com.vzome.core.editor.api.OrbitSource */
            public getOrientations(rowMajor?: any): number[][] {
                if (((typeof rowMajor === 'boolean') || rowMajor === null)) {
                    let __args = arguments;
                    if (this.symmetry === undefined) { this.symmetry = null; } 
                    if (this.orbits === undefined) { this.orbits = null; } 
                    return <any>(() => {
                        const symmetry: com.vzome.core.math.symmetry.Symmetry = this.getSymmetry();
                        const field: com.vzome.core.algebra.AlgebraicField = symmetry.getField();
                        const order: number = symmetry.getChiralOrder();
                        const orientations: number[][] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(order);
                        for(let orientation: number = 0; orientation < order; orientation++) {{
                            if (rowMajor){
                                orientations[orientation] = symmetry.getMatrix(orientation).getRowMajorRealElements();
                                continue;
                            }
                            const asFloats: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(16);
                            const transform: com.vzome.core.algebra.AlgebraicMatrix = symmetry.getMatrix(orientation);
                            for(let i: number = 0; i < 3; i++) {{
                                const columnSelect: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, i);
                                const columnI: com.vzome.core.algebra.AlgebraicVector = transform.timesColumn(columnSelect);
                                const colRV: com.vzome.core.math.RealVector = columnI.toRealVector();
                                asFloats[i * 4 + 0] = colRV.x;
                                asFloats[i * 4 + 1] = colRV.y;
                                asFloats[i * 4 + 2] = colRV.z;
                                asFloats[i * 4 + 3] = 0.0;
                            };}
                            asFloats[12] = 0.0;
                            asFloats[13] = 0.0;
                            asFloats[14] = 0.0;
                            asFloats[15] = 1.0;
                            orientations[orientation] = asFloats;
                        };}
                        return orientations;
                    })();
                } else if (rowMajor === undefined) {
                    return <any>this.getOrientations$();
                } else throw new Error('invalid overload');
            }
            symmetry: com.vzome.core.math.symmetry.Symmetry;

            orbits: com.vzome.core.math.symmetry.OrbitSet;

            constructor(symmetry: com.vzome.core.math.symmetry.Symmetry) {
                if (this.symmetry === undefined) { this.symmetry = null; }
                if (this.orbits === undefined) { this.orbits = null; }
                this.symmetry = symmetry;
                this.orbits = new com.vzome.core.math.symmetry.OrbitSet(symmetry);
            }

            /**
             * 
             * @param {com.vzome.core.math.symmetry.Direction} orbit
             * @return {com.vzome.core.construction.Color}
             */
            public getColor(orbit: com.vzome.core.math.symmetry.Direction): com.vzome.core.construction.Color {
                return new com.vzome.core.construction.Color(128, 123, 128);
            }

            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} vector
             * @return {com.vzome.core.math.symmetry.Axis}
             */
            public getAxis(vector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.math.symmetry.Axis {
                return this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](vector);
            }

            /**
             * 
             * @return {com.vzome.core.math.symmetry.OrbitSet}
             */
            public getOrbits(): com.vzome.core.math.symmetry.OrbitSet {
                return this.orbits;
            }

            /**
             * 
             * @return {*}
             */
            public getShapes(): com.vzome.core.editor.api.Shapes {
                return null;
            }

            /**
             * 
             * @return {*}
             */
            public getSymmetry(): com.vzome.core.math.symmetry.Symmetry {
                return this.symmetry;
            }

            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} vector
             * @return {com.vzome.core.construction.Color}
             */
            public getVectorColor(vector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.construction.Color {
                return null;
            }

            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return null;
            }
        }
        SymmetryOrbitSource["__class"] = "com.vzome.core.render.RenderedModel.SymmetryOrbitSource";
        SymmetryOrbitSource["__interfaces"] = ["com.vzome.core.editor.api.OrbitSource"];


    }

}
namespace com.vzome.core.render {
    export class TransparentRendering implements com.vzome.core.render.RenderingChanges {
        /*private*/ mRealOne: com.vzome.core.render.RenderingChanges;

        public constructor(realOne: com.vzome.core.render.RenderingChanges) {
            if (this.mRealOne === undefined) { this.mRealOne = null; }
            this.mRealOne = realOne;
        }

        /**
         * 
         */
        public reset() {
            this.mRealOne.reset();
        }

        /**
         * 
         * @param {com.vzome.core.render.RenderedManifestation} manifestation
         */
        public manifestationAdded(manifestation: com.vzome.core.render.RenderedManifestation) {
            manifestation.setTransparency(0.5);
            manifestation.setPickable(false);
            this.mRealOne.manifestationAdded(manifestation);
        }

        /**
         * 
         * @param {com.vzome.core.render.RenderedManifestation} manifestation
         */
        public manifestationRemoved(manifestation: com.vzome.core.render.RenderedManifestation) {
            this.mRealOne.manifestationRemoved(manifestation);
        }

        /**
         * 
         * @param {com.vzome.core.render.RenderedManifestation} manifestation
         */
        public glowChanged(manifestation: com.vzome.core.render.RenderedManifestation) {
            this.mRealOne.glowChanged(manifestation);
        }

        /**
         * 
         * @param {com.vzome.core.render.RenderedManifestation} manifestation
         */
        public labelChanged(manifestation: com.vzome.core.render.RenderedManifestation) {
            this.mRealOne.labelChanged(manifestation);
        }

        /**
         * 
         * @param {com.vzome.core.render.RenderedManifestation} manifestation
         */
        public colorChanged(manifestation: com.vzome.core.render.RenderedManifestation) {
            this.mRealOne.colorChanged(manifestation);
        }

        /**
         * 
         * @param {com.vzome.core.render.RenderedManifestation} manifestation
         */
        public locationChanged(manifestation: com.vzome.core.render.RenderedManifestation) {
            this.mRealOne.locationChanged(manifestation);
        }

        /**
         * 
         * @param {com.vzome.core.render.RenderedManifestation} manifestation
         */
        public orientationChanged(manifestation: com.vzome.core.render.RenderedManifestation) {
            this.mRealOne.orientationChanged(manifestation);
        }

        /**
         * 
         * @param {com.vzome.core.render.RenderedManifestation} manifestation
         */
        public shapeChanged(manifestation: com.vzome.core.render.RenderedManifestation) {
            this.mRealOne.shapeChanged(manifestation);
        }

        /**
         * 
         * @param {com.vzome.core.render.RenderedManifestation} from
         * @param {com.vzome.core.render.RenderedManifestation} to
         */
        public manifestationSwitched(from: com.vzome.core.render.RenderedManifestation, to: com.vzome.core.render.RenderedManifestation) {
            throw new java.lang.IllegalStateException();
        }

        /**
         * 
         * @param {*} shapes
         * @return {boolean}
         */
        public shapesChanged(shapes: com.vzome.core.editor.api.Shapes): boolean {
            return this.mRealOne.shapesChanged(shapes);
        }
    }
    TransparentRendering["__class"] = "com.vzome.core.render.TransparentRendering";
    TransparentRendering["__interfaces"] = ["com.vzome.core.render.RenderingChanges"];


}
namespace com.vzome.core.render {
    /**
     * This is no longer used statically everywhere.  Now, any Shapes subclass can override
     * getCmScaling(), and RenderedModel exposes that in its own methods.  See the default
     * implementation in AbstractShapes.
     * @class
     */
    export interface RealZomeScaling {    }

    export namespace RealZomeScaling {

        export const VZOME_BLUE_DIAMETER: number = 2.0;

        export const RZOME_BLUE_DIAMETER_INCHES: number = 0.6958;

        export const RZOME_BLUE_DIAMETER_CM: number = 1.7673;

        export const RZOME_INCH_SCALING: number = RealZomeScaling.RZOME_BLUE_DIAMETER_INCHES / RealZomeScaling.VZOME_BLUE_DIAMETER;

        export const RZOME_CM_SCALING: number = RealZomeScaling.RZOME_BLUE_DIAMETER_CM / RealZomeScaling.VZOME_BLUE_DIAMETER;

        export const RZOME_MM_SCALING: number = RealZomeScaling.RZOME_CM_SCALING * 10.0;

        export const VZOME_STRUT_MODEL_BALL_DIAMETER: number = 44.36;

        export const VZOME_STRUT_MODEL_INCH_SCALING: number = RealZomeScaling.RZOME_BLUE_DIAMETER_INCHES / RealZomeScaling.VZOME_STRUT_MODEL_BALL_DIAMETER;
    }

}
namespace com.vzome.core.render {
    /**
     * @author vorth
     * @param {*} symm
     * @class
     */
    export abstract class AbstractZomicEventHandler implements com.vzome.core.render.ZomicEventHandler {
        mSymmetry: com.vzome.core.math.symmetry.Symmetry;

        mOrientation: com.vzome.core.math.symmetry.Permutation;

        mHandedNess: number;

        mScale: com.vzome.core.algebra.AlgebraicNumber;

        mAction: number;

        public constructor(symm: com.vzome.core.math.symmetry.Symmetry) {
            if (this.mSymmetry === undefined) { this.mSymmetry = null; }
            if (this.mOrientation === undefined) { this.mOrientation = null; }
            this.mHandedNess = com.vzome.core.math.symmetry.Symmetry.PLUS;
            if (this.mScale === undefined) { this.mScale = null; }
            this.mAction = com.vzome.core.render.ZomicEventHandler.BUILD;
            this.mSymmetry = symm;
            this.mScale = symm.getField().one();
            this.mOrientation = this.mSymmetry.getPermutation(0);
        }

        getPermutation(): com.vzome.core.math.symmetry.Permutation {
            return this.mOrientation;
        }

        public getDirection(name: string): com.vzome.core.math.symmetry.Direction {
            return this.mSymmetry.getDirection(name);
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Permutation} permutation
         * @param {number} sense
         */
        public permute(permutation: com.vzome.core.math.symmetry.Permutation, sense: number) {
            this.mOrientation = permutation.compose(this.mOrientation);
            this.mHandedNess = (this.mHandedNess + sense) % 2;
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Axis} axis
         * @param {number} steps
         */
        public rotate(axis: com.vzome.core.math.symmetry.Axis, steps: number) {
            axis = this.mOrientation.permute(axis, this.mHandedNess);
            if (axis.getSense() === this.mHandedNess)steps *= -1;
            this.permute(axis.getRotationPermutation().power(steps), com.vzome.core.math.symmetry.Symmetry.PLUS);
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Axis} blueAxis
         */
        public reflect(blueAxis: com.vzome.core.math.symmetry.Axis) {
            if (blueAxis == null)this.permute(this.mSymmetry.getPermutation(0), com.vzome.core.math.symmetry.Symmetry.MINUS); else {
                blueAxis = this.mOrientation.permute(blueAxis, this.mHandedNess);
                this.permute(blueAxis.getRotationPermutation(), com.vzome.core.math.symmetry.Symmetry.MINUS);
            }
        }

        /**
         * 
         * @param {*} scale
         */
        public scale(scale: com.vzome.core.algebra.AlgebraicNumber) {
            this.mScale = this.mScale['times$com_vzome_core_algebra_AlgebraicNumber'](scale);
        }

        /**
         * 
         * @param {number} action
         */
        public action(action: number) {
            this.mAction = action;
        }

        abstract copyLocation(): AbstractZomicEventHandler;

        abstract restoreLocation(changed: AbstractZomicEventHandler);

        /**
         * 
         * @param {number} variables
         * @return {*}
         */
        public save(variables: number): com.vzome.core.render.ZomicEventHandler {
            const newVM: AbstractZomicEventHandler = this.copyLocation();
            newVM.mAction = this.mAction;
            newVM.mOrientation = this.mOrientation;
            newVM.mHandedNess = this.mHandedNess;
            newVM.mScale = this.mScale;
            return newVM;
        }

        /**
         * 
         * @param {*} changes
         * @param {number} variables
         */
        public restore(changes: com.vzome.core.render.ZomicEventHandler, variables: number) {
            const changedVM: AbstractZomicEventHandler = <AbstractZomicEventHandler><any>changes;
            if ((com.vzome.core.render.ZomicEventHandler.LOCATION & variables) === 0)this.restoreLocation(changedVM);
            if ((com.vzome.core.render.ZomicEventHandler.SCALE & variables) === 0)this.mScale = changedVM.mScale;
            if ((com.vzome.core.render.ZomicEventHandler.ORIENTATION & variables) === 0){
                this.mOrientation = changedVM.mOrientation;
                this.mHandedNess = changedVM.mHandedNess;
            }
            if ((com.vzome.core.render.ZomicEventHandler.ACTION & variables) === 0)this.mAction = changedVM.mAction;
        }

        public abstract step(axis?: any, length?: any): any;    }
    AbstractZomicEventHandler["__class"] = "com.vzome.core.render.AbstractZomicEventHandler";
    AbstractZomicEventHandler["__interfaces"] = ["com.vzome.core.render.ZomicEventHandler"];


}
namespace com.vzome.core.viewing {
    export abstract class AbstractShapes implements com.vzome.core.editor.api.Shapes {
        /*private*/ strutShapesByLengthAndOrbit: java.util.Map<com.vzome.core.math.symmetry.Direction, java.util.Map<com.vzome.core.algebra.AlgebraicNumber, com.vzome.core.math.Polyhedron>>;

        /*private*/ strutGeometriesByOrbit: java.util.Map<com.vzome.core.math.symmetry.Direction, com.vzome.core.parts.StrutGeometry>;

        /*private*/ panelShapes: java.util.Map<number, java.util.Map<com.vzome.core.algebra.AlgebraicNumber, java.util.Map<com.vzome.core.math.symmetry.Direction, java.util.HashMap<java.util.List<com.vzome.core.algebra.AlgebraicVector>, com.vzome.core.math.Polyhedron>>>>;

        mPkgName: string;

        mName: string;

        alias: string;

        mSymmetry: com.vzome.core.math.symmetry.Symmetry;

        mConnectorGeometry: com.vzome.core.math.Polyhedron;

        public constructor(pkgName: string, name: string, alias: string, symm: com.vzome.core.math.symmetry.Symmetry) {
            this.strutShapesByLengthAndOrbit = <any>(new java.util.HashMap<any, any>());
            this.strutGeometriesByOrbit = <any>(new java.util.HashMap<any, any>());
            this.panelShapes = <any>(new java.util.HashMap<any, any>());
            if (this.mPkgName === undefined) { this.mPkgName = null; }
            if (this.mName === undefined) { this.mName = null; }
            if (this.alias === undefined) { this.alias = null; }
            if (this.mSymmetry === undefined) { this.mSymmetry = null; }
            if (this.mConnectorGeometry === undefined) { this.mConnectorGeometry = null; }
            this.mPkgName = pkgName;
            this.mName = name;
            this.alias = alias;
            this.mConnectorGeometry = null;
            this.mSymmetry = symm;
        }

        /**
         * 
         * @return {string}
         */
        public toString(): string {
            return /* getSimpleName */(c => typeof c === 'string' ? (<any>c).substring((<any>c).lastIndexOf('.')+1) : c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.')+1) : c["name"].substring(c["name"].lastIndexOf('.')+1))((<any>this.constructor)) + "( Symmetry:" + this.mSymmetry.getName() + ", PkgName:" + this.mPkgName + ", Name:" + this.mName + (this.alias == null ? "" : (", Alias:" + this.alias)) + " )";
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Direction} dir
         * @return {com.vzome.core.construction.Color}
         */
        public getColor(dir: com.vzome.core.math.symmetry.Direction): com.vzome.core.construction.Color {
            return null;
        }

        /**
         * 
         * @return {boolean}
         */
        public hasColors(): boolean {
            return false;
        }

        createStrutGeometry(dir: com.vzome.core.math.symmetry.Direction): com.vzome.core.parts.StrutGeometry {
            return new com.vzome.core.parts.FastDefaultStrutGeometry(dir);
        }

        /*private*/ getStrutGeometry(orbit: com.vzome.core.math.symmetry.Direction): com.vzome.core.parts.StrutGeometry {
            let orbitStrutGeometry: com.vzome.core.parts.StrutGeometry = this.strutGeometriesByOrbit.get(orbit);
            if (orbitStrutGeometry == null){
                orbitStrutGeometry = this.createStrutGeometry(orbit);
                this.strutGeometriesByOrbit.put(orbit, orbitStrutGeometry);
            }
            return orbitStrutGeometry;
        }

        public getStrutGeometries(): java.util.Map<string, com.vzome.core.parts.StrutGeometry> {
            return <any>(java.util.Arrays.stream<any>(this.mSymmetry.getDirectionNames()).collect<any, any>(java.util.stream.Collectors.toMap<any, any, any>(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['apply'] ? funcInst['apply'] : funcInst) .call(funcInst, arg0)})((x=>x))), (name) => this.getStrutGeometry(this.mSymmetry.getDirection(name)))));
        }

        /**
         * 
         * @return {string}
         */
        public getName(): string {
            return this.mName;
        }

        /**
         * 
         * @return {string}
         */
        public getAlias(): string {
            return this.alias;
        }

        /**
         * 
         * @return {string}
         */
        public getPackage(): string {
            return this.mPkgName;
        }

        /**
         * 
         * @return {com.vzome.core.math.Polyhedron}
         */
        public getConnectorShape(): com.vzome.core.math.Polyhedron {
            if (this.mConnectorGeometry == null){
                this.mConnectorGeometry = this.buildConnectorShape(this.mPkgName);
                this.mConnectorGeometry.setName("ball");
            }
            return this.mConnectorGeometry;
        }

        abstract buildConnectorShape(pkgName: string): com.vzome.core.math.Polyhedron;

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Direction} orbit
         * @param {*} length
         * @return {com.vzome.core.math.Polyhedron}
         */
        public getStrutShape(orbit: com.vzome.core.math.symmetry.Direction, length: com.vzome.core.algebra.AlgebraicNumber): com.vzome.core.math.Polyhedron {
            let strutShapesByLength: java.util.Map<com.vzome.core.algebra.AlgebraicNumber, com.vzome.core.math.Polyhedron> = this.strutShapesByLengthAndOrbit.get(orbit);
            if (strutShapesByLength == null){
                strutShapesByLength = <any>(new java.util.HashMap<any, any>());
                this.strutShapesByLengthAndOrbit.put(orbit, strutShapesByLength);
            }
            let lengthShape: com.vzome.core.math.Polyhedron = strutShapesByLength.get(length);
            if (lengthShape == null){
                const orbitStrutGeometry: com.vzome.core.parts.StrutGeometry = this.getStrutGeometry(orbit);
                lengthShape = orbitStrutGeometry.getStrutPolyhedron(length);
                strutShapesByLength.put(length, lengthShape);
                if (lengthShape != null){
                    lengthShape.setName(orbit.getName() + strutShapesByLength.size());
                    lengthShape.setOrbit(orbit);
                    lengthShape.setLength(orbit.getLengthInUnits(length));
                }
            }
            return lengthShape;
        }

        /**
         * 
         * @return {*}
         */
        public getSymmetry(): com.vzome.core.math.symmetry.Symmetry {
            return this.mSymmetry;
        }

        /*private*/ makePanelPolyhedron(vertices: java.lang.Iterable<com.vzome.core.algebra.AlgebraicVector>, oneSided: boolean): com.vzome.core.math.Polyhedron {
            const poly: com.vzome.core.math.Polyhedron = new com.vzome.core.math.Polyhedron(this.mSymmetry.getField());
            poly.setPanel(true);
            let arity: number = 0;
            for(let index=vertices.iterator();index.hasNext();) {
                let gv = index.next();
                {
                    arity++;
                    poly.addVertex(gv);
                }
            }
            if (poly.getVertexList().size() < arity)return null;
            const front: com.vzome.core.math.Polyhedron.Face = poly.newFace();
            const back: com.vzome.core.math.Polyhedron.Face = poly.newFace();
            for(let i: number = 0; i < arity; i++) {{
                const j: number = i;
                front.add(j);
                back.add(0, j);
            };}
            poly.addFace(front);
            if (!oneSided)poly.addFace(back);
            return poly;
        }

        /**
         * 
         * @param {number} vertexCount
         * @param {*} quadrea
         * @param {com.vzome.core.math.symmetry.Axis} zone
         * @param {*} vertices
         * @param {boolean} oneSidedPanels
         * @return {com.vzome.core.math.Polyhedron}
         */
        public getPanelShape(vertexCount: number, quadrea: com.vzome.core.algebra.AlgebraicNumber, zone: com.vzome.core.math.symmetry.Axis, vertices: java.lang.Iterable<com.vzome.core.algebra.AlgebraicVector>, oneSidedPanels: boolean): com.vzome.core.math.Polyhedron {
            let map1: java.util.Map<com.vzome.core.algebra.AlgebraicNumber, java.util.Map<com.vzome.core.math.symmetry.Direction, java.util.HashMap<java.util.List<com.vzome.core.algebra.AlgebraicVector>, com.vzome.core.math.Polyhedron>>> = this.panelShapes.get(vertexCount);
            if (map1 == null){
                map1 = <any>(new java.util.HashMap<any, any>());
                this.panelShapes.put(vertexCount, map1);
            }
            let map2: java.util.Map<com.vzome.core.math.symmetry.Direction, java.util.HashMap<java.util.List<com.vzome.core.algebra.AlgebraicVector>, com.vzome.core.math.Polyhedron>> = map1.get(quadrea);
            if (map2 == null){
                map2 = <any>(new java.util.HashMap<any, any>());
                map1.put(quadrea, map2);
            }
            const orbit: com.vzome.core.math.symmetry.Direction = zone.getDirection();
            let map3: java.util.HashMap<java.util.List<com.vzome.core.algebra.AlgebraicVector>, com.vzome.core.math.Polyhedron> = map2.get(orbit);
            if (map3 == null){
                map3 = <any>(new java.util.HashMap<any, any>());
                map2.put(orbit, map3);
            }
            const orientation: number = zone.getOrientation();
            const perm: com.vzome.core.math.symmetry.Permutation = this.mSymmetry.getPermutation(orientation).inverse();
            const inverseOrientation: number = perm.mapIndex(0);
            const inverseTrans: com.vzome.core.algebra.AlgebraicMatrix = this.mSymmetry.getMatrix(inverseOrientation);
            const canonicalVertices: java.util.List<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>());
            for(let index=vertices.iterator();index.hasNext();) {
                let vertex = index.next();
                {
                    canonicalVertices.add(inverseTrans.timesColumn(vertex));
                }
            }
            let shape: com.vzome.core.math.Polyhedron = map3.get(canonicalVertices);
            if (shape == null){
                shape = this.makePanelPolyhedron(canonicalVertices, oneSidedPanels);
                map3.put(canonicalVertices, shape);
            }
            return shape;
        }

        /**
         * 
         * @return {number}
         */
        public getCmScaling(): number {
            return com.vzome.core.render.RealZomeScaling.RZOME_CM_SCALING;
        }
    }
    AbstractShapes["__class"] = "com.vzome.core.viewing.AbstractShapes";
    AbstractShapes["__interfaces"] = ["com.vzome.core.editor.api.Shapes"];


}
namespace com.vzome.core.viewing {
    export class ExportedVEFStrutGeometry implements com.vzome.core.parts.StrutGeometry {
        static LOGGER: java.util.logging.Logger; public static LOGGER_$LI$(): java.util.logging.Logger { if (ExportedVEFStrutGeometry.LOGGER == null) { ExportedVEFStrutGeometry.LOGGER = java.util.logging.Logger.getLogger("com.vzome.core.viewing.ExportedVEFStrutGeometry"); }  return ExportedVEFStrutGeometry.LOGGER; }

        public prototypeVertices: java.util.List<com.vzome.core.algebra.AlgebraicVector>;

        public prototypeFaces: java.util.List<java.util.List<number>>;

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        public prototypeVector: com.vzome.core.algebra.AlgebraicVector;

        public fullScaleVertices: java.util.Set<number>;

        public halfScaleVertices: java.util.Set<number>;

        /*private*/ shortGeometry: com.vzome.core.parts.StrutGeometry;

        public constructor(vertices?: any, faces?: any, prototype?: any, fullScaleVertices?: any, halfScaleVertices?: any, field?: any) {
            if (((vertices != null && (vertices.constructor != null && vertices.constructor["__interfaces"] != null && vertices.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || vertices === null) && ((faces != null && (faces.constructor != null && faces.constructor["__interfaces"] != null && faces.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || faces === null) && ((prototype != null && prototype instanceof <any>com.vzome.core.algebra.AlgebraicVector) || prototype === null) && ((fullScaleVertices != null && (fullScaleVertices.constructor != null && fullScaleVertices.constructor["__interfaces"] != null && fullScaleVertices.constructor["__interfaces"].indexOf("java.util.Set") >= 0)) || fullScaleVertices === null) && ((halfScaleVertices != null && (halfScaleVertices.constructor != null && halfScaleVertices.constructor["__interfaces"] != null && halfScaleVertices.constructor["__interfaces"].indexOf("java.util.Set") >= 0)) || halfScaleVertices === null) && ((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null)) {
                let __args = arguments;
                if (this.prototypeVertices === undefined) { this.prototypeVertices = null; } 
                if (this.prototypeFaces === undefined) { this.prototypeFaces = null; } 
                if (this.field === undefined) { this.field = null; } 
                if (this.prototypeVector === undefined) { this.prototypeVector = null; } 
                if (this.fullScaleVertices === undefined) { this.fullScaleVertices = null; } 
                if (this.halfScaleVertices === undefined) { this.halfScaleVertices = null; } 
                this.shortGeometry = null;
                this.prototypeVertices = vertices;
                this.prototypeFaces = faces;
                this.prototypeVector = prototype;
                this.fullScaleVertices = fullScaleVertices;
                this.halfScaleVertices = halfScaleVertices;
                this.field = field;
            } else if (((vertices != null && (vertices.constructor != null && vertices.constructor["__interfaces"] != null && vertices.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || vertices === null) && ((faces != null && (faces.constructor != null && faces.constructor["__interfaces"] != null && faces.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || faces === null) && ((prototype != null && prototype instanceof <any>com.vzome.core.algebra.AlgebraicVector) || prototype === null) && ((fullScaleVertices != null && (fullScaleVertices.constructor != null && fullScaleVertices.constructor["__interfaces"] != null && fullScaleVertices.constructor["__interfaces"].indexOf("java.util.Set") >= 0)) || fullScaleVertices === null) && ((halfScaleVertices != null && (halfScaleVertices.constructor != null && halfScaleVertices.constructor["__interfaces"] != null && halfScaleVertices.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || halfScaleVertices === null) && field === undefined) {
                let __args = arguments;
                let field: any = __args[4];
                {
                    let __args = arguments;
                    let halfScaleVertices: any = null;
                    if (this.prototypeVertices === undefined) { this.prototypeVertices = null; } 
                    if (this.prototypeFaces === undefined) { this.prototypeFaces = null; } 
                    if (this.field === undefined) { this.field = null; } 
                    if (this.prototypeVector === undefined) { this.prototypeVector = null; } 
                    if (this.fullScaleVertices === undefined) { this.fullScaleVertices = null; } 
                    if (this.halfScaleVertices === undefined) { this.halfScaleVertices = null; } 
                    this.shortGeometry = null;
                    this.prototypeVertices = vertices;
                    this.prototypeFaces = faces;
                    this.prototypeVector = prototype;
                    this.fullScaleVertices = fullScaleVertices;
                    this.halfScaleVertices = halfScaleVertices;
                    this.field = field;
                }
            } else throw new Error('invalid overload');
        }

        public getTriangles(): java.util.List<com.vzome.core.math.Polyhedron.Face.Triangle> {
            return this.getStrutPolyhedron(this.field.one()).getTriangleFaces();
        }

        /**
         * 
         * @param {*} length
         * @return {com.vzome.core.math.Polyhedron}
         */
        public getStrutPolyhedron(length: com.vzome.core.algebra.AlgebraicNumber): com.vzome.core.math.Polyhedron {
            const tipVertex: com.vzome.core.algebra.AlgebraicVector = this.prototypeVector.scale(length);
            let maxNonTipDistance: number = 0;
            let minTipDistance: number = tipVertex.toRealVector().length();
            const midpoint: com.vzome.core.algebra.AlgebraicVector = tipVertex.scale(this.field['createRational$long$long'](1, 2));
            if ((this.field.getName() === ("snubDodec")) && ExportedVEFStrutGeometry.LOGGER_$LI$().isLoggable(java.util.logging.Level.FINE)){
                ExportedVEFStrutGeometry.LOGGER_$LI$().fine("proto length = " + this.prototypeVector.toRealVector().length());
                ExportedVEFStrutGeometry.LOGGER_$LI$().fine("strut length = " + length.evaluate());
                ExportedVEFStrutGeometry.LOGGER_$LI$().fine("tip length = " + tipVertex.toRealVector().length());
            }
            const result: com.vzome.core.math.Polyhedron = new com.vzome.core.math.Polyhedron(this.field);
            for(let i: number = 0; i < this.prototypeVertices.size(); i++) {{
                let vertex: com.vzome.core.algebra.AlgebraicVector = this.prototypeVertices.get(i);
                if (this.fullScaleVertices.contains(i)){
                    vertex = vertex.plus(tipVertex);
                    minTipDistance = Math.min(minTipDistance, vertex.toRealVector().length());
                } else {
                    if (this.halfScaleVertices != null && this.halfScaleVertices.contains(i)){
                        vertex = vertex.plus(midpoint);
                    }
                    maxNonTipDistance = Math.max(maxNonTipDistance, vertex.toRealVector().length());
                }
                result.addVertex(vertex);
            };}
            if (maxNonTipDistance > minTipDistance){
                if (this.shortGeometry != null){
                    return this.shortGeometry.getStrutPolyhedron(length);
                } else return null;
            }
            for(let index=this.prototypeFaces.iterator();index.hasNext();) {
                let prototypeFace = index.next();
                {
                    const face: com.vzome.core.math.Polyhedron.Face = result.newFace();
                    face.addAll(prototypeFace);
                    result.addFace(face);
                }
            }
            return result;
        }

        public setShortGeometry(shortGeometry: com.vzome.core.parts.StrutGeometry) {
            this.shortGeometry = shortGeometry;
        }
    }
    ExportedVEFStrutGeometry["__class"] = "com.vzome.core.viewing.ExportedVEFStrutGeometry";
    ExportedVEFStrutGeometry["__interfaces"] = ["com.vzome.core.parts.StrutGeometry"];


}
namespace com.vzome.core.viewing {
    /**
     * This is really a SceneModel
     * @author Scott Vorthmann
     * @param {com.vzome.core.viewing.Lights} prototype
     * @class
     */
    export class Lights implements java.lang.Iterable<Lights.DirectionalLight> {
        /*private*/ pcs: java.beans.PropertyChangeSupport;

        public addPropertyListener(listener: java.beans.PropertyChangeListener) {
            this.pcs.addPropertyChangeListener$java_beans_PropertyChangeListener(listener);
        }

        public removePropertyListener(listener: java.beans.PropertyChangeListener) {
            this.pcs.removePropertyChangeListener$java_beans_PropertyChangeListener(listener);
        }

        public setProperty(cmd: string, value: any) {
            if ("backgroundColor" === cmd){
                this.backgroundColor = new com.vzome.core.construction.Color(javaemul.internal.IntegerHelper.parseInt(<string>value, 16));
                this.pcs.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(cmd, null, value);
            }
        }

        directionalLights: java.util.List<Lights.DirectionalLight>;

        mAmbientLightColor: com.vzome.core.construction.Color;

        /*private*/ backgroundColor: com.vzome.core.construction.Color;

        public constructor(prototype?: any) {
            if (((prototype != null && prototype instanceof <any>com.vzome.core.viewing.Lights) || prototype === null)) {
                let __args = arguments;
                {
                    let __args = arguments;
                    if (this.mAmbientLightColor === undefined) { this.mAmbientLightColor = null; } 
                    if (this.backgroundColor === undefined) { this.backgroundColor = null; } 
                    this.pcs = new java.beans.PropertyChangeSupport(this);
                    this.directionalLights = <any>(new java.util.ArrayList<any>(3));
                }
                (() => {
                    this.backgroundColor = prototype.backgroundColor;
                    this.mAmbientLightColor = prototype.mAmbientLightColor;
                    for(let i: number = 0; i < prototype.directionalLights.size(); i++) {{
                        this.addDirectionLight$com_vzome_core_viewing_Lights_DirectionalLight(prototype.directionalLights.get(i));
                    };}
                })();
            } else if (((prototype != null && (prototype.constructor != null && prototype.constructor["__interfaces"] != null && prototype.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || prototype === null)) {
                let __args = arguments;
                let element: any = __args[0];
                {
                    let __args = arguments;
                    if (this.mAmbientLightColor === undefined) { this.mAmbientLightColor = null; } 
                    if (this.backgroundColor === undefined) { this.backgroundColor = null; } 
                    this.pcs = new java.beans.PropertyChangeSupport(this);
                    this.directionalLights = <any>(new java.util.ArrayList<any>(3));
                }
                (() => {
                    let str: string = element.getAttribute("background");
                    this.backgroundColor = com.vzome.core.construction.Color.parseColor(str);
                    str = element.getAttribute("ambientLight");
                    this.mAmbientLightColor = com.vzome.core.construction.Color.parseColor(str);
                    const nodes: org.w3c.dom.NodeList = element.getChildNodes();
                    for(let i: number = 0; i < nodes.getLength(); i++) {{
                        const node: org.w3c.dom.Node = nodes.item(i);
                        if (node != null && (node.constructor != null && node.constructor["__interfaces"] != null && node.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)){
                            const viewElem: org.w3c.dom.Element = <org.w3c.dom.Element><any>node;
                            str = viewElem.getAttribute("color");
                            const color: com.vzome.core.construction.Color = com.vzome.core.construction.Color.parseColor(str);
                            const pos: com.vzome.core.math.RealVector = new com.vzome.core.math.RealVector(javaemul.internal.FloatHelper.parseFloat(viewElem.getAttribute("x")), javaemul.internal.FloatHelper.parseFloat(viewElem.getAttribute("y")), javaemul.internal.FloatHelper.parseFloat(viewElem.getAttribute("z")));
                            this.addDirectionLight$com_vzome_core_viewing_Lights_DirectionalLight(new Lights.DirectionalLight(pos, color));
                        }
                    };}
                })();
            } else if (prototype === undefined) {
                let __args = arguments;
                if (this.mAmbientLightColor === undefined) { this.mAmbientLightColor = null; } 
                if (this.backgroundColor === undefined) { this.backgroundColor = null; } 
                this.pcs = new java.beans.PropertyChangeSupport(this);
                this.directionalLights = <any>(new java.util.ArrayList<any>(3));
            } else throw new Error('invalid overload');
        }

        public size(): number {
            return this.directionalLights.size();
        }

        public addDirectionLight$com_vzome_core_viewing_Lights_DirectionalLight(light: Lights.DirectionalLight) {
            this.directionalLights.add(light);
        }

        public setAmbientColor(color: com.vzome.core.construction.Color) {
            this.mAmbientLightColor = color;
        }

        public getAmbientColor(): com.vzome.core.construction.Color {
            return this.mAmbientLightColor;
        }

        public getAmbientColorWeb(): string {
            return this.mAmbientLightColor.toWebString();
        }

        public getDirectionalLights() {
        }

        public getBackgroundColor(): com.vzome.core.construction.Color {
            return this.backgroundColor;
        }

        public getBackgroundColorWeb(): string {
            return this.backgroundColor.toWebString();
        }

        public setBackgroundColor(color: com.vzome.core.construction.Color) {
            this.backgroundColor = color;
        }

        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const result: org.w3c.dom.Element = doc.createElement("sceneModel");
            com.vzome.xml.DomUtils.addAttribute(result, "ambientLight", this.mAmbientLightColor.toString());
            com.vzome.xml.DomUtils.addAttribute(result, "background", this.backgroundColor.toString());
            for(let i: number = 0; i < this.directionalLights.size(); i++) {{
                const light: Lights.DirectionalLight = this.directionalLights.get(i);
                const child: org.w3c.dom.Element = doc.createElement("directionalLight");
                com.vzome.xml.DomUtils.addAttribute(child, "x", /* toString */(''+(light.direction.x)));
                com.vzome.xml.DomUtils.addAttribute(child, "y", /* toString */(''+(light.direction.y)));
                com.vzome.xml.DomUtils.addAttribute(child, "z", /* toString */(''+(light.direction.z)));
                com.vzome.xml.DomUtils.addAttribute(child, "color", light.color.toString());
                result.appendChild(child);
            };}
            return result;
        }

        /**
         * 
         * @return {*}
         */
        public iterator(): java.util.Iterator<Lights.DirectionalLight> {
            return this.directionalLights.iterator();
        }

        public addDirectionLight$com_vzome_core_construction_Color$com_vzome_core_math_RealVector(color: com.vzome.core.construction.Color, dir: com.vzome.core.math.RealVector) {
            this.addDirectionLight$com_vzome_core_viewing_Lights_DirectionalLight(new Lights.DirectionalLight(dir, color));
        }

        public addDirectionLight(color?: any, dir?: any) {
            if (((color != null && color instanceof <any>com.vzome.core.construction.Color) || color === null) && ((dir != null && dir instanceof <any>com.vzome.core.math.RealVector) || dir === null)) {
                return <any>this.addDirectionLight$com_vzome_core_construction_Color$com_vzome_core_math_RealVector(color, dir);
            } else if (((color != null && color instanceof <any>com.vzome.core.viewing.Lights.DirectionalLight) || color === null) && dir === undefined) {
                return <any>this.addDirectionLight$com_vzome_core_viewing_Lights_DirectionalLight(color);
            } else throw new Error('invalid overload');
        }

        public getDirectionalLightVector(i: number): com.vzome.core.math.RealVector {
            const light: Lights.DirectionalLight = this.directionalLights.get(i);
            return new com.vzome.core.math.RealVector(light.direction.x, light.direction.y, light.direction.z);
        }

        public getDirectionalLightColor(i: number): com.vzome.core.construction.Color {
            const light: Lights.DirectionalLight = this.directionalLights.get(i);
            return light.color;
        }
    }
    Lights["__class"] = "com.vzome.core.viewing.Lights";
    Lights["__interfaces"] = ["java.lang.Iterable"];



    export namespace Lights {

        export class DirectionalLight {
            public constructor(direction: com.vzome.core.math.RealVector, color: com.vzome.core.construction.Color) {
                if (this.direction === undefined) { this.direction = null; }
                if (this.color === undefined) { this.color = null; }
                this.direction = direction;
                this.color = color;
            }

            public direction: com.vzome.core.math.RealVector;

            color: com.vzome.core.construction.Color;

            public getColor(): string {
                return this.color.toWebString();
            }

            public getDirection(): number[] {
                return [this.direction.x, this.direction.y, this.direction.z];
            }
        }
        DirectionalLight["__class"] = "com.vzome.core.viewing.Lights.DirectionalLight";

    }

}
namespace com.vzome.core.viewing {
    export interface CameraIntf {
        isPerspective(): boolean;

        getFieldOfView(): number;

        getViewDistance(): number;

        getMagnification(): number;

        getLookAtPointRV(): com.vzome.core.math.RealVector;

        getLookDirectionRV(): com.vzome.core.math.RealVector;

        getUpDirectionRV(): com.vzome.core.math.RealVector;

        mapViewToWorld(rv: com.vzome.core.math.RealVector): com.vzome.core.math.RealVector;
    }
}
namespace com.vzome.core.zomic {
    /**
     * An exception thrown by the Zomic parser or interpreter.
     * A ZomeException may wrap another exception.
     * Handlers are obligated to "unwrap" a ZomeException
     * before reporting it, by calling getCulprit().
     * @param {java.lang.Exception} culprit
     * @class
     * @extends java.lang.Exception
     */
    export class ZomicException extends Error {
        /*private*/ m_culprit: Error;

        public constructor(culprit?: any) {
            if (((culprit != null && culprit instanceof <any>Error) || culprit === null)) {
                let __args = arguments;
                super("wrapped"); this.message="wrapped";
                if (this.m_culprit === undefined) { this.m_culprit = null; } 
                this.m_culprit = culprit;
            } else if (((typeof culprit === 'string') || culprit === null)) {
                let __args = arguments;
                let msg: any = __args[0];
                super(msg); this.message=msg;
                if (this.m_culprit === undefined) { this.m_culprit = null; } 
            } else throw new Error('invalid overload');
        }

        /**
         * Return the original culprit wrapped by this ZomeException.
         * Arbitrarily deep wrapping will be unwrapped by a single call
         * to getCulprit.  If there is no culprit, returns this ZomeException.
         * @return {java.lang.Exception}
         */
        public getCulprit(): Error {
            if (this.m_culprit == null){
                return this;
            }
            if (this.m_culprit != null && this.m_culprit instanceof <any>com.vzome.core.zomic.ZomicException){
                return (<ZomicException>this.m_culprit).getCulprit();
            } else {
                return this.m_culprit;
            }
        }
    }
    ZomicException["__class"] = "com.vzome.core.zomic.ZomicException";
    ZomicException["__interfaces"] = ["java.io.Serializable"];


}
namespace com.vzome.core.zomic.program {
    export interface Visitor {
        visitWalk(walk: com.vzome.core.zomic.program.Walk);

        visitLabel(id: string);

        visitNested(compound: com.vzome.core.zomic.program.Nested);

        visitRepeat(repeated: com.vzome.core.zomic.program.Repeat, repetitions: number);

        visitRotate(axis: com.vzome.core.math.symmetry.Axis, steps: number);

        visitReflect(blueAxis: com.vzome.core.math.symmetry.Axis);

        visitMove(axis: com.vzome.core.math.symmetry.Axis, length: com.vzome.core.algebra.AlgebraicNumber);

        visitSymmetry(model: com.vzome.core.zomic.program.Symmetry, permute: com.vzome.core.zomic.program.Permute);

        visitScale(size: com.vzome.core.algebra.AlgebraicNumber);

        visitSave(body: com.vzome.core.zomic.program.Save, state: number);

        visitBuild(build: boolean, destroy: boolean);

        /**
         * @param untranslatable
         * @param {string} message
         */
        visitUntranslatable(message: string);
    }

    export namespace Visitor {

        export class Default implements com.vzome.core.zomic.program.Visitor {
            /**
             * 
             * @param {com.vzome.core.zomic.program.Walk} walk
             */
            public visitWalk(walk: com.vzome.core.zomic.program.Walk) {
                for(let index=walk.iterator();index.hasNext();) {
                    let stmt = index.next();
                    {
                        stmt.accept(this);
                    }
                }
            }

            /**
             * 
             * @param {string} id
             */
            public visitLabel(id: string) {
            }

            /**
             * 
             * @param {com.vzome.core.zomic.program.Nested} compound
             */
            public visitNested(compound: com.vzome.core.zomic.program.Nested) {
                compound.getBody().accept(this);
            }

            /**
             * 
             * @param {com.vzome.core.zomic.program.Repeat} repeated
             * @param {number} repetitions
             */
            public visitRepeat(repeated: com.vzome.core.zomic.program.Repeat, repetitions: number) {
                for(let i: number = 0; i < repetitions; i++) {{
                    this.visitNested(repeated);
                };}
            }

            /**
             * 
             * @param {com.vzome.core.math.symmetry.Axis} axis
             * @param {number} steps
             */
            public visitRotate(axis: com.vzome.core.math.symmetry.Axis, steps: number) {
            }

            /**
             * 
             * @param {com.vzome.core.math.symmetry.Axis} blueAxis
             */
            public visitReflect(blueAxis: com.vzome.core.math.symmetry.Axis) {
            }

            /**
             * 
             * @param {com.vzome.core.math.symmetry.Axis} axis
             * @param {*} length
             */
            public visitMove(axis: com.vzome.core.math.symmetry.Axis, length: com.vzome.core.algebra.AlgebraicNumber) {
            }

            /**
             * 
             * @param {com.vzome.core.zomic.program.Symmetry} model
             * @param {com.vzome.core.zomic.program.Permute} permute
             */
            public visitSymmetry(model: com.vzome.core.zomic.program.Symmetry, permute: com.vzome.core.zomic.program.Permute) {
                this.visitNested(model);
            }

            /**
             * 
             * @param {com.vzome.core.zomic.program.Save} stmt
             * @param {number} state
             */
            public visitSave(stmt: com.vzome.core.zomic.program.Save, state: number) {
                this.visitNested(stmt);
            }

            /**
             * 
             * @param {*} size
             */
            public visitScale(size: com.vzome.core.algebra.AlgebraicNumber) {
            }

            /**
             * 
             * @param {boolean} build
             * @param {boolean} destroy
             */
            public visitBuild(build: boolean, destroy: boolean) {
            }

            /**
             * 
             * @param {string} message
             */
            public visitUntranslatable(message: string) {
            }

            constructor() {
            }
        }
        Default["__class"] = "com.vzome.core.zomic.program.Visitor.Default";
        Default["__interfaces"] = ["com.vzome.core.zomic.program.Visitor"];


    }

}
namespace com.vzome.core.zomic.program {
    export abstract class ZomicStatement {
        public abstract accept(visitor: com.vzome.core.zomic.program.Visitor);

        public setErrors(errors: string[]) {
            this.mErrors = errors;
        }

        public getErrors(): string[] {
            return this.mErrors;
        }

        mErrors: string[];

        constructor() {
            if (this.mErrors === undefined) { this.mErrors = null; }
        }
    }
    ZomicStatement["__class"] = "com.vzome.core.zomic.program.ZomicStatement";

}
namespace com.vzome.core.zomic {
    export class ZomicCompilerState {
        public constructor(icosaSymm: com.vzome.core.math.symmetry.IcosahedralSymmetry) {
            if (this.icosaSymmetry === undefined) { this.icosaSymmetry = null; }
            if (this.namingConvention === undefined) { this.namingConvention = null; }
            this.statements = <any>(new java.util.Stack<any>());
            this.templates = <any>(new java.util.Stack<any>());
            this.icosaSymmetry = icosaSymm;
            this.namingConvention = new com.vzome.core.zomic.ZomicNamingConvention(icosaSymm);
        }

        /*private*/ icosaSymmetry: com.vzome.core.math.symmetry.IcosahedralSymmetry;

        /*private*/ namingConvention: com.vzome.core.zomic.ZomicNamingConvention;

        /*private*/ statements: java.util.Stack<com.vzome.core.zomic.program.ZomicStatement>;

        /*private*/ templates: java.util.Stack<ZomicCompilerState.ZomicStatementTemplate<any>>;

        public getProgram(): com.vzome.core.zomic.program.Walk {
            return this.statements.size() === 0 ? new com.vzome.core.zomic.program.Walk() : <com.vzome.core.zomic.program.Walk>this.statements.firstElement();
        }

        public prepareStatement(statement: com.vzome.core.zomic.program.ZomicStatement) {
            this.statements.push(statement);
        }

        public peekTemplate(): ZomicCompilerState.ZomicStatementTemplate<any> {
            return this.templates.peek();
        }

        public popTemplate(): ZomicCompilerState.ZomicStatementTemplate<any> {
            return this.templates.pop();
        }

        public commitLastStatement() {
            const statement: com.vzome.core.zomic.program.ZomicStatement = this.statements.pop();
            if (statement != null && statement instanceof <any>com.vzome.core.zomic.program.Nested){
                const body: com.vzome.core.zomic.program.ZomicStatement = (<com.vzome.core.zomic.program.Nested>statement).getBody();
                if ((body == null) || ((body != null && body instanceof <any>com.vzome.core.zomic.program.Walk) && (<com.vzome.core.zomic.program.Walk>body).size() === 0)){
                    return;
                }
            }
            this.commit(statement);
        }

        public commit(newStatement: com.vzome.core.zomic.program.ZomicStatement) {
            const currentStatement: com.vzome.core.zomic.program.ZomicStatement = this.statements.peek();
            if (currentStatement != null && currentStatement instanceof <any>com.vzome.core.zomic.program.Walk){
                (<com.vzome.core.zomic.program.Walk>currentStatement).addStatement(newStatement);
            } else {
                (<com.vzome.core.zomic.program.Nested>currentStatement).setBody(newStatement);
            }
        }

        public reset() {
            this.statements.clear();
            this.templates.clear();
        }

        public setCurrentScale(scale: number) {
            (<ZomicCompilerState.ScaleInfo><any>this.templates.peek()).scale = scale;
        }

        public prepareSymmetryTemplate(symmetryMode: ZomicCompilerState.SymmetryModeEnum) {
            const template: ZomicCompilerState.SymmetryTemplate = new ZomicCompilerState.SymmetryTemplate(this, symmetryMode);
            this.templates.push(template);
        }

        public prepareMoveTemplate() {
            const template: ZomicCompilerState.MoveTemplate = new ZomicCompilerState.MoveTemplate(this);
            this.templates.push(template);
        }

        public prepareScaleTemplate() {
            const template: ZomicCompilerState.ScaleTemplate = new ZomicCompilerState.ScaleTemplate(this);
            this.templates.push(template);
        }

        public prepareReflectTemplate(isThruCenter: boolean) {
            const template: ZomicCompilerState.ReflectTemplate = new ZomicCompilerState.ReflectTemplate(this, isThruCenter);
            this.templates.push(template);
        }

        public prepareRotateTemplate() {
            const template: ZomicCompilerState.RotateTemplate = new ZomicCompilerState.RotateTemplate(this);
            this.templates.push(template);
        }
    }
    ZomicCompilerState["__class"] = "com.vzome.core.zomic.ZomicCompilerState";


    export namespace ZomicCompilerState {

        export interface ZomicStatementTemplate<T extends com.vzome.core.zomic.program.ZomicStatement> {
            generate(): T;
        }

        export interface IHaveAxisInfo {
            axisColor(): string;

            setAxisColor(s: string);

            indexNumber(): string;

            setIndexNumber(s: string);

            handedness(): string;

            setHandedness(s: string);

            indexFullName(): string;
        }

        export class AxisInfo implements ZomicCompilerState.IHaveAxisInfo {
            public __parent: any;
            __axisColor: string;

            __indexNumber: string;

            __handedness: string;

            generate(): com.vzome.core.math.symmetry.Axis {
                try {
                    const axis: com.vzome.core.math.symmetry.Axis = this.__parent.namingConvention.getAxis(this.__axisColor, this.indexFullName());
                    if (axis == null){
                        const msg: string = "bad axis specification: \'" + this.__axisColor + " " + this.indexFullName() + "\'";
                        throw new Error(msg);
                    }
                    return axis;
                } catch(ex) {
                    const msg: string = "bad axis specification: \'" + this.__axisColor + " " + this.indexFullName() + "\'";
                    throw new Error(msg);
                }
            }

            /**
             * 
             * @return {string}
             */
            public axisColor(): string {
                return this.__axisColor;
            }

            /**
             * 
             * @param {string} s
             */
            public setAxisColor(s: string) {
                this.__axisColor = s;
            }

            /**
             * 
             * @return {string}
             */
            public indexNumber(): string {
                return this.__indexNumber;
            }

            /**
             * 
             * @param {string} s
             */
            public setIndexNumber(s: string) {
                this.__indexNumber = s;
            }

            /**
             * 
             * @return {string}
             */
            public handedness(): string {
                return this.__handedness;
            }

            /**
             * 
             * @param {string} s
             */
            public setHandedness(s: string) {
                this.__handedness = s;
            }

            /**
             * 
             * @return {string}
             */
            public indexFullName(): string {
                return this.__indexNumber + this.__handedness;
            }

            constructor(__parent: any) {
                this.__parent = __parent;
                this.__axisColor = "";
                this.__indexNumber = "";
                this.__handedness = "";
            }
        }
        AxisInfo["__class"] = "com.vzome.core.zomic.ZomicCompilerState.AxisInfo";
        AxisInfo["__interfaces"] = ["com.vzome.core.zomic.ZomicCompilerState.IHaveAxisInfo"];



        export class ScaleInfo {
            public __parent: any;
            public ones: number;

            public phis: number;

            public scale: number;

            generate(symmetry: com.vzome.core.math.symmetry.IcosahedralSymmetry): com.vzome.core.algebra.AlgebraicNumber {
                return symmetry.getField()['createAlgebraicNumber$int$int$int$int'](this.ones, this.phis, 1, this.scale);
            }

            constructor(__parent: any) {
                this.__parent = __parent;
                this.ones = 1;
                this.phis = 0;
                this.scale = 1;
            }
        }
        ScaleInfo["__class"] = "com.vzome.core.zomic.ZomicCompilerState.ScaleInfo";


        export class RotateTemplate implements ZomicCompilerState.ZomicStatementTemplate<com.vzome.core.zomic.program.Rotate>, ZomicCompilerState.IHaveAxisInfo {
            public __parent: any;
            axisInfo: ZomicCompilerState.AxisInfo;

            public steps: number;

            /**
             * 
             * @return {com.vzome.core.zomic.program.Rotate}
             */
            public generate(): com.vzome.core.zomic.program.Rotate {
                const axis: com.vzome.core.math.symmetry.Axis = this.axisInfo.generate();
                return new com.vzome.core.zomic.program.Rotate(axis, this.steps);
            }

            /**
             * 
             * @return {string}
             */
            public axisColor(): string {
                return this.axisInfo.__axisColor;
            }

            /**
             * 
             * @param {string} s
             */
            public setAxisColor(s: string) {
                this.axisInfo.setAxisColor(s);
            }

            /**
             * 
             * @return {string}
             */
            public indexNumber(): string {
                return this.axisInfo.__indexNumber;
            }

            /**
             * 
             * @param {string} s
             */
            public setIndexNumber(s: string) {
                this.axisInfo.setIndexNumber(s);
            }

            /**
             * 
             * @return {string}
             */
            public handedness(): string {
                return this.axisInfo.__handedness;
            }

            /**
             * 
             * @param {string} s
             */
            public setHandedness(s: string) {
                this.axisInfo.setHandedness(s);
            }

            /**
             * 
             * @return {string}
             */
            public indexFullName(): string {
                return this.axisInfo.indexFullName();
            }

            constructor(__parent: any) {
                this.__parent = __parent;
                this.axisInfo = new ZomicCompilerState.AxisInfo(this.__parent);
                this.steps = 1;
            }
        }
        RotateTemplate["__class"] = "com.vzome.core.zomic.ZomicCompilerState.RotateTemplate";
        RotateTemplate["__interfaces"] = ["com.vzome.core.zomic.ZomicCompilerState.IHaveAxisInfo","com.vzome.core.zomic.ZomicCompilerState.ZomicStatementTemplate"];



        export class ReflectTemplate implements ZomicCompilerState.ZomicStatementTemplate<com.vzome.core.zomic.program.Reflect>, ZomicCompilerState.IHaveAxisInfo {
            public __parent: any;
            axisInfo: ZomicCompilerState.AxisInfo;

            isThroughCenter: boolean;

            public constructor(__parent: any, isThruCenter: boolean) {
                this.__parent = __parent;
                this.axisInfo = new ZomicCompilerState.AxisInfo(this.__parent);
                if (this.isThroughCenter === undefined) { this.isThroughCenter = false; }
                this.isThroughCenter = isThruCenter;
            }

            /**
             * 
             * @return {com.vzome.core.zomic.program.Reflect}
             */
            public generate(): com.vzome.core.zomic.program.Reflect {
                const result: com.vzome.core.zomic.program.Reflect = new com.vzome.core.zomic.program.Reflect();
                if (!this.isThroughCenter){
                    if (("" === this.axisColor()) && !("" === this.indexNumber())){
                        this.setAxisColor("blue");
                    }
                    const axis: com.vzome.core.math.symmetry.Axis = this.axisInfo.generate();
                    result.setAxis(axis);
                }
                return result;
            }

            /**
             * 
             * @return {string}
             */
            public axisColor(): string {
                return this.axisInfo.__axisColor;
            }

            /**
             * 
             * @param {string} s
             */
            public setAxisColor(s: string) {
                if (!("blue" === s)){
                    this.enforceBlueAxis();
                } else {
                    this.axisInfo.setAxisColor(s);
                }
            }

            /**
             * 
             * @return {string}
             */
            public indexNumber(): string {
                return this.axisInfo.__indexNumber;
            }

            /**
             * 
             * @param {string} s
             */
            public setIndexNumber(s: string) {
                if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "-"))s = s.substring(1);
                this.axisInfo.setIndexNumber(s);
                if (this.isThroughCenter && !("" === this.indexNumber())){
                    this.setAxisColor("blue");
                }
            }

            /**
             * 
             * @return {string}
             */
            public handedness(): string {
                return this.axisInfo.__handedness;
            }

            /**
             * 
             * @param {string} s
             */
            public setHandedness(s: string) {
                this.enforceBlueAxis();
            }

            /**
             * 
             * @return {string}
             */
            public indexFullName(): string {
                return this.axisInfo.indexFullName();
            }

            enforceBlueAxis() {
                throw new java.lang.IllegalStateException("Only \'center\' or blue axis indexes are allowed.");
            }
        }
        ReflectTemplate["__class"] = "com.vzome.core.zomic.ZomicCompilerState.ReflectTemplate";
        ReflectTemplate["__interfaces"] = ["com.vzome.core.zomic.ZomicCompilerState.IHaveAxisInfo","com.vzome.core.zomic.ZomicCompilerState.ZomicStatementTemplate"];



        export enum SymmetryModeEnum {
            Icosahedral, RotateAroundAxis, MirrorThroughBlueAxis, ReflectThroughOrigin
        }

        export class SymmetryTemplate implements ZomicCompilerState.ZomicStatementTemplate<com.vzome.core.zomic.program.Symmetry>, ZomicCompilerState.IHaveAxisInfo {
            public __parent: any;
            axisInfo: ZomicCompilerState.AxisInfo;

            symmetryMode: ZomicCompilerState.SymmetryModeEnum;

            public constructor(__parent: any, mode: ZomicCompilerState.SymmetryModeEnum) {
                this.__parent = __parent;
                this.axisInfo = new ZomicCompilerState.AxisInfo(this.__parent);
                if (this.symmetryMode === undefined) { this.symmetryMode = null; }
                this.symmetryMode = mode;
            }

            /**
             * 
             * @return {com.vzome.core.zomic.program.Symmetry}
             */
            public generate(): com.vzome.core.zomic.program.Symmetry {
                const result: com.vzome.core.zomic.program.Symmetry = <com.vzome.core.zomic.program.Symmetry>this.__parent.statements.peek();
                switch((this.symmetryMode)) {
                case com.vzome.core.zomic.ZomicCompilerState.SymmetryModeEnum.Icosahedral:
                    break;
                case com.vzome.core.zomic.ZomicCompilerState.SymmetryModeEnum.RotateAroundAxis:
                    {
                        const rotate: com.vzome.core.zomic.program.Rotate = new com.vzome.core.zomic.program.Rotate(null, -1);
                        const axis: com.vzome.core.math.symmetry.Axis = this.axisInfo.generate();
                        rotate.setAxis(axis);
                        result.setPermute(rotate);
                    };
                    break;
                case com.vzome.core.zomic.ZomicCompilerState.SymmetryModeEnum.MirrorThroughBlueAxis:
                    {
                        const reflect: com.vzome.core.zomic.program.Reflect = new com.vzome.core.zomic.program.Reflect();
                        const axis: com.vzome.core.math.symmetry.Axis = this.axisInfo.generate();
                        reflect.setAxis(axis);
                        result.setPermute(reflect);
                    };
                    break;
                case com.vzome.core.zomic.ZomicCompilerState.SymmetryModeEnum.ReflectThroughOrigin:
                    result.setPermute(new com.vzome.core.zomic.program.Reflect());
                    break;
                default:
                    throw new java.lang.IllegalStateException("Unexpected SymmetryModeEnum: " + this.symmetryMode == null ? "<null>" : com.vzome.core.zomic.ZomicCompilerState.SymmetryModeEnum["_$wrappers"][this.symmetryMode].toString());
                }
                return result;
            }

            /**
             * 
             * @return {string}
             */
            public axisColor(): string {
                return this.axisInfo.__axisColor;
            }

            /**
             * 
             * @param {string} s
             */
            public setAxisColor(s: string) {
                this.axisInfo.setAxisColor(s);
            }

            /**
             * 
             * @return {string}
             */
            public indexNumber(): string {
                return this.axisInfo.__indexNumber;
            }

            /**
             * 
             * @param {string} s
             */
            public setIndexNumber(s: string) {
                if (this.symmetryMode === ZomicCompilerState.SymmetryModeEnum.MirrorThroughBlueAxis){
                    if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "-"))s = s.substring(1);
                }
                this.axisInfo.setIndexNumber(s);
                if (this.symmetryMode === ZomicCompilerState.SymmetryModeEnum.MirrorThroughBlueAxis){
                    this.setAxisColor("blue");
                }
            }

            /**
             * 
             * @return {string}
             */
            public handedness(): string {
                return this.axisInfo.__handedness;
            }

            /**
             * 
             * @param {string} s
             */
            public setHandedness(s: string) {
                this.axisInfo.setHandedness(s);
            }

            /**
             * 
             * @return {string}
             */
            public indexFullName(): string {
                return this.axisInfo.indexFullName();
            }
        }
        SymmetryTemplate["__class"] = "com.vzome.core.zomic.ZomicCompilerState.SymmetryTemplate";
        SymmetryTemplate["__interfaces"] = ["com.vzome.core.zomic.ZomicCompilerState.IHaveAxisInfo","com.vzome.core.zomic.ZomicCompilerState.ZomicStatementTemplate"];



        export class ScaleTemplate extends ZomicCompilerState.ScaleInfo implements ZomicCompilerState.ZomicStatementTemplate<com.vzome.core.zomic.program.Scale> {
            public __parent: any;
            public generate(symmetry?: any): any {
                if (((symmetry != null && symmetry instanceof <any>com.vzome.core.math.symmetry.IcosahedralSymmetry) || symmetry === null)) {
                    return super.generate(symmetry);
                } else if (symmetry === undefined) {
                    return <any>this.generate$();
                } else throw new Error('invalid overload');
            }

            public generate$(): com.vzome.core.zomic.program.Scale {
                const algebraicNumber: com.vzome.core.algebra.AlgebraicNumber = this.generate(this.__parent.icosaSymmetry);
                return new com.vzome.core.zomic.program.Scale(algebraicNumber);
            }

            constructor(__parent: any) {
                super(__parent);
                this.__parent = __parent;
            }
        }
        ScaleTemplate["__class"] = "com.vzome.core.zomic.ZomicCompilerState.ScaleTemplate";
        ScaleTemplate["__interfaces"] = ["com.vzome.core.zomic.ZomicCompilerState.ZomicStatementTemplate"];



        export class MoveTemplate extends ZomicCompilerState.ScaleInfo implements ZomicCompilerState.ZomicStatementTemplate<com.vzome.core.zomic.program.Move>, ZomicCompilerState.IHaveAxisInfo {
            public __parent: any;
            axisInfo: ZomicCompilerState.AxisInfo;

            public denominator: number;

            public sizeRef: string;

            public constructor(__parent: any) {
                super(__parent);
                this.__parent = __parent;
                this.axisInfo = new ZomicCompilerState.AxisInfo(this.__parent);
                this.denominator = 1;
                this.sizeRef = null;
                this.__isVariableLength = false;
                this.scale = com.vzome.core.zomic.ZomicNamingConvention.MEDIUM;
            }

            __isVariableLength: boolean;

            public isVariableLength$(): boolean {
                return (this.__isVariableLength || (-99 === this.scale));
            }

            public isVariableLength$boolean(is: boolean) {
                this.__isVariableLength = is;
            }

            public isVariableLength(is?: any) {
                if (((typeof is === 'boolean') || is === null)) {
                    return <any>this.isVariableLength$boolean(is);
                } else if (is === undefined) {
                    return <any>this.isVariableLength$();
                } else throw new Error('invalid overload');
            }

            public generate$java_lang_String(axisColor: string): com.vzome.core.algebra.AlgebraicNumber {
                if (this.denominator !== 1){
                    const direction: com.vzome.core.math.symmetry.Direction = this.__parent.icosaSymmetry.getDirection(axisColor);
                    if (direction == null || !direction.hasHalfSizes()){
                        const msg: string = "half struts are not allowed on \'" + axisColor + "\' axes.";
                        throw new Error(msg);
                    }
                }
                if (this.isVariableLength$()){
                    return this.__parent.icosaSymmetry.getField().zero();
                }
                let lengthFactor: number = 1;
                let scaleOffset: number = 0;
                switch((axisColor)) {
                case "blue":
                    lengthFactor = 2;
                    break;
                case "green":
                    lengthFactor = 2;
                    break;
                case "yellow":
                    scaleOffset = -1;
                    break;
                case "purple":
                    scaleOffset = -1;
                    break;
                default:
                    break;
                }
                return this.__parent.icosaSymmetry.getField()['createAlgebraicNumber$int$int$int$int'](this.ones * lengthFactor, this.phis * lengthFactor, this.denominator, this.scale + scaleOffset);
            }

            public generate(axisColor?: any): any {
                if (((typeof axisColor === 'string') || axisColor === null)) {
                    return <any>this.generate$java_lang_String(axisColor);
                } else if (((axisColor != null && axisColor instanceof <any>com.vzome.core.math.symmetry.IcosahedralSymmetry) || axisColor === null)) {
                    return super.generate(axisColor);
                } else if (axisColor === undefined) {
                    return <any>this.generate$();
                } else throw new Error('invalid overload');
            }

            public generate$(): com.vzome.core.zomic.program.Move {
                const axis: com.vzome.core.math.symmetry.Axis = this.axisInfo.generate();
                const strutLength: com.vzome.core.algebra.AlgebraicNumber = this.generate$java_lang_String(this.axisColor());
                return new com.vzome.core.zomic.program.Move(axis, strutLength);
            }

            /**
             * 
             * @return {string}
             */
            public axisColor(): string {
                return this.axisInfo.__axisColor;
            }

            /**
             * 
             * @param {string} s
             */
            public setAxisColor(s: string) {
                this.axisInfo.setAxisColor(s);
            }

            /**
             * 
             * @return {string}
             */
            public indexNumber(): string {
                return this.axisInfo.__indexNumber;
            }

            /**
             * 
             * @param {string} s
             */
            public setIndexNumber(s: string) {
                this.axisInfo.setIndexNumber(s);
            }

            /**
             * 
             * @return {string}
             */
            public handedness(): string {
                return this.axisInfo.__handedness;
            }

            /**
             * 
             * @param {string} s
             */
            public setHandedness(s: string) {
                this.axisInfo.setHandedness(s);
            }

            /**
             * 
             * @return {string}
             */
            public indexFullName(): string {
                return this.axisInfo.indexFullName();
            }
        }
        MoveTemplate["__class"] = "com.vzome.core.zomic.ZomicCompilerState.MoveTemplate";
        MoveTemplate["__interfaces"] = ["com.vzome.core.zomic.ZomicCompilerState.IHaveAxisInfo","com.vzome.core.zomic.ZomicCompilerState.ZomicStatementTemplate"];


    }

}
namespace com.vzome.core.zomic {
    /**
     * @author Scott Vorthmann
     * @class
     */
    export class Recorder implements com.vzome.core.render.ZomicEventHandler {
        mOutput: Recorder.Output;

        mSaves: java.util.Stack<com.vzome.core.zomic.program.Walk>;

        public setOutput(output: Recorder.Output) {
            this.mOutput = output;
        }

        public record(stmt: com.vzome.core.zomic.program.ZomicStatement) {
            if (!this.mSaves.isEmpty())this.mSaves.peek().addStatement(stmt); else if (this.mOutput != null)this.mOutput.statement(stmt);
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Axis} axis
         * @param {*} length
         */
        public step(axis: com.vzome.core.math.symmetry.Axis, length: com.vzome.core.algebra.AlgebraicNumber) {
            this.record(new com.vzome.core.zomic.program.Move(axis, length));
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Axis} axis
         * @param {number} steps
         */
        public rotate(axis: com.vzome.core.math.symmetry.Axis, steps: number) {
            this.record(new com.vzome.core.zomic.program.Rotate(axis, steps));
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Axis} blueAxis
         */
        public reflect(blueAxis: com.vzome.core.math.symmetry.Axis) {
            const r: com.vzome.core.zomic.program.Reflect = new com.vzome.core.zomic.program.Reflect();
            r.setAxis(blueAxis);
            this.record(r);
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Permutation} permutation
         * @param {number} sense
         */
        public permute(permutation: com.vzome.core.math.symmetry.Permutation, sense: number) {
            this.record(new com.vzome.core.zomic.program.Untranslatable("permutation"));
        }

        /**
         * 
         * @param {*} scale
         */
        public scale(scale: com.vzome.core.algebra.AlgebraicNumber) {
            this.record(new com.vzome.core.zomic.program.Scale(scale));
        }

        /**
         * 
         * @param {number} action
         */
        public action(action: number) {
            this.record(new com.vzome.core.zomic.program.Build((action & com.vzome.core.render.ZomicEventHandler.BUILD) !== 0, (action & com.vzome.core.render.ZomicEventHandler.DESTROY) !== 0));
        }

        /**
         * 
         * @param {number} variables
         * @return {*}
         */
        public save(variables: number): com.vzome.core.render.ZomicEventHandler {
            this.mSaves.push(new com.vzome.core.zomic.program.Walk());
            return this;
        }

        public getLocation(): number[] {
            throw new java.lang.UnsupportedOperationException();
        }

        public getPermutation(): com.vzome.core.math.symmetry.Permutation {
            throw new java.lang.UnsupportedOperationException();
        }

        /**
         * 
         * @param {*} changes
         * @param {number} variables
         */
        public restore(changes: com.vzome.core.render.ZomicEventHandler, variables: number) {
            const walk: com.vzome.core.zomic.program.Walk = this.mSaves.pop();
            const save: com.vzome.core.zomic.program.Save = new com.vzome.core.zomic.program.Save(variables);
            save.setBody(walk);
            this.record(save);
        }

        constructor() {
            if (this.mOutput === undefined) { this.mOutput = null; }
            this.mSaves = <any>(new java.util.Stack<any>());
        }
    }
    Recorder["__class"] = "com.vzome.core.zomic.Recorder";
    Recorder["__interfaces"] = ["com.vzome.core.render.ZomicEventHandler"];



    export namespace Recorder {

        export interface Output {
            statement(stmt: com.vzome.core.zomic.program.ZomicStatement);
        }
    }

}
namespace com.vzome.core.math {
    /**
     * @author David Hall
     * @param {*} field
     * @class
     */
    export class TetrahedralProjection implements com.vzome.core.math.Projection {
        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        /*private*/ basis: com.vzome.core.algebra.AlgebraicVector[];

        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            if (this.field === undefined) { this.field = null; }
            if (this.basis === undefined) { this.basis = null; }
            this.field = field;
            const pos: com.vzome.core.algebra.AlgebraicNumber = field.one();
            const neg: com.vzome.core.algebra.AlgebraicNumber = pos.negate();
            this.basis = [null, null, null, null];
            this.basis[0] = new com.vzome.core.algebra.AlgebraicVector(pos, pos, pos);
            this.basis[1] = new com.vzome.core.algebra.AlgebraicVector(pos, neg, neg);
            this.basis[2] = new com.vzome.core.algebra.AlgebraicVector(neg, pos, neg);
            this.basis[3] = new com.vzome.core.algebra.AlgebraicVector(neg, neg, pos);
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} source
         * @param {boolean} wFirst
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public projectImage(source: com.vzome.core.algebra.AlgebraicVector, wFirst: boolean): com.vzome.core.algebra.AlgebraicVector {
            let result: com.vzome.core.algebra.AlgebraicVector = this.field.origin(this.basis[0].dimension());
            let pos: number = wFirst ? 0 : this.basis.length - 1;
            for(let index = 0; index < this.basis.length; index++) {
                let unitVector = this.basis[index];
                {
                    const scalar: com.vzome.core.algebra.AlgebraicNumber = source.getComponent(pos);
                    result = result.plus(unitVector.scale(scalar));
                    pos = (pos + 1) % this.basis.length;
                }
            }
            return result;
        }

        /**
         * 
         * @param {*} element
         */
        public getXmlAttributes(element: org.w3c.dom.Element) {
        }

        /**
         * 
         * @param {*} xml
         */
        public setXmlAttributes(xml: org.w3c.dom.Element) {
        }

        /**
         * 
         * @return {string}
         */
        public getProjectionName(): string {
            return "Tetrahedral";
        }
    }
    TetrahedralProjection["__class"] = "com.vzome.core.math.TetrahedralProjection";
    TetrahedralProjection["__interfaces"] = ["com.vzome.core.math.Projection"];


}
namespace com.vzome.core.math {
    export class Polyhedron implements java.lang.Cloneable {
        static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (Polyhedron.logger == null) { Polyhedron.logger = java.util.logging.Logger.getLogger("com.vzome.core.math.Polyhedron"); }  return Polyhedron.logger; }

        numVertices: number;

        m_vertices: java.util.Map<com.vzome.core.algebra.AlgebraicVector, number>;

        m_vertexList: java.util.List<com.vzome.core.algebra.AlgebraicVector>;

        m_faces: java.util.Set<Polyhedron.Face>;

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        /*private*/ evilTwin: Polyhedron;

        /*private*/ isEvil: boolean;

        /*private*/ __isPanel: boolean;

        /*private*/ guid: java.util.UUID;

        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            this.numVertices = 0;
            this.m_vertices = <any>(new java.util.HashMap<any, any>());
            this.m_vertexList = <any>(new java.util.ArrayList<any>());
            this.m_faces = <any>(new java.util.HashSet<any>());
            if (this.field === undefined) { this.field = null; }
            if (this.evilTwin === undefined) { this.evilTwin = null; }
            this.isEvil = false;
            this.__isPanel = false;
            this.guid = java.util.UUID.randomUUID();
            if (this.name === undefined) { this.name = null; }
            if (this.orbit === undefined) { this.orbit = null; }
            if (this.length === undefined) { this.length = null; }
            this.field = field;
        }

        /**
         * Get the mirror twin of this Polyhedron.
         * The vertices are transformed by the given reflection.
         * The faces are oriented in reverse, so that when oriented with
         * a mirroring transformation, the face normals will still point
         * outward.
         * @return
         * @param {com.vzome.core.algebra.AlgebraicMatrix} reflection
         * @return {com.vzome.core.math.Polyhedron}
         */
        public getEvilTwin(reflection: com.vzome.core.algebra.AlgebraicMatrix): Polyhedron {
            if (this.evilTwin == null){
                try {
                    this.evilTwin = <Polyhedron>/* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this);
                } catch(e) {
                    console.error(e.message, e);
                }
                this.evilTwin.isEvil = true;
                this.evilTwin.guid = java.util.UUID.randomUUID();
                this.evilTwin.m_vertexList = <any>(new java.util.ArrayList<any>());
                for(let index=this.m_vertexList.iterator();index.hasNext();) {
                    let vertex = index.next();
                    {
                        this.evilTwin.addVertex(reflection.timesColumn(vertex));
                    }
                }
                this.evilTwin.m_faces = <any>(new java.util.HashSet<Polyhedron.Face>());
                for(let index=this.m_faces.iterator();index.hasNext();) {
                    let face = index.next();
                    {
                        this.evilTwin.addFace(face.createReverse());
                    }
                }
            }
            return this.evilTwin;
        }

        public getField(): com.vzome.core.algebra.AlgebraicField {
            return this.field;
        }

        /*private*/ name: string;

        /*private*/ orbit: com.vzome.core.math.symmetry.Direction;

        /*private*/ length: com.vzome.core.algebra.AlgebraicNumber;

        public setName(name: string) {
            this.name = name;
        }

        public getName(): string {
            return this.name;
        }

        public addVertex(location: com.vzome.core.algebra.AlgebraicVector) {
            this.m_vertexList.add(location);
        }

        /**
         * Only used in ZomicPolyhedronModelInterpreter.
         * This used to be the implementation of addVertex, but all other callers
         * don't use the return value, and have already assigned their own indices,
         * so the collisions here are a bad idea.
         * @param halfLoc
         * @return
         * @param {com.vzome.core.algebra.AlgebraicVector} location
         * @return {number}
         */
        public addIndexedVertex(location: com.vzome.core.algebra.AlgebraicVector): number {
            let vertexObj: number = this.m_vertices.get(location);
            if (vertexObj == null){
                this.m_vertexList.add(location);
                this.m_vertices.put(location, vertexObj = this.numVertices++);
            }
            return vertexObj;
        }

        public addFace(face: Polyhedron.Face) {
            face.canonicallyOrder();
            if (!this.m_faces.contains(face)){
                this.m_faces.add(face);
            }
        }

        public newFace(): Polyhedron.Face {
            return new Polyhedron.Face(this);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode(): number {
            const prime: number = 31;
            let result: number = 1;
            result = prime * result + (this.isEvil ? 1231 : 1237);
            result = prime * result + ((this.length == null) ? 0 : /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})(this.length)));
            result = prime * result + ((this.m_faces == null) ? 0 : /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})(this.m_faces)));
            result = prime * result + ((this.m_vertexList == null) ? 0 : /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})(this.m_vertexList)));
            result = prime * result + this.numVertices;
            result = prime * result + ((this.orbit == null) ? 0 : /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})(this.orbit)));
            return result;
        }

        /**
         * 
         * @param {*} obj
         * @return {boolean}
         */
        public equals(obj: any): boolean {
            if (this === obj){
                return true;
            }
            if (obj == null){
                return false;
            }
            if ((<any>this.constructor) !== (<any>obj.constructor)){
                return false;
            }
            const other: Polyhedron = <Polyhedron>obj;
            if (this.isEvil !== other.isEvil){
                return false;
            }
            if (this.length == null){
                if (other.length != null){
                    return false;
                }
            } else if (!/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(this.length,other.length))){
                return false;
            }
            if (this.m_faces == null){
                if (other.m_faces != null){
                    return false;
                }
            } else if (!/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(this.m_faces,other.m_faces))){
                return false;
            }
            if (this.m_vertexList == null){
                if (other.m_vertexList != null){
                    return false;
                }
            } else if (!/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(this.m_vertexList,other.m_vertexList))){
                return false;
            }
            if (this.numVertices !== other.numVertices){
                return false;
            }
            if (this.orbit == null){
                if (other.orbit != null){
                    return false;
                }
            } else if (!this.orbit.equals(other.orbit)){
                return false;
            }
            return true;
        }

        public setOrbit(orbit: com.vzome.core.math.symmetry.Direction) {
            this.orbit = orbit;
        }

        public setLength(length: com.vzome.core.algebra.AlgebraicNumber) {
            this.length = length;
        }

        public getOrbit(): com.vzome.core.math.symmetry.Direction {
            return this.orbit;
        }

        public getLength(): com.vzome.core.algebra.AlgebraicNumber {
            return this.length;
        }

        public isPanel(): boolean {
            return this.__isPanel;
        }

        public setPanel(isPanel: boolean) {
            this.__isPanel = isPanel;
        }

        public getVertexList(): java.util.List<com.vzome.core.algebra.AlgebraicVector> {
            return this.m_vertexList;
        }

        public getFaceSet(): java.util.Set<Polyhedron.Face> {
            return this.m_faces;
        }

        public getGuid(): java.util.UUID {
            return this.guid;
        }

        public getTriangleFaces(): java.util.List<Polyhedron.Face.Triangle> {
            const result: java.util.ArrayList<Polyhedron.Face.Triangle> = <any>(new java.util.ArrayList<any>());
            for(let index=this.m_faces.iterator();index.hasNext();) {
                let face = index.next();
                {
                    result.addAll(face.getTriangles());
                }
            }
            return result;
        }

        public getTriangles(): java.util.List<number> {
            let index: number = 0;
            const result: java.util.ArrayList<number> = <any>(new java.util.ArrayList<any>());
            for(let index1=this.m_faces.iterator();index1.hasNext();) {
                let face = index1.next();
                {
                    for(let index1=face.getTriangles().iterator();index1.hasNext();) {
                        let triangle = index1.next();
                        {
                            result.add(index++);
                            result.add(index++);
                            result.add(index++);
                        }
                    }
                }
            }
            return result;
        }

        public getTriangleVertices(): java.util.List<com.vzome.core.math.RealVector> {
            const result: java.util.ArrayList<com.vzome.core.math.RealVector> = <any>(new java.util.ArrayList<any>());
            for(let index=this.m_faces.iterator();index.hasNext();) {
                let face = index.next();
                {
                    for(let index=face.getTriangles().iterator();index.hasNext();) {
                        let triangle = index.next();
                        {
                            for(let loopIndex = 0; loopIndex < triangle.vertices.length; loopIndex++) {
                                let index = triangle.vertices[loopIndex];
                                {
                                    const vertex: com.vzome.core.algebra.AlgebraicVector = this.m_vertexList.get(index);
                                    result.add(vertex.toRealVector());
                                }
                            }
                        }
                    }
                }
            }
            return result;
        }

        public getNormals(): java.util.List<com.vzome.core.math.RealVector> {
            const result: java.util.ArrayList<com.vzome.core.math.RealVector> = <any>(new java.util.ArrayList<any>());
            for(let index=this.m_faces.iterator();index.hasNext();) {
                let face = index.next();
                {
                    const normal: com.vzome.core.math.RealVector = face.getNormal(this.m_vertexList).toRealVector();
                    for(let index=face.getTriangles().iterator();index.hasNext();) {
                        let triangle = index.next();
                        {
                            result.add(normal);
                            result.add(normal);
                            result.add(normal);
                        }
                    }
                }
            }
            return result;
        }
    }
    Polyhedron["__class"] = "com.vzome.core.math.Polyhedron";
    Polyhedron["__interfaces"] = ["java.lang.Cloneable"];



    export namespace Polyhedron {

        export class Face extends java.util.ArrayList<number> implements java.lang.Cloneable {
            public __parent: any;
            constructor(__parent: any) {
                super();
                this.__parent = __parent;
            }

            public createReverse(): Polyhedron.Face {
                const vertices: java.util.ArrayList<number> = <java.util.ArrayList<number>>/* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(this);
                java.util.Collections.reverse(vertices);
                const mirrorFace: Polyhedron.Face = new Polyhedron.Face(this.__parent);
                mirrorFace.addAll(vertices);
                return mirrorFace;
            }

            public getVertex(index: number): number {
                if (index >= this.size()){
                    const msg: string = "index larger than Face size";
                    com.vzome.core.math.Polyhedron.logger_$LI$().severe(msg);
                    throw new java.lang.IllegalStateException(msg);
                }
                return this.get(index);
            }

            public getTriangles(): java.util.List<com.vzome.core.math.Polyhedron.Face.Triangle> {
                const arity: number = this.size();
                const result: java.util.ArrayList<com.vzome.core.math.Polyhedron.Face.Triangle> = <any>(new java.util.ArrayList<any>());
                let v0: number = -1;
                let v1: number = -1;
                for(let j: number = 0; j < arity; j++) {{
                    const index: number = this.get(j);
                    if (v0 === -1){
                        v0 = index;
                    } else if (v1 === -1){
                        v1 = index;
                    } else {
                        const triangle: com.vzome.core.math.Polyhedron.Face.Triangle = new com.vzome.core.math.Polyhedron.Face.Triangle(this, v0, v1, index);
                        result.add(triangle);
                        v1 = index;
                    }
                };}
                return result;
            }

            public getNormal(vertices: java.util.List<com.vzome.core.algebra.AlgebraicVector>): com.vzome.core.algebra.AlgebraicVector {
                return com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(vertices.get(this.getVertex(0)), vertices.get(this.getVertex(1)), vertices.get(this.getVertex(2)));
            }

            canonicallyOrder() {
                let minIndex: number = -1;
                let minVertex: number = javaemul.internal.IntegerHelper.MAX_VALUE;
                const sz: number = this.size();
                for(let i: number = 0; i < sz; i++) {if (this.getVertex(i) <= minVertex){
                    minVertex = this.getVertex(i);
                    minIndex = i;
                };}
                const temp: number[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(sz);
                for(let j: number = 0; j < sz; j++) {{
                    temp[j] = this.get((j + minIndex) % sz);
                };}
                for(let k: number = 0; k < sz; k++) {this.set(k, temp[k]);}
            }

            /**
             * 
             * @return {number}
             */
            public hashCode(): number {
                let tot: number = 0;
                for(let i: number = 0; i < this.size(); i++) {tot += this.getVertex(i);}
                return tot;
            }

            /**
             * 
             * @param {*} other
             * @return {boolean}
             */
            public equals(other: any): boolean {
                if (other == null)return false;
                if (other === this)return true;
                if (!(other != null && other instanceof <any>com.vzome.core.math.Polyhedron.Face))return false;
                const otherFace: Polyhedron.Face = <Polyhedron.Face>other;
                if (otherFace.size() !== this.size())return false;
                for(let i: number = 0; i < this.size(); i++) {if (!(this.get(i) === otherFace.get(i)))return false;;}
                return true;
            }
        }
        Face["__class"] = "com.vzome.core.math.Polyhedron.Face";
        Face["__interfaces"] = ["java.util.RandomAccess","java.lang.Cloneable","java.util.List","java.util.Collection","java.lang.Iterable","java.io.Serializable"];



        export namespace Face {

            export class Triangle {
                public __parent: any;
                public vertices: number[];

                public constructor(__parent: any, v0: number, v1: number, v2: number) {
                    this.__parent = __parent;
                    this.vertices = [0, 0, 0];
                    this.vertices[0] = v0;
                    this.vertices[1] = v1;
                    this.vertices[2] = v2;
                }
            }
            Triangle["__class"] = "com.vzome.core.math.Polyhedron.Face.Triangle";

        }


        export class Views {
            constructor() {
            }
        }
        Views["__class"] = "com.vzome.core.math.Polyhedron.Views";


        export namespace Views {

            export interface UnityMesh {            }

            export interface Triangles {            }

            export interface Polygons {            }
        }

    }

}
namespace com.vzome.core.math {
    /**
     * @param {float[]} m 16 elements in column-major order
     * @param {boolean} transpose
     * @class
     */
    export class RealMatrix4 {
        /*private*/ m00: number;

        /*private*/ m01: number;

        /*private*/ m02: number;

        /*private*/ m03: number;

        /*private*/ m10: number;

        /*private*/ m11: number;

        /*private*/ m12: number;

        /*private*/ m13: number;

        /*private*/ m20: number;

        /*private*/ m21: number;

        /*private*/ m22: number;

        /*private*/ m23: number;

        /*private*/ m30: number;

        /*private*/ m31: number;

        /*private*/ m32: number;

        /*private*/ m33: number;

        public constructor(m?: any, transpose?: any) {
            if (((m != null && m instanceof <any>Array && (m.length == 0 || m[0] == null ||(typeof m[0] === 'number'))) || m === null) && ((typeof transpose === 'boolean') || transpose === null)) {
                let __args = arguments;
                if (this.m00 === undefined) { this.m00 = 0; } 
                if (this.m01 === undefined) { this.m01 = 0; } 
                if (this.m02 === undefined) { this.m02 = 0; } 
                if (this.m03 === undefined) { this.m03 = 0; } 
                if (this.m10 === undefined) { this.m10 = 0; } 
                if (this.m11 === undefined) { this.m11 = 0; } 
                if (this.m12 === undefined) { this.m12 = 0; } 
                if (this.m13 === undefined) { this.m13 = 0; } 
                if (this.m20 === undefined) { this.m20 = 0; } 
                if (this.m21 === undefined) { this.m21 = 0; } 
                if (this.m22 === undefined) { this.m22 = 0; } 
                if (this.m23 === undefined) { this.m23 = 0; } 
                if (this.m30 === undefined) { this.m30 = 0; } 
                if (this.m31 === undefined) { this.m31 = 0; } 
                if (this.m32 === undefined) { this.m32 = 0; } 
                if (this.m33 === undefined) { this.m33 = 0; } 
                this.m00 = m[0];
                this.m01 = m[4];
                this.m02 = m[8];
                this.m03 = m[12];
                this.m10 = m[1];
                this.m11 = m[5];
                this.m12 = m[9];
                this.m13 = m[13];
                this.m20 = m[2];
                this.m21 = m[6];
                this.m22 = m[10];
                this.m23 = m[14];
                this.m30 = m[3];
                this.m31 = m[7];
                this.m32 = m[11];
                this.m33 = m[15];
            } else if (((m != null && m instanceof <any>Array && (m.length == 0 || m[0] == null ||(typeof m[0] === 'number'))) || m === null) && transpose === undefined) {
                let __args = arguments;
                if (this.m00 === undefined) { this.m00 = 0; } 
                if (this.m01 === undefined) { this.m01 = 0; } 
                if (this.m02 === undefined) { this.m02 = 0; } 
                if (this.m03 === undefined) { this.m03 = 0; } 
                if (this.m10 === undefined) { this.m10 = 0; } 
                if (this.m11 === undefined) { this.m11 = 0; } 
                if (this.m12 === undefined) { this.m12 = 0; } 
                if (this.m13 === undefined) { this.m13 = 0; } 
                if (this.m20 === undefined) { this.m20 = 0; } 
                if (this.m21 === undefined) { this.m21 = 0; } 
                if (this.m22 === undefined) { this.m22 = 0; } 
                if (this.m23 === undefined) { this.m23 = 0; } 
                if (this.m30 === undefined) { this.m30 = 0; } 
                if (this.m31 === undefined) { this.m31 = 0; } 
                if (this.m32 === undefined) { this.m32 = 0; } 
                if (this.m33 === undefined) { this.m33 = 0; } 
                this.m00 = m[0];
                this.m01 = m[1];
                this.m02 = m[2];
                this.m03 = m[3];
                this.m10 = m[4];
                this.m11 = m[5];
                this.m12 = m[6];
                this.m13 = m[7];
                this.m20 = m[8];
                this.m21 = m[9];
                this.m22 = m[10];
                this.m23 = m[11];
                this.m30 = m[12];
                this.m31 = m[13];
                this.m32 = m[14];
                this.m33 = m[15];
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {com.vzome.core.math.RealVector} v 4th component treated as 1
         * @return
         * @return {com.vzome.core.math.RealVector}
         */
        public transform3dPt(v: com.vzome.core.math.RealVector): com.vzome.core.math.RealVector {
            return new com.vzome.core.math.RealVector((<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m00 * v.x) + (<any>Math).fround(this.m01 * v.y)) + (<any>Math).fround(this.m02 * v.z)) + this.m03), (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m10 * v.x) + (<any>Math).fround(this.m11 * v.y)) + (<any>Math).fround(this.m12 * v.z)) + this.m13), (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m20 * v.x) + (<any>Math).fround(this.m21 * v.y)) + (<any>Math).fround(this.m22 * v.z)) + this.m23));
        }

        /**
         * 
         * @param {com.vzome.core.math.RealVector} v 4th component treated as 0
         * @return
         * @return {com.vzome.core.math.RealVector}
         */
        public transform3dVec(v: com.vzome.core.math.RealVector): com.vzome.core.math.RealVector {
            return new com.vzome.core.math.RealVector((<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m00 * v.x) + (<any>Math).fround(this.m01 * v.y)) + (<any>Math).fround(this.m02 * v.z)), (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m10 * v.x) + (<any>Math).fround(this.m11 * v.y)) + (<any>Math).fround(this.m12 * v.z)), (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m20 * v.x) + (<any>Math).fround(this.m21 * v.y)) + (<any>Math).fround(this.m22 * v.z)));
        }

        public transform4d(v: number[]): number[] {
            const x: number = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m00 * v[0]) + (<any>Math).fround(this.m01 * v[1])) + (<any>Math).fround(this.m02 * v[2])) + (<any>Math).fround(this.m03 * v[3]));
            const y: number = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m10 * v[0]) + (<any>Math).fround(this.m11 * v[1])) + (<any>Math).fround(this.m12 * v[2])) + (<any>Math).fround(this.m13 * v[3]));
            const z: number = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m20 * v[0]) + (<any>Math).fround(this.m21 * v[1])) + (<any>Math).fround(this.m22 * v[2])) + (<any>Math).fround(this.m23 * v[3]));
            const w: number = (<any>Math).fround((<any>Math).fround((<any>Math).fround((<any>Math).fround(this.m30 * v[0]) + (<any>Math).fround(this.m31 * v[1])) + (<any>Math).fround(this.m32 * v[2])) + (<any>Math).fround(this.m33 * v[3]));
            return [x, y, z, w];
        }

        /**
         * Helping function that specifies the position and orientation of a
         * view matrix. The inverse of this transform can be used to control
         * the ViewPlatform object within the scene graph.
         * @param {com.vzome.core.math.RealVector} eye the location of the eye
         * @param {com.vzome.core.math.RealVector} center a point in the virtual world where the eye is looking
         * @param {com.vzome.core.math.RealVector} up an up vector specifying the frustum's up direction
         * @return {com.vzome.core.math.RealMatrix4}
         */
        public static lookAt(eye: com.vzome.core.math.RealVector, center: com.vzome.core.math.RealVector, up: com.vzome.core.math.RealVector): RealMatrix4 {
            let forwardx: number;
            let forwardy: number;
            let forwardz: number;
            let invMag: number;
            let upx: number;
            let upy: number;
            let upz: number;
            let sidex: number;
            let sidey: number;
            let sidez: number;
            forwardx = (<any>Math).fround(eye.x - center.x);
            forwardy = (<any>Math).fround(eye.y - center.y);
            forwardz = (<any>Math).fround(eye.z - center.z);
            invMag = (<any>Math).fround((1.0 / Math.sqrt((<any>Math).fround((<any>Math).fround((<any>Math).fround(forwardx * forwardx) + (<any>Math).fround(forwardy * forwardy)) + (<any>Math).fround(forwardz * forwardz)))));
            forwardx = (<any>Math).fround(forwardx * invMag);
            forwardy = (<any>Math).fround(forwardy * invMag);
            forwardz = (<any>Math).fround(forwardz * invMag);
            invMag = (<any>Math).fround((1.0 / Math.sqrt((<any>Math).fround((<any>Math).fround((<any>Math).fround(up.x * up.x) + (<any>Math).fround(up.y * up.y)) + (<any>Math).fround(up.z * up.z)))));
            upx = (<any>Math).fround(up.x * invMag);
            upy = (<any>Math).fround(up.y * invMag);
            upz = (<any>Math).fround(up.z * invMag);
            sidex = (<any>Math).fround((<any>Math).fround(upy * forwardz) - (<any>Math).fround(forwardy * upz));
            sidey = (<any>Math).fround((<any>Math).fround(upz * forwardx) - (<any>Math).fround(upx * forwardz));
            sidez = (<any>Math).fround((<any>Math).fround(upx * forwardy) - (<any>Math).fround(upy * forwardx));
            invMag = (<any>Math).fround((1.0 / Math.sqrt((<any>Math).fround((<any>Math).fround((<any>Math).fround(sidex * sidex) + (<any>Math).fround(sidey * sidey)) + (<any>Math).fround(sidez * sidez)))));
            sidex *= invMag;
            sidey *= invMag;
            sidez *= invMag;
            upx = (<any>Math).fround((<any>Math).fround(forwardy * sidez) - (<any>Math).fround(sidey * forwardz));
            upy = (<any>Math).fround((<any>Math).fround(forwardz * sidex) - (<any>Math).fround(forwardx * sidez));
            upz = (<any>Math).fround((<any>Math).fround(forwardx * sidey) - (<any>Math).fround(forwardy * sidex));
            const m00: number = sidex;
            const m01: number = sidey;
            const m02: number = sidez;
            const m10: number = upx;
            const m11: number = upy;
            const m12: number = upz;
            const m20: number = forwardx;
            const m21: number = forwardy;
            const m22: number = forwardz;
            const m03: number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(-eye.x * m00) + (<any>Math).fround(-eye.y * m01)) + (<any>Math).fround(-eye.z * m02));
            const m13: number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(-eye.x * m10) + (<any>Math).fround(-eye.y * m11)) + (<any>Math).fround(-eye.z * m12));
            const m23: number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(-eye.x * m20) + (<any>Math).fround(-eye.y * m21)) + (<any>Math).fround(-eye.z * m22));
            return new RealMatrix4([m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, 0, 0, 0, 1]);
        }

        /**
         * Creates a perspective projection transform that mimics a standard,
         * camera-based,
         * view-model.
         * (From javax.media.j3d.Transform3d.java)
         * This transform maps coordinates from Eye Coordinates (EC)
         * to Clipping Coordinates (CC).  Note that unlike the similar function
         * in OpenGL, the clipping coordinates generated by the resulting
         * transform are in a right-handed coordinate system
         * (as are all other coordinate systems in Java 3D). Also note that the
         * field of view is specified in radians.
         * @param {number} fovx specifies the field of view in the x direction, in radians
         * @param {number} aspect specifies the aspect ratio and thus the field of
         * view in the x direction. The aspect ratio is the ratio of x to y,
         * or width to height.
         * @param {number} zNear the distance to the frustum's near clipping plane.
         * This value must be positive, (the value -zNear is the location of the
         * near clip plane).
         * @param {number} zFar the distance to the frustum's far clipping plane
         * @return {com.vzome.core.math.RealMatrix4}
         */
        public static perspective(fovx: number, aspect: number, zNear: number, zFar: number): RealMatrix4 {
            let sine: number;
            let cotangent: number;
            let deltaZ: number;
            const half_fov: number = (<any>Math).fround(fovx * 0.5);
            deltaZ = (<any>Math).fround(zFar - zNear);
            sine = (<any>Math).fround(Math.sin(half_fov));
            cotangent = (<any>Math).fround((Math.cos(half_fov) / sine));
            const m00: number = cotangent;
            const m11: number = (<any>Math).fround(cotangent * aspect);
            const m22: number = (<any>Math).fround(((<any>Math).fround(zFar + zNear)) / deltaZ);
            const m23: number = (<any>Math).fround((<any>Math).fround((<any>Math).fround(2.0 * zNear) * zFar) / deltaZ);
            const m32: number = -1.0;
            return new RealMatrix4([m00, 0, 0, 0, 0, m11, 0, 0, 0, 0, m22, m23, 0, 0, m32, 0]);
        }

        /**
         * Creates an orthographic projection transform that mimics a standard,
         * camera-based,
         * view-model.
         * (From javax.media.j3d.Transform3d.java)
         * This transform maps coordinates from Eye Coordinates (EC)
         * to Clipping Coordinates (CC).  Note that unlike the similar function
         * in OpenGL, the clipping coordinates generated by the resulting
         * transform are in a right-handed coordinate system
         * (as are all other coordinate systems in Java 3D).
         * @param {number} left the vertical line on the left edge of the near
         * clipping plane mapped to the left edge of the graphics window
         * @param {number} right the vertical line on the right edge of the near
         * clipping plane mapped to the right edge of the graphics window
         * @param {number} bottom the horizontal line on the bottom edge of the near
         * clipping plane mapped to the bottom edge of the graphics window
         * @param {number} top the horizontal line on the top edge of the near
         * clipping plane mapped to the top edge of the graphics window
         * @param {number} near the distance to the frustum's near clipping plane
         * (the value -near is the location of the near clip plane)
         * @param {number} far the distance to the frustum's far clipping plane
         * @return {com.vzome.core.math.RealMatrix4}
         */
        public static ortho(left: number, right: number, bottom: number, top: number, near: number, far: number): RealMatrix4 {
            const deltax: number = (<any>Math).fround(1 / ((<any>Math).fround(right - left)));
            const deltay: number = (<any>Math).fround(1 / ((<any>Math).fround(top - bottom)));
            const deltaz: number = (<any>Math).fround(1 / ((<any>Math).fround(far - near)));
            const m00: number = (<any>Math).fround(2.0 * deltax);
            const m03: number = (<any>Math).fround(-((<any>Math).fround(right + left)) * deltax);
            const m11: number = (<any>Math).fround(2.0 * deltay);
            const m13: number = (<any>Math).fround(-((<any>Math).fround(top + bottom)) * deltay);
            const m22: number = (<any>Math).fround(2.0 * deltaz);
            const m23: number = (<any>Math).fround(((<any>Math).fround(far + near)) * deltaz);
            const m33: number = 1;
            return new RealMatrix4([m00, 0.0, 0.0, m03, 0.0, m11, 0.0, m13, 0.0, 0.0, m22, m23, 0.0, 0.0, 0.0, m33]);
        }

        public toArray(): number[] {
            return [this.m00, this.m01, this.m02, this.m03, this.m10, this.m11, this.m12, this.m13, this.m20, this.m21, this.m22, this.m23, this.m30, this.m31, this.m32, this.m33];
        }
    }
    RealMatrix4["__class"] = "com.vzome.core.math.RealMatrix4";

}
namespace com.vzome.core.math.convexhull {
    /**
     * Constructs a vertex with the specified coordinates and index.
     * @param {com.vzome.core.algebra.AlgebraicVector} v
     * @param {number} idx
     * @class
     * @author John E. Lloyd, Fall 2004
     */
    export class Vertex {
        /**
         * Spatial point associated with this vertex.
         */
        pnt: com.vzome.core.algebra.AlgebraicVector;

        /**
         * Back index into an array.
         */
        index: number;

        /**
         * List forward link.
         */
        prev: Vertex;

        /**
         * List backward link.
         */
        next: Vertex;

        /**
         * Current face that this vertex is outside of.
         */
        face: com.vzome.core.math.convexhull.Face;

        public constructor(v: com.vzome.core.algebra.AlgebraicVector, idx: number) {
            if (this.pnt === undefined) { this.pnt = null; }
            if (this.index === undefined) { this.index = 0; }
            if (this.prev === undefined) { this.prev = null; }
            if (this.next === undefined) { this.next = null; }
            if (this.face === undefined) { this.face = null; }
            this.pnt = v;
            this.index = idx;
        }
    }
    Vertex["__class"] = "com.vzome.core.math.convexhull.Vertex";

}
namespace com.vzome.core.math.convexhull {
    export class GrahamScan2D {
        constructor() {
        }

        /**
         * Constructs the 2d convex hull of a coplanar set of 3d points.
         * 
         * @param {*} points
         * a set of 3d input points
         * @return  {com.vzome.core.algebra.AlgebraicVector[]} an array of the vertices of the planar convex hull.
         * The points are ordered so that the normal of the resulting polygon points AWAY from the origin.
         * The points in the array are unique, so the last point is NOT the same as the first.
         * This means that polygon edges derived from this array must connect the last to the first.
         * @throws Failure
         * if the number of input points is less than three,
         * or if the points are collinear
         * or if the points are not coplanar.
         */
        public static buildHull(points: java.util.Set<com.vzome.core.algebra.AlgebraicVector>): com.vzome.core.algebra.AlgebraicVector[] {
            if (points.size() < 3){
                GrahamScan2D.fail("At least three input points are required for a 2d convex hull.\n\n" + points.size() + " specified.");
            }
            const normal: com.vzome.core.algebra.AlgebraicVector = com.vzome.core.algebra.AlgebraicVectors.getNormal$java_util_Collection(points);
            if (normal.isOrigin()){
                GrahamScan2D.fail("Cannot generate a 2d convex hull from collinear points");
            }
            if (!com.vzome.core.algebra.AlgebraicVectors.areOrthogonalTo(normal, points)){
                GrahamScan2D.fail("Cannot generate a 2d convex hull from non-coplanar points");
            }
            const keySet: java.util.Collection<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>());
            const xyTo3dMap: java.util.Map<string, com.vzome.core.algebra.AlgebraicVector> = GrahamScan2D.map3dToXY(points, normal, keySet);
            const stack2d: java.util.Deque<com.vzome.core.algebra.AlgebraicVector> = GrahamScan2D.getHull2d(keySet);
            const vertices3d: com.vzome.core.algebra.AlgebraicVector[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(stack2d.size());
            let i: number = 0;
            for(let index=stack2d.iterator();index.hasNext();) {
                let point2d = index.next();
                {
                    const point3d: com.vzome.core.algebra.AlgebraicVector = xyTo3dMap.get(point2d.toString(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT));
                    vertices3d[i++] = point3d;
                }
            }
            return vertices3d;
        }

        /*private*/ static map3dToXY(points3d: java.util.Collection<com.vzome.core.algebra.AlgebraicVector>, normal: com.vzome.core.algebra.AlgebraicVector, keySet: java.util.Collection<com.vzome.core.algebra.AlgebraicVector>): java.util.Map<string, com.vzome.core.algebra.AlgebraicVector> {
            const maxAxis: number = com.vzome.core.algebra.AlgebraicVectors.getMaxComponentIndex(normal);
            const mapX: number = (maxAxis + 1) % 3;
            const mapY: number = (maxAxis + 2) % 3;
            const map: java.util.Map<string, com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.HashMap<any, any>());
            for(let index=points3d.iterator();index.hasNext();) {
                let point3d = index.next();
                {
                    const point2d: com.vzome.core.algebra.AlgebraicVector = new com.vzome.core.algebra.AlgebraicVector(point3d.getComponent(mapX), point3d.getComponent(mapY));
                    keySet.add(point2d);
                    map.put(point2d.toString(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT), point3d);
                }
            }
            return map;
        }

        /*private*/ static getHull2d(points2d: java.util.Collection<com.vzome.core.algebra.AlgebraicVector>): java.util.Deque<com.vzome.core.algebra.AlgebraicVector> {
            const sortedPoints2d: java.util.List<com.vzome.core.algebra.AlgebraicVector> = GrahamScan2D.getSortedPoints(points2d);
            const stack2d: java.util.Deque<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayDeque<any>());
            stack2d.push(sortedPoints2d.get(0));
            stack2d.push(sortedPoints2d.get(1));
            for(let i: number = 2; i < sortedPoints2d.size(); i++) {{
                const head: com.vzome.core.algebra.AlgebraicVector = sortedPoints2d.get(i);
                const middle: com.vzome.core.algebra.AlgebraicVector = stack2d.pop();
                const tail: com.vzome.core.algebra.AlgebraicVector = stack2d.peek();
                const turn: number = GrahamScan2D.getWindingDirection(tail, middle, head);
                switch((turn)) {
                case 1:
                    stack2d.push(middle);
                    stack2d.push(head);
                    break;
                case -1:
                    i--;
                    break;
                case 0:
                    stack2d.push(head);
                    break;
                default:
                    throw new java.lang.IllegalStateException("Illegal turn: " + turn);
                }
            };}
            return stack2d;
        }

        /**
         * @param {*} points2d set of 2d points to be sorted
         * @return {*} a list of points sorted:
         * 1) in increasing order of the angle they and the lowest point make with the x-axis.
         * 2) by increasing distance from the lowest point.
         * @private
         */
        /*private*/ static getSortedPoints(points2d: java.util.Collection<com.vzome.core.algebra.AlgebraicVector>): java.util.List<com.vzome.core.algebra.AlgebraicVector> {
            const lowest: com.vzome.core.algebra.AlgebraicVector = GrahamScan2D.getLowest2dPoint(points2d);
            const list: java.util.List<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>(points2d));
            java.util.Collections.sort<any>(list, (a: com.vzome.core.algebra.AlgebraicVector, b: com.vzome.core.algebra.AlgebraicVector) => {
                if (a.equals(b)){
                    return 0;
                }
                if (a.equals(lowest)){
                    return -1;
                }
                if (b.equals(lowest)){
                    return 1;
                }
                const turn: number = GrahamScan2D.getWindingDirection(lowest, a, b);
                if (turn !== 0){
                    return -turn;
                }
                const lengthSqA: com.vzome.core.algebra.AlgebraicNumber = com.vzome.core.algebra.AlgebraicVectors.getMagnitudeSquared(a.minus(lowest));
                const lengthSqB: com.vzome.core.algebra.AlgebraicNumber = com.vzome.core.algebra.AlgebraicVectors.getMagnitudeSquared(b.minus(lowest));
                return lengthSqA.compareTo(lengthSqB);
            });
            return list;
        }

        /**
         * @param {*} points2d a collection of 2d points from which to determine the lowest point.
         * @return  {com.vzome.core.algebra.AlgebraicVector} the point with the lowest y coordinate.
         * In case more than one point has the same minimum y coordinate,
         * the one with the lowest x coordinate is returned.
         */
        static getLowest2dPoint(points2d: java.util.Collection<com.vzome.core.algebra.AlgebraicVector>): com.vzome.core.algebra.AlgebraicVector {
            let lowest: com.vzome.core.algebra.AlgebraicVector = null;
            for(let index=points2d.iterator();index.hasNext();) {
                let point2d = index.next();
                {
                    if (lowest == null){
                        lowest = point2d;
                    } else {
                        const signum: number = point2d.getComponent(com.vzome.core.algebra.AlgebraicVector.Y)['minus$com_vzome_core_algebra_AlgebraicNumber'](lowest.getComponent(com.vzome.core.algebra.AlgebraicVector.Y)).signum();
                        switch((signum)) {
                        case -1:
                            lowest = point2d;
                            break;
                        case 0:
                            if (point2d.getComponent(com.vzome.core.algebra.AlgebraicVector.X).lessThan(lowest.getComponent(com.vzome.core.algebra.AlgebraicVector.X))){
                                lowest = point2d;
                            }
                            break;
                        }
                    }
                }
            }
            return lowest;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} a 2d coordinate
         * @param {com.vzome.core.algebra.AlgebraicVector} b 2d coordinate
         * @param {com.vzome.core.algebra.AlgebraicVector} c 2d coordinate
         * @return {number} -1, 0 or 1, depending on the orientation of vector ac with respect to vector ab:
         * 1: COUNTER_CLOCKWISE
         * c
         * /
         * /
         * a-----b
         * -1: CLOCKWISE
         * b
         * /
         * /
         * a-----c
         * 0: COLLINEAR
         * a-----b--c
         * @private
         */
        /*private*/ static getWindingDirection(a: com.vzome.core.algebra.AlgebraicVector, b: com.vzome.core.algebra.AlgebraicVector, c: com.vzome.core.algebra.AlgebraicVector): number {
            const ab: com.vzome.core.algebra.AlgebraicVector = b.minus(a);
            const ac: com.vzome.core.algebra.AlgebraicVector = c.minus(a);
            return (new com.vzome.core.algebra.AlgebraicMatrix(ab, ac)).determinant().signum();
        }

        /*private*/ static fail(msg: string) {
            throw new com.vzome.core.commands.Command.Failure(msg);
        }
    }
    GrahamScan2D["__class"] = "com.vzome.core.math.convexhull.GrahamScan2D";

}
namespace com.vzome.core.math.convexhull {
    /**
     * Basic triangular face used to form the hull.
     * 
     * <p>
     * The information stored for each face consists of a planar normal, a planar
     * offset, and a doubly-linked list of three <a href=HalfEdge>HalfEdges</a>
     * which surround the face in a counter-clockwise direction.
     * 
     * @author John E. Lloyd, Fall 2004
     * @class
     */
    export class Face {
        he0: com.vzome.core.math.convexhull.HalfEdge;

        /*private*/ normal: com.vzome.core.algebra.AlgebraicVector;

        area: number;

        /*private*/ centroid: com.vzome.core.algebra.AlgebraicVector;

        planeOffset: com.vzome.core.algebra.AlgebraicNumber;

        index: number;

        numVerts: number;

        next: Face;

        static VISIBLE: number = 1;

        static NON_CONVEX: number = 2;

        static DELETED: number = 3;

        mark: number;

        outside: com.vzome.core.math.convexhull.Vertex;

        public computeCentroid(): com.vzome.core.algebra.AlgebraicVector {
            const vectors: java.util.Set<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.HashSet<any>());
            let he: com.vzome.core.math.convexhull.HalfEdge = this.he0;
            do {{
                vectors.add(he.head().pnt);
                he = he.next;
            }} while((he !== this.he0));
            this.centroid = com.vzome.core.algebra.AlgebraicVectors.calculateCentroid(vectors);
            return this.centroid;
        }

        public computeNormal(): com.vzome.core.algebra.AlgebraicVector {
            let he1: com.vzome.core.math.convexhull.HalfEdge = this.he0.next;
            let he2: com.vzome.core.math.convexhull.HalfEdge = he1.next;
            const p0: com.vzome.core.algebra.AlgebraicVector = this.he0.head().pnt;
            let p2: com.vzome.core.algebra.AlgebraicVector = he1.head().pnt;
            let d2: com.vzome.core.algebra.AlgebraicVector = p2.minus(p0);
            this.normal = p0.getField().origin(3);
            this.numVerts = 2;
            while((he2 !== this.he0)) {{
                const d1: com.vzome.core.algebra.AlgebraicVector = d2;
                p2 = he2.head().pnt;
                d2 = p2.minus(p0);
                this.normal = this.normal.plus(d1.cross(d2));
                he1 = he2;
                he2 = he2.next;
                this.numVerts++;
            }};
            return this.normal;
        }

        /*private*/ computeNormalAndCentroid$() {
            this.normal = this.computeNormal();
            this.centroid = this.computeCentroid();
            this.planeOffset = this.normal.dot(this.centroid);
            let numv: number = 0;
            let he: com.vzome.core.math.convexhull.HalfEdge = this.he0;
            do {{
                numv++;
                he = he.next;
            }} while((he !== this.he0));
            if (numv !== this.numVerts){
                this.fail("face " + this.getVertexString() + " numVerts=" + this.numVerts + " should be " + numv);
            }
        }

        public computeNormalAndCentroid$double(minArea: number) {
            this.normal = this.computeNormal();
            this.centroid = this.computeCentroid();
            this.planeOffset = this.normal.dot(this.centroid);
        }

        public computeNormalAndCentroid(minArea?: any) {
            if (((typeof minArea === 'number') || minArea === null)) {
                return <any>this.computeNormalAndCentroid$double(minArea);
            } else if (minArea === undefined) {
                return <any>this.computeNormalAndCentroid$();
            } else throw new Error('invalid overload');
        }

        public static createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(v0: com.vzome.core.math.convexhull.Vertex, v1: com.vzome.core.math.convexhull.Vertex, v2: com.vzome.core.math.convexhull.Vertex): Face {
            return Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$double(v0, v1, v2, 0);
        }

        public static createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$double(v0: com.vzome.core.math.convexhull.Vertex, v1: com.vzome.core.math.convexhull.Vertex, v2: com.vzome.core.math.convexhull.Vertex, minArea: number): Face {
            const face: Face = new Face();
            const he0: com.vzome.core.math.convexhull.HalfEdge = new com.vzome.core.math.convexhull.HalfEdge(v0, face);
            const he1: com.vzome.core.math.convexhull.HalfEdge = new com.vzome.core.math.convexhull.HalfEdge(v1, face);
            const he2: com.vzome.core.math.convexhull.HalfEdge = new com.vzome.core.math.convexhull.HalfEdge(v2, face);
            he0.prev = he2;
            he0.next = he1;
            he1.prev = he0;
            he1.next = he2;
            he2.prev = he1;
            he2.next = he0;
            face.he0 = he0;
            face.computeNormalAndCentroid$double(minArea);
            return face;
        }

        /**
         * Constructs a triangule Face from vertices v0, v1, and v2.
         * 
         * @param {com.vzome.core.math.convexhull.Vertex} v0
         * first vertex
         * @param {com.vzome.core.math.convexhull.Vertex} v1
         * second vertex
         * @param {com.vzome.core.math.convexhull.Vertex} v2
         * third vertex
         * @param {number} minArea
         * @return {com.vzome.core.math.convexhull.Face}
         */
        public static createTriangle(v0?: any, v1?: any, v2?: any, minArea?: any): Face {
            if (((v0 != null && v0 instanceof <any>com.vzome.core.math.convexhull.Vertex) || v0 === null) && ((v1 != null && v1 instanceof <any>com.vzome.core.math.convexhull.Vertex) || v1 === null) && ((v2 != null && v2 instanceof <any>com.vzome.core.math.convexhull.Vertex) || v2 === null) && ((typeof minArea === 'number') || minArea === null)) {
                return <any>com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$double(v0, v1, v2, minArea);
            } else if (((v0 != null && v0 instanceof <any>com.vzome.core.math.convexhull.Vertex) || v0 === null) && ((v1 != null && v1 instanceof <any>com.vzome.core.math.convexhull.Vertex) || v1 === null) && ((v2 != null && v2 instanceof <any>com.vzome.core.math.convexhull.Vertex) || v2 === null) && minArea === undefined) {
                return <any>com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(v0, v1, v2);
            } else throw new Error('invalid overload');
        }

        public static create(vtxArray: com.vzome.core.math.convexhull.Vertex[], indices: number[]): Face {
            const face: Face = new Face();
            let hePrev: com.vzome.core.math.convexhull.HalfEdge = null;
            for(let i: number = 0; i < indices.length; i++) {{
                const he: com.vzome.core.math.convexhull.HalfEdge = new com.vzome.core.math.convexhull.HalfEdge(vtxArray[indices[i]], face);
                if (hePrev != null){
                    he.setPrev(hePrev);
                    hePrev.setNext(he);
                } else {
                    face.he0 = he;
                }
                hePrev = he;
            };}
            face.he0.setPrev(hePrev);
            hePrev.setNext(face.he0);
            face.computeNormalAndCentroid$();
            return face;
        }

        constructor() {
            if (this.he0 === undefined) { this.he0 = null; }
            if (this.normal === undefined) { this.normal = null; }
            if (this.area === undefined) { this.area = 0; }
            if (this.centroid === undefined) { this.centroid = null; }
            if (this.planeOffset === undefined) { this.planeOffset = null; }
            if (this.index === undefined) { this.index = 0; }
            if (this.numVerts === undefined) { this.numVerts = 0; }
            if (this.next === undefined) { this.next = null; }
            this.mark = Face.VISIBLE;
            if (this.outside === undefined) { this.outside = null; }
            this.mark = Face.VISIBLE;
        }

        /**
         * Gets the i-th half-edge associated with the face.
         * 
         * @param {number} i
         * the half-edge index, in the range 0-2.
         * @return {com.vzome.core.math.convexhull.HalfEdge} the half-edge
         */
        public getEdge(i: number): com.vzome.core.math.convexhull.HalfEdge {
            let he: com.vzome.core.math.convexhull.HalfEdge = this.he0;
            while((i > 0)) {{
                he = he.next;
                i--;
            }};
            while((i < 0)) {{
                he = he.prev;
                i++;
            }};
            return he;
        }

        public getFirstEdge(): com.vzome.core.math.convexhull.HalfEdge {
            return this.he0;
        }

        /**
         * Finds the half-edge within this face which has tail <code>vt</code> and head
         * <code>vh</code>.
         * 
         * @param {com.vzome.core.math.convexhull.Vertex} vt
         * tail point
         * @param {com.vzome.core.math.convexhull.Vertex} vh
         * head point
         * @return {com.vzome.core.math.convexhull.HalfEdge} the half-edge, or null if none is found.
         */
        public findEdge(vt: com.vzome.core.math.convexhull.Vertex, vh: com.vzome.core.math.convexhull.Vertex): com.vzome.core.math.convexhull.HalfEdge {
            let he: com.vzome.core.math.convexhull.HalfEdge = this.he0;
            do {{
                if (he.head() === vh && he.tail() === vt){
                    return he;
                }
                he = he.next;
            }} while((he !== this.he0));
            return null;
        }

        /**
         * Computes the distance from a point p to the plane of this face.
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} p
         * the point
         * @return {*} distance from the point to the plane
         */
        public distanceToPlane(p: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicNumber {
            return this.normal.dot(p)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.planeOffset);
        }

        /**
         * Returns the normal of the plane associated with this face.
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector} the planar normal
         */
        public getNormal(): com.vzome.core.algebra.AlgebraicVector {
            return this.normal;
        }

        public getCentroid(): com.vzome.core.algebra.AlgebraicVector {
            return this.centroid;
        }

        public numVertices(): number {
            return this.numVerts;
        }

        public getVertexString(): string {
            let s: string = null;
            let he: com.vzome.core.math.convexhull.HalfEdge = this.he0;
            do {{
                if (s == null){
                    s = "" + he.head().index;
                } else {
                    s += " " + he.head().index;
                }
                he = he.next;
            }} while((he !== this.he0));
            return s;
        }

        public getVertexIndices(idxs: number[]) {
            let he: com.vzome.core.math.convexhull.HalfEdge = this.he0;
            let i: number = 0;
            do {{
                idxs[i++] = he.head().index;
                he = he.next;
            }} while((he !== this.he0));
        }

        /*private*/ connectHalfEdges(hedgePrev: com.vzome.core.math.convexhull.HalfEdge, hedge: com.vzome.core.math.convexhull.HalfEdge): Face {
            let discardedFace: Face = null;
            if (hedgePrev.oppositeFace() === hedge.oppositeFace()){
                const oppFace: Face = hedge.oppositeFace();
                let hedgeOpp: com.vzome.core.math.convexhull.HalfEdge;
                if (hedgePrev === this.he0){
                    this.he0 = hedge;
                }
                if (oppFace.numVertices() === 3){
                    hedgeOpp = hedge.getOpposite().prev.getOpposite();
                    oppFace.mark = Face.DELETED;
                    discardedFace = oppFace;
                } else {
                    hedgeOpp = hedge.getOpposite().next;
                    if (oppFace.he0 === hedgeOpp.prev){
                        oppFace.he0 = hedgeOpp;
                    }
                    hedgeOpp.prev = hedgeOpp.prev.prev;
                    hedgeOpp.prev.next = hedgeOpp;
                }
                hedge.prev = hedgePrev.prev;
                hedge.prev.next = hedge;
                hedge.opposite = hedgeOpp;
                hedgeOpp.opposite = hedge;
                oppFace.computeNormalAndCentroid$();
            } else {
                hedgePrev.next = hedge;
                hedge.prev = hedgePrev;
            }
            return discardedFace;
        }

        /*private*/ fail(msg: string) {
            throw new com.vzome.core.commands.Command.Failure(msg);
        }

        checkConsistency() {
            let hedge: com.vzome.core.math.convexhull.HalfEdge = this.he0;
            let maxd: number = 0;
            let numv: number = 0;
            if (this.numVerts < 3){
                this.fail("degenerate face: " + this.getVertexString());
            }
            do {{
                const hedgeOpp: com.vzome.core.math.convexhull.HalfEdge = hedge.getOpposite();
                if (hedgeOpp == null){
                    this.fail("face " + this.getVertexString() + ": unreflected half edge " + hedge.getVertexString());
                } else if (hedgeOpp.getOpposite() !== hedge){
                    this.fail("face " + this.getVertexString() + ": opposite half edge " + hedgeOpp.getVertexString() + " has opposite " + hedgeOpp.getOpposite().getVertexString());
                }
                if (hedgeOpp.head() !== hedge.tail() || hedge.head() !== hedgeOpp.tail()){
                    this.fail("face " + this.getVertexString() + ": half edge " + hedge.getVertexString() + " reflected by " + hedgeOpp.getVertexString());
                }
                const oppFace: Face = hedgeOpp.face;
                if (oppFace == null){
                    this.fail("face " + this.getVertexString() + ": no face on half edge " + hedgeOpp.getVertexString());
                } else if (oppFace.mark === Face.DELETED){
                    this.fail("face " + this.getVertexString() + ": opposite face " + oppFace.getVertexString() + " not on hull");
                }
                const d: number = Math.abs(this.distanceToPlane(hedge.head().pnt).evaluate());
                if (d > maxd){
                    maxd = d;
                }
                numv++;
                hedge = hedge.next;
            }} while((hedge !== this.he0));
            if (numv !== this.numVerts){
                this.fail("face " + this.getVertexString() + " numVerts=" + this.numVerts + " should be " + numv);
            }
        }

        public mergeAdjacentFace(hedgeAdj: com.vzome.core.math.convexhull.HalfEdge, discarded: Face[]): number {
            const oppFace: Face = hedgeAdj.oppositeFace();
            let numDiscarded: number = 0;
            discarded[numDiscarded++] = oppFace;
            oppFace.mark = Face.DELETED;
            const hedgeOpp: com.vzome.core.math.convexhull.HalfEdge = hedgeAdj.getOpposite();
            let hedgeAdjPrev: com.vzome.core.math.convexhull.HalfEdge = hedgeAdj.prev;
            let hedgeAdjNext: com.vzome.core.math.convexhull.HalfEdge = hedgeAdj.next;
            let hedgeOppPrev: com.vzome.core.math.convexhull.HalfEdge = hedgeOpp.prev;
            let hedgeOppNext: com.vzome.core.math.convexhull.HalfEdge = hedgeOpp.next;
            let foo: number = 0;
            while((hedgeAdjPrev.oppositeFace() === oppFace)) {{
                hedgeAdjPrev = hedgeAdjPrev.prev;
                hedgeOppNext = hedgeOppNext.next;
                if (++foo > 1000){
                    this.fail("Oops, it\'s hung.");
                }
            }};
            foo = 0;
            while((hedgeAdjNext.oppositeFace() === oppFace)) {{
                hedgeOppPrev = hedgeOppPrev.prev;
                hedgeAdjNext = hedgeAdjNext.next;
                if (++foo > 1000){
                    this.fail("Oops, it\'s hung.");
                }
            }};
            let hedge: com.vzome.core.math.convexhull.HalfEdge;
            foo = 0;
            for(hedge = hedgeOppNext; hedge !== hedgeOppPrev.next; hedge = hedge.next) {{
                hedge.face = this;
                if (++foo > 1000){
                    this.fail("Oops, it\'s hung.");
                }
            };}
            if (hedgeAdj === this.he0){
                this.he0 = hedgeAdjNext;
            }
            let discardedFace: Face;
            discardedFace = this.connectHalfEdges(hedgeOppPrev, hedgeAdjNext);
            if (discardedFace != null){
                discarded[numDiscarded++] = discardedFace;
            }
            discardedFace = this.connectHalfEdges(hedgeAdjPrev, hedgeOppNext);
            if (discardedFace != null){
                discarded[numDiscarded++] = discardedFace;
            }
            this.computeNormalAndCentroid$();
            this.checkConsistency();
            return numDiscarded;
        }

        public triangulate(newFaces: java.util.List<Face>) {
            const minArea: number = 0;
            let hedge: com.vzome.core.math.convexhull.HalfEdge;
            if (this.numVertices() < 4){
                return;
            }
            const v0: com.vzome.core.math.convexhull.Vertex = this.he0.head();
            hedge = this.he0.next;
            let oppPrev: com.vzome.core.math.convexhull.HalfEdge = hedge.opposite;
            let face0: Face = null;
            for(hedge = hedge.next; hedge !== this.he0.prev; hedge = hedge.next) {{
                const face: Face = Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$double(v0, hedge.prev.head(), hedge.head(), minArea);
                face.he0.next.setOpposite(oppPrev);
                face.he0.prev.setOpposite(hedge.opposite);
                oppPrev = face.he0;
                newFaces.add(face);
                if (face0 == null){
                    face0 = face;
                }
            };}
            hedge = new com.vzome.core.math.convexhull.HalfEdge(this.he0.prev.prev.head(), this);
            hedge.setOpposite(oppPrev);
            hedge.prev = this.he0;
            hedge.prev.next = hedge;
            hedge.next = this.he0.prev;
            hedge.next.prev = hedge;
            this.computeNormalAndCentroid$double(minArea);
            this.checkConsistency();
            for(let face: Face = face0; face != null; face = face.next) {{
                face.checkConsistency();
            };}
        }
    }
    Face["__class"] = "com.vzome.core.math.convexhull.Face";

}
namespace com.vzome.core.math.convexhull {
    /**
     * Creates an empty convex hull object.
     * @class
     * @author John E. Lloyd, Fall 2004
     */
    export class QuickHull3D {
        /**
         * Specifies that (on output) vertex indices for a face should be listed in
         * clockwise order.
         */
        public static CLOCKWISE: number = 1;

        /**
         * Specifies that (on output) the vertex indices for a face should be numbered
         * starting from 1.
         */
        public static INDEXED_FROM_ONE: number = 2;

        /**
         * Specifies that (on output) the vertex indices for a face should be numbered
         * starting from 0.
         */
        public static INDEXED_FROM_ZERO: number = 4;

        /**
         * Specifies that (on output) the vertex indices for a face should be numbered
         * with respect to the original input points.
         */
        public static POINT_RELATIVE: number = 8;

        findIndex: number;

        debug: boolean;

        pointBuffer: com.vzome.core.math.convexhull.Vertex[];

        vertexPointIndices: number[];

        /*private*/ discardedFaces: com.vzome.core.math.convexhull.Face[];

        /*private*/ maxVtxs: com.vzome.core.math.convexhull.Vertex[];

        /*private*/ minVtxs: com.vzome.core.math.convexhull.Vertex[];

        faces: java.util.Vector<com.vzome.core.math.convexhull.Face>;

        /*private*/ newFaces: java.util.List<com.vzome.core.math.convexhull.Face>;

        /*private*/ unclaimed: com.vzome.core.math.convexhull.VertexList;

        /*private*/ claimed: com.vzome.core.math.convexhull.VertexList;

        numVertices: number;

        numFaces: number;

        numPoints: number;

        /**
         * Returns true if debugging is enabled.
         * 
         * @return {boolean} true is debugging is enabled
         * @see QuickHull3D#setDebug
         */
        public getDebug(): boolean {
            return this.debug;
        }

        /**
         * Enables the printing of debugging diagnostics.
         * 
         * @param {boolean} enable
         * if true, enables debugging
         */
        public setDebug(enable: boolean) {
            this.debug = enable;
        }

        /*private*/ addPointToFace(vtx: com.vzome.core.math.convexhull.Vertex, face: com.vzome.core.math.convexhull.Face) {
            vtx.face = face;
            if (face.outside == null){
                this.claimed.add(vtx);
            } else {
                this.claimed.insertBefore(vtx, face.outside);
            }
            face.outside = vtx;
        }

        /*private*/ removePointFromFace(vtx: com.vzome.core.math.convexhull.Vertex, face: com.vzome.core.math.convexhull.Face) {
            if (vtx === face.outside){
                if (vtx.next != null && vtx.next.face === face){
                    face.outside = vtx.next;
                } else {
                    face.outside = null;
                }
            }
            this.claimed.delete$com_vzome_core_math_convexhull_Vertex(vtx);
        }

        /*private*/ removeAllPointsFromFace(face: com.vzome.core.math.convexhull.Face): com.vzome.core.math.convexhull.Vertex {
            if (face.outside != null){
                let end: com.vzome.core.math.convexhull.Vertex = face.outside;
                while((end.next != null && end.next.face === face)) {{
                    end = end.next;
                }};
                this.claimed.delete$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(face.outside, end);
                end.next = null;
                return face.outside;
            } else {
                return null;
            }
        }

        public constructor() {
            this.findIndex = -1;
            this.debug = false;
            this.pointBuffer = [];
            this.vertexPointIndices = [];
            this.discardedFaces = [null, null, null];
            this.maxVtxs = [null, null, null];
            this.minVtxs = [null, null, null];
            this.faces = <any>(new java.util.Vector<any>(16));
            this.newFaces = <any>(new java.util.LinkedList<any>());
            this.unclaimed = new com.vzome.core.math.convexhull.VertexList();
            this.claimed = new com.vzome.core.math.convexhull.VertexList();
            if (this.numVertices === undefined) { this.numVertices = 0; }
            if (this.numFaces === undefined) { this.numFaces = 0; }
            if (this.numPoints === undefined) { this.numPoints = 0; }
        }

        /*private*/ findHalfEdge(tail: com.vzome.core.math.convexhull.Vertex, head: com.vzome.core.math.convexhull.Vertex): com.vzome.core.math.convexhull.HalfEdge {
            for(let index=this.faces.iterator();index.hasNext();) {
                let face = index.next();
                {
                    const he: com.vzome.core.math.convexhull.HalfEdge = face.findEdge(tail, head);
                    if (he != null){
                        return he;
                    }
                }
            }
            return null;
        }

        setHull(coords: com.vzome.core.algebra.AlgebraicVector[], nump: number, faceIndices: number[][], numf: number) {
            this.initBuffers(nump);
            this.setPoints(coords, nump);
            this.computeMaxAndMin();
            for(let i: number = 0; i < numf; i++) {{
                const face: com.vzome.core.math.convexhull.Face = com.vzome.core.math.convexhull.Face.create(this.pointBuffer, faceIndices[i]);
                let he: com.vzome.core.math.convexhull.HalfEdge = face.he0;
                do {{
                    const heOpp: com.vzome.core.math.convexhull.HalfEdge = this.findHalfEdge(he.head(), he.tail());
                    if (heOpp != null){
                        he.setOpposite(heOpp);
                    }
                    he = he.next;
                }} while((he !== face.he0));
                this.faces.add(face);
            };}
        }

        public build$java_util_Collection(points: java.util.Collection<com.vzome.core.algebra.AlgebraicVector>) {
            this.build$com_vzome_core_algebra_AlgebraicVector_A(points.toArray<any>((s => { let a=[]; while(s-->0) a.push(null); return a; })(points.size())));
        }

        public build$com_vzome_core_algebra_AlgebraicVector_A(points: com.vzome.core.algebra.AlgebraicVector[]) {
            this.build$com_vzome_core_algebra_AlgebraicVector_A$int(points, points.length);
        }

        public build$com_vzome_core_algebra_AlgebraicVector_A$int(points: com.vzome.core.algebra.AlgebraicVector[], nump: number) {
            if (nump < 4){
                throw new com.vzome.core.commands.Command.Failure("At least four input points are required for a 3d convex hull.\n\n" + nump + " specified.");
            }
            if (points.length < nump){
                throw new com.vzome.core.commands.Command.Failure("Point array too small for specified number of points");
            }
            this.printPointSet(points, nump);
            this.initBuffers(nump);
            this.setPoints(points, nump);
            this.buildHull();
        }

        /**
         * Constructs the convex hull of an array of points.
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector[]} points
         * input points
         * @param {number} nump
         * number of input points
         * @throws Failure
         * if the number of input points is less than four or greater than the
         * length of <code>points</code>, or the points are
         * coincident, collinear, or coplanar.
         */
        public build(points?: any, nump?: any) {
            if (((points != null && points instanceof <any>Array && (points.length == 0 || points[0] == null ||(points[0] != null && points[0] instanceof <any>com.vzome.core.algebra.AlgebraicVector))) || points === null) && ((typeof nump === 'number') || nump === null)) {
                return <any>this.build$com_vzome_core_algebra_AlgebraicVector_A$int(points, nump);
            } else if (((points != null && (points.constructor != null && points.constructor["__interfaces"] != null && points.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || points === null) && nump === undefined) {
                return <any>this.build$java_util_Collection(points);
            } else if (((points != null && points instanceof <any>Array && (points.length == 0 || points[0] == null ||(points[0] != null && points[0] instanceof <any>com.vzome.core.algebra.AlgebraicVector))) || points === null) && nump === undefined) {
                return <any>this.build$com_vzome_core_algebra_AlgebraicVector_A(points);
            } else throw new Error('invalid overload');
        }

        /**
         * prints the initial set of points.
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector[]} points
         * input points
         * @param {number} nump
         * number of input points
         */
        public printPointSet(points: com.vzome.core.algebra.AlgebraicVector[], nump: number) {
            if (this.debug){
                console.info("initial point set:");
                for(let i: number = 0; i < nump; i++) {{
                    console.info(i + ": " + points[i]);
                };}
            }
        }

        /**
         * Triangulates any non-triangular hull faces. In some cases, due to precision
         * issues, the resulting triangles may be very thin or small, and hence appear
         * to be non-convex (this same limitation is present in <a href=http://www.qhull.org>qhull</a>).
         * @throws Failure
         */
        public triangulate() {
            this.newFaces.clear();
            for(let index=this.faces.iterator();index.hasNext();) {
                let face = index.next();
                {
                    if (face.mark === com.vzome.core.math.convexhull.Face.VISIBLE){
                        face.triangulate(this.newFaces);
                    }
                }
            }
            for(let index=this.newFaces.iterator();index.hasNext();) {
                let face = index.next();
                {
                    this.faces.add(face);
                }
            }
        }

        initBuffers(nump: number) {
            if (this.pointBuffer.length < nump){
                const newBuffer: com.vzome.core.math.convexhull.Vertex[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(nump);
                this.vertexPointIndices = (s => { let a=[]; while(s-->0) a.push(0); return a; })(nump);
                for(let i: number = 0; i < this.pointBuffer.length; i++) {{
                    newBuffer[i] = this.pointBuffer[i];
                };}
                for(let i: number = this.pointBuffer.length; i < nump; i++) {{
                    newBuffer[i] = null;
                };}
                this.pointBuffer = newBuffer;
            }
            this.faces.clear();
            this.claimed.clear();
            this.numFaces = 0;
            this.numPoints = nump;
        }

        setPoints(pnts: com.vzome.core.algebra.AlgebraicVector[], nump: number) {
            this.pointBuffer = (s => { let a=[]; while(s-->0) a.push(null); return a; })(nump);
            for(let i: number = 0; i < nump; i++) {{
                this.pointBuffer[i] = new com.vzome.core.math.convexhull.Vertex(pnts[i], i);
            };}
        }

        computeMaxAndMin() {
            for(let i: number = 0; i < 3; i++) {{
                this.maxVtxs[i] = this.minVtxs[i] = this.pointBuffer[0];
            };}
            const max: com.vzome.core.algebra.AlgebraicVector = this.pointBuffer[0].pnt;
            let maxx: number = max.getComponent(com.vzome.core.algebra.AlgebraicVector.X).evaluate();
            let maxy: number = max.getComponent(com.vzome.core.algebra.AlgebraicVector.Y).evaluate();
            let maxz: number = max.getComponent(com.vzome.core.algebra.AlgebraicVector.Z).evaluate();
            let minx: number = maxx;
            let miny: number = maxy;
            let minz: number = maxz;
            for(let i: number = 1; i < this.numPoints; i++) {{
                const pnt: com.vzome.core.algebra.AlgebraicVector = this.pointBuffer[i].pnt;
                const pntx: number = pnt.getComponent(com.vzome.core.algebra.AlgebraicVector.X).evaluate();
                const pnty: number = pnt.getComponent(com.vzome.core.algebra.AlgebraicVector.Y).evaluate();
                const pntz: number = pnt.getComponent(com.vzome.core.algebra.AlgebraicVector.Z).evaluate();
                if (pntx > maxx){
                    maxx = pntx;
                    this.maxVtxs[0] = this.pointBuffer[i];
                } else if (pntx < minx){
                    minx = pntx;
                    this.minVtxs[0] = this.pointBuffer[i];
                }
                if (pnty > maxy){
                    maxy = pnty;
                    this.maxVtxs[1] = this.pointBuffer[i];
                } else if (pnty < miny){
                    miny = pnty;
                    this.minVtxs[1] = this.pointBuffer[i];
                }
                if (pntz > maxz){
                    maxz = pntz;
                    this.maxVtxs[2] = this.pointBuffer[i];
                } else if (pntz < minz){
                    minz = pntz;
                    this.minVtxs[2] = this.pointBuffer[i];
                }
            };}
        }

        /**
         * Creates the initial simplex from which the hull will be built.
         */
        createInitialSimplex() {
            let max: number = 0;
            let imax: number = 0;
            for(let i: number = 0; i < 3; i++) {{
                const diff: number = this.maxVtxs[i].pnt.getComponent(i)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.minVtxs[i].pnt.getComponent(i)).evaluate();
                if (diff > max){
                    max = diff;
                    imax = i;
                }
            };}
            if (max <= 0){
                throw new com.vzome.core.commands.Command.Failure("Input points are coincident");
            }
            const vtx: com.vzome.core.math.convexhull.Vertex[] = [null, null, null, null];
            vtx[0] = this.maxVtxs[imax];
            vtx[1] = this.minVtxs[imax];
            let diff02: com.vzome.core.algebra.AlgebraicVector;
            let nrml: com.vzome.core.algebra.AlgebraicVector = null;
            let maxSqr: number = 0;
            const u01: com.vzome.core.algebra.AlgebraicVector = vtx[1].pnt.minus(vtx[0].pnt);
            for(let i: number = 0; i < this.numPoints; i++) {{
                diff02 = this.pointBuffer[i].pnt.minus(vtx[0].pnt);
                const xprod: com.vzome.core.algebra.AlgebraicVector = u01.cross(diff02);
                const lenSqr: com.vzome.core.algebra.AlgebraicNumber = xprod.dot(xprod);
                if (lenSqr.evaluate() > maxSqr && this.pointBuffer[i] !== vtx[0] && this.pointBuffer[i] !== vtx[1]){
                    maxSqr = lenSqr.evaluate();
                    vtx[2] = this.pointBuffer[i];
                    nrml = xprod;
                }
            };}
            if (maxSqr === 0){
                throw new com.vzome.core.commands.Command.Failure("Input points are collinear");
            }
            const res: com.vzome.core.algebra.AlgebraicVector = u01.scale(nrml.dot(u01));
            nrml = nrml.minus(res);
            let maxDist: number = 0.0;
            const d0: com.vzome.core.algebra.AlgebraicNumber = vtx[2].pnt.dot(nrml);
            for(let i: number = 0; i < this.numPoints; i++) {{
                const dist: number = Math.abs(this.pointBuffer[i].pnt.dot(nrml)['minus$com_vzome_core_algebra_AlgebraicNumber'](d0).evaluate());
                if (dist > maxDist && this.pointBuffer[i] !== vtx[0] && this.pointBuffer[i] !== vtx[1] && this.pointBuffer[i] !== vtx[2]){
                    maxDist = dist;
                    vtx[3] = this.pointBuffer[i];
                }
            };}
            if (maxDist === 0.0){
                throw new com.vzome.core.commands.Command.Failure("Input points are coplanar");
            }
            if (this.debug){
                console.info("initial vertices:");
                console.info(vtx[0].index + ": " + vtx[0].pnt);
                console.info(vtx[1].index + ": " + vtx[1].pnt);
                console.info(vtx[2].index + ": " + vtx[2].pnt);
                console.info(vtx[3].index + ": " + vtx[3].pnt);
            }
            const tris: com.vzome.core.math.convexhull.Face[] = [null, null, null, null];
            if (vtx[3].pnt.dot(nrml)['minus$com_vzome_core_algebra_AlgebraicNumber'](d0).evaluate() < 0){
                tris[0] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[0], vtx[1], vtx[2]);
                tris[1] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[3], vtx[1], vtx[0]);
                tris[2] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[3], vtx[2], vtx[1]);
                tris[3] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[3], vtx[0], vtx[2]);
                for(let i: number = 0; i < 3; i++) {{
                    const k: number = (i + 1) % 3;
                    tris[i + 1].getEdge(1).setOpposite(tris[k + 1].getEdge(0));
                    tris[i + 1].getEdge(2).setOpposite(tris[0].getEdge(k));
                };}
            } else {
                tris[0] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[0], vtx[2], vtx[1]);
                tris[1] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[3], vtx[0], vtx[1]);
                tris[2] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[3], vtx[1], vtx[2]);
                tris[3] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[3], vtx[2], vtx[0]);
                for(let i: number = 0; i < 3; i++) {{
                    const k: number = (i + 1) % 3;
                    tris[i + 1].getEdge(0).setOpposite(tris[k + 1].getEdge(1));
                    tris[i + 1].getEdge(2).setOpposite(tris[0].getEdge((3 - i) % 3));
                };}
            }
            for(let i: number = 0; i < 4; i++) {{
                this.faces.add(tris[i]);
            };}
            for(let i: number = 0; i < this.numPoints; i++) {{
                const v: com.vzome.core.math.convexhull.Vertex = this.pointBuffer[i];
                if (v === vtx[0] || v === vtx[1] || v === vtx[2] || v === vtx[3]){
                    continue;
                }
                maxDist = 0.0;
                let maxFace: com.vzome.core.math.convexhull.Face = null;
                for(let k: number = 0; k < 4; k++) {{
                    const dist: number = tris[k].distanceToPlane(v.pnt).evaluate();
                    if (dist > maxDist){
                        maxFace = tris[k];
                        maxDist = dist;
                    }
                };}
                if (maxFace != null){
                    this.addPointToFace(v, maxFace);
                }
            };}
        }

        /**
         * Returns the number of vertices in this hull.
         * 
         * @return {number} number of vertices
         */
        public getNumVertices(): number {
            return this.numVertices;
        }

        public getVertices$(): com.vzome.core.algebra.AlgebraicVector[] {
            const vtxs: com.vzome.core.algebra.AlgebraicVector[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.numVertices);
            for(let i: number = 0; i < this.numVertices; i++) {{
                vtxs[i] = this.pointBuffer[this.vertexPointIndices[i]].pnt;
            };}
            return vtxs;
        }

        public getVertices$com_vzome_core_algebra_AlgebraicNumber_A(coords: com.vzome.core.algebra.AlgebraicNumber[]): number {
            for(let i: number = 0; i < this.numVertices; i++) {{
                const pnt: com.vzome.core.algebra.AlgebraicVector = this.pointBuffer[this.vertexPointIndices[i]].pnt;
                coords[i * 3 + 0] = pnt.getComponent(com.vzome.core.algebra.AlgebraicVector.X);
                coords[i * 3 + 1] = pnt.getComponent(com.vzome.core.algebra.AlgebraicVector.Y);
                coords[i * 3 + 2] = pnt.getComponent(com.vzome.core.algebra.AlgebraicVector.Z);
            };}
            return this.numVertices;
        }

        /**
         * Returns the coordinates of the vertex points of this hull.
         * 
         * @param {com.vzome.core.algebra.AlgebraicNumber[]} coords
         * returns the x, y, z coordinates of each vertex. This length of
         * this array must be at least three times the number of vertices.
         * @return {number} the number of vertices
         * @see QuickHull3D#getVertices()
         * @see QuickHull3D#getFaces()
         */
        public getVertices(coords?: any): any {
            if (((coords != null && coords instanceof <any>Array && (coords.length == 0 || coords[0] == null ||(coords[0] != null && (coords[0].constructor != null && coords[0].constructor["__interfaces"] != null && coords[0].constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)))) || coords === null)) {
                return <any>this.getVertices$com_vzome_core_algebra_AlgebraicNumber_A(coords);
            } else if (coords === undefined) {
                return <any>this.getVertices$();
            } else throw new Error('invalid overload');
        }

        /**
         * Returns an array specifing the index of each hull vertex with respect to the
         * original input points.
         * 
         * @return {int[]} vertex indices with respect to the original points
         */
        public getVertexPointIndices(): number[] {
            const indices: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.numVertices);
            for(let i: number = 0; i < this.numVertices; i++) {{
                indices[i] = this.vertexPointIndices[i];
            };}
            return indices;
        }

        /**
         * Returns the number of edges in this hull.
         * 
         * @return {number} number of edges
         */
        public getNumEdges(): number {
            let count: number = 0;
            for(let index=this.faces.iterator();index.hasNext();) {
                let face = index.next();
                {
                    count += face.numVertices();
                }
            }
            return (count / 2|0);
        }

        /**
         * Returns the number of faces in this hull.
         * 
         * @return {number} number of faces
         */
        public getNumFaces(): number {
            return this.faces.size();
        }

        public getFaces$(): number[][] {
            return this.getFaces$int(0);
        }

        public getFaces$int(indexFlags: number): number[][] {
            const allFaces: number[][] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.faces.size());
            let k: number = 0;
            for(let index=this.faces.iterator();index.hasNext();) {
                let face = index.next();
                {
                    allFaces[k] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(face.numVertices());
                    this.getFaceIndices(allFaces[k], face, indexFlags);
                    k++;
                }
            }
            return allFaces;
        }

        /**
         * Returns the faces associated with this hull.
         * 
         * <p>
         * Each face is represented by an integer array which gives the indices of the
         * vertices. By default, these indices are numbered with respect to the hull
         * vertices (as opposed to the input points), are zero-based, and are arranged
         * counter-clockwise. However, this can be changed by setting
         * {@link #POINT_RELATIVE}, {@link #INDEXED_FROM_ONE}, or {@link #CLOCKWISE} in the indexFlags
         * parameter.
         * 
         * @param {number} indexFlags
         * specifies index characteristics (0 results in the default)
         * @return {int[][]} array of integer arrays, giving the vertex indices for each face.
         * @see QuickHull3D#getVertices()
         */
        public getFaces(indexFlags?: any): number[][] {
            if (((typeof indexFlags === 'number') || indexFlags === null)) {
                return <any>this.getFaces$int(indexFlags);
            } else if (indexFlags === undefined) {
                return <any>this.getFaces$();
            } else throw new Error('invalid overload');
        }

        public print$java_io_PrintStream(ps: java.io.PrintStream) {
            this.print$java_io_PrintStream$int(ps, 0);
        }

        public print$java_io_PrintStream$int(ps: java.io.PrintStream, indexFlags: number) {
            if ((indexFlags & QuickHull3D.INDEXED_FROM_ZERO) === 0){
                indexFlags |= QuickHull3D.INDEXED_FROM_ONE;
            }
            for(let i: number = 0; i < this.numVertices; i++) {{
                const pnt: com.vzome.core.algebra.AlgebraicVector = this.pointBuffer[this.vertexPointIndices[i]].pnt;
                ps.println(pnt);
            };}
            for(let index=this.faces.iterator();index.hasNext();) {
                let face = index.next();
                {
                    const indices: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(face.numVertices());
                    this.getFaceIndices(indices, face, indexFlags);
                    ps.print("f");
                    for(let k: number = 0; k < indices.length; k++) {{
                        ps.print(" " + indices[k]);
                    };}
                    ps.println("");
                }
            }
        }

        /**
         * Prints the vertices and faces of this hull to the stream ps.
         * 
         * <p>
         * This is done using the Alias Wavefront .obj file format, with the vertices
         * printed first (each preceding by the letter <code>v</code>), followed by the
         * vertex indices for each face (each preceded by the letter <code>f</code>).
         * 
         * <p>
         * By default, the face indices are numbered with respect to the hull vertices
         * (as opposed to the input points), with a lowest index of 1, and are arranged
         * counter-clockwise. However, this can be changed by setting
         * {@link #POINT_RELATIVE}, {@link #INDEXED_FROM_ONE}, or {@link #CLOCKWISE} in the indexFlags
         * parameter.
         * 
         * @param {java.io.PrintStream} ps
         * stream used for printing
         * @param {number} indexFlags
         * specifies index characteristics (0 results in the default).
         * @see QuickHull3D#getVertices()
         * @see QuickHull3D#getFaces()
         */
        public print(ps?: any, indexFlags?: any) {
            if (((ps != null && ps instanceof <any>java.io.PrintStream) || ps === null) && ((typeof indexFlags === 'number') || indexFlags === null)) {
                return <any>this.print$java_io_PrintStream$int(ps, indexFlags);
            } else if (((ps != null && ps instanceof <any>java.io.PrintStream) || ps === null) && indexFlags === undefined) {
                return <any>this.print$java_io_PrintStream(ps);
            } else throw new Error('invalid overload');
        }

        /*private*/ getFaceIndices(indices: number[], face: com.vzome.core.math.convexhull.Face, flags: number) {
            const ccw: boolean = ((flags & QuickHull3D.CLOCKWISE) === 0);
            const indexedFromOne: boolean = ((flags & QuickHull3D.INDEXED_FROM_ONE) !== 0);
            const pointRelative: boolean = ((flags & QuickHull3D.POINT_RELATIVE) !== 0);
            let hedge: com.vzome.core.math.convexhull.HalfEdge = face.he0;
            let k: number = 0;
            do {{
                let idx: number = hedge.head().index;
                if (pointRelative){
                    idx = this.vertexPointIndices[idx];
                }
                if (indexedFromOne){
                    idx++;
                }
                indices[k++] = idx;
                hedge = (ccw ? hedge.next : hedge.prev);
            }} while((hedge !== face.he0));
        }

        resolveUnclaimedPoints(newFaces: java.util.List<com.vzome.core.math.convexhull.Face>) {
            let vtxNext: com.vzome.core.math.convexhull.Vertex = this.unclaimed.first();
            for(let vtx: com.vzome.core.math.convexhull.Vertex = vtxNext; vtx != null; vtx = vtxNext) {{
                vtxNext = vtx.next;
                let maxDist: number = 0;
                let maxFace: com.vzome.core.math.convexhull.Face = null;
                for(let index=newFaces.iterator();index.hasNext();) {
                    let newFace = index.next();
                    {
                        if (newFace.mark === com.vzome.core.math.convexhull.Face.VISIBLE){
                            const dist: number = newFace.distanceToPlane(vtx.pnt).evaluate();
                            if (dist > maxDist){
                                maxDist = dist;
                                maxFace = newFace;
                            }
                            if (maxDist > 0){
                                break;
                            }
                        }
                    }
                }
                if (maxFace != null){
                    this.addPointToFace(vtx, maxFace);
                    if (this.debug && vtx.index === this.findIndex){
                        console.info(this.findIndex + " CLAIMED BY " + maxFace.getVertexString());
                    }
                } else {
                    if (this.debug && vtx.index === this.findIndex){
                        console.info(this.findIndex + " DISCARDED");
                    }
                }
            };}
        }

        deleteFacePoints(face: com.vzome.core.math.convexhull.Face, absorbingFace: com.vzome.core.math.convexhull.Face) {
            const faceVtxs: com.vzome.core.math.convexhull.Vertex = this.removeAllPointsFromFace(face);
            if (faceVtxs != null){
                if (absorbingFace == null){
                    this.unclaimed.addAll(faceVtxs);
                } else {
                    let vtxNext: com.vzome.core.math.convexhull.Vertex = faceVtxs;
                    for(let vtx: com.vzome.core.math.convexhull.Vertex = vtxNext; vtx != null; vtx = vtxNext) {{
                        vtxNext = vtx.next;
                        const dist: number = absorbingFace.distanceToPlane(vtx.pnt).evaluate();
                        if (dist > 0){
                            this.addPointToFace(vtx, absorbingFace);
                        } else {
                            this.unclaimed.add(vtx);
                        }
                    };}
                }
            }
        }

        static NONCONVEX_WRT_LARGER_FACE: number = 1;

        static NONCONVEX: number = 2;

        oppFaceDistance(he: com.vzome.core.math.convexhull.HalfEdge): com.vzome.core.algebra.AlgebraicNumber {
            return he.face.distanceToPlane(he.opposite.face.getCentroid());
        }

        /*private*/ doAdjacentMerge(face: com.vzome.core.math.convexhull.Face, mergeType: number): boolean {
            let hedge: com.vzome.core.math.convexhull.HalfEdge = face.he0;
            let convex: boolean = true;
            do {{
                const oppFace: com.vzome.core.math.convexhull.Face = hedge.oppositeFace();
                let merge: boolean = false;
                const tolerance: number = 0;
                if (mergeType === QuickHull3D.NONCONVEX){
                    if (this.oppFaceDistance(hedge).evaluate() > -tolerance || this.oppFaceDistance(hedge.opposite).evaluate() > -tolerance){
                        merge = true;
                    }
                } else {
                    if (face.area > oppFace.area){
                        if (this.oppFaceDistance(hedge).evaluate() > -tolerance){
                            merge = true;
                        } else if (this.oppFaceDistance(hedge.opposite).evaluate() > -tolerance){
                            convex = false;
                        }
                    } else {
                        if (this.oppFaceDistance(hedge.opposite).evaluate() >= -tolerance){
                            merge = true;
                        } else if (this.oppFaceDistance(hedge).evaluate() >= -tolerance){
                            convex = false;
                        }
                    }
                }
                if (merge){
                    if (this.debug){
                        console.info("  merging " + face.getVertexString() + "  and  " + oppFace.getVertexString());
                    }
                    const numd: number = face.mergeAdjacentFace(hedge, this.discardedFaces);
                    for(let i: number = 0; i < numd; i++) {{
                        this.deleteFacePoints(this.discardedFaces[i], face);
                    };}
                    if (this.debug){
                        console.info("  result: " + face.getVertexString());
                    }
                    return true;
                }
                hedge = hedge.next;
            }} while((hedge !== face.he0));
            if (!convex){
                face.mark = com.vzome.core.math.convexhull.Face.NON_CONVEX;
            }
            return false;
        }

        calculateHorizon(eyePnt: com.vzome.core.algebra.AlgebraicVector, edge0: com.vzome.core.math.convexhull.HalfEdge, face: com.vzome.core.math.convexhull.Face, horizon: java.util.Vector<com.vzome.core.math.convexhull.HalfEdge>) {
            this.deleteFacePoints(face, null);
            face.mark = com.vzome.core.math.convexhull.Face.DELETED;
            if (this.debug){
                console.info("  visiting face " + face.getVertexString());
            }
            let edge: com.vzome.core.math.convexhull.HalfEdge;
            if (edge0 == null){
                edge0 = face.getEdge(0);
                edge = edge0;
            } else {
                edge = edge0.getNext();
            }
            const tolerance: number = 0;
            do {{
                const oppFace: com.vzome.core.math.convexhull.Face = edge.oppositeFace();
                if (oppFace.mark === com.vzome.core.math.convexhull.Face.VISIBLE){
                    if (oppFace.distanceToPlane(eyePnt).evaluate() > tolerance){
                        this.calculateHorizon(eyePnt, edge.getOpposite(), oppFace, horizon);
                    } else {
                        horizon.add(edge);
                        if (this.debug){
                            console.info("  adding horizon edge " + edge.getVertexString());
                        }
                    }
                }
                edge = edge.getNext();
            }} while((edge !== edge0));
        }

        /*private*/ addAdjoiningFace(eyeVtx: com.vzome.core.math.convexhull.Vertex, he: com.vzome.core.math.convexhull.HalfEdge): com.vzome.core.math.convexhull.HalfEdge {
            const face: com.vzome.core.math.convexhull.Face = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(eyeVtx, he.tail(), he.head());
            this.faces.add(face);
            face.getEdge(-1).setOpposite(he.getOpposite());
            return face.getEdge(0);
        }

        addNewFaces(newFaces: java.util.List<com.vzome.core.math.convexhull.Face>, eyeVtx: com.vzome.core.math.convexhull.Vertex, horizon: java.util.Vector<com.vzome.core.math.convexhull.HalfEdge>) {
            newFaces.clear();
            let hedgeSidePrev: com.vzome.core.math.convexhull.HalfEdge = null;
            let hedgeSideBegin: com.vzome.core.math.convexhull.HalfEdge = null;
            for(let index=horizon.iterator();index.hasNext();) {
                let horizonHe = index.next();
                {
                    const hedgeSide: com.vzome.core.math.convexhull.HalfEdge = this.addAdjoiningFace(eyeVtx, horizonHe);
                    if (this.debug){
                        console.info("new face: " + hedgeSide.face.getVertexString());
                    }
                    if (hedgeSidePrev != null){
                        hedgeSide.next.setOpposite(hedgeSidePrev);
                    } else {
                        hedgeSideBegin = hedgeSide;
                    }
                    newFaces.add(hedgeSide.getFace());
                    hedgeSidePrev = hedgeSide;
                }
            }
            hedgeSideBegin.next.setOpposite(hedgeSidePrev);
        }

        nextPointToAdd(): com.vzome.core.math.convexhull.Vertex {
            if (!this.claimed.isEmpty()){
                const eyeFace: com.vzome.core.math.convexhull.Face = this.claimed.first().face;
                let eyeVtx: com.vzome.core.math.convexhull.Vertex = null;
                let maxDist: number = 0;
                for(let vtx: com.vzome.core.math.convexhull.Vertex = eyeFace.outside; vtx != null && vtx.face === eyeFace; vtx = vtx.next) {{
                    const dist: number = eyeFace.distanceToPlane(vtx.pnt).evaluate();
                    if (dist > maxDist){
                        maxDist = dist;
                        eyeVtx = vtx;
                    }
                };}
                return eyeVtx;
            } else {
                return null;
            }
        }

        addPointToHull(eyeVtx: com.vzome.core.math.convexhull.Vertex) {
            const horizon: java.util.Vector<com.vzome.core.math.convexhull.HalfEdge> = <any>(new java.util.Vector<any>());
            this.unclaimed.clear();
            if (this.debug){
                console.info("Adding point: " + eyeVtx.index);
                console.info(" which is " + eyeVtx.face.distanceToPlane(eyeVtx.pnt) + " above face " + eyeVtx.face.getVertexString());
            }
            this.removePointFromFace(eyeVtx, eyeVtx.face);
            this.calculateHorizon(eyeVtx.pnt, null, eyeVtx.face, horizon);
            this.newFaces.clear();
            this.addNewFaces(this.newFaces, eyeVtx, horizon);
            for(let index=this.newFaces.iterator();index.hasNext();) {
                let face = index.next();
                {
                    if (face.mark === com.vzome.core.math.convexhull.Face.VISIBLE){
                        while((this.doAdjacentMerge(face, QuickHull3D.NONCONVEX_WRT_LARGER_FACE))) {};
                    }
                }
            }
            for(let index=this.newFaces.iterator();index.hasNext();) {
                let face = index.next();
                {
                    if (face.mark === com.vzome.core.math.convexhull.Face.NON_CONVEX){
                        face.mark = com.vzome.core.math.convexhull.Face.VISIBLE;
                        while((this.doAdjacentMerge(face, QuickHull3D.NONCONVEX))) {};
                    }
                }
            }
            this.resolveUnclaimedPoints(this.newFaces);
        }

        buildHull() {
            let cnt: number = 0;
            let eyeVtx: com.vzome.core.math.convexhull.Vertex;
            this.computeMaxAndMin();
            this.createInitialSimplex();
            while(((eyeVtx = this.nextPointToAdd()) != null)) {{
                this.addPointToHull(eyeVtx);
                cnt++;
                if (this.debug){
                    console.info("iteration " + cnt + " done");
                }
            }};
            this.reindexFacesAndVertices();
            if (this.debug){
                console.info("hull done");
            }
        }

        /*private*/ markFaceVertices(face: com.vzome.core.math.convexhull.Face, mark: number) {
            const he0: com.vzome.core.math.convexhull.HalfEdge = face.getFirstEdge();
            let he: com.vzome.core.math.convexhull.HalfEdge = he0;
            do {{
                he.head().index = mark;
                he = he.next;
            }} while((he !== he0));
        }

        reindexFacesAndVertices() {
            for(let i: number = 0; i < this.numPoints; i++) {{
                this.pointBuffer[i].index = -1;
            };}
            this.numFaces = 0;
            for(const it: java.util.Iterator<com.vzome.core.math.convexhull.Face> = this.faces.iterator(); it.hasNext(); ) {{
                const face: com.vzome.core.math.convexhull.Face = it.next();
                if (face.mark !== com.vzome.core.math.convexhull.Face.VISIBLE){
                    it.remove();
                } else {
                    this.markFaceVertices(face, 0);
                    this.numFaces++;
                }
            };}
            this.numVertices = 0;
            for(let i: number = 0; i < this.numPoints; i++) {{
                const vtx: com.vzome.core.math.convexhull.Vertex = this.pointBuffer[i];
                if (vtx.index === 0){
                    this.vertexPointIndices[this.numVertices] = i;
                    vtx.index = this.numVertices++;
                }
            };}
        }

        checkFaceConvexity(face: com.vzome.core.math.convexhull.Face, ps: java.io.PrintStream): boolean {
            let he: com.vzome.core.math.convexhull.HalfEdge = face.he0;
            do {{
                face.checkConsistency();
                let dist: com.vzome.core.algebra.AlgebraicNumber = this.oppFaceDistance(he);
                if (!dist.isZero()){
                    if (ps != null){
                        ps.println("Edge " + he.getVertexString() + " non-convex by " + dist);
                    }
                    return false;
                }
                dist = this.oppFaceDistance(he.opposite);
                if (!dist.isZero()){
                    if (ps != null){
                        ps.println("Opposite edge " + he.opposite.getVertexString() + " non-convex by " + dist);
                    }
                    return false;
                }
                if (he.next.oppositeFace() === he.oppositeFace()){
                    if (ps != null){
                        ps.println("Redundant vertex " + he.head().index + " in face " + face.getVertexString());
                    }
                    return false;
                }
                he = he.next;
            }} while((he !== face.he0));
            return true;
        }

        checkFaces(ps: java.io.PrintStream): boolean {
            let convex: boolean = true;
            for(let index=this.faces.iterator();index.hasNext();) {
                let face = index.next();
                {
                    if (face.mark === com.vzome.core.math.convexhull.Face.VISIBLE){
                        if (!this.checkFaceConvexity(face, ps)){
                            convex = false;
                        }
                    }
                }
            }
            return convex;
        }

        /**
         * Checks the correctness of the hull. This is done by making sure that no faces
         * are non-convex and that no points are outside any face. These tests are
         * performed using the distance tolerance <i>tol</i>. Faces are considered
         * non-convex if any edge is non-convex, and an edge is non-convex if the
         * centroid of either adjoining face is more than <i>tol</i> above the plane of
         * the other face. Similarly, a point is considered outside a face if its
         * distance to that face's plane is more than 10 times <i>tol</i>.
         * 
         * <p>
         * If the hull has been {@link #triangulate}, then this routine may
         * fail if some of the resulting triangles are very small or thin.
         * 
         * @param {java.io.PrintStream} ps
         * print stream for diagnostic messages; may be set to
         * <code>null</code> if no messages are desired.
         * @return {boolean} true if the hull is valid
         * @throws Failure
         * @see QuickHull3D#check(PrintStream)
         */
        public check(ps: java.io.PrintStream): boolean {
            if (!this.checkFaces(ps)){
                return false;
            }
            for(let i: number = 0; i < this.numPoints; i++) {{
                const pnt: com.vzome.core.algebra.AlgebraicVector = this.pointBuffer[i].pnt;
                for(let index=this.faces.iterator();index.hasNext();) {
                    let face = index.next();
                    {
                        if (face.mark === com.vzome.core.math.convexhull.Face.VISIBLE){
                            const dist: com.vzome.core.algebra.AlgebraicNumber = face.distanceToPlane(pnt);
                            if (!dist.isZero()){
                                if (ps != null){
                                    ps.println("Point " + i + " " + dist + " above face " + face.getVertexString());
                                }
                                return false;
                            }
                        }
                    }
                }
            };}
            return true;
        }
    }
    QuickHull3D["__class"] = "com.vzome.core.math.convexhull.QuickHull3D";

}
namespace com.vzome.core.math.convexhull {
    /**
     * Maintains a double-linked list of vertices for use by QuickHull3D
     * @class
     */
    export class VertexList {
        /*private*/ head: com.vzome.core.math.convexhull.Vertex;

        /*private*/ tail: com.vzome.core.math.convexhull.Vertex;

        /**
         * Clears this list.
         */
        public clear() {
            this.head = this.tail = null;
        }

        /**
         * Adds a vertex to the end of this list.
         * @param {com.vzome.core.math.convexhull.Vertex} vtx
         */
        public add(vtx: com.vzome.core.math.convexhull.Vertex) {
            if (this.head == null){
                this.head = vtx;
            } else {
                this.tail.next = vtx;
            }
            vtx.prev = this.tail;
            vtx.next = null;
            this.tail = vtx;
        }

        /**
         * Adds a chain of vertices to the end of this list.
         * @param {com.vzome.core.math.convexhull.Vertex} vtx
         */
        public addAll(vtx: com.vzome.core.math.convexhull.Vertex) {
            if (this.head == null){
                this.head = vtx;
            } else {
                this.tail.next = vtx;
            }
            vtx.prev = this.tail;
            while((vtx.next != null)) {{
                vtx = vtx.next;
            }};
            this.tail = vtx;
        }

        public delete$com_vzome_core_math_convexhull_Vertex(vtx: com.vzome.core.math.convexhull.Vertex) {
            if (vtx.prev == null){
                this.head = vtx.next;
            } else {
                vtx.prev.next = vtx.next;
            }
            if (vtx.next == null){
                this.tail = vtx.prev;
            } else {
                vtx.next.prev = vtx.prev;
            }
        }

        public delete$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx1: com.vzome.core.math.convexhull.Vertex, vtx2: com.vzome.core.math.convexhull.Vertex) {
            if (vtx1.prev == null){
                this.head = vtx2.next;
            } else {
                vtx1.prev.next = vtx2.next;
            }
            if (vtx2.next == null){
                this.tail = vtx1.prev;
            } else {
                vtx2.next.prev = vtx1.prev;
            }
        }

        /**
         * Deletes a chain of vertices from this list.
         * @param {com.vzome.core.math.convexhull.Vertex} vtx1
         * @param {com.vzome.core.math.convexhull.Vertex} vtx2
         */
        public delete(vtx1?: any, vtx2?: any) {
            if (((vtx1 != null && vtx1 instanceof <any>com.vzome.core.math.convexhull.Vertex) || vtx1 === null) && ((vtx2 != null && vtx2 instanceof <any>com.vzome.core.math.convexhull.Vertex) || vtx2 === null)) {
                return <any>this.delete$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx1, vtx2);
            } else if (((vtx1 != null && vtx1 instanceof <any>com.vzome.core.math.convexhull.Vertex) || vtx1 === null) && vtx2 === undefined) {
                return <any>this.delete$com_vzome_core_math_convexhull_Vertex(vtx1);
            } else throw new Error('invalid overload');
        }

        /**
         * Inserts a vertex into this list before another specificed vertex.
         * @param {com.vzome.core.math.convexhull.Vertex} vtx
         * @param {com.vzome.core.math.convexhull.Vertex} next
         */
        public insertBefore(vtx: com.vzome.core.math.convexhull.Vertex, next: com.vzome.core.math.convexhull.Vertex) {
            vtx.prev = next.prev;
            if (next.prev == null){
                this.head = vtx;
            } else {
                next.prev.next = vtx;
            }
            vtx.next = next;
            next.prev = vtx;
        }

        /**
         * Returns the first element in this list.
         * @return {com.vzome.core.math.convexhull.Vertex}
         */
        public first(): com.vzome.core.math.convexhull.Vertex {
            return this.head;
        }

        /**
         * Returns true if this list is empty.
         * @return {boolean}
         */
        public isEmpty(): boolean {
            return this.head == null;
        }

        constructor() {
            if (this.head === undefined) { this.head = null; }
            if (this.tail === undefined) { this.tail = null; }
        }
    }
    VertexList["__class"] = "com.vzome.core.math.convexhull.VertexList";

}
namespace com.vzome.core.math.convexhull {
    /**
     * Constructs a HalfEdge with head vertex <code>v</code> and left-hand
     * triangular face <code>f</code>.
     * 
     * @param {com.vzome.core.math.convexhull.Vertex} v
     * head vertex
     * @param {com.vzome.core.math.convexhull.Face} f
     * left-hand triangular face
     * @class
     * @author John E. Lloyd, Fall 2004
     */
    export class HalfEdge {
        /**
         * The vertex associated with the head of this half-edge.
         */
        vertex: com.vzome.core.math.convexhull.Vertex;

        /**
         * Triangular face associated with this half-edge.
         */
        face: com.vzome.core.math.convexhull.Face;

        /**
         * Next half-edge in the triangle.
         */
        next: HalfEdge;

        /**
         * Previous half-edge in the triangle.
         */
        prev: HalfEdge;

        /**
         * Half-edge associated with the opposite triangle adjacent to this edge.
         */
        opposite: HalfEdge;

        public constructor(v?: any, f?: any) {
            if (((v != null && v instanceof <any>com.vzome.core.math.convexhull.Vertex) || v === null) && ((f != null && f instanceof <any>com.vzome.core.math.convexhull.Face) || f === null)) {
                let __args = arguments;
                if (this.vertex === undefined) { this.vertex = null; } 
                if (this.face === undefined) { this.face = null; } 
                if (this.next === undefined) { this.next = null; } 
                if (this.prev === undefined) { this.prev = null; } 
                if (this.opposite === undefined) { this.opposite = null; } 
                this.vertex = v;
                this.face = f;
            } else if (v === undefined && f === undefined) {
                let __args = arguments;
                if (this.vertex === undefined) { this.vertex = null; } 
                if (this.face === undefined) { this.face = null; } 
                if (this.next === undefined) { this.next = null; } 
                if (this.prev === undefined) { this.prev = null; } 
                if (this.opposite === undefined) { this.opposite = null; } 
            } else throw new Error('invalid overload');
        }

        /**
         * Sets the value of the next edge adjacent (counter-clockwise) to this one
         * within the triangle.
         * 
         * @param {com.vzome.core.math.convexhull.HalfEdge} edge
         * next adjacent edge
         */
        public setNext(edge: HalfEdge) {
            this.next = edge;
        }

        /**
         * Gets the value of the next edge adjacent (counter-clockwise) to this one
         * within the triangle.
         * 
         * @return {com.vzome.core.math.convexhull.HalfEdge} next adjacent edge
         */
        public getNext(): HalfEdge {
            return this.next;
        }

        /**
         * Sets the value of the previous edge adjacent (clockwise) to this one within
         * the triangle.
         * 
         * @param {com.vzome.core.math.convexhull.HalfEdge} edge
         * previous adjacent edge
         */
        public setPrev(edge: HalfEdge) {
            this.prev = edge;
        }

        /**
         * Gets the value of the previous edge adjacent (clockwise) to this one within
         * the triangle.
         * 
         * @return {com.vzome.core.math.convexhull.HalfEdge} previous adjacent edge
         */
        public getPrev(): HalfEdge {
            return this.prev;
        }

        /**
         * Returns the triangular face located to the left of this half-edge.
         * 
         * @return {com.vzome.core.math.convexhull.Face} left-hand triangular face
         */
        public getFace(): com.vzome.core.math.convexhull.Face {
            return this.face;
        }

        /**
         * Returns the half-edge opposite to this half-edge.
         * 
         * @return {com.vzome.core.math.convexhull.HalfEdge} opposite half-edge
         */
        public getOpposite(): HalfEdge {
            return this.opposite;
        }

        /**
         * Sets the half-edge opposite to this half-edge.
         * 
         * @param {com.vzome.core.math.convexhull.HalfEdge} edge
         * opposite half-edge
         */
        public setOpposite(edge: HalfEdge) {
            this.opposite = edge;
            edge.opposite = this;
        }

        /**
         * Returns the head vertex associated with this half-edge.
         * 
         * @return {com.vzome.core.math.convexhull.Vertex} head vertex
         */
        public head(): com.vzome.core.math.convexhull.Vertex {
            return this.vertex;
        }

        /**
         * Returns the tail vertex associated with this half-edge.
         * 
         * @return {com.vzome.core.math.convexhull.Vertex} tail vertex
         */
        public tail(): com.vzome.core.math.convexhull.Vertex {
            return this.prev != null ? this.prev.vertex : null;
        }

        /**
         * Returns the opposite triangular face associated with this half-edge.
         * 
         * @return {com.vzome.core.math.convexhull.Face} opposite triangular face
         */
        public oppositeFace(): com.vzome.core.math.convexhull.Face {
            return this.opposite == null ? null : this.opposite.face;
        }

        /**
         * Produces a string identifying this half-edge by the point index values of its
         * tail and head vertices.
         * 
         * @return {string} identifying string
         */
        public getVertexString(): string {
            if (this.tail() != null){
                return "" + this.tail().index + "-" + this.head().index;
            } else {
                return "?-" + this.head().index;
            }
        }

        /**
         * Returns the length squared of this half-edge.
         * 
         * @return {*} half-edge length squared
         */
        public lengthSquared(): com.vzome.core.algebra.AlgebraicNumber {
            if (this.tail() == null){
                return this.head().pnt.getField()['createRational$long'](-1);
            }
            const offset: com.vzome.core.algebra.AlgebraicVector = this.head().pnt.minus(this.tail().pnt);
            return offset.dot(offset);
        }
    }
    HalfEdge["__class"] = "com.vzome.core.math.convexhull.HalfEdge";

}
namespace com.vzome.core.math {
    /**
     * @author Scott Vorthmann
     * @param {*} field
     * @class
     */
    export class SixCubeProjection implements com.vzome.core.math.Projection {
        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        /*private*/ basis: com.vzome.core.algebra.AlgebraicVector[];

        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            if (this.field === undefined) { this.field = null; }
            if (this.basis === undefined) { this.basis = null; }
            this.field = field;
            const zero: com.vzome.core.algebra.AlgebraicNumber = field.zero();
            const one: com.vzome.core.algebra.AlgebraicNumber = field.one();
            const nOne: com.vzome.core.algebra.AlgebraicNumber = one.negate();
            const phi: com.vzome.core.algebra.AlgebraicNumber = field['createPower$int'](1);
            this.basis = [null, null, null, null, null, null];
            this.basis[0] = new com.vzome.core.algebra.AlgebraicVector(phi, one, zero);
            this.basis[1] = new com.vzome.core.algebra.AlgebraicVector(phi, nOne, zero);
            this.basis[2] = new com.vzome.core.algebra.AlgebraicVector(zero, phi, one);
            this.basis[3] = new com.vzome.core.algebra.AlgebraicVector(zero, phi, nOne);
            this.basis[4] = new com.vzome.core.algebra.AlgebraicVector(one, zero, phi);
            this.basis[5] = new com.vzome.core.algebra.AlgebraicVector(nOne, zero, phi);
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} source
         * @param {boolean} wFirst
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public projectImage(source: com.vzome.core.algebra.AlgebraicVector, wFirst: boolean): com.vzome.core.algebra.AlgebraicVector {
            let result: com.vzome.core.algebra.AlgebraicVector = this.field.origin(this.basis[0].dimension());
            let pos: number = wFirst ? 0 : this.basis.length - 1;
            for(let index = 0; index < this.basis.length; index++) {
                let unitVector = this.basis[index];
                {
                    const scalar: com.vzome.core.algebra.AlgebraicNumber = source.getComponent(pos);
                    result = result.plus(unitVector.scale(scalar));
                    pos = (pos + 1) % this.basis.length;
                }
            }
            return result;
        }

        /**
         * 
         * @param {*} element
         */
        public getXmlAttributes(element: org.w3c.dom.Element) {
        }

        /**
         * 
         * @param {*} xml
         */
        public setXmlAttributes(xml: org.w3c.dom.Element) {
        }

        /**
         * 
         * @return {string}
         */
        public getProjectionName(): string {
            return "SixCube";
        }
    }
    SixCubeProjection["__class"] = "com.vzome.core.math.SixCubeProjection";
    SixCubeProjection["__interfaces"] = ["com.vzome.core.math.Projection"];


}
namespace com.vzome.core.math.symmetry {
    export class A4Group implements com.vzome.core.math.symmetry.CoxeterGroup {
        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        /*private*/ ROOTS: com.vzome.core.algebra.AlgebraicVector[];

        /*private*/ WEIGHTS: com.vzome.core.algebra.AlgebraicVector[];

        /*private*/ ROOTS_R4: com.vzome.core.algebra.AlgebraicVector[];

        static S5_PERMS: number[][]; public static S5_PERMS_$LI$(): number[][] { if (A4Group.S5_PERMS == null) { A4Group.S5_PERMS = [[0, 1, 2, 3, 4], [1, 2, 3, 4, 0], [2, 3, 4, 0, 1], [3, 4, 0, 1, 2], [4, 0, 1, 2, 3], [1, 2, 0, 3, 4], [2, 0, 3, 4, 1], [0, 3, 4, 1, 2], [3, 4, 1, 2, 0], [4, 1, 2, 0, 3], [0, 2, 3, 1, 4], [2, 3, 1, 4, 0], [3, 1, 4, 0, 2], [1, 4, 0, 2, 3], [4, 0, 2, 3, 1], [0, 1, 3, 4, 2], [1, 3, 4, 2, 0], [3, 4, 2, 0, 1], [4, 2, 0, 1, 3], [2, 0, 1, 3, 4], [3, 1, 2, 4, 0], [1, 2, 4, 0, 3], [2, 4, 0, 3, 1], [4, 0, 3, 1, 2], [0, 3, 1, 2, 4], [1, 4, 2, 3, 0], [4, 2, 3, 0, 1], [2, 3, 0, 1, 4], [3, 0, 1, 4, 2], [0, 1, 4, 2, 3], [1, 3, 2, 0, 4], [3, 2, 0, 4, 1], [2, 0, 4, 1, 3], [0, 4, 1, 3, 2], [4, 1, 3, 2, 0], [0, 2, 4, 3, 1], [2, 4, 3, 1, 0], [4, 3, 1, 0, 2], [3, 1, 0, 2, 4], [1, 0, 2, 4, 3], [2, 1, 3, 0, 4], [1, 3, 0, 4, 2], [3, 0, 4, 2, 1], [0, 4, 2, 1, 3], [4, 2, 1, 3, 0], [0, 3, 2, 4, 1], [3, 2, 4, 1, 0], [2, 4, 1, 0, 3], [4, 1, 0, 3, 2], [1, 0, 3, 2, 4], [2, 1, 4, 3, 0], [1, 4, 3, 0, 2], [4, 3, 0, 2, 1], [3, 0, 2, 1, 4], [0, 2, 1, 4, 3], [4, 3, 2, 1, 0], [3, 2, 1, 0, 4], [2, 1, 0, 4, 3], [1, 0, 4, 3, 2], [0, 4, 3, 2, 1], [0, 1, 3, 2, 4], [0, 2, 1, 3, 4], [0, 3, 2, 1, 4], [1, 0, 2, 3, 4], [1, 2, 3, 0, 4], [1, 3, 0, 2, 4], [2, 1, 0, 3, 4], [2, 0, 3, 1, 4], [2, 3, 1, 0, 4], [3, 1, 2, 0, 4], [3, 2, 0, 1, 4], [3, 0, 1, 2, 4], [0, 1, 2, 4, 3], [0, 2, 3, 4, 1], [0, 3, 1, 4, 2], [1, 0, 3, 4, 2], [1, 2, 0, 4, 3], [1, 3, 2, 4, 0], [2, 1, 3, 4, 0], [2, 0, 1, 4, 3], [2, 3, 0, 4, 1], [3, 1, 0, 4, 2], [3, 2, 1, 4, 0], [3, 0, 2, 4, 1], [0, 2, 4, 1, 3], [0, 3, 4, 2, 1], [1, 0, 4, 2, 3], [1, 2, 4, 3, 0], [1, 3, 4, 0, 2], [2, 1, 4, 0, 3], [2, 0, 4, 3, 1], [2, 3, 4, 1, 0], [3, 1, 4, 2, 0], [3, 2, 4, 0, 1], [3, 0, 4, 1, 2], [0, 4, 1, 2, 3], [0, 4, 2, 3, 1], [0, 4, 3, 1, 2], [1, 4, 0, 3, 2], [1, 4, 2, 0, 3], [1, 4, 3, 2, 0], [2, 4, 1, 3, 0], [2, 4, 0, 1, 3], [2, 4, 3, 0, 1], [3, 4, 1, 0, 2], [3, 4, 2, 1, 0], [3, 4, 0, 2, 1], [4, 0, 1, 3, 2], [4, 0, 2, 1, 3], [4, 0, 3, 2, 1], [4, 1, 0, 2, 3], [4, 1, 2, 3, 0], [4, 1, 3, 0, 2], [4, 2, 1, 0, 3], [4, 2, 0, 3, 1], [4, 2, 3, 1, 0], [4, 3, 1, 2, 0], [4, 3, 2, 0, 1], [0, 1, 4, 3, 2], [4, 3, 0, 1, 2]]; }  return A4Group.S5_PERMS; }

        /*private*/ ONE_FIFTH: com.vzome.core.algebra.AlgebraicNumber;

        /*private*/ TWO_FIFTHS: com.vzome.core.algebra.AlgebraicNumber;

        /*private*/ THREE_FIFTHS: com.vzome.core.algebra.AlgebraicNumber;

        /*private*/ FOUR_FIFTHS: com.vzome.core.algebra.AlgebraicNumber;

        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            if (this.field === undefined) { this.field = null; }
            this.ROOTS = [null, null, null, null];
            this.WEIGHTS = [null, null, null, null];
            this.ROOTS_R4 = [null, null, null, null];
            if (this.ONE_FIFTH === undefined) { this.ONE_FIFTH = null; }
            if (this.TWO_FIFTHS === undefined) { this.TWO_FIFTHS = null; }
            if (this.THREE_FIFTHS === undefined) { this.THREE_FIFTHS = null; }
            if (this.FOUR_FIFTHS === undefined) { this.FOUR_FIFTHS = null; }
            this.field = field;
            this.ONE_FIFTH = field['createRational$long$long'](1, 5);
            this.TWO_FIFTHS = field['createRational$long$long'](2, 5);
            this.THREE_FIFTHS = field['createRational$long$long'](3, 5);
            this.FOUR_FIFTHS = field['createRational$long$long'](4, 5);
            const neg_one: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long'](-1);
            this.ROOTS[0] = field.basisVector(5, 0);
            this.ROOTS[0].setComponent(1, neg_one);
            this.ROOTS[1] = field.basisVector(5, 1);
            this.ROOTS[1].setComponent(2, neg_one);
            this.ROOTS[2] = field.basisVector(5, 2);
            this.ROOTS[2].setComponent(3, neg_one);
            this.ROOTS[3] = field.basisVector(5, 3);
            this.ROOTS[3].setComponent(4, neg_one);
            this.WEIGHTS[0] = field.basisVector(5, 0);
            this.WEIGHTS[0].setComponent(0, this.FOUR_FIFTHS);
            this.WEIGHTS[0].setComponent(1, this.ONE_FIFTH.negate());
            this.WEIGHTS[0].setComponent(2, this.ONE_FIFTH.negate());
            this.WEIGHTS[0].setComponent(3, this.ONE_FIFTH.negate());
            this.WEIGHTS[0].setComponent(4, this.ONE_FIFTH.negate());
            this.WEIGHTS[1] = field.basisVector(5, 0);
            this.WEIGHTS[1].setComponent(0, this.THREE_FIFTHS);
            this.WEIGHTS[1].setComponent(1, this.THREE_FIFTHS);
            this.WEIGHTS[1].setComponent(2, this.TWO_FIFTHS.negate());
            this.WEIGHTS[1].setComponent(3, this.TWO_FIFTHS.negate());
            this.WEIGHTS[1].setComponent(4, this.TWO_FIFTHS.negate());
            this.WEIGHTS[2] = field.basisVector(5, 0);
            this.WEIGHTS[2].setComponent(0, this.TWO_FIFTHS);
            this.WEIGHTS[2].setComponent(1, this.TWO_FIFTHS);
            this.WEIGHTS[2].setComponent(2, this.TWO_FIFTHS);
            this.WEIGHTS[2].setComponent(3, this.THREE_FIFTHS.negate());
            this.WEIGHTS[2].setComponent(4, this.THREE_FIFTHS.negate());
            this.WEIGHTS[3] = field.basisVector(5, 0);
            this.WEIGHTS[3].setComponent(0, this.ONE_FIFTH);
            this.WEIGHTS[3].setComponent(1, this.ONE_FIFTH);
            this.WEIGHTS[3].setComponent(2, this.ONE_FIFTH);
            this.WEIGHTS[3].setComponent(3, this.ONE_FIFTH);
            this.WEIGHTS[3].setComponent(4, this.FOUR_FIFTHS.negate());
            const two: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long'](2);
            const two_neg: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long'](-2);
            this.ROOTS_R4[0] = field.basisVector(4, 1);
            this.ROOTS_R4[0].setComponent(1, two);
            this.ROOTS_R4[0].setComponent(2, two_neg);
            this.ROOTS_R4[1] = field.basisVector(4, 1);
            this.ROOTS_R4[1].setComponent(3, two_neg);
            this.ROOTS_R4[1].setComponent(1, two_neg);
            this.ROOTS_R4[2] = field.basisVector(4, 1);
            this.ROOTS_R4[2].setComponent(1, two);
            this.ROOTS_R4[2].setComponent(2, two);
            this.ROOTS_R4[3] = field.basisVector(4, 3);
            const root5: com.vzome.core.algebra.AlgebraicNumber = field['createAlgebraicNumber$int$int$int$int'](-1, 2, 1, 0);
            this.ROOTS_R4[3].setComponent(1, neg_one);
            this.ROOTS_R4[3].setComponent(2, neg_one);
            this.ROOTS_R4[3].setComponent(0, root5);
        }

        /**
         * 
         * @return {number}
         */
        public getOrder(): number {
            return A4Group.S5_PERMS_$LI$().length;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} model
         * @param {number} element
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public groupAction(model: com.vzome.core.algebra.AlgebraicVector, element: number): com.vzome.core.algebra.AlgebraicVector {
            let result: com.vzome.core.algebra.AlgebraicVector = this.field.origin(4);
            let sum: com.vzome.core.algebra.AlgebraicNumber = this.field['createRational$long'](0);
            for(let c: number = 0; c < 4; c++) {{
                const source: com.vzome.core.algebra.AlgebraicNumber = model.getComponent(A4Group.S5_PERMS_$LI$()[element][c]);
                sum = sum['plus$com_vzome_core_algebra_AlgebraicNumber'](source);
                const scaled: com.vzome.core.algebra.AlgebraicVector = this.ROOTS_R4[c].scale(sum);
                result = result.plus(scaled);
            };}
            return result.scale(this.field['createPower$int'](-1));
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getOrigin(): com.vzome.core.algebra.AlgebraicVector {
            return this.field.origin(5);
        }

        /**
         * 
         * @param {number} i
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getWeight(i: number): com.vzome.core.algebra.AlgebraicVector {
            return this.WEIGHTS[i];
        }

        /**
         * 
         * @param {number} i
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getSimpleRoot(i: number): com.vzome.core.algebra.AlgebraicVector {
            return this.ROOTS[i];
        }

        /**
         * 
         * @return {*}
         */
        public getField(): com.vzome.core.algebra.AlgebraicField {
            return this.field;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} model
         * @param {number} element
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public chiralSubgroupAction(model: com.vzome.core.algebra.AlgebraicVector, element: number): com.vzome.core.algebra.AlgebraicVector {
            if (element >= 60)return null;
            let result: com.vzome.core.algebra.AlgebraicVector = this.field.origin(4);
            let sum: com.vzome.core.algebra.AlgebraicNumber = this.field['createRational$long'](0);
            for(let c: number = 0; c < 4; c++) {{
                const source: com.vzome.core.algebra.AlgebraicNumber = model.getComponent(A4Group.S5_PERMS_$LI$()[element][c]);
                sum = sum['plus$com_vzome_core_algebra_AlgebraicNumber'](source);
                const scaled: com.vzome.core.algebra.AlgebraicVector = this.ROOTS_R4[c].scale(sum);
                result = result.plus(scaled);
            };}
            return result.scale(this.field['createPower$int'](-1));
        }
    }
    A4Group["__class"] = "com.vzome.core.math.symmetry.A4Group";
    A4Group["__interfaces"] = ["com.vzome.core.math.symmetry.CoxeterGroup"];


}
namespace com.vzome.core.math.symmetry {
    export class WythoffConstruction {
        public static constructPolytope(group: com.vzome.core.math.symmetry.CoxeterGroup, index: number, edgesToRender: number, edgeScales: com.vzome.core.algebra.AlgebraicNumber[], renderingGroup: com.vzome.core.math.symmetry.CoxeterGroup, listener: WythoffConstruction.Listener) {
            const neighbors: com.vzome.core.algebra.AlgebraicVector[] = [null, null, null, null];
            const chiral: boolean = false;
            if (chiral){
                index = edgesToRender = 15;
            }
            const origin: com.vzome.core.algebra.AlgebraicVector = group.getOrigin();
            let model: com.vzome.core.algebra.AlgebraicVector = origin;
            let bits: number = index;
            for(let i: number = 0; i < 4; i++) {{
                if (bits % 2 === 1)model = model.plus(group.getWeight(i).scale(edgeScales[i]));
                bits >>= 1;
            };}
            bits = index;
            for(let i: number = 0; i < 4; i++) {{
                if ((bits % 2 === 1) && (edgesToRender % 2 === 1))neighbors[i] = model.minus(group.getSimpleRoot(i).scale(edgeScales[i])); else neighbors[i] = origin;
                bits >>= 1;
                edgesToRender >>= 1;
            };}
            const order: number = renderingGroup.getOrder();
            if (chiral){
                for(let i: number = 0; i < order; i++) {{
                    const vector: com.vzome.core.algebra.AlgebraicVector = renderingGroup.chiralSubgroupAction(model, i);
                    if (vector == null)continue;
                    for(let e: number = 0; e < 4; e++) {for(let f: number = e + 1; f < 4; f++) {{
                        const v1: com.vzome.core.algebra.AlgebraicVector = renderingGroup.chiralSubgroupAction(neighbors[e], i);
                        const p1: any = listener.addVertex(v1);
                        const v2: com.vzome.core.algebra.AlgebraicVector = renderingGroup.chiralSubgroupAction(neighbors[f], i);
                        const p2: any = listener.addVertex(v2);
                        listener.addEdge(p1, p2);
                    };};}
                };}
            } else for(let i: number = 0; i < order; i++) {{
                const vector: com.vzome.core.algebra.AlgebraicVector = renderingGroup.groupAction(model, i);
                const p: any = listener.addVertex(vector);
                for(let e: number = 0; e < 4; e++) {{
                    if (neighbors[e].equals(origin))continue;
                    const other: com.vzome.core.algebra.AlgebraicVector = renderingGroup.groupAction(neighbors[e], i);
                    if (!other.equals(vector)){
                        const p2: any = listener.addVertex(other);
                        listener.addEdge(p, p2);
                    }
                };}
            };}
        }
    }
    WythoffConstruction["__class"] = "com.vzome.core.math.symmetry.WythoffConstruction";


    export namespace WythoffConstruction {

        export interface Listener {
            addVertex(v: com.vzome.core.algebra.AlgebraicVector): any;

            addEdge(p1: any, p2: any): any;

            addFace(vertices: any[]): any;
        }

        export class VefPrinter implements WythoffConstruction.Listener {
            vefVertices: java.lang.StringBuffer;

            vefEdges: java.lang.StringBuffer;

            numEdges: number;

            numVertices: number;

            field: com.vzome.core.algebra.AlgebraicField;

            public constructor(field2: com.vzome.core.algebra.AlgebraicField) {
                this.vefVertices = new java.lang.StringBuffer();
                this.vefEdges = new java.lang.StringBuffer();
                this.numEdges = 0;
                this.numVertices = 0;
                if (this.field === undefined) { this.field = null; }
                this.field = field2;
            }

            /**
             * 
             * @param {*} p1
             * @param {*} p2
             * @return {*}
             */
            public addEdge(p1: any, p2: any): any {
                this.vefEdges.append((<number>p1) + "\t" + (<number>p2) + "\n");
                ++this.numEdges;
                return null;
            }

            /**
             * 
             * @param {java.lang.Object[]} vertices
             * @return {*}
             */
            public addFace(vertices: any[]): any {
                return null;
            }

            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} gv
             * @return {*}
             */
            public addVertex(gv: com.vzome.core.algebra.AlgebraicVector): any {
                gv.getVectorExpression$java_lang_StringBuffer$int(this.vefVertices, com.vzome.core.algebra.AlgebraicField.VEF_FORMAT);
                this.vefVertices.append("\n");
                return this.numVertices++;
            }

            public print(out: java.io.PrintWriter) {
                out.println$java_lang_Object("vZome VEF 5");
                out.println$java_lang_Object(this.numVertices);
                out.println$java_lang_Object(this.vefVertices.toString());
                out.println$java_lang_Object(this.numEdges);
                out.println$java_lang_Object(this.vefEdges.toString());
                out.close();
            }
        }
        VefPrinter["__class"] = "com.vzome.core.math.symmetry.WythoffConstruction.VefPrinter";
        VefPrinter["__interfaces"] = ["com.vzome.core.math.symmetry.WythoffConstruction.Listener"];


    }

}
namespace com.vzome.core.math.symmetry {
    export class D4Group implements com.vzome.core.math.symmetry.CoxeterGroup {
        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        ROOTS: com.vzome.core.algebra.AlgebraicVector[];

        WEIGHTS: com.vzome.core.algebra.AlgebraicVector[];

        static D4_PERMS: number[][]; public static D4_PERMS_$LI$(): number[][] { if (D4Group.D4_PERMS == null) { D4Group.D4_PERMS = [[0, 1, 2, 3], [2, 3, 0, 1], [1, 0, 3, 2], [3, 2, 1, 0], [2, 1, 3, 0], [3, 0, 2, 1], [1, 2, 0, 3], [0, 3, 1, 2], [0, 2, 3, 1], [3, 1, 0, 2], [2, 0, 1, 3], [1, 3, 2, 0], [1, 0, 2, 3], [2, 3, 1, 0], [0, 1, 3, 2], [3, 2, 0, 1], [0, 2, 1, 3], [1, 3, 0, 2], [2, 0, 3, 1], [3, 1, 2, 0], [2, 1, 0, 3], [0, 3, 2, 1], [1, 2, 3, 0], [3, 0, 1, 2]]; }  return D4Group.D4_PERMS; }

        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            if (this.field === undefined) { this.field = null; }
            this.ROOTS = [null, null, null, null];
            this.WEIGHTS = [null, null, null, null];
            this.field = field;
            const neg_one: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long'](-1);
            this.ROOTS[0] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
            this.ROOTS[0].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, neg_one);
            this.ROOTS[1] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Y4);
            this.ROOTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, neg_one);
            this.ROOTS[2] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Z4);
            this.ROOTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, neg_one);
            this.ROOTS[3] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Z4);
            this.ROOTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, field.one());
            const y: com.vzome.core.algebra.AlgebraicVector = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Y4);
            const half: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long$long'](1, 2);
            const neg_half: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long$long'](-1, 2);
            this.WEIGHTS[0] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
            this.WEIGHTS[1] = this.WEIGHTS[0].plus(y);
            this.WEIGHTS[2] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, half);
            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, half);
            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, neg_half);
            this.WEIGHTS[3] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, half);
            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, half);
            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, half);
        }

        /**
         * 
         * @return {number}
         */
        public getOrder(): number {
            return 24 * 8;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} model
         * @param {number} element
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public groupAction(model: com.vzome.core.algebra.AlgebraicVector, element: number): com.vzome.core.algebra.AlgebraicVector {
            const result: com.vzome.core.algebra.AlgebraicVector = this.field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
            const perm: number = (element / 8|0);
            let signs: number = element % 8;
            let even: boolean = true;
            for(let c: number = 0; c < 4; c++) {{
                let source: com.vzome.core.algebra.AlgebraicNumber = model.getComponent((D4Group.D4_PERMS_$LI$()[perm][c] + 1) % 4);
                if (c === 3 && !even){
                    source = source.negate();
                } else if (signs % 2 !== 0){
                    even = !even;
                    source = source.negate();
                }
                result.setComponent((c + 1) % 4, source);
                signs = signs >> 1;
            };}
            return result;
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getOrigin(): com.vzome.core.algebra.AlgebraicVector {
            return this.field.origin(4);
        }

        /**
         * 
         * @param {number} i
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getWeight(i: number): com.vzome.core.algebra.AlgebraicVector {
            return this.WEIGHTS[i];
        }

        /**
         * 
         * @param {number} i
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getSimpleRoot(i: number): com.vzome.core.algebra.AlgebraicVector {
            return this.ROOTS[i];
        }

        /**
         * 
         * @return {*}
         */
        public getField(): com.vzome.core.algebra.AlgebraicField {
            return this.field;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} model
         * @param {number} element
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public chiralSubgroupAction(model: com.vzome.core.algebra.AlgebraicVector, element: number): com.vzome.core.algebra.AlgebraicVector {
            const result: com.vzome.core.algebra.AlgebraicVector = this.field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
            const perm: number = (element / 8|0);
            if (perm >= 12)return null;
            let signs: number = element % 8;
            let even: boolean = true;
            for(let c: number = 0; c < 4; c++) {{
                let source: com.vzome.core.algebra.AlgebraicNumber = model.getComponent((D4Group.D4_PERMS_$LI$()[perm][c] + 1) % 4);
                if (c === 3 && !even){
                    source = source.negate();
                } else if (signs % 2 !== 0){
                    even = !even;
                    source = source.negate();
                }
                result.setComponent((c + 1) % 4, source);
                signs = signs >> 1;
            };}
            return result;
        }
    }
    D4Group["__class"] = "com.vzome.core.math.symmetry.D4Group";
    D4Group["__interfaces"] = ["com.vzome.core.math.symmetry.CoxeterGroup"];


}
namespace com.vzome.core.math.symmetry {
    export enum SpecialOrbit {
        BLUE, RED, YELLOW, BLACK
    }
}
namespace com.vzome.core.math.symmetry {
    export class Permutation {
        /**
         * Since the MINUS side always mirrors the PLUS side,
         * the map only needs to indicate one.
         */
        /*private*/ m_map: number[];

        /*private*/ m_order: number;

        /*private*/ mSymmetryGroup: com.vzome.core.math.symmetry.Symmetry;

        public constructor(group: com.vzome.core.math.symmetry.Symmetry, map: number[]) {
            if (this.m_map === undefined) { this.m_map = null; }
            this.m_order = 1;
            if (this.mSymmetryGroup === undefined) { this.mSymmetryGroup = null; }
            this.mSymmetryGroup = group;
            if (map == null){
                const numUnits: number = group.getChiralOrder();
                map = (s => { let a=[]; while(s-->0) a.push(0); return a; })(numUnits);
                for(let unit: number = 0; unit < numUnits; unit++) {map[unit] = unit;}
            }
            this.m_map = map;
            let unit: number = 0;
            for(let i: number = 0; i < this.m_map.length; i++) {{
                unit = this.m_map[unit];
                if (unit === 0){
                    this.m_order = i + 1;
                    break;
                }
            };}
        }

        public getJsonValue(): number[] {
            return this.m_map;
        }

        /**
         * 
         * @return {string}
         */
        public toString(): string {
            return "permutation #" + this.mapIndex(0);
        }

        public getOrder(): number {
            return this.m_order;
        }

        /**
         * Composition, where p1.compose( p2 ) .permute(axis)  == p1.permute( p2.permute( axis ) )
         * @param {com.vzome.core.math.symmetry.Permutation} other
         * @return {com.vzome.core.math.symmetry.Permutation}
         */
        public compose(other: Permutation): Permutation {
            return this.mSymmetryGroup.getPermutation(this.m_map[other.m_map[0]]);
        }

        public inverse(): Permutation {
            for(let i: number = 0; i < this.m_map.length; i++) {if (this.mapIndex(i) === 0)return this.mSymmetryGroup.getPermutation(i);;}
            return null;
        }

        public power(power: number): Permutation {
            if (power === 0)return this.mSymmetryGroup.getPermutation(0);
            let base: Permutation = this;
            if (power < 0){
                base = this.inverse();
                power *= -1;
            }
            if (power === 1)return base;
            return base.compose(base.power(power - 1));
        }

        public mapIndex(i: number): number {
            if ((i < 0) || (i >= this.m_map.length))return com.vzome.core.math.symmetry.Symmetry.NO_ROTATION;
            return this.m_map[i];
        }

        public permute(axis: com.vzome.core.math.symmetry.Axis, sense: number): com.vzome.core.math.symmetry.Axis {
            let orn: number = axis.getOrientation();
            orn = this.mapIndex(orn);
            return axis.getDirection().getAxis$int$int((sense + axis.getSense()) % 2, orn);
        }
    }
    Permutation["__class"] = "com.vzome.core.math.symmetry.Permutation";

}
namespace com.vzome.core.math.symmetry {
    export class OrbitDotLocator {
        /*private*/ worldTrianglePoint: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ worldTriangleNormal: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ dotTransform: com.vzome.core.algebra.AlgebraicMatrix;

        /*private*/ orbitProbe: com.vzome.core.math.RealVector;

        /*private*/ symmetry: com.vzome.core.math.symmetry.Symmetry;

        /*private*/ debugger: com.vzome.core.algebra.VefVectorExporter;

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        /*private*/ vefDebugOutput: java.io.StringWriter;

        public constructor(symmetry: com.vzome.core.math.symmetry.Symmetry, worldTriangle: com.vzome.core.algebra.AlgebraicVector[]) {
            if (this.worldTrianglePoint === undefined) { this.worldTrianglePoint = null; }
            if (this.worldTriangleNormal === undefined) { this.worldTriangleNormal = null; }
            if (this.dotTransform === undefined) { this.dotTransform = null; }
            if (this.orbitProbe === undefined) { this.orbitProbe = null; }
            if (this.symmetry === undefined) { this.symmetry = null; }
            if (this.debugger === undefined) { this.debugger = null; }
            if (this.field === undefined) { this.field = null; }
            if (this.vefDebugOutput === undefined) { this.vefDebugOutput = null; }
            this.symmetry = symmetry;
            this.field = symmetry.getField();
            const oldMatrix: com.vzome.core.algebra.AlgebraicMatrix = new com.vzome.core.algebra.AlgebraicMatrix(worldTriangle);
            const X: com.vzome.core.algebra.AlgebraicVector = this.field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
            const Y: com.vzome.core.algebra.AlgebraicVector = this.field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y);
            const Z: com.vzome.core.algebra.AlgebraicVector = this.field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
            const viewTriangle: com.vzome.core.algebra.AlgebraicVector[] = [Z, X.plus(Z), Y.plus(Z)];
            const newMatrix: com.vzome.core.algebra.AlgebraicMatrix = new com.vzome.core.algebra.AlgebraicMatrix(viewTriangle);
            this.dotTransform = newMatrix.times(oldMatrix.inverse());
            const blueVertex: com.vzome.core.algebra.AlgebraicVector = worldTriangle[0];
            const redVertex: com.vzome.core.algebra.AlgebraicVector = worldTriangle[1];
            const yellowVertex: com.vzome.core.algebra.AlgebraicVector = worldTriangle[2];
            this.orbitProbe = redVertex.plus(yellowVertex.plus(blueVertex)).toRealVector();
            this.worldTrianglePoint = blueVertex;
            this.worldTriangleNormal = com.vzome.core.algebra.AlgebraicVectors.getNormal$java_util_Collection(java.util.Arrays.asList<any>(worldTriangle));
            if (this.debugger != null){
                this.debugger.exportSegment(this.field.origin(3), redVertex);
                this.debugger.exportPoint(redVertex);
                this.debugger.exportSegment(this.field.origin(3), yellowVertex);
                this.debugger.exportPoint(yellowVertex);
                this.debugger.exportSegment(this.field.origin(3), blueVertex);
                this.debugger.exportPoint(blueVertex);
                this.debugger.exportPolygon(java.util.Arrays.asList<any>(worldTriangle));
                this.debugger.exportPolygon(java.util.Arrays.asList<any>(viewTriangle));
                this.debugger.exportSegment(blueVertex, this.worldTriangleNormal);
            }
        }

        public enableDebugger() {
            this.vefDebugOutput = new java.io.StringWriter();
            this.debugger = new com.vzome.core.algebra.VefVectorExporter(this.vefDebugOutput, this.field);
        }

        public locateOrbitDot(orbit: com.vzome.core.math.symmetry.Direction) {
            const dotZone: com.vzome.core.algebra.AlgebraicVector = this.symmetry['getAxis$com_vzome_core_math_RealVector$java_util_Collection'](this.orbitProbe, java.util.Collections.singleton<any>(orbit)).normal();
            const lineStart: com.vzome.core.algebra.AlgebraicVector = this.field.origin(3);
            const worldDot: com.vzome.core.algebra.AlgebraicVector = com.vzome.core.algebra.AlgebraicVectors.getLinePlaneIntersection(lineStart, dotZone, this.worldTrianglePoint, this.worldTriangleNormal);
            const viewDot: com.vzome.core.algebra.AlgebraicVector = this.dotTransform.timesColumn(worldDot);
            const dotX: number = viewDot.getComponent(com.vzome.core.algebra.AlgebraicVector.X).evaluate();
            const dotY: number = viewDot.getComponent(com.vzome.core.algebra.AlgebraicVector.Y).evaluate();
            orbit.setDotLocation(dotX, dotY);
            if (this.debugger != null){
                this.debugger.exportSegment(this.field.origin(3), dotZone);
                this.debugger.exportPoint(worldDot);
                this.debugger.exportPoint(viewDot);
            }
        }

        public getDebuggerOutput(): string {
            this.debugger.finishExport();
            this.debugger = null;
            return this.vefDebugOutput.toString();
        }
    }
    OrbitDotLocator["__class"] = "com.vzome.core.math.symmetry.OrbitDotLocator";

}
namespace com.vzome.core.math.symmetry {
    /**
     * Should be called Zone, an infinite family of parallel lines, one member of an orbit (Direction)
     * of a Symmetry group.
     * @class
     */
    export class Axis {
        /*private*/ mDirection: com.vzome.core.math.symmetry.Direction;

        /*private*/ orientation: number;

        public static PLUS: number = 0;

        public static MINUS: number = 1;

        /*private*/ mSense: number;

        /**
         * Only false for orbits when Symmetry.getPrincipalReflection() != null,
         * and then for only half of the axes.  See HeptagonalAntiprismSymmetry.
         * For such groups, mSense==MINUS does not imply an inverted normal
         * relative to mSense==PLUS, but probably a specific reflection.
         * Each zone is oriented, and the inbound and outbound axes DO have opposite normals.
         * 
         * Typical group, where getPrincipalReflection() == null:
         * 
         * sense    outbound        normal
         * --------+------------+------------------
         * PLUS  |   true     +    (+x, +y, +z)
         * --------+------------+------------------
         * MINUS  |   true     +    (-x, -y, -z)
         * --------+------------+------------------
         * PLUS  |   false    +    (-x, -y, -z)   // no Axis created, just aliased
         * --------+------------+------------------
         * MINUS  |   false    +    (+x, +y, +z)   // no Axis created, just aliased
         * 
         * Odd prismatic group, where getPrincipalReflection() != null:
         * 
         * sense    outbound        normal
         * --------+------------+------------------
         * PLUS  |   true     +    (+x, +y, +z)
         * --------+------------+------------------
         * MINUS  |   true     +    (+x, +y, -z)   // PLUS outbound reflected in XY plane (for example)
         * --------+------------+------------------
         * PLUS  |   false    +    (-x, -y, -z)   // PLUS outbound reflected through origin
         * --------+------------+------------------
         * MINUS  |   false    +    (-x, -y, +z)
         */
        /*private*/ outbound: boolean;

        /*private*/ mRotationPerm: com.vzome.core.math.symmetry.Permutation;

        /*private*/ mRotation: number;

        /*private*/ __normal: com.vzome.core.algebra.AlgebraicVector;

        public constructor(dir?: any, index?: any, sense?: any, rotation?: any, rotPerm?: any, normal?: any, outbound?: any) {
            if (((dir != null && dir instanceof <any>com.vzome.core.math.symmetry.Direction) || dir === null) && ((typeof index === 'number') || index === null) && ((typeof sense === 'number') || sense === null) && ((typeof rotation === 'number') || rotation === null) && ((rotPerm != null && rotPerm instanceof <any>com.vzome.core.math.symmetry.Permutation) || rotPerm === null) && ((normal != null && normal instanceof <any>com.vzome.core.algebra.AlgebraicVector) || normal === null) && ((typeof outbound === 'boolean') || outbound === null)) {
                let __args = arguments;
                if (this.mDirection === undefined) { this.mDirection = null; } 
                if (this.orientation === undefined) { this.orientation = 0; } 
                if (this.mSense === undefined) { this.mSense = 0; } 
                if (this.mRotationPerm === undefined) { this.mRotationPerm = null; } 
                if (this.mRotation === undefined) { this.mRotation = 0; } 
                if (this.__normal === undefined) { this.__normal = null; } 
                this.outbound = true;
                this.mDirection = dir;
                this.mRotation = rotation;
                this.mRotationPerm = rotPerm;
                this.orientation = index;
                this.__normal = normal;
                this.mSense = sense;
                this.outbound = outbound;
            } else if (((dir != null && dir instanceof <any>com.vzome.core.math.symmetry.Direction) || dir === null) && ((typeof index === 'number') || index === null) && ((typeof sense === 'number') || sense === null) && ((typeof rotation === 'number') || rotation === null) && ((rotPerm != null && rotPerm instanceof <any>com.vzome.core.math.symmetry.Permutation) || rotPerm === null) && ((normal != null && normal instanceof <any>com.vzome.core.algebra.AlgebraicVector) || normal === null) && outbound === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let outbound: any = true;
                    if (this.mDirection === undefined) { this.mDirection = null; } 
                    if (this.orientation === undefined) { this.orientation = 0; } 
                    if (this.mSense === undefined) { this.mSense = 0; } 
                    if (this.mRotationPerm === undefined) { this.mRotationPerm = null; } 
                    if (this.mRotation === undefined) { this.mRotation = 0; } 
                    if (this.__normal === undefined) { this.__normal = null; } 
                    this.outbound = true;
                    this.mDirection = dir;
                    this.mRotation = rotation;
                    this.mRotationPerm = rotPerm;
                    this.orientation = index;
                    this.__normal = normal;
                    this.mSense = sense;
                    this.outbound = outbound;
                }
            } else throw new Error('invalid overload');
        }

        /**
         * Return the normal vector for this axis.
         * Note that this vector may not have length=1.0, but it will have length
         * equal to one "unit" for this axis.
         * @return {com.vzome.core.algebra.AlgebraicVector} AlgebraicVector
         */
        public normal(): com.vzome.core.algebra.AlgebraicVector {
            return this.__normal;
        }

        public isOutbound(): boolean {
            return this.outbound;
        }

        public getLength(vector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicNumber {
            return vector.getLength(this.__normal);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode(): number {
            const prime: number = 31;
            let result: number = 1;
            result = prime * result + ((this.mDirection == null) ? 0 : /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})(this.mDirection)));
            result = prime * result + this.mSense;
            result = prime * result + ((this.__normal == null) ? 0 : /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})(this.__normal)));
            return result;
        }

        /**
         * 
         * @param {*} obj
         * @return {boolean}
         */
        public equals(obj: any): boolean {
            if (this === obj)return true;
            if (obj == null)return false;
            if ((<any>this.constructor) !== (<any>obj.constructor))return false;
            const other: Axis = <Axis>obj;
            if (this.mDirection == null){
                if (other.mDirection != null)return false;
            } else if (!this.mDirection.equals(other.mDirection))return false;
            if (this.mSense !== other.mSense)return false;
            if (this.__normal == null){
                if (other.__normal != null)return false;
            } else if (!this.__normal.equals(other.__normal))return false;
            return true;
        }

        /**
         * 
         * @return {string}
         */
        public toString(): string {
            return this.mDirection.toString() + " " + ((this.mSense === com.vzome.core.math.symmetry.Symmetry.PLUS) ? "+" : "-") + this.orientation + (this.outbound ? "" : "i");
        }

        public getOrbit(): com.vzome.core.math.symmetry.Direction {
            return this.mDirection;
        }

        public getDirection(): com.vzome.core.math.symmetry.Direction {
            return this.mDirection;
        }

        public getOrientation(): number {
            return this.orientation;
        }

        public getRotation(): number {
            return this.mRotation;
        }

        public getCorrectRotation(): number {
            return (this.mRotationPerm == null) ? com.vzome.core.math.symmetry.Symmetry.NO_ROTATION : this.mRotationPerm.mapIndex(0);
        }

        public getRotationPermutation(): com.vzome.core.math.symmetry.Permutation {
            return this.mRotationPerm;
        }

        public getSense(): number {
            return this.mSense;
        }

        /**
         * @param plus
         * @param {number} orientation2
         * @param {boolean} outbound
         * @param {number} sense
         */
        public rename(sense: number, orientation2: number, outbound: boolean) {
            this.mSense = sense;
            this.orientation = orientation2;
            this.outbound = outbound;
        }

        public getXML(elem: org.w3c.dom.Element) {
            com.vzome.xml.DomUtils.addAttribute(elem, "symm", this.mDirection.getSymmetry().getName());
            com.vzome.xml.DomUtils.addAttribute(elem, "dir", this.mDirection.getName());
            com.vzome.xml.DomUtils.addAttribute(elem, "orbit", this.mDirection.getCanonicalName());
            com.vzome.xml.DomUtils.addAttribute(elem, "index", /* toString */(''+(this.orientation)));
            if (this.mSense !== com.vzome.core.math.symmetry.Symmetry.PLUS)com.vzome.xml.DomUtils.addAttribute(elem, "sense", "minus");
        }
    }
    Axis["__class"] = "com.vzome.core.math.symmetry.Axis";

}
namespace com.vzome.core.math.symmetry {
    export interface CoxeterGroup {
        getOrder(): number;

        getField(): com.vzome.core.algebra.AlgebraicField;

        groupAction(model: com.vzome.core.algebra.AlgebraicVector, element: number): com.vzome.core.algebra.AlgebraicVector;

        getOrigin(): com.vzome.core.algebra.AlgebraicVector;

        getWeight(i: number): com.vzome.core.algebra.AlgebraicVector;

        getSimpleRoot(i: number): com.vzome.core.algebra.AlgebraicVector;

        chiralSubgroupAction(model: com.vzome.core.algebra.AlgebraicVector, i: number): com.vzome.core.algebra.AlgebraicVector;
    }
}
namespace com.vzome.core.math.symmetry {
    export interface Symmetries4D {
        constructPolytope(groupName: string, index: number, edgesToRender: number, edgeScales: com.vzome.core.algebra.AlgebraicNumber[], listener: com.vzome.core.math.symmetry.WythoffConstruction.Listener);

        getQuaternionSymmetry(name: string): com.vzome.core.math.symmetry.QuaternionicSymmetry;
    }
}
namespace com.vzome.core.math.symmetry {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.math.symmetry.Direction} dir
     * @param {string} name
     * @class
     */
    export class DirectionNaming {
        static SIGN: string[]; public static SIGN_$LI$(): string[] { if (DirectionNaming.SIGN == null) { DirectionNaming.SIGN = ["+", "-"]; }  return DirectionNaming.SIGN; }

        /*private*/ mName: string;

        /*private*/ mDirection: com.vzome.core.math.symmetry.Direction;

        public constructor(dir: com.vzome.core.math.symmetry.Direction, name: string) {
            if (this.mName === undefined) { this.mName = null; }
            if (this.mDirection === undefined) { this.mDirection = null; }
            this.mName = name;
            this.mDirection = dir;
        }

        public getName$(): string {
            return this.mName;
        }

        /**
         * Default behavior.
         * @param {string} axisName
         * @return
         * @return {com.vzome.core.math.symmetry.Axis}
         */
        public getAxis(axisName: string): com.vzome.core.math.symmetry.Axis {
            return this.mDirection.getAxis$int$int(this.getSign(axisName), this.getInteger(axisName));
        }

        getSign(axisName: string): number {
            if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(axisName, "-"))return com.vzome.core.math.symmetry.Symmetry.MINUS;
            return com.vzome.core.math.symmetry.Symmetry.PLUS;
        }

        getInteger(axisName: string): number {
            if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(axisName, "-") || /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(axisName, "+"))return javaemul.internal.IntegerHelper.parseInt(axisName.substring(1));
            return javaemul.internal.IntegerHelper.parseInt(axisName);
        }

        public getName$com_vzome_core_math_symmetry_Axis(axis: com.vzome.core.math.symmetry.Axis): string {
            const sign: string = DirectionNaming.SIGN_$LI$()[axis.getSense()];
            return sign + axis.getOrientation();
        }

        public getName(axis?: any): string {
            if (((axis != null && axis instanceof <any>com.vzome.core.math.symmetry.Axis) || axis === null)) {
                return <any>this.getName$com_vzome_core_math_symmetry_Axis(axis);
            } else if (axis === undefined) {
                return <any>this.getName$();
            } else throw new Error('invalid overload');
        }

        public getFullName(axis: com.vzome.core.math.symmetry.Axis): string {
            return this.mName + " " + this.getName$com_vzome_core_math_symmetry_Axis(axis);
        }

        public getDirection(): com.vzome.core.math.symmetry.Direction {
            return this.mDirection;
        }
    }
    DirectionNaming["__class"] = "com.vzome.core.math.symmetry.DirectionNaming";

}
namespace com.vzome.core.math.symmetry {
    /**
     * @author Scott Vorthmann
     * @class
     */
    export abstract class AbstractSymmetry implements com.vzome.core.math.symmetry.Symmetry {
        mDirectionMap: java.util.Map<string, com.vzome.core.math.symmetry.Direction>;

        mDirectionList: java.util.List<com.vzome.core.math.symmetry.Direction>;

        orbitSet: com.vzome.core.math.symmetry.OrbitSet;

        mOrientations: com.vzome.core.math.symmetry.Permutation[];

        mMatrices: com.vzome.core.algebra.AlgebraicMatrix[];

        mField: com.vzome.core.algebra.AlgebraicField;

        /*private*/ principalReflection: com.vzome.core.algebra.AlgebraicMatrix;

        /*private*/ dotLocator: com.vzome.core.math.symmetry.OrbitDotLocator;

        constructor(order: number, field: com.vzome.core.algebra.AlgebraicField, frameColor: string, principalReflection: com.vzome.core.algebra.AlgebraicMatrix) {
            this.mDirectionMap = <any>(new java.util.HashMap<any, any>());
            this.mDirectionList = <any>(new java.util.ArrayList<any>());
            this.orbitSet = new com.vzome.core.math.symmetry.OrbitSet(this);
            if (this.mOrientations === undefined) { this.mOrientations = null; }
            if (this.mMatrices === undefined) { this.mMatrices = null; }
            if (this.mField === undefined) { this.mField = null; }
            this.principalReflection = null;
            if (this.dotLocator === undefined) { this.dotLocator = null; }
            this.mField = field;
            this.principalReflection = principalReflection;
            this.mOrientations = (s => { let a=[]; while(s-->0) a.push(null); return a; })(order);
            this.mMatrices = (s => { let a=[]; while(s-->0) a.push(null); return a; })(order);
            this.createInitialPermutations();
            let done: boolean = false;
            while((!done)) {{
                done = true;
                for(let i: number = 1; i < order; i++) {{
                    const p1: com.vzome.core.math.symmetry.Permutation = this.mOrientations[i];
                    if (p1 == null){
                        done = false;
                        continue;
                    }
                    done = true;
                    for(let j: number = 1; j < order; j++) {{
                        const p2: com.vzome.core.math.symmetry.Permutation = this.mOrientations[j];
                        if (p2 == null){
                            done = false;
                            continue;
                        }
                        const result: number = p1.mapIndex(p2.mapIndex(0));
                        if (this.mOrientations[result] != null)continue;
                        const map: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(order);
                        for(let k: number = 0; k < order; k++) {map[k] = p1.mapIndex(p2.mapIndex(k));}
                        this.mOrientations[result] = new com.vzome.core.math.symmetry.Permutation(this, map);
                    };}
                    if (done)break;
                };}
            }};
            this.createFrameOrbit(frameColor);
            this.createOtherOrbits();
        }

        abstract createFrameOrbit(frameColor: string);

        abstract createOtherOrbits();

        abstract createInitialPermutations();

        /**
         * 
         * @return {*}
         */
        public getField(): com.vzome.core.algebra.AlgebraicField {
            return this.mField;
        }

        /**
         * 
         * @return {com.vzome.core.math.symmetry.Axis}
         */
        public getPreferredAxis(): com.vzome.core.math.symmetry.Axis {
            return null;
        }

        public createZoneOrbit$java_lang_String$int$int$int_A_A(name: string, prototype: number, rotatedPrototype: number, norm: number[][]): com.vzome.core.math.symmetry.Direction {
            const aNorm: com.vzome.core.algebra.AlgebraicVector = this.mField.createVector(norm);
            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(name, prototype, rotatedPrototype, aNorm, false);
        }

        public createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector(name: string, prototype: number, rotatedPrototype: number, norm: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.math.symmetry.Direction {
            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(name, prototype, rotatedPrototype, norm, false);
        }

        public createZoneOrbit$java_lang_String$int$int$int_A_A$boolean(name: string, prototype: number, rotatedPrototype: number, norm: number[][], standard: boolean): com.vzome.core.math.symmetry.Direction {
            const aNorm: com.vzome.core.algebra.AlgebraicVector = this.mField.createVector(norm);
            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean(name, prototype, rotatedPrototype, aNorm, standard, false);
        }

        public createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(name: string, prototype: number, rotatedPrototype: number, norm: com.vzome.core.algebra.AlgebraicVector, standard: boolean): com.vzome.core.math.symmetry.Direction {
            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean(name, prototype, rotatedPrototype, norm, standard, false);
        }

        createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean(name: string, prototype: number, rotatedPrototype: number, norm: number[][], standard: boolean, halfSizes: boolean): com.vzome.core.math.symmetry.Direction {
            const aNorm: com.vzome.core.algebra.AlgebraicVector = this.mField.createVector(norm);
            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, aNorm, standard, false, null);
        }

        createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean(name: string, prototype: number, rotatedPrototype: number, norm: com.vzome.core.algebra.AlgebraicVector, standard: boolean, halfSizes: boolean): com.vzome.core.math.symmetry.Direction {
            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, norm, standard, false, this.mField.one());
        }

        public createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name: string, prototype: number, rotatedPrototype: number, norm: number[][], standard: boolean, halfSizes: boolean, unitLength: com.vzome.core.algebra.AlgebraicNumber): com.vzome.core.math.symmetry.Direction {
            const aNorm: com.vzome.core.algebra.AlgebraicVector = this.mField.createVector(norm);
            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, aNorm, standard, halfSizes, unitLength);
        }

        public createZoneOrbit(name?: any, prototype?: any, rotatedPrototype?: any, norm?: any, standard?: any, halfSizes?: any, unitLength?: any): com.vzome.core.math.symmetry.Direction {
            if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof <any>Array && (norm.length == 0 || norm[0] == null ||norm[0] instanceof Array)) || norm === null) && ((typeof standard === 'boolean') || standard === null) && ((typeof halfSizes === 'boolean') || halfSizes === null) && ((unitLength != null && (unitLength.constructor != null && unitLength.constructor["__interfaces"] != null && unitLength.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || unitLength === null)) {
                return <any>this.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, norm, standard, halfSizes, unitLength);
            } else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof <any>com.vzome.core.algebra.AlgebraicVector) || norm === null) && ((typeof standard === 'boolean') || standard === null) && ((typeof halfSizes === 'boolean') || halfSizes === null) && ((unitLength != null && (unitLength.constructor != null && unitLength.constructor["__interfaces"] != null && unitLength.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || unitLength === null)) {
                return <any>this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, norm, standard, halfSizes, unitLength);
            } else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof <any>Array && (norm.length == 0 || norm[0] == null ||norm[0] instanceof Array)) || norm === null) && ((typeof standard === 'boolean') || standard === null) && ((typeof halfSizes === 'boolean') || halfSizes === null) && unitLength === undefined) {
                return <any>this.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean(name, prototype, rotatedPrototype, norm, standard, halfSizes);
            } else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof <any>com.vzome.core.algebra.AlgebraicVector) || norm === null) && ((typeof standard === 'boolean') || standard === null) && ((typeof halfSizes === 'boolean') || halfSizes === null) && unitLength === undefined) {
                return <any>this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean(name, prototype, rotatedPrototype, norm, standard, halfSizes);
            } else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof <any>Array && (norm.length == 0 || norm[0] == null ||norm[0] instanceof Array)) || norm === null) && ((typeof standard === 'boolean') || standard === null) && halfSizes === undefined && unitLength === undefined) {
                return <any>this.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean(name, prototype, rotatedPrototype, norm, standard);
            } else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof <any>com.vzome.core.algebra.AlgebraicVector) || norm === null) && ((typeof standard === 'boolean') || standard === null) && halfSizes === undefined && unitLength === undefined) {
                return <any>this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(name, prototype, rotatedPrototype, norm, standard);
            } else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof <any>Array && (norm.length == 0 || norm[0] == null ||norm[0] instanceof Array)) || norm === null) && standard === undefined && halfSizes === undefined && unitLength === undefined) {
                return <any>this.createZoneOrbit$java_lang_String$int$int$int_A_A(name, prototype, rotatedPrototype, norm);
            } else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof <any>com.vzome.core.algebra.AlgebraicVector) || norm === null) && standard === undefined && halfSizes === undefined && unitLength === undefined) {
                return <any>this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector(name, prototype, rotatedPrototype, norm);
            } else throw new Error('invalid overload');
        }

        public createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name: string, prototype: number, rotatedPrototype: number, norm: com.vzome.core.algebra.AlgebraicVector, standard: boolean, halfSizes: boolean, unitLength: com.vzome.core.algebra.AlgebraicNumber): com.vzome.core.math.symmetry.Direction {
            const existingDir: com.vzome.core.math.symmetry.Direction = this.mDirectionMap.get(name);
            if (existingDir != null){
                this.mDirectionMap.remove(name);
                this.orbitSet.remove(existingDir);
                this.mDirectionList.remove(existingDir);
            }
            const orbit: com.vzome.core.math.symmetry.Direction = new com.vzome.core.math.symmetry.Direction(name, this, prototype, rotatedPrototype, norm, standard);
            if (halfSizes)orbit.setHalfSizes(true);
            orbit.setUnitLength(unitLength);
            this.mDirectionMap.put(orbit.getName(), orbit);
            this.mDirectionList.add(orbit);
            this.orbitSet.add(orbit);
            if (this.dotLocator != null)this.dotLocator.locateOrbitDot(orbit);
            return orbit;
        }

        /**
         * 
         * @param {string} name
         * @param {number} prototype
         * @param {number} rotatedPrototype
         * @param {com.vzome.core.algebra.AlgebraicVector} norm
         * @return {com.vzome.core.math.symmetry.Direction}
         */
        public createNewZoneOrbit(name: string, prototype: number, rotatedPrototype: number, norm: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.math.symmetry.Direction {
            const orbit: com.vzome.core.math.symmetry.Direction = new com.vzome.core.math.symmetry.Direction(name, this, prototype, rotatedPrototype, norm, false).withCorrection();
            if (this.dotLocator == null)this.dotLocator = new com.vzome.core.math.symmetry.OrbitDotLocator(this, this.getOrbitTriangle());
            this.dotLocator.locateOrbitDot(orbit);
            return orbit;
        }

        /**
         * 
         * @return {com.vzome.core.math.symmetry.OrbitSet}
         */
        public getOrbitSet(): com.vzome.core.math.symmetry.OrbitSet {
            return this.orbitSet;
        }

        /**
         * @param unit
         * @param rot
         * @return
         * @param {number} from
         * @param {number} to
         * @return {number}
         */
        public getMapping(from: number, to: number): number {
            if (to === com.vzome.core.math.symmetry.Symmetry.NO_ROTATION)return com.vzome.core.math.symmetry.Symmetry.NO_ROTATION;
            for(let p: number = 0; p < this.mOrientations.length; p++) {if (this.mOrientations[p].mapIndex(from) === to)return p;;}
            return com.vzome.core.math.symmetry.Symmetry.NO_ROTATION;
        }

        public mapAxis(from: com.vzome.core.math.symmetry.Axis, to: com.vzome.core.math.symmetry.Axis): com.vzome.core.math.symmetry.Permutation {
            return this.mapAxes([from], [to]);
        }

        public mapAxes(from: com.vzome.core.math.symmetry.Axis[], to: com.vzome.core.math.symmetry.Axis[]): com.vzome.core.math.symmetry.Permutation {
            if (from.length !== to.length)throw new AbstractSymmetry.MismatchedAxes("must map to equal number of axes");
            if (from.length > 3)throw new AbstractSymmetry.MismatchedAxes("must map three or fewer axes");
            for(let i: number = 0; i < from.length; i++) {if (from[i].getDirection().equals(to[i].getDirection()))throw new AbstractSymmetry.MismatchedAxes("must map between same color axes");;}
            const result: com.vzome.core.math.symmetry.Permutation[] = [null];
            return result[0];
        }

        /**
         * 
         * @return {*}
         */
        public getDirections(): java.lang.Iterable<com.vzome.core.math.symmetry.Direction> {
            return this.mDirectionList;
        }

        public getAxis$com_vzome_core_algebra_AlgebraicVector(vector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.math.symmetry.Axis {
            return this.getAxis$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_math_symmetry_OrbitSet(vector, this.orbitSet);
        }

        public getAxis$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_math_symmetry_OrbitSet(vector: com.vzome.core.algebra.AlgebraicVector, orbits: com.vzome.core.math.symmetry.OrbitSet): com.vzome.core.math.symmetry.Axis {
            if (vector.isOrigin()){
                return null;
            }
            const canonicalOrbit: com.vzome.core.math.symmetry.Direction = this.getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.BLACK);
            if (canonicalOrbit == null)for(let index=orbits.getDirections().iterator();index.hasNext();) {
                let dir = index.next();
                {
                    const candidate: com.vzome.core.math.symmetry.Axis = dir.getAxis$com_vzome_core_algebra_AlgebraicVector(vector);
                    if (candidate != null){
                        return candidate;
                    }
                }
            } else {
                const zone: com.vzome.core.math.symmetry.Axis = canonicalOrbit.getAxis$com_vzome_core_math_RealVector(vector.toRealVector());
                const orientation: number = zone.getOrientation();
                const sense: number = zone.getSense();
                for(let index=orbits.getDirections().iterator();index.hasNext();) {
                    let orbit = index.next();
                    {
                        const candidate: com.vzome.core.math.symmetry.Axis = orbit.getCanonicalAxis(sense, orientation);
                        if (com.vzome.core.algebra.AlgebraicVectors.areParallel(candidate.normal(), vector)){
                            return candidate;
                        }
                    }
                }
            }
            return null;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} vector
         * @param {com.vzome.core.math.symmetry.OrbitSet} orbits
         * @return {com.vzome.core.math.symmetry.Axis}
         */
        public getAxis(vector?: any, orbits?: any): com.vzome.core.math.symmetry.Axis {
            if (((vector != null && vector instanceof <any>com.vzome.core.algebra.AlgebraicVector) || vector === null) && ((orbits != null && orbits instanceof <any>com.vzome.core.math.symmetry.OrbitSet) || orbits === null)) {
                return <any>this.getAxis$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_math_symmetry_OrbitSet(vector, orbits);
            } else if (((vector != null && vector instanceof <any>com.vzome.core.math.RealVector) || vector === null) && ((orbits != null && (orbits.constructor != null && orbits.constructor["__interfaces"] != null && orbits.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || orbits === null)) {
                return <any>this.getAxis$com_vzome_core_math_RealVector$java_util_Collection(vector, orbits);
            } else if (((vector != null && vector instanceof <any>com.vzome.core.algebra.AlgebraicVector) || vector === null) && orbits === undefined) {
                return <any>this.getAxis$com_vzome_core_algebra_AlgebraicVector(vector);
            } else throw new Error('invalid overload');
        }

        public getAxis$com_vzome_core_math_RealVector$java_util_Collection(vector: com.vzome.core.math.RealVector, dirMask: java.util.Collection<com.vzome.core.math.symmetry.Direction>): com.vzome.core.math.symmetry.Axis {
            if (com.vzome.core.math.RealVector.ORIGIN_$LI$().equals(vector)){
                return null;
            }
            let maxCosine: number = -1.0;
            let closest: com.vzome.core.math.symmetry.Axis = null;
            let orientation: number = -1;
            let sense: number = -1;
            const chiralOrbit: com.vzome.core.math.symmetry.Direction = this.getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.BLACK);
            if (chiralOrbit != null){
                const closestChiralAxis: com.vzome.core.math.symmetry.Axis = chiralOrbit.getChiralAxis(vector);
                orientation = closestChiralAxis.getOrientation();
                sense = closestChiralAxis.getSense();
            }
            const dirs: java.lang.Iterable<com.vzome.core.math.symmetry.Direction> = dirMask == null ? this.orbitSet.getDirections() : dirMask;
            for(let index=dirs.iterator();index.hasNext();) {
                let dir = index.next();
                {
                    const axis: com.vzome.core.math.symmetry.Axis = (orientation >= 0) ? dir.getCanonicalAxis(sense, orientation) : dir.getAxisBruteForce(vector);
                    const axisV: com.vzome.core.math.RealVector = axis.normal().toRealVector();
                    const cosine: number = vector.dot(axisV) / (vector.length() * axisV.length());
                    if (cosine > maxCosine){
                        maxCosine = cosine;
                        closest = axis;
                    }
                }
            }
            return closest;
        }

        /**
         * 
         * @return {number}
         */
        public getChiralOrder(): number {
            return this.mOrientations.length;
        }

        /**
         * 
         * @param {number} i
         * @return {com.vzome.core.math.symmetry.Permutation}
         */
        public getPermutation(i: number): com.vzome.core.math.symmetry.Permutation {
            if ((i < 0) || (i > this.mOrientations.length))return null;
            return this.mOrientations[i];
        }

        public getPermutations(): com.vzome.core.math.symmetry.Permutation[] {
            return this.mOrientations;
        }

        /**
         * 
         * @param {number} i
         * @return {com.vzome.core.algebra.AlgebraicMatrix}
         */
        public getMatrix(i: number): com.vzome.core.algebra.AlgebraicMatrix {
            return this.mMatrices[i];
        }

        public getMatrices(): com.vzome.core.algebra.AlgebraicMatrix[] {
            return this.mMatrices;
        }

        /**
         * 
         * @param {number} orientation
         * @return {number}
         */
        public inverse(orientation: number): number {
            if ((orientation < 0) || (orientation > this.mOrientations.length))return com.vzome.core.math.symmetry.Symmetry.NO_ROTATION;
            return this.mOrientations[orientation].inverse().mapIndex(0);
        }

        /**
         * 
         * @param {string} color
         * @return {com.vzome.core.math.symmetry.Direction}
         */
        public getDirection(color: string): com.vzome.core.math.symmetry.Direction {
            return this.mDirectionMap.get(color);
        }

        /**
         * 
         * @return {java.lang.String[]}
         */
        public getDirectionNames(): string[] {
            const list: java.util.ArrayList<string> = <any>(new java.util.ArrayList<any>());
            for(let index=this.mDirectionList.iterator();index.hasNext();) {
                let dir = index.next();
                {
                    if (!dir.isAutomatic())list.add(dir.getName());
                }
            }
            return list.toArray<any>([]);
        }

        /**
         * 
         * @param {int[]} perms
         * @return {int[]}
         */
        public closure(perms: number[]): number[] {
            const newPerms: java.util.List<com.vzome.core.math.symmetry.Permutation> = <any>(new java.util.ArrayList<any>());
            const knownPerms: com.vzome.core.math.symmetry.Permutation[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.mOrientations.length);
            let closureSize: number = 0;
            for(let i: number = 0; i < perms.length; i++) {{
                const perm: com.vzome.core.math.symmetry.Permutation = this.mOrientations[perms[i]];
                knownPerms[perms[i]] = perm;
                newPerms.add(perm);
                ++closureSize;
            };}
            while((!newPerms.isEmpty())) {{
                const perm: com.vzome.core.math.symmetry.Permutation = newPerms.remove(0);
                for(let index = 0; index < knownPerms.length; index++) {
                    let knownPerm = knownPerms[index];
                    {
                        if (knownPerm != null){
                            let composition: com.vzome.core.math.symmetry.Permutation = perm.compose(knownPerm);
                            let j: number = composition.mapIndex(0);
                            if (knownPerms[j] == null){
                                newPerms.add(composition);
                                knownPerms[j] = composition;
                                ++closureSize;
                            }
                            composition = knownPerm.compose(perm);
                            j = composition.mapIndex(0);
                            if (knownPerms[j] == null){
                                newPerms.add(composition);
                                knownPerms[j] = composition;
                                ++closureSize;
                            }
                        }
                    }
                }
            }};
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(closureSize);
            let j: number = 0;
            for(let i: number = 0; i < knownPerms.length; i++) {{
                if (knownPerms[i] != null){
                    result[j++] = i;
                }
            };}
            return result;
        }

        /**
         * 
         * @param {number} orientation
         * @return {int[]}
         */
        public getIncidentOrientations(orientation: number): number[] {
            return null;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} v
         * @return {com.vzome.core.math.RealVector}
         */
        public embedInR3(v: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.math.RealVector {
            return v.toRealVector();
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} v
         * @return {double[]}
         */
        public embedInR3Double(v: com.vzome.core.algebra.AlgebraicVector): number[] {
            return v.to3dDoubleVector();
        }

        /**
         * 
         * @return {boolean}
         */
        public isTrivial(): boolean {
            return true;
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicMatrix}
         */
        public getPrincipalReflection(): com.vzome.core.algebra.AlgebraicMatrix {
            return this.principalReflection;
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector[]}
         */
        public getOrbitTriangle(): com.vzome.core.algebra.AlgebraicVector[] {
            const blueVertex: com.vzome.core.algebra.AlgebraicVector = this.getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.BLUE).getPrototype();
            const redVertex: com.vzome.core.algebra.AlgebraicVector = this.getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.RED).getPrototype();
            const yellowVertex: com.vzome.core.algebra.AlgebraicVector = this.getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.YELLOW).getPrototype();
            return [blueVertex, redVertex, yellowVertex];
        }

        /**
         * 
         * @return {string}
         */
        public computeOrbitDots(): string {
            if (this.dotLocator == null)this.dotLocator = new com.vzome.core.math.symmetry.OrbitDotLocator(this, this.getOrbitTriangle());
            for(let index=this.mDirectionList.iterator();index.hasNext();) {
                let orbit = index.next();
                {
                    this.dotLocator.locateOrbitDot(orbit);
                }
            }
            return null;
        }

        /**
         * 
         * @return {boolean}
         */
        public reverseOrbitTriangle(): boolean {
            return false;
        }

        public abstract getName(): any;
        public abstract getSpecialOrbit(which?: any): any;
        public abstract subgroup(name?: any): any;    }
    AbstractSymmetry["__class"] = "com.vzome.core.math.symmetry.AbstractSymmetry";
    AbstractSymmetry["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry","com.vzome.core.math.symmetry.Embedding"];



    export namespace AbstractSymmetry {

        export class MismatchedAxes extends java.lang.RuntimeException {
            static serialVersionUID: number = 2610579323321804987;

            public constructor(message: string) {
                super(message);
                (<any>Object).setPrototypeOf(this, MismatchedAxes.prototype);
            }
        }
        MismatchedAxes["__class"] = "com.vzome.core.math.symmetry.AbstractSymmetry.MismatchedAxes";
        MismatchedAxes["__interfaces"] = ["java.io.Serializable"];


    }

}
namespace com.vzome.core.math.symmetry {
    export interface Embedding {
        embedInR3(v: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.math.RealVector;

        embedInR3Double(v: com.vzome.core.algebra.AlgebraicVector): number[];

        isTrivial(): boolean;
    }

    export namespace Embedding {

        export class Trivial implements com.vzome.core.math.symmetry.Embedding {
            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} v
             * @return {com.vzome.core.math.RealVector}
             */
            public embedInR3(v: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.math.RealVector {
                return v.toRealVector();
            }

            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} v
             * @return {double[]}
             */
            public embedInR3Double(v: com.vzome.core.algebra.AlgebraicVector): number[] {
                return v.to3dDoubleVector();
            }

            /**
             * 
             * @return {boolean}
             */
            public isTrivial(): boolean {
                return true;
            }

            constructor() {
            }
        }
        Trivial["__class"] = "com.vzome.core.math.symmetry.Embedding.Trivial";
        Trivial["__interfaces"] = ["com.vzome.core.math.symmetry.Embedding"];


    }

}
namespace com.vzome.core.math.symmetry {
    export class OrbitSet {
        /*private*/ contents: java.util.Map<string, com.vzome.core.math.symmetry.Direction>;

        /*private*/ symmetry: com.vzome.core.math.symmetry.Symmetry;

        /*private*/ lastAdded: com.vzome.core.math.symmetry.Direction;

        public constructor(symmetry: com.vzome.core.math.symmetry.Symmetry) {
            this.contents = <any>(new java.util.HashMap<any, any>());
            if (this.symmetry === undefined) { this.symmetry = null; }
            this.lastAdded = null;
            this.symmetry = symmetry;
        }

        public getSymmetry(): com.vzome.core.math.symmetry.Symmetry {
            return this.symmetry;
        }

        public getAxis(vector: com.vzome.core.math.RealVector): com.vzome.core.math.symmetry.Axis {
            return this.symmetry['getAxis$com_vzome_core_math_RealVector$java_util_Collection'](vector, this.contents.values());
        }

        public getDirection(name: string): com.vzome.core.math.symmetry.Direction {
            for(let index=this.getDirections().iterator();index.hasNext();) {
                let dir = index.next();
                {
                    if (dir.getCanonicalName() === name)return dir;
                    if (dir.getName() === name)return dir;
                }
            }
            return null;
        }

        public getDirections(): java.lang.Iterable<com.vzome.core.math.symmetry.Direction> {
            return this.contents.values();
        }

        public remove(orbit: com.vzome.core.math.symmetry.Direction): boolean {
            const key: string = orbit.toString();
            const hadOne: boolean = this.contents.containsKey(key);
            this.contents.remove(orbit.toString());
            return hadOne;
        }

        public add(orbit: com.vzome.core.math.symmetry.Direction): boolean {
            const key: string = orbit.toString();
            const hadOne: boolean = this.contents.containsKey(key);
            this.contents.put(orbit.toString(), orbit);
            if (!hadOne)this.lastAdded = orbit;
            return !hadOne;
        }

        public contains(orbit: com.vzome.core.math.symmetry.Direction): boolean {
            return this.contents.containsKey(orbit.toString());
        }

        public size(): number {
            return this.contents.size();
        }

        public clear() {
            this.contents.clear();
        }

        public addAll(orbits: OrbitSet) {
            this.contents.putAll(orbits.contents);
        }

        public retainAll(allOrbits: OrbitSet) {
            const badKeys: java.util.List<string> = <any>(new java.util.ArrayList<string>());
            for(let index=this.contents.keySet().iterator();index.hasNext();) {
                let key = index.next();
                {
                    if (!allOrbits.contents.containsKey(key))badKeys.add(key);
                }
            }
            for(let index=badKeys.iterator();index.hasNext();) {
                let key = index.next();
                {
                    this.contents.remove(key);
                }
            }
        }

        public isEmpty(): boolean {
            return this.contents.isEmpty();
        }

        public last(): com.vzome.core.math.symmetry.Direction {
            return this.lastAdded;
        }
    }
    OrbitSet["__class"] = "com.vzome.core.math.symmetry.OrbitSet";


    export namespace OrbitSet {

        export interface Field {
            getGroup(name: string): com.vzome.core.math.symmetry.OrbitSet;

            getQuaternionSet(name: string): com.vzome.core.math.symmetry.QuaternionicSymmetry;
        }

        export class OrbitComparator {
            public __parent: any;
            names: string[];

            /**
             * 
             * @param {com.vzome.core.math.symmetry.Direction} dir1
             * @param {com.vzome.core.math.symmetry.Direction} dir2
             * @return {number}
             */
            public compare(dir1: com.vzome.core.math.symmetry.Direction, dir2: com.vzome.core.math.symmetry.Direction): number {
                const name1: string = dir1.getName();
                const name2: string = dir2.getName();
                let i1: number = -1;
                let i2: number = -1;
                for(let i: number = 0; i < this.names.length; i++) {{
                    if (name1 === (this.names[i]))i1 = i; else if (name2 === (this.names[i]))i2 = i;
                };}
                return i2 - i1;
            }

            constructor(__parent: any) {
                this.__parent = __parent;
                this.names = this.__parent.getSymmetry().getDirectionNames();
            }
        }
        OrbitComparator["__class"] = "com.vzome.core.math.symmetry.OrbitSet.OrbitComparator";
        OrbitComparator["__interfaces"] = ["java.util.Comparator"];


    }

}
namespace com.vzome.core.math.symmetry {
    /**
     * @author Scott Vorthmann
     * @class
     */
    export class NamingConvention {
        public static UNKNOWN_AXIS: string = "UNKNOWN AXIS";

        /*private*/ mNamings: java.util.Map<string, com.vzome.core.math.symmetry.DirectionNaming>;

        public addDirectionNaming(naming: com.vzome.core.math.symmetry.DirectionNaming) {
            this.mNamings.put(naming.getName$(), naming);
        }

        public getAxis(color: string, name: string): com.vzome.core.math.symmetry.Axis {
            const naming: com.vzome.core.math.symmetry.DirectionNaming = this.mNamings.get(color);
            if (naming == null)return null;
            return naming.getAxis(name);
        }

        public getName(axis: com.vzome.core.math.symmetry.Axis): string {
            for(let index=this.mNamings.values().iterator();index.hasNext();) {
                let naming = index.next();
                {
                    if (naming.getDirection().equals(axis.getDirection()))return naming.getName$com_vzome_core_math_symmetry_Axis(axis);
                }
            }
            return NamingConvention.UNKNOWN_AXIS;
        }

        constructor() {
            this.mNamings = <any>(new java.util.HashMap<any, any>());
        }
    }
    NamingConvention["__class"] = "com.vzome.core.math.symmetry.NamingConvention";

}
namespace com.vzome.core.math.symmetry {
    /**
     * @author Scott Vorthmann
     * @class
     */
    export interface Symmetry extends com.vzome.core.math.symmetry.Embedding {
        getChiralOrder(): number;

        getName(): string;

        getAxis(vector?: any, orbits?: any): com.vzome.core.math.symmetry.Axis;

        getMapping(from: number, to: number): number;

        getPermutation(i: number): com.vzome.core.math.symmetry.Permutation;

        getMatrix(i: number): com.vzome.core.algebra.AlgebraicMatrix;

        inverse(orientation: number): number;

        getDirectionNames(): string[];

        getDirection(name: string): com.vzome.core.math.symmetry.Direction;

        getField(): com.vzome.core.algebra.AlgebraicField;

        getOrbitSet(): com.vzome.core.math.symmetry.OrbitSet;

        /**
         * Generate a subgroup, by taking the closure of some collection of Permutations
         * @param {int[]} perms an array of Permutations indices
         * @return {int[]} an array of Permutations indices
         */
        closure(perms: number[]): number[];

        subgroup(name: string): number[];

        createNewZoneOrbit(name: string, prototype: number, rotatedPrototype: number, vector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.math.symmetry.Direction;

        getIncidentOrientations(orientation: number): number[];

        getSpecialOrbit(which: com.vzome.core.math.symmetry.SpecialOrbit): com.vzome.core.math.symmetry.Direction;

        getPreferredAxis(): com.vzome.core.math.symmetry.Axis;

        /**
         * Get the transformation matrix that maps zone 7 to zone -7 (for example).
         * If null, the matrix is implicitly a central inversion, negating vectors.
         * @return {com.vzome.core.algebra.AlgebraicMatrix} {@link AlgebraicMatrix}
         */
        getPrincipalReflection(): com.vzome.core.algebra.AlgebraicMatrix;

        getOrbitTriangle(): com.vzome.core.algebra.AlgebraicVector[];

        /**
         * Compute the orbit triangle dots for all existing orbits,
         * and leave behind an OrbitDotLocator for new ones.
         * The result is just a VEF string, for debugging.
         * @return
         * @return {string}
         */
        computeOrbitDots(): string;

        reverseOrbitTriangle(): boolean;

        getDirections(): java.lang.Iterable<com.vzome.core.math.symmetry.Direction>;
    }

    export namespace Symmetry {

        export const PLUS: number = 0;

        export const MINUS: number = 1;

        export const NO_ROTATION: number = -1;

        export const TETRAHEDRAL: string = "tetrahedral";

        export const PYRITOHEDRAL: string = "pyritohedral";
    }

}
namespace com.vzome.core.math.symmetry {
    /**
     * A single orbit in a Symmetry group.
     * Consists of a collection of zones (Axis), each of which is an infinite family of parallel lines.
     * There is a prototype zone (Axis) which has index==0; ideally, that zone should
     * have normal vector =~ (1,e,e), for 0 < e << 1, but this is not true, historically.
     * 
     * The orbit is represented by a single "dot" on the fundamental region triangle, and typically
     * struts in the orbit are rendered with a shape and color unique from all other orbits.
     * 
     * @author Scott Vorthmann
     * @param {string} name
     * @param {*} group
     * @param {number} prototype
     * @param {number} rotatedPrototype
     * @param {com.vzome.core.algebra.AlgebraicVector} vector
     * @param {boolean} isStd
     * @class
     */
    export class Direction implements java.lang.Comparable<Direction>, java.lang.Iterable<com.vzome.core.math.symmetry.Axis> {
        /**
         * 
         * @return {number}
         */
        public hashCode(): number {
            const prime: number = 31;
            let result: number = 1;
            result = prime * result + this.index;
            result = prime * result + ((this.mPrototype == null) ? 0 : /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})(this.mPrototype)));
            result = prime * result + ((this.mSymmetryGroup == null) ? 0 : /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})(this.mSymmetryGroup)));
            return result;
        }

        /**
         * 
         * @param {*} obj
         * @return {boolean}
         */
        public equals(obj: any): boolean {
            if (this === obj){
                return true;
            }
            if (obj == null){
                return false;
            }
            if ((<any>this.constructor) !== (<any>obj.constructor)){
                return false;
            }
            const other: Direction = <Direction>obj;
            if (this.index !== other.index){
                return false;
            }
            if (this.mPrototype == null){
                if (other.mPrototype != null){
                    return false;
                }
            } else if (!this.mPrototype.equals(other.mPrototype)){
                return false;
            }
            if (this.mSymmetryGroup == null){
                if (other.mSymmetryGroup != null){
                    return false;
                }
            } else if (!/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(this.mSymmetryGroup,other.mSymmetryGroup))){
                return false;
            }
            return true;
        }

        /*private*/ mName: string;

        /*private*/ canonicalName: string;

        /*private*/ zoneNames: com.vzome.core.math.symmetry.Axis[][][];

        /*private*/ zoneVectors: java.util.Map<string, com.vzome.core.math.symmetry.Axis>;

        /*private*/ mSymmetryGroup: com.vzome.core.math.symmetry.Symmetry;

        /*private*/ mPrototype: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ mStandard: boolean;

        /*private*/ mAutomatic: boolean;

        /*private*/ __hasHalfSizes: boolean;

        /*private*/ scaleNames: string[];

        public scales: com.vzome.core.algebra.AlgebraicNumber[];

        /*private*/ unitLength: com.vzome.core.algebra.AlgebraicNumber;

        /*private*/ unitLengthReciprocal: com.vzome.core.algebra.AlgebraicNumber;

        /*private*/ dotX: number;

        /*private*/ dotY: number;

        static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (Direction.logger == null) { Direction.logger = java.util.logging.Logger.getLogger("com.vzome.core.math.symmetry.Orbit"); }  return Direction.logger; }

        public setAutomatic(auto: boolean) {
            this.mAutomatic = auto;
        }

        public isAutomatic(): boolean {
            return this.mAutomatic;
        }

        public isStandard(): boolean {
            return this.mStandard;
        }

        static globalIndex: number = 0;

        /*private*/ index: number;

        /*private*/ prototype: number;

        /*private*/ rotatedPrototype: number;

        public canonicalize: number;

        /*private*/ needsCanonicalization: boolean;

        public constructor(name: string, group: com.vzome.core.math.symmetry.Symmetry, prototype: number, rotatedPrototype: number, vector: com.vzome.core.algebra.AlgebraicVector, isStd: boolean) {
            if (this.mName === undefined) { this.mName = null; }
            if (this.canonicalName === undefined) { this.canonicalName = null; }
            if (this.zoneNames === undefined) { this.zoneNames = null; }
            this.zoneVectors = <any>(new java.util.HashMap<any, any>());
            if (this.mSymmetryGroup === undefined) { this.mSymmetryGroup = null; }
            if (this.mPrototype === undefined) { this.mPrototype = null; }
            if (this.mStandard === undefined) { this.mStandard = false; }
            if (this.mAutomatic === undefined) { this.mAutomatic = false; }
            if (this.__hasHalfSizes === undefined) { this.__hasHalfSizes = false; }
            this.scaleNames = ["shorter", "short", "medium", "long"];
            this.scales = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.scaleNames.length);
            if (this.unitLength === undefined) { this.unitLength = null; }
            if (this.unitLengthReciprocal === undefined) { this.unitLengthReciprocal = null; }
            this.dotX = -999.0;
            this.dotY = -999.0;
            if (this.index === undefined) { this.index = 0; }
            if (this.prototype === undefined) { this.prototype = 0; }
            if (this.rotatedPrototype === undefined) { this.rotatedPrototype = 0; }
            this.canonicalize = 0;
            this.needsCanonicalization = false;
            this.prototype = prototype;
            this.rotatedPrototype = rotatedPrototype;
            this.index = Direction.globalIndex++;
            this.mStandard = isStd;
            this.mName = name;
            this.canonicalName = null;
            this.mSymmetryGroup = group;
            for(let i: number = 0; i < this.scales.length; i++) {{
                this.scales[i] = this.mSymmetryGroup.getField()['createPower$int'](i - 1);
            };}
            this.mPrototype = vector;
            const order: number = group.getChiralOrder();
            this.zoneNames = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([2, 2, order]);
        }

        /*private*/ getZoneVectors(): java.util.Map<string, com.vzome.core.math.symmetry.Axis> {
            if (this.zoneVectors.isEmpty()){
                if (Direction.logger_$LI$().isLoggable(java.util.logging.Level.FINER))Direction.logger_$LI$().finer("creating zone vectors: " + this.toString());
                for(let i: number = 0; i < this.mSymmetryGroup.getChiralOrder(); i++) {{
                    const transform: com.vzome.core.algebra.AlgebraicMatrix = this.mSymmetryGroup.getMatrix(i);
                    const perm: com.vzome.core.math.symmetry.Permutation = this.mSymmetryGroup.getPermutation(i);
                    const j: number = perm.mapIndex(this.prototype);
                    const rotated: number = perm.mapIndex(this.rotatedPrototype);
                    const normal: com.vzome.core.algebra.AlgebraicVector = transform.timesColumn(this.mPrototype);
                    const rot: number = this.mSymmetryGroup.getMapping(j, rotated);
                    this.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(j, rot, normal);
                };}
            }
            return this.zoneVectors;
        }

        /**
         * 
         * @return {string}
         */
        public toString(): string {
            return this.mSymmetryGroup.getName() + " " + this.mName;
        }

        public getPrototype(): com.vzome.core.algebra.AlgebraicVector {
            return this.mPrototype;
        }

        /**
         * 
         * @return {*}
         */
        public iterator(): java.util.Iterator<com.vzome.core.math.symmetry.Axis> {
            return this.getZoneVectors().values().iterator();
        }

        public getSymmetry(): com.vzome.core.math.symmetry.Symmetry {
            return this.mSymmetryGroup;
        }

        public getName(): string {
            return this.mName;
        }

        public getCanonicalName(): string {
            if (this.canonicalName == null){
                const canonicalAxis: com.vzome.core.math.symmetry.Axis = this.getCanonicalAxis(0, 0);
                const vector: com.vzome.core.algebra.AlgebraicVector = canonicalAxis.normal();
                const x: com.vzome.core.algebra.AlgebraicNumber = vector.getComponent(0);
                let y: com.vzome.core.algebra.AlgebraicNumber = vector.getComponent(1);
                let z: com.vzome.core.algebra.AlgebraicNumber = vector.getComponent(2).negate();
                if (x.isZero()){
                    this.canonicalName = this.mName;
                } else {
                    y = y.dividedBy(x);
                    z = z.dividedBy(x);
                    this.canonicalName = "[" + /* replace */java.util.Arrays.toString(y.toTrailingDivisor()).split(" ").join("") + "," + /* replace */java.util.Arrays.toString(z.toTrailingDivisor()).split(" ").join("") + "]";
                }
            }
            return this.canonicalName;
        }

        public getAxis$com_vzome_core_algebra_AlgebraicVector(vector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.math.symmetry.Axis {
            for(let index=this.getZoneVectors().values().iterator();index.hasNext();) {
                let axis = index.next();
                {
                    const normal: com.vzome.core.algebra.AlgebraicVector = axis.normal();
                    if (com.vzome.core.algebra.AlgebraicVectors.areParallel(normal, vector)){
                        const dotProd: com.vzome.core.algebra.AlgebraicNumber = normal.dot(vector);
                        if (dotProd.evaluate() > 0){
                            return axis;
                        } else {
                            const principalReflection: com.vzome.core.algebra.AlgebraicMatrix = this.mSymmetryGroup.getPrincipalReflection();
                            if (principalReflection == null){
                                const opp: number = (axis.getSense() + 1) % 2;
                                return this.getAxis$int$int(opp, axis.getOrientation());
                            } else {
                                return this.getAxis$int$int$boolean(axis.getSense(), axis.getOrientation(), !axis.isOutbound());
                            }
                        }
                    }
                }
            }
            return null;
        }

        public getAxis$com_vzome_core_math_RealVector(vector: com.vzome.core.math.RealVector): com.vzome.core.math.symmetry.Axis {
            return this.getSymmetry()['getAxis$com_vzome_core_math_RealVector$java_util_Collection'](vector, java.util.Collections.singleton<any>(this));
        }

        getChiralAxis(vector: com.vzome.core.math.RealVector): com.vzome.core.math.symmetry.Axis {
            if (com.vzome.core.math.RealVector.ORIGIN_$LI$().equals(vector)){
                return null;
            }
            const vectorLength: number = vector.length();
            const checked: java.util.Set<com.vzome.core.math.symmetry.Axis> = <any>(new java.util.HashSet<any>());
            let closestOrientation: number = 0;
            let closestSense: number = com.vzome.core.math.symmetry.Symmetry.PLUS;
            let closestAxis: com.vzome.core.math.symmetry.Axis = this.getCanonicalAxis(com.vzome.core.math.symmetry.Symmetry.PLUS, 0);
            checked.add(closestAxis);
            let axisV: com.vzome.core.math.RealVector = closestAxis.normal().toRealVector();
            let maxCosine: number = vector.dot(axisV) / (vectorLength * axisV.length());
            if (maxCosine < 0){
                closestAxis = this.getCanonicalAxis(com.vzome.core.math.symmetry.Symmetry.MINUS, 0);
                closestSense = com.vzome.core.math.symmetry.Symmetry.MINUS;
                checked.add(closestAxis);
                axisV = closestAxis.normal().toRealVector();
                maxCosine = vector.dot(axisV) / (vectorLength * axisV.length());
            }
            const finished: boolean = false;
            while((!finished)) {{
                const incidentOrientations: number[] = this.getSymmetry().getIncidentOrientations(closestOrientation);
                if (incidentOrientations == null){
                    break;
                }
                const reverseSense: number = (closestSense + 1) % 2;
                for(let index = 0; index < incidentOrientations.length; index++) {
                    let i = incidentOrientations[index];
                    {
                        const neighbor: com.vzome.core.math.symmetry.Axis = this.getCanonicalAxis(reverseSense, i);
                        if (checked.contains(neighbor))continue;
                        checked.add(neighbor);
                        axisV = neighbor.normal().toRealVector();
                        const cosine: number = vector.dot(axisV) / (vectorLength * axisV.length());
                        if (cosine > maxCosine){
                            maxCosine = cosine;
                            closestAxis = neighbor;
                            closestOrientation = i;
                            closestSense = reverseSense;
                        }
                    }
                }
                if (reverseSense !== closestSense){
                    return closestAxis;
                }
            }};
            return this.getAxisBruteForce(vector);
        }

        getAxisBruteForce(vector: com.vzome.core.math.RealVector): com.vzome.core.math.symmetry.Axis {
            let closestAxis: com.vzome.core.math.symmetry.Axis = null;
            let maxCosine: number = -1.0;
            for(let index=this.iterator();index.hasNext();) {
                let axis = index.next();
                {
                    const axisV: com.vzome.core.math.RealVector = axis.normal().toRealVector();
                    const cosine: number = vector.dot(axisV) / (vector.length() * axisV.length());
                    if (cosine > maxCosine){
                        maxCosine = cosine;
                        closestAxis = axis;
                    }
                }
            }
            return closestAxis;
        }

        zoneInitialized(sense: number, unit: number): boolean {
            return this.zoneNames[1][sense][unit] != null;
        }

        public getAxis$int$int(sense: number, index: number): com.vzome.core.math.symmetry.Axis {
            return this.getAxis$int$int$boolean(sense, index, true);
        }

        public getAxis$int$int$boolean(sense: number, index: number, outbound: boolean): com.vzome.core.math.symmetry.Axis {
            this.getZoneVectors();
            return this.zoneNames[outbound ? 1 : 0][sense][index];
        }

        public getAxis(sense?: any, index?: any, outbound?: any): com.vzome.core.math.symmetry.Axis {
            if (((typeof sense === 'number') || sense === null) && ((typeof index === 'number') || index === null) && ((typeof outbound === 'boolean') || outbound === null)) {
                return <any>this.getAxis$int$int$boolean(sense, index, outbound);
            } else if (((typeof sense === 'number') || sense === null) && ((typeof index === 'number') || index === null) && outbound === undefined) {
                return <any>this.getAxis$int$int(sense, index);
            } else if (((sense != null && sense instanceof <any>com.vzome.core.algebra.AlgebraicVector) || sense === null) && index === undefined && outbound === undefined) {
                return <any>this.getAxis$com_vzome_core_algebra_AlgebraicVector(sense);
            } else if (((sense != null && sense instanceof <any>com.vzome.core.math.RealVector) || sense === null) && index === undefined && outbound === undefined) {
                return <any>this.getAxis$com_vzome_core_math_RealVector(sense);
            } else throw new Error('invalid overload');
        }

        public withCorrection(): Direction {
            this.needsCanonicalization = true;
            return this;
        }

        /**
         * Get the axis that protrudes from the canonical direction on the zome ball.
         * Many Directions (orbits) are created without regard to whether "axis 0" actually sticks out
         * of the ball in the fundamental domain with index 0.
         * @param {number} sense
         * @param {number} index
         * @return
         * @return {com.vzome.core.math.symmetry.Axis}
         */
        public getCanonicalAxis(sense: number, index: number): com.vzome.core.math.symmetry.Axis {
            if (this.needsCanonicalization){
                const treatedAs0: com.vzome.core.math.symmetry.Axis = this.getAxisBruteForce(com.vzome.core.math.RealVector.DIRECTION_0_$LI$());
                this.canonicalize = treatedAs0.getOrientation();
                if (treatedAs0.getSense() === com.vzome.core.math.symmetry.Symmetry.MINUS)this.canonicalize *= -1;
                this.needsCanonicalization = false;
            }
            if (this.canonicalize !== 0){
                if (this.canonicalize < 0)sense = (sense + 1) % 2;
                const target: com.vzome.core.math.symmetry.Permutation = this.mSymmetryGroup.getPermutation(index);
                index = target.mapIndex(Math.abs(this.canonicalize));
            }
            return this.getAxis$int$int(sense, index);
        }

        public createAxis$int$int$int_A_A(orientation: number, rotation: number, norm: number[][]) {
            const aNorm: com.vzome.core.algebra.AlgebraicVector = this.mSymmetryGroup.getField().createVector(norm);
            this.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(orientation, rotation, aNorm);
        }

        public createAxis(orientation?: any, rotation?: any, norm?: any) {
            if (((typeof orientation === 'number') || orientation === null) && ((typeof rotation === 'number') || rotation === null) && ((norm != null && norm instanceof <any>Array && (norm.length == 0 || norm[0] == null ||norm[0] instanceof Array)) || norm === null)) {
                return <any>this.createAxis$int$int$int_A_A(orientation, rotation, norm);
            } else if (((typeof orientation === 'number') || orientation === null) && ((typeof rotation === 'number') || rotation === null) && ((norm != null && norm instanceof <any>com.vzome.core.algebra.AlgebraicVector) || norm === null)) {
                return <any>this.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(orientation, rotation, norm);
            } else throw new Error('invalid overload');
        }

        public createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(orientation: number, rotation: number, norm: com.vzome.core.algebra.AlgebraicVector) {
            let perm: com.vzome.core.math.symmetry.Permutation = this.mSymmetryGroup.getPermutation(rotation);
            this.recordZone(this, orientation, com.vzome.core.math.symmetry.Symmetry.PLUS, rotation, perm, norm, true);
            const inversion: com.vzome.core.algebra.AlgebraicMatrix = this.mSymmetryGroup.getPrincipalReflection();
            if (inversion == null){
                if (perm != null)perm = perm.inverse();
                this.recordZone(this, orientation, com.vzome.core.math.symmetry.Symmetry.MINUS, rotation, perm, norm.negate(), true);
            } else {
                let reverseRotation: number = rotation;
                let reversePerm: com.vzome.core.math.symmetry.Permutation = perm;
                if (perm != null){
                    reversePerm = perm.inverse();
                    reverseRotation = perm.mapIndex(0);
                }
                this.recordZone(this, orientation, com.vzome.core.math.symmetry.Symmetry.PLUS, reverseRotation, reversePerm, norm.negate(), false);
                let reflectedNorm: com.vzome.core.algebra.AlgebraicVector = inversion.timesColumn(norm);
                this.recordZone(this, orientation, com.vzome.core.math.symmetry.Symmetry.MINUS, reverseRotation, reversePerm, reflectedNorm, true);
                reflectedNorm = reflectedNorm.negate();
                this.recordZone(this, orientation, com.vzome.core.math.symmetry.Symmetry.MINUS, rotation, perm, reflectedNorm, false);
            }
        }

        /*private*/ recordZone(dir: Direction, orientation: number, sense: number, rotation: number, rotPerm: com.vzome.core.math.symmetry.Permutation, normal: com.vzome.core.algebra.AlgebraicVector, outbound: boolean) {
            let zone: com.vzome.core.math.symmetry.Axis = this.zoneVectors.get(normal.toString());
            if (zone == null){
                zone = new com.vzome.core.math.symmetry.Axis(this, orientation, sense, rotation, rotPerm, normal, outbound);
                this.zoneVectors.put(normal.toString(), zone);
                if (Direction.logger_$LI$().isLoggable(java.util.logging.Level.FINER))Direction.logger_$LI$().finer("creating zone " + zone.toString() + " " + normal.toString());
            } else {
                if (outbound && !zone.isOutbound()){
                    const oldName: string = zone.toString();
                    zone.rename(sense, orientation, true);
                    if (Direction.logger_$LI$().isLoggable(java.util.logging.Level.FINER))Direction.logger_$LI$().finer("zone " + oldName + " upgraded to " + zone.toString());
                } else if (zone.isOutbound() && !outbound){
                    if (Direction.logger_$LI$().isLoggable(java.util.logging.Level.FINEST))Direction.logger_$LI$().finest("zone " + zone.toString() + " aliased as " + ((sense === com.vzome.core.math.symmetry.Axis.MINUS) ? "-" : "") + orientation + (outbound ? "" : "i"));
                } else if (sense === com.vzome.core.math.symmetry.Axis.PLUS && (zone.getSense() === com.vzome.core.math.symmetry.Axis.MINUS)){
                    const oldName: string = zone.toString();
                    zone.rename(sense, orientation, outbound);
                    if (Direction.logger_$LI$().isLoggable(java.util.logging.Level.FINER))Direction.logger_$LI$().finer("zone " + oldName + " upgraded to " + zone.toString());
                } else {
                    if (Direction.logger_$LI$().isLoggable(java.util.logging.Level.FINEST))Direction.logger_$LI$().finest("zone " + zone.toString() + " aliased as " + ((sense === com.vzome.core.math.symmetry.Axis.MINUS) ? "-" : "") + orientation + (outbound ? "" : "i"));
                }
            }
            this.zoneNames[outbound ? 1 : 0][sense][orientation] = zone;
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Direction} other
         * @return {number}
         */
        public compareTo(other: Direction): number {
            return this.index - other.index;
        }

        public setHalfSizes(value: boolean) {
            this.__hasHalfSizes = value;
        }

        public hasHalfSizes(): boolean {
            return this.__hasHalfSizes;
        }

        public setScaleNames(names: string[]) {
            for(let i: number = 0; i < names.length; i++) {{
                this.scaleNames[i] = names[i];
            };}
        }

        public getScaleName(scale: number): string {
            if (scale < this.scaleNames.length && scale >= 0)return this.scaleNames[scale]; else return "scale " + (scale - 1);
        }

        public setUnitLength(unitLength: com.vzome.core.algebra.AlgebraicNumber) {
            this.unitLength = unitLength;
            this.unitLengthReciprocal = unitLength.reciprocal();
        }

        public getUnitLength(): com.vzome.core.algebra.AlgebraicNumber {
            if (this.unitLength == null)return this.mSymmetryGroup.getField().one(); else return this.unitLength;
        }

        public static USER_SCALE: number = 3;

        public getLengthInUnits(rawLength: com.vzome.core.algebra.AlgebraicNumber): com.vzome.core.algebra.AlgebraicNumber {
            const field: com.vzome.core.algebra.AlgebraicField = this.mSymmetryGroup.getField();
            const scaledLength: com.vzome.core.algebra.AlgebraicNumber = rawLength['times$com_vzome_core_algebra_AlgebraicNumber'](field['createPower$int'](-Direction.USER_SCALE));
            if (this.unitLength == null)return scaledLength; else return scaledLength['times$com_vzome_core_algebra_AlgebraicNumber'](this.unitLengthReciprocal);
        }

        public getLengthName(length: com.vzome.core.algebra.AlgebraicNumber): string {
            for(let i: number = 0; i < this.scales.length; i++) {{
                if (/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(this.scales[i],length))){
                    return this.scaleNames[i];
                }
            };}
            return "";
        }

        public getLengthExpression(buf: java.lang.StringBuffer, length: com.vzome.core.algebra.AlgebraicNumber) {
            const bufLen: number = buf.length();
            buf.append(this.getLengthName(length));
            if (buf.length() === bufLen){
                buf.append(" ");
            }
            buf.append(":");
            length.getNumberExpression(buf, com.vzome.core.algebra.AlgebraicField.EXPRESSION_FORMAT);
        }

        public getDotX(): number {
            return this.dotX;
        }

        public getDotY(): number {
            return this.dotY;
        }

        public setDotLocation(x: number, y: number) {
            this.dotX = x;
            this.dotY = y;
        }
    }
    Direction["__class"] = "com.vzome.core.math.symmetry.Direction";
    Direction["__interfaces"] = ["java.lang.Comparable","java.lang.Iterable"];


}
namespace com.vzome.core.math.symmetry {
    export class B4Group implements com.vzome.core.math.symmetry.CoxeterGroup {
        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        ROOTS: com.vzome.core.algebra.AlgebraicVector[];

        WEIGHTS: com.vzome.core.algebra.AlgebraicVector[];

        static B4_PERMS: number[][]; public static B4_PERMS_$LI$(): number[][] { if (B4Group.B4_PERMS == null) { B4Group.B4_PERMS = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 2, 1, 3], [0, 2, 3, 1], [0, 3, 2, 1], [0, 3, 1, 2], [1, 0, 2, 3], [1, 0, 3, 2], [1, 2, 0, 3], [1, 2, 3, 0], [1, 3, 2, 0], [1, 3, 0, 2], [2, 1, 0, 3], [2, 1, 3, 0], [2, 0, 1, 3], [2, 0, 3, 1], [2, 3, 0, 1], [2, 3, 1, 0], [3, 1, 2, 0], [3, 1, 0, 2], [3, 2, 1, 0], [3, 2, 0, 1], [3, 0, 2, 1], [3, 0, 1, 2]]; }  return B4Group.B4_PERMS; }

        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            if (this.field === undefined) { this.field = null; }
            this.ROOTS = [null, null, null, null];
            this.WEIGHTS = [null, null, null, null];
            this.field = field;
            const neg_one: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long'](-1);
            this.ROOTS[0] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
            this.ROOTS[0].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, neg_one);
            this.ROOTS[1] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Y4);
            this.ROOTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, neg_one);
            this.ROOTS[2] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Z4);
            this.ROOTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, neg_one);
            this.ROOTS[3] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.W4);
            const y: com.vzome.core.algebra.AlgebraicVector = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Y4);
            const z: com.vzome.core.algebra.AlgebraicVector = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Z4);
            this.WEIGHTS[0] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
            this.WEIGHTS[1] = this.WEIGHTS[0].plus(y);
            this.WEIGHTS[2] = this.WEIGHTS[1].plus(z);
            this.WEIGHTS[3] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
            const half: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long$long'](1, 2);
            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, half);
            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, half);
            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, half);
            if (field.scale4dRoots()){
                const scale: com.vzome.core.algebra.AlgebraicNumber = field['createPower$int'](1);
                this.ROOTS[3] = this.ROOTS[3].scale(scale);
                this.WEIGHTS[3] = this.WEIGHTS[3].scale(scale);
            }
        }

        /**
         * 
         * @return {number}
         */
        public getOrder(): number {
            return 24 * 16;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} model
         * @param {number} element
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public groupAction(model: com.vzome.core.algebra.AlgebraicVector, element: number): com.vzome.core.algebra.AlgebraicVector {
            const result: com.vzome.core.algebra.AlgebraicVector = this.field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
            const perm: number = (element / 16|0);
            let signs: number = element % 16;
            for(let c: number = 0; c < 4; c++) {{
                let source: com.vzome.core.algebra.AlgebraicNumber = model.getComponent((B4Group.B4_PERMS_$LI$()[perm][c] + 1) % 4);
                if (signs % 2 !== 0)source = source.negate();
                result.setComponent((c + 1) % 4, source);
                signs = signs >> 1;
            };}
            return result;
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getOrigin(): com.vzome.core.algebra.AlgebraicVector {
            return this.field.origin(4);
        }

        /**
         * 
         * @param {number} i
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getWeight(i: number): com.vzome.core.algebra.AlgebraicVector {
            return this.WEIGHTS[i];
        }

        /**
         * 
         * @param {number} i
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getSimpleRoot(i: number): com.vzome.core.algebra.AlgebraicVector {
            return this.ROOTS[i];
        }

        /**
         * 
         * @return {*}
         */
        public getField(): com.vzome.core.algebra.AlgebraicField {
            return this.field;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} model
         * @param {number} element
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public chiralSubgroupAction(model: com.vzome.core.algebra.AlgebraicVector, element: number): com.vzome.core.algebra.AlgebraicVector {
            const result: com.vzome.core.algebra.AlgebraicVector = this.field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
            const perm: number = (element / 16|0);
            let signs: number = element % 16;
            let even: boolean = true;
            for(let c: number = 0; c < 4; c++) {{
                let source: com.vzome.core.algebra.AlgebraicNumber = model.getComponent((B4Group.B4_PERMS_$LI$()[perm][c] + 1) % 4);
                if (signs % 2 !== 0){
                    even = !even;
                    source = source.negate();
                }
                result.setComponent((c + 1) % 4, source);
                signs = signs >> 1;
            };}
            return even ? result : null;
        }
    }
    B4Group["__class"] = "com.vzome.core.math.symmetry.B4Group";
    B4Group["__interfaces"] = ["com.vzome.core.math.symmetry.CoxeterGroup"];


}
namespace com.vzome.core.math.symmetry {
    /**
     * @deprecated
     * @author Scott Vorthmann
     * @class
     */
    export interface Constants {    }

    export namespace Constants {

        export const RED: number = 0;

        export const YELLOW: number = 1;

        export const BLUE: number = 2;

        export const GREEN: number = 3;

        export const ORANGE: number = 4;

        export const PURPLE: number = 5;

        export const BLACK: number = 6;

        export const NO_AXIS: number = 7;

        /**
         * Blue axes of basis.
         */
        export const X: number = 2;

        /**
         * Blue axes of basis.
         */
        export const Y: number = 5;

        /**
         * Blue axes of basis.
         */
        export const Z: number = 13;

        export const SHORT: number = 3;

        export const MEDIUM: number = 4;

        export const LONG: number = 5;

        export const JUST_RED: number = 1 << Constants.RED;

        export const JUST_YELLOW: number = 1 << Constants.YELLOW;

        export const JUST_BLUE: number = 1 << Constants.BLUE;

        export const JUST_GREEN: number = 1 << Constants.GREEN;

        export const JUST_ORANGE: number = 1 << Constants.ORANGE;

        export const JUST_PURPLE: number = 1 << Constants.PURPLE;

        export const JUST_BLACK: number = 1 << Constants.BLACK;

        export const ORIGINAL_STRUTS: number = Constants.JUST_RED | Constants.JUST_YELLOW | Constants.JUST_BLUE;

        export const ALL_STRUTS: number = Constants.ORIGINAL_STRUTS | Constants.JUST_GREEN | Constants.JUST_ORANGE | Constants.JUST_PURPLE | Constants.JUST_BLACK;

        export const RED_AXIS_YELLOW_NEIGHBORS: number[][] = [[0, 1, 2, 3, 4], [1, 0, 5, -8, 6], [2, 1, 6, -9, 7], [3, 2, 7, -5, 8], [4, 3, 8, -6, 9], [0, 4, 9, -7, 5]];

        export const AXIS_SYMMETRY: number[] = [5, 3, 2, 1, 1, 1, 1];
    }

}
namespace com.vzome.core.math {
    export abstract class VefParser {
        public static VERSION_EXPLICIT_OFFSET: number = 10;

        public static VERSION_EXPLICIT_DIMENSION: number = 9;

        public static VERSION_SCALE_VECTOR: number = 8;

        public static VERSION_RATIONAL_ACTUAL_SCALE: number = 7;

        public static VERSION_EXPLICIT_BALLS: number = 6;

        public static VERSION_ANY_FIELD: number = 5;

        public static VERSION_W_FIRST: number = 4;

        /*private*/ mVersion: number;

        /*private*/ dimension: number;

        /*private*/ __isRational: boolean;

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        parsedOffset: com.vzome.core.algebra.AlgebraicVector;

        abstract startVertices(numVertices: number);

        abstract addVertex(index: number, location: com.vzome.core.algebra.AlgebraicVector);

        endVertices() {
        }

        abstract startEdges(numEdges: number);

        abstract addEdge(index: number, v1: number, v2: number);

        endEdges() {
        }

        abstract startFaces(numFaces: number);

        abstract addFace(index: number, verts: number[]);

        endFaces() {
        }

        abstract startBalls(numVertices: number);

        abstract addBall(index: number, vertex: number);

        endBalls() {
        }

        getVersion(): number {
            return this.mVersion;
        }

        getField(): com.vzome.core.algebra.AlgebraicField {
            return this.field;
        }

        isRational(): boolean {
            return this.__isRational;
        }

        wFirst(): boolean {
            return this.mVersion >= VefParser.VERSION_W_FIRST;
        }

        public parseVEF(vefData: string, field: com.vzome.core.algebra.AlgebraicField) {
            this.field = field;
            const tokens: java.util.StringTokenizer = new java.util.StringTokenizer(vefData);
            let token: string = null;
            try {
                token = tokens.nextToken();
            } catch(e1) {
                throw new java.lang.IllegalStateException("VEF format error: no tokens in file data: \"" + vefData + "\"");
            }
            this.mVersion = 0;
            this.__isRational = false;
            if (token === ("vZome")){
                try {
                    token = tokens.nextToken();
                } catch(e1) {
                    throw new java.lang.IllegalStateException("VEF format error: no tokens after \"vZome\"");
                }
                if (!("VEF" === token))throw new java.lang.IllegalStateException("VEF format error: token after \"vZome\" (\"" + token + "\" should be \"VEF\"");
                try {
                    token = tokens.nextToken();
                } catch(e1) {
                    throw new java.lang.IllegalStateException("VEF format error: no tokens after \"VEF\"");
                }
                try {
                    this.mVersion = javaemul.internal.IntegerHelper.parseInt(token);
                } catch(e) {
                    throw new java.lang.RuntimeException("VEF format error: VEF version number (\"" + token + "\") must be an integer", e);
                }
                token = tokens.nextToken();
            }
            if (token === ("field")){
                try {
                    token = tokens.nextToken();
                } catch(e1) {
                    throw new java.lang.IllegalStateException("VEF format error: no tokens after \"field\"");
                }
                if (token === ("rational")){
                    this.__isRational = true;
                    token = field.getName();
                }
                if (!field.supportsSubfield(token)){
                    throw new java.lang.IllegalStateException("VEF field mismatch error: VEF field name (\"" + token + "\") does not match current model field name (\"" + field.getName() + "\").");
                }
                token = tokens.nextToken();
            }
            if (token === ("actual")){
                try {
                    token = tokens.nextToken();
                } catch(e1) {
                    throw new java.lang.IllegalStateException("VEF format error: no tokens after \"actual\"");
                }
            }
            if (token === ("dimension")){
                try {
                    token = tokens.nextToken();
                } catch(e1) {
                    throw new java.lang.IllegalStateException("VEF format error: no tokens after \"dimension\"");
                }
                try {
                    this.dimension = javaemul.internal.IntegerHelper.parseInt(token);
                } catch(e) {
                    throw new java.lang.RuntimeException("VEF format error: dimension number (\"" + token + "\") must be an integer", e);
                }
                try {
                    token = tokens.nextToken();
                } catch(e) {
                    throw new java.lang.IllegalStateException("VEF format error: no tokens after \"dimension\"");
                }
            }
            const scaleVector: com.vzome.core.algebra.AlgebraicVector = new com.vzome.core.algebra.AlgebraicVector(field, this.dimension);
            if (token === ("scale")){
                try {
                    token = tokens.nextToken();
                    if (token === ("vector")){
                        try {
                            for(let tokNum: number = 0; tokNum < this.dimension; tokNum++) {{
                                token = tokens.nextToken();
                                const coord: com.vzome.core.algebra.AlgebraicNumber = this.field.parseVefNumber(token, this.__isRational);
                                scaleVector.setComponent(tokNum, coord);
                            };}
                        } catch(e) {
                            throw new java.lang.IllegalStateException("VEF format error: scale vector requires " + this.dimension + " coordinates");
                        }
                    } else {
                        const scale: com.vzome.core.algebra.AlgebraicNumber = this.field.parseVefNumber(token, this.__isRational);
                        for(let i: number = 0; i < this.dimension; i++) {{
                            scaleVector.setComponent(i, scale);
                        };}
                    }
                    token = tokens.nextToken();
                } catch(e) {
                    throw new java.lang.IllegalStateException("VEF format error: no tokens after \"scale\"");
                }
            } else {
                for(let i: number = 0; i < this.dimension; i++) {{
                    scaleVector.setComponent(i, field.one());
                };}
            }
            this.parsedOffset = new com.vzome.core.algebra.AlgebraicVector(field, this.dimension);
            if (token === ("offset")){
                try {
                    for(let tokNum: number = 0; tokNum < this.dimension; tokNum++) {{
                        token = tokens.nextToken();
                        const coord: com.vzome.core.algebra.AlgebraicNumber = this.field.parseVefNumber(token, this.__isRational);
                        this.parsedOffset.setComponent(tokNum, coord);
                    };}
                } catch(e) {
                    throw new java.lang.IllegalStateException("VEF format error: offset vector requires " + this.dimension + " coordinates");
                }
                try {
                    token = tokens.nextToken();
                } catch(e) {
                    throw new java.lang.IllegalStateException("VEF format error: no tokens after \"offset\"");
                }
            }
            let numVertices: number;
            try {
                numVertices = javaemul.internal.IntegerHelper.parseInt(token);
            } catch(e) {
                throw new java.lang.RuntimeException("VEF format error: number of vertices (\"" + token + "\") must be an integer", e);
            }
            this.startVertices(numVertices);
            const hasOffset: boolean = !this.parsedOffset.isOrigin();
            for(let i: number = 0; i < numVertices; i++) {{
                let v: com.vzome.core.algebra.AlgebraicVector = field.origin(this.dimension);
                for(let tokNum: number = 0; tokNum < this.dimension; tokNum++) {{
                    try {
                        token = tokens.nextToken();
                    } catch(e1) {
                        throw new java.lang.IllegalStateException("VEF format error: not enough vertices in list");
                    }
                    const coord: com.vzome.core.algebra.AlgebraicNumber = this.field.parseVefNumber(token, this.__isRational)['times$com_vzome_core_algebra_AlgebraicNumber'](scaleVector.getComponent(tokNum));
                    v.setComponent(tokNum, coord);
                };}
                if (hasOffset){
                    v = v.plus(this.parsedOffset);
                }
                this.addVertex(i, v);
            };}
            this.endVertices();
            if (tokens.hasMoreTokens()){
                token = tokens.nextToken();
                let numEdges: number;
                try {
                    numEdges = javaemul.internal.IntegerHelper.parseInt(token);
                } catch(e) {
                    throw new java.lang.RuntimeException("VEF format error: number of edges (\"" + token + "\") must be an integer", e);
                }
                this.startEdges(numEdges);
                for(let i: number = 0; i < numEdges; i++) {{
                    try {
                        token = tokens.nextToken();
                    } catch(e1) {
                        throw new java.lang.IllegalStateException("VEF format error: not enough edges in list");
                    }
                    const v1: number = javaemul.internal.IntegerHelper.parseInt(token);
                    try {
                        token = tokens.nextToken();
                    } catch(e1) {
                        throw new java.lang.IllegalStateException("VEF format error: 2nd vertex index of last edge is missing");
                    }
                    const v2: number = javaemul.internal.IntegerHelper.parseInt(token);
                    this.addEdge(i, v1, v2);
                };}
                this.endEdges();
            }
            if (tokens.hasMoreTokens()){
                token = tokens.nextToken();
                let numFaces: number;
                try {
                    numFaces = javaemul.internal.IntegerHelper.parseInt(token);
                } catch(e) {
                    throw new java.lang.RuntimeException("VEF format error: number of faces (\"" + token + "\") must be an integer", e);
                }
                this.startFaces(numFaces);
                for(let i: number = 0; i < numFaces; i++) {{
                    try {
                        token = tokens.nextToken();
                    } catch(e1) {
                        throw new java.lang.IllegalStateException("VEF format error: not enough faces in list");
                    }
                    const order: number = javaemul.internal.IntegerHelper.parseInt(token);
                    const verts: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(order);
                    for(let j: number = 0; j < order; j++) {{
                        try {
                            token = tokens.nextToken();
                        } catch(e1) {
                            throw new java.lang.IllegalStateException("VEF format error: not enough vertices in last face");
                        }
                        verts[j] = javaemul.internal.IntegerHelper.parseInt(token);
                    };}
                    this.addFace(i, verts);
                };}
                this.endFaces();
            }
            if (tokens.hasMoreTokens()){
                token = tokens.nextToken();
                let numBalls: number;
                try {
                    numBalls = javaemul.internal.IntegerHelper.parseInt(token);
                } catch(e) {
                    throw new java.lang.RuntimeException("VEF format error: number of balls (\"" + token + "\") must be an integer", e);
                }
                this.startBalls(numBalls);
                for(let i: number = 0; i < numBalls; i++) {{
                    try {
                        token = tokens.nextToken();
                    } catch(e1) {
                        throw new java.lang.IllegalStateException("VEF format error: not enough balls in list");
                    }
                    const v1: number = javaemul.internal.IntegerHelper.parseInt(token);
                    this.addBall(i, v1);
                };}
                this.endBalls();
            }
            this.endFile(tokens);
        }

        endFile(tokens: java.util.StringTokenizer) {
        }

        constructor() {
            this.mVersion = 0;
            this.dimension = 4;
            this.__isRational = false;
            if (this.field === undefined) { this.field = null; }
            if (this.parsedOffset === undefined) { this.parsedOffset = null; }
        }
    }
    VefParser["__class"] = "com.vzome.core.math.VefParser";

}
namespace com.vzome.core.math {
    /**
     * @param {*} field
     * @param {com.vzome.core.algebra.AlgebraicVector} leftQuat
     * @param {com.vzome.core.algebra.AlgebraicVector} rightQuat
     * @class
     */
    export class QuaternionProjection implements com.vzome.core.math.Projection {
        /*private*/ quaternions: com.vzome.core.algebra.Quaternion[][];

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        public constructor(field: com.vzome.core.algebra.AlgebraicField, leftQuat: com.vzome.core.algebra.AlgebraicVector, rightQuat: com.vzome.core.algebra.AlgebraicVector) {
            this.quaternions = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([2, 2]);
            if (this.field === undefined) { this.field = null; }
            this.field = field;
            this.setQuaternion(leftQuat, QuaternionProjection.LEFT);
            this.setQuaternion(rightQuat, QuaternionProjection.RIGHT);
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} source
         * @param {boolean} wFirst
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public projectImage(source: com.vzome.core.algebra.AlgebraicVector, wFirst: boolean): com.vzome.core.algebra.AlgebraicVector {
            let result: com.vzome.core.algebra.AlgebraicVector = source;
            const leftQuat: com.vzome.core.algebra.Quaternion = this.getQuaternion(QuaternionProjection.LEFT, wFirst);
            const rightQuat: com.vzome.core.algebra.Quaternion = this.getQuaternion(QuaternionProjection.RIGHT, wFirst);
            if (rightQuat != null){
                if (leftQuat != null){
                    result = leftQuat.rightMultiply(result);
                    console.info("left mult: " + result.toString());
                }
                result = rightQuat.leftMultiply(result);
            } else {
                result = leftQuat.rightMultiply(result);
            }
            return this.field.projectTo3d(result, wFirst);
        }

        static LEFT: number = 0;

        static RIGHT: number = 1;

        static WFIRST: number = 0;

        static WLAST: number = 1;

        /*private*/ setQuaternion(quatVector: com.vzome.core.algebra.AlgebraicVector, hand: number) {
            this.quaternions[hand][QuaternionProjection.WFIRST] = quatVector == null ? null : new com.vzome.core.algebra.Quaternion(this.field, quatVector.inflateTo4d$boolean(true));
            this.quaternions[hand][QuaternionProjection.WLAST] = quatVector == null ? null : new com.vzome.core.algebra.Quaternion(this.field, quatVector.inflateTo4d$boolean(false));
        }

        /*private*/ getQuaternion(hand: number, wFirst: boolean): com.vzome.core.algebra.Quaternion {
            return this.quaternions[hand][wFirst ? QuaternionProjection.WFIRST : QuaternionProjection.WLAST];
        }

        static RIGHT_QUATERNION_ATTRIBUTENAME: string = "quaternion";

        static LEFT_QUATERNION_ATTRIBUTENAME: string = "leftQuaternion";

        /**
         * 
         * @param {*} element
         */
        public getXmlAttributes(element: org.w3c.dom.Element) {
            const leftQuat: com.vzome.core.algebra.Quaternion = this.getQuaternion(QuaternionProjection.LEFT, true);
            const rightQuat: com.vzome.core.algebra.Quaternion = this.getQuaternion(QuaternionProjection.RIGHT, true);
            if (leftQuat != null){
                com.vzome.xml.DomUtils.addAttribute(element, QuaternionProjection.LEFT_QUATERNION_ATTRIBUTENAME, leftQuat.getVector().toParsableString());
            }
            if (rightQuat != null){
                com.vzome.xml.DomUtils.addAttribute(element, QuaternionProjection.RIGHT_QUATERNION_ATTRIBUTENAME, rightQuat.getVector().toParsableString());
            }
        }

        /**
         * 
         * @param {*} xml
         */
        public setXmlAttributes(xml: org.w3c.dom.Element) {
            this.setQuaternion(this.parseRationalVector(xml, QuaternionProjection.LEFT_QUATERNION_ATTRIBUTENAME), QuaternionProjection.LEFT);
            this.setQuaternion(this.parseRationalVector(xml, QuaternionProjection.RIGHT_QUATERNION_ATTRIBUTENAME), QuaternionProjection.RIGHT);
        }

        /*private*/ parseRationalVector(xml: org.w3c.dom.Element, attrName: string): com.vzome.core.algebra.AlgebraicVector {
            const nums: string = xml.getAttribute(attrName);
            if (nums == null || /* isEmpty */(nums.length === 0))return null;
            const loc: com.vzome.core.algebra.AlgebraicVector = this.field.parseVector(nums);
            return loc;
        }

        /**
         * 
         * @return {string}
         */
        public getProjectionName(): string {
            return "Quaternion";
        }
    }
    QuaternionProjection["__class"] = "com.vzome.core.math.QuaternionProjection";
    QuaternionProjection["__interfaces"] = ["com.vzome.core.math.Projection"];


}
namespace com.vzome.core.math {
    export interface Projection {
        projectImage(source: com.vzome.core.algebra.AlgebraicVector, wFirst: boolean): com.vzome.core.algebra.AlgebraicVector;

        getXmlAttributes(element: org.w3c.dom.Element);

        setXmlAttributes(xml: org.w3c.dom.Element);

        getProjectionName(): string;
    }

    export namespace Projection {

        export class Default implements com.vzome.core.math.Projection {
            field: com.vzome.core.algebra.AlgebraicField;

            public constructor(field: com.vzome.core.algebra.AlgebraicField) {
                if (this.field === undefined) { this.field = null; }
                this.field = field;
            }

            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} source
             * @param {boolean} wFirst
             * @return {com.vzome.core.algebra.AlgebraicVector}
             */
            public projectImage(source: com.vzome.core.algebra.AlgebraicVector, wFirst: boolean): com.vzome.core.algebra.AlgebraicVector {
                return this.field.projectTo3d(source, wFirst);
            }

            /**
             * 
             * @param {*} element
             */
            public getXmlAttributes(element: org.w3c.dom.Element) {
            }

            /**
             * 
             * @param {*} xml
             */
            public setXmlAttributes(xml: org.w3c.dom.Element) {
            }

            /**
             * 
             * @return {string}
             */
            public getProjectionName(): string {
                return "";
            }
        }
        Default["__class"] = "com.vzome.core.math.Projection.Default";
        Default["__interfaces"] = ["com.vzome.core.math.Projection"];


    }

}
namespace com.vzome.core.math {
    export class PerspectiveProjection implements com.vzome.core.math.Projection {
        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        /*private*/ cameraDist: com.vzome.core.algebra.AlgebraicNumber;

        public constructor(field: com.vzome.core.algebra.AlgebraicField, cameraDist: com.vzome.core.algebra.AlgebraicNumber) {
            if (this.field === undefined) { this.field = null; }
            if (this.cameraDist === undefined) { this.cameraDist = null; }
            if (this.minDenom === undefined) { this.minDenom = null; }
            if (this.minDenomValue === undefined) { this.minDenomValue = 0; }
            this.field = field;
            this.cameraDist = cameraDist;
        }

        /*private*/ minDenom: com.vzome.core.algebra.AlgebraicNumber;

        /*private*/ minDenomValue: number;

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} source
         * @param {boolean} wFirst
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public projectImage(source: com.vzome.core.algebra.AlgebraicVector, wFirst: boolean): com.vzome.core.algebra.AlgebraicVector {
            const result: com.vzome.core.algebra.AlgebraicVector = this.field.origin(4);
            const w: com.vzome.core.algebra.AlgebraicNumber = source.getComponent(0);
            let denom: com.vzome.core.algebra.AlgebraicNumber = this.cameraDist['minus$com_vzome_core_algebra_AlgebraicNumber'](w);
            if (this.minDenom == null){
                this.minDenom = this.field['createPower$int'](-5);
                this.minDenomValue = this.minDenom.evaluate();
            }
            const denomValue: number = denom.evaluate();
            if (denomValue < this.minDenomValue){
                denom = this.minDenom;
            }
            const numerator: com.vzome.core.algebra.AlgebraicNumber = denom.reciprocal();
            result.setComponent(0, this.field.one());
            result.setComponent(1, source.getComponent(1)['times$com_vzome_core_algebra_AlgebraicNumber'](numerator));
            result.setComponent(2, source.getComponent(2)['times$com_vzome_core_algebra_AlgebraicNumber'](numerator));
            result.setComponent(3, source.getComponent(3)['times$com_vzome_core_algebra_AlgebraicNumber'](numerator));
            return result;
        }

        /**
         * 
         * @param {*} element
         */
        public getXmlAttributes(element: org.w3c.dom.Element) {
            if (this.cameraDist != null){
                com.vzome.xml.DomUtils.addAttribute(element, "cameraDist", this.cameraDist.toString(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
            }
        }

        /**
         * 
         * @param {*} xml
         */
        public setXmlAttributes(xml: org.w3c.dom.Element) {
            const nums: string = xml.getAttribute("cameraDist");
            if (nums == null || /* isEmpty */(nums.length === 0))return;
            this.cameraDist = this.field.parseNumber(nums);
        }

        /**
         * 
         * @return {string}
         */
        public getProjectionName(): string {
            return "Perspective";
        }
    }
    PerspectiveProjection["__class"] = "com.vzome.core.math.PerspectiveProjection";
    PerspectiveProjection["__interfaces"] = ["com.vzome.core.math.Projection"];


}
namespace com.vzome.core.math {
    export class Line {
        /*private*/ origin: com.vzome.core.math.RealVector;

        /*private*/ direction: com.vzome.core.math.RealVector;

        public constructor(origin: com.vzome.core.math.RealVector, direction: com.vzome.core.math.RealVector) {
            if (this.origin === undefined) { this.origin = null; }
            if (this.direction === undefined) { this.direction = null; }
            this.direction = direction;
            this.origin = origin;
        }

        public getOrigin(): com.vzome.core.math.RealVector {
            return this.origin;
        }

        public getDirection(): com.vzome.core.math.RealVector {
            return this.direction;
        }
    }
    Line["__class"] = "com.vzome.core.math.Line";

}
namespace com.vzome.core.model {
    export interface RealizedModel extends java.lang.Iterable<com.vzome.core.model.Manifestation> {
        getField(): com.vzome.core.algebra.AlgebraicField;

        findConstruction(c: com.vzome.core.construction.Construction): com.vzome.core.model.Manifestation;

        removeConstruction(c: com.vzome.core.construction.Construction): com.vzome.core.model.Manifestation;

        getManifestation(c: com.vzome.core.construction.Construction): com.vzome.core.model.Manifestation;

        size(): number;

        show(mManifestation: com.vzome.core.model.Manifestation);

        hide(mManifestation: com.vzome.core.model.Manifestation);

        add(m: com.vzome.core.model.Manifestation);

        remove(mManifestation: com.vzome.core.model.Manifestation);

        setColor(manifestation: com.vzome.core.model.Manifestation, color: com.vzome.core.construction.Color);

        setLabel(m: com.vzome.core.model.Manifestation, label: string);

        findPerEditManifestation(signature: string): com.vzome.core.model.Manifestation;

        addPerEditManifestation(signature: string, m: com.vzome.core.model.Manifestation);

        clearPerEditManifestations();
    }
}
namespace com.vzome.core.model {
    export class Group extends java.util.ArrayList<com.vzome.core.model.GroupElement> implements com.vzome.core.model.GroupElement {
        /*private*/ mContainer: Group;

        public getContainer(): Group {
            return this.mContainer;
        }

        /**
         * 
         * @param {com.vzome.core.model.Group} container
         */
        public setContainer(container: Group) {
            this.mContainer = container;
        }

        constructor() {
            super();
            if (this.mContainer === undefined) { this.mContainer = null; }
        }
    }
    Group["__class"] = "com.vzome.core.model.Group";
    Group["__interfaces"] = ["java.util.RandomAccess","com.vzome.core.model.GroupElement","java.util.List","java.lang.Cloneable","java.util.Collection","java.lang.Iterable","java.io.Serializable"];


}
namespace com.vzome.core.model {
    export interface Manifestation extends com.vzome.core.model.GroupElement {
        getLocation(): com.vzome.core.algebra.AlgebraicVector;

        getConstructions(): java.util.Iterator<com.vzome.core.construction.Construction>;

        getFirstConstruction(): com.vzome.core.construction.Construction;

        getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element;

        isHidden(): boolean;

        isRendered(): boolean;

        toConstruction(): com.vzome.core.construction.Construction;

        getCentroid(): com.vzome.core.algebra.AlgebraicVector;

        isUnnecessary(): boolean;

        addConstruction(mConstruction: com.vzome.core.construction.Construction);

        removeConstruction(mConstruction: com.vzome.core.construction.Construction);

        setHidden(b: boolean);

        getContainer(): com.vzome.core.model.Group;

        getColor(): com.vzome.core.construction.Color;

        setColor(color: com.vzome.core.construction.Color);

        setRenderedObject(renderedObject: com.vzome.core.model.RenderedObject);

        setLabel(label: string);

        getLabel(): string;
    }
}
namespace com.vzome.core.model {
    export interface RenderedObject {
        getShape(): com.vzome.core.math.Polyhedron;

        getOrientation(): com.vzome.core.algebra.AlgebraicMatrix;

        getLocationAV(): com.vzome.core.algebra.AlgebraicVector;

        getSymmetryShapes(): string;

        resetAttributes(oneSidedPanels: boolean, colorPanels: boolean);
    }
}
namespace com.vzome.core.model {
    export interface HasRenderedObject {
        getRenderedObject(): com.vzome.core.model.RenderedObject;
    }
}
namespace com.vzome.core.model {
    export interface Connector extends com.vzome.core.model.Manifestation, java.lang.Comparable<Connector> {
        compareTo(other: Connector): number;
    }
}
namespace com.vzome.core.model {
    export interface ManifestationChanges {
        manifestationAdded(m: com.vzome.core.model.Manifestation);

        manifestationRemoved(m: com.vzome.core.model.Manifestation);

        manifestationColored(m: com.vzome.core.model.Manifestation, color: com.vzome.core.construction.Color);

        manifestationLabeled(m: com.vzome.core.model.Manifestation, label: string);
    }
}
namespace com.vzome.core.model {
    export interface Panel extends com.vzome.core.model.Manifestation, java.lang.Iterable<com.vzome.core.algebra.AlgebraicVector> {
        getZoneVector(): com.vzome.core.algebra.AlgebraicVector;

        setZoneVector(vector: com.vzome.core.algebra.AlgebraicVector);

        getFirstVertex(): com.vzome.core.algebra.AlgebraicVector;

        /**
         * 
         * @return {*}
         */
        iterator(): java.util.Iterator<com.vzome.core.algebra.AlgebraicVector>;

        getVertexCount(): number;

        getNormal(embedding?: any): any;

        getQuadrea(): com.vzome.core.algebra.AlgebraicNumber;
    }
}
namespace com.vzome.core.model {
    /**
     * @author Scott Vorthmann
     * @param {*} field
     * @param {*} projection
     * @class
     */
    export class RealizedModelImpl implements com.vzome.core.model.RealizedModel {
        /*private*/ mListeners: java.util.List<com.vzome.core.model.ManifestationChanges>;

        /*private*/ mManifestations: java.util.HashMap<string, com.vzome.core.model.Manifestation>;

        /*private*/ mProjection: com.vzome.core.math.Projection;

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        public constructor(field: com.vzome.core.algebra.AlgebraicField, projection: com.vzome.core.math.Projection) {
            this.mListeners = <any>(new java.util.ArrayList<any>(1));
            this.mManifestations = <any>(new java.util.LinkedHashMap<any, any>(1000));
            if (this.mProjection === undefined) { this.mProjection = null; }
            if (this.field === undefined) { this.field = null; }
            this.doingBatch = false;
            this.additions = <any>(new java.util.HashSet<any>());
            this.removals = <any>(new java.util.HashSet<any>());
            if (this.mManifestedNow === undefined) { this.mManifestedNow = null; }
            this.field = field;
            this.mProjection = projection;
        }

        public moreVisibleThan(other: RealizedModelImpl): java.util.Set<com.vzome.core.model.Manifestation> {
            const result: java.util.Set<com.vzome.core.model.Manifestation> = <any>(new java.util.HashSet<any>());
            for(let index=this.mManifestations.values().iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (man.isHidden())continue;
                    const doppel: com.vzome.core.model.Manifestation = other.mManifestations.get(man.toConstruction().getSignature());
                    if (doppel == null || doppel.isHidden())result.add(man);
                }
            }
            return result;
        }

        public addListener(l: com.vzome.core.model.ManifestationChanges) {
            this.mListeners.add(l);
        }

        public removeListener(l: com.vzome.core.model.ManifestationChanges) {
            this.mListeners.remove(l);
        }

        /**
         * 
         * @return {*}
         */
        public iterator(): java.util.Iterator<com.vzome.core.model.Manifestation> {
            return this.mManifestations.values().iterator();
        }

        public manifest(c: com.vzome.core.construction.Construction): com.vzome.core.model.Manifestation {
            let m: com.vzome.core.model.Manifestation = null;
            if (c != null && c instanceof <any>com.vzome.core.construction.Point){
                const p: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>c;
                m = new com.vzome.core.model.ConnectorImpl(this.mProjection.projectImage(p.getLocation(), true));
            } else if (c != null && c instanceof <any>com.vzome.core.construction.Segment){
                const s: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>c;
                const start: com.vzome.core.algebra.AlgebraicVector = this.mProjection.projectImage(s.getStart(), true);
                const end: com.vzome.core.algebra.AlgebraicVector = this.mProjection.projectImage(s.getEnd(), true);
                if (!start.equals(end)){
                    m = new com.vzome.core.model.StrutImpl(start, end);
                }
            } else if (c != null && c instanceof <any>com.vzome.core.construction.Polygon){
                const p: com.vzome.core.construction.Polygon = <com.vzome.core.construction.Polygon>c;
                const vertices: java.util.List<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>());
                for(let i: number = 0; i < p.getVertexCount(); i++) {{
                    vertices.add(this.mProjection.projectImage(p.getVertex(i), true));
                };}
                m = new com.vzome.core.model.PanelImpl(vertices);
            }
            return m;
        }

        static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (RealizedModelImpl.logger == null) { RealizedModelImpl.logger = java.util.logging.Logger.getLogger("com.vzome.core.model"); }  return RealizedModelImpl.logger; }

        /**
         * 
         * @param {*} m
         */
        public add(m: com.vzome.core.model.Manifestation) {
            const key: string = m.toConstruction().getSignature();
            this.mManifestations.put(key, m);
            if (RealizedModelImpl.logger_$LI$().isLoggable(java.util.logging.Level.FINER))RealizedModelImpl.logger_$LI$().finer("add manifestation: " + m.toString());
        }

        /**
         * 
         * @param {*} m
         */
        public remove(m: com.vzome.core.model.Manifestation) {
            const key: string = m.toConstruction().getSignature();
            this.mManifestations.remove(key);
            if (RealizedModelImpl.logger_$LI$().isLoggable(java.util.logging.Level.FINER))RealizedModelImpl.logger_$LI$().finer("remove manifestation: " + m.toString());
        }

        public refresh(on: boolean, unused: RealizedModelImpl) {
            for(let index=this.mManifestations.values().iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (!man.isHidden()){
                        if (on)this.show(man); else this.hide(man);
                    }
                }
            }
        }

        /**
         * 
         * @param {*} m
         */
        public show(m: com.vzome.core.model.Manifestation) {
            if (this.doingBatch){
                if (this.removals.contains(m))this.removals.remove(m); else this.additions.add(m);
            } else this.privateShow(m);
        }

        /*private*/ privateShow(m: com.vzome.core.model.Manifestation) {
            if (!m.isRendered()){
                for(let index=this.mListeners.iterator();index.hasNext();) {
                    let next = index.next();
                    {
                        next.manifestationAdded(m);
                    }
                }
            }
        }

        /**
         * 
         * @param {*} m
         */
        public hide(m: com.vzome.core.model.Manifestation) {
            if (this.doingBatch){
                if (this.additions.contains(m))this.additions.remove(m); else this.removals.add(m);
            } else this.privateHide(m);
        }

        /*private*/ privateHide(m: com.vzome.core.model.Manifestation) {
            if (m.isRendered()){
                for(let index=this.mListeners.iterator();index.hasNext();) {
                    let next = index.next();
                    {
                        next.manifestationRemoved(m);
                    }
                }
            }
        }

        /**
         * 
         * @param {*} m
         * @param {com.vzome.core.construction.Color} color
         */
        public setColor(m: com.vzome.core.model.Manifestation, color: com.vzome.core.construction.Color) {
            m.setColor(color);
            if (m.isRendered()){
                for(let index=this.mListeners.iterator();index.hasNext();) {
                    let next = index.next();
                    {
                        next.manifestationColored(m, color);
                    }
                }
            }
        }

        /**
         * 
         * @param {*} m
         * @param {string} label
         */
        public setLabel(m: com.vzome.core.model.Manifestation, label: string) {
            m.setLabel(label);
            if (m.isRendered()){
                for(let index=this.mListeners.iterator();index.hasNext();) {
                    let next = index.next();
                    {
                        next.manifestationLabeled(m, label);
                    }
                }
            }
        }

        /**
         * 
         * @param {com.vzome.core.construction.Construction} c
         * @return {*}
         */
        public findConstruction(c: com.vzome.core.construction.Construction): com.vzome.core.model.Manifestation {
            let actualMan: com.vzome.core.model.Manifestation = this.mManifestations.get(c.getSignature());
            if (actualMan == null)actualMan = this.manifest(c);
            return actualMan;
        }

        /**
         * 
         * @param {com.vzome.core.construction.Construction} c
         * @return {*}
         */
        public removeConstruction(c: com.vzome.core.construction.Construction): com.vzome.core.model.Manifestation {
            const actualMan: com.vzome.core.model.Manifestation = this.mManifestations.get(c.getSignature());
            if (actualMan == null)return null;
            return this.manifest(c);
        }

        /**
         * @param {com.vzome.core.construction.Construction} c
         * @return
         * @return {*}
         */
        public getManifestation(c: com.vzome.core.construction.Construction): com.vzome.core.model.Manifestation {
            return this.mManifestations.get(c.getSignature());
        }

        /**
         * 
         * @return {number}
         */
        public size(): number {
            return this.mManifestations.size();
        }

        /**
         * 
         * @param {*} object
         * @return {boolean}
         */
        public equals(object: any): boolean {
            if (object == null){
                return false;
            }
            if (object === this){
                return true;
            }
            if (!(object != null && object instanceof <any>com.vzome.core.model.RealizedModelImpl))return false;
            const that: RealizedModelImpl = <RealizedModelImpl>object;
            if (this.size() !== that.size())return false;
            for(let index=this.mManifestations.values().iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (!that.mManifestations.values().contains(man)){
                        return false;
                    }
                }
            }
            return true;
        }

        /**
         * 
         * @return {number}
         */
        public hashCode(): number {
            return this.size();
        }

        /*private*/ doingBatch: boolean;

        /*private*/ additions: java.util.Set<com.vzome.core.model.Manifestation>;

        /*private*/ removals: java.util.Set<com.vzome.core.model.Manifestation>;

        public startBatch() {
            this.additions.clear();
            this.removals.clear();
            this.doingBatch = true;
        }

        public endBatch() {
            for(let index=this.removals.iterator();index.hasNext();) {
                let m = index.next();
                {
                    this.privateHide(m);
                }
            }
            for(let index=this.additions.iterator();index.hasNext();) {
                let m = index.next();
                {
                    this.privateShow(m);
                }
            }
            this.additions.clear();
            this.removals.clear();
            this.doingBatch = false;
        }

        /**
         * 
         * @return {*}
         */
        public getField(): com.vzome.core.algebra.AlgebraicField {
            return this.field;
        }

        /**
         * This records the NEW manifestations produced by manifestConstruction for this edit,
         * to avoid creating colliding manifestations.
         */
        /*private*/ mManifestedNow: java.util.Map<string, com.vzome.core.model.Manifestation>;

        /**
         * 
         * @param {string} signature
         * @return {*}
         */
        public findPerEditManifestation(signature: string): com.vzome.core.model.Manifestation {
            return this.mManifestedNow.get(signature);
        }

        /**
         * 
         * @param {string} signature
         * @param {*} m
         */
        public addPerEditManifestation(signature: string, m: com.vzome.core.model.Manifestation) {
            this.mManifestedNow.put(signature, m);
        }

        /**
         * 
         */
        public clearPerEditManifestations() {
            this.mManifestedNow = <any>(new java.util.HashMap<any, any>());
        }
    }
    RealizedModelImpl["__class"] = "com.vzome.core.model.RealizedModelImpl";
    RealizedModelImpl["__interfaces"] = ["com.vzome.core.model.RealizedModel","java.lang.Iterable"];


}
namespace com.vzome.core.model {
    /**
     * @author David Hall
     * @class
     */
    export interface GroupElement {
        setContainer(container: com.vzome.core.model.Group);
    }
}
namespace com.vzome.core.model {
    export interface Strut extends com.vzome.core.model.Manifestation, java.lang.Comparable<Strut> {
        getZoneVector(): com.vzome.core.algebra.AlgebraicVector;

        setZoneVector(vector: com.vzome.core.algebra.AlgebraicVector);

        /**
         * 
         * @param {*} other
         * @return {number}
         */
        compareTo(other: Strut): number;

        getCanonicalLesserEnd(): com.vzome.core.algebra.AlgebraicVector;

        getCanonicalGreaterEnd(): com.vzome.core.algebra.AlgebraicVector;

        getEnd(): com.vzome.core.algebra.AlgebraicVector;

        getOffset(): com.vzome.core.algebra.AlgebraicVector;
    }
}
namespace com.vzome.core.model {
    /**
     * @author Scott Vorthmann
     * @class
     */
    export abstract class ManifestationImpl implements com.vzome.core.model.GroupElement, com.vzome.core.model.Manifestation, com.vzome.core.model.HasRenderedObject {
        mManifests: java.util.List<com.vzome.core.construction.Construction>;

        mRendered: com.vzome.core.render.RenderedManifestation;

        /*private*/ hidden: boolean;

        /*private*/ mId: number;

        /*private*/ color: com.vzome.core.construction.Color;

        static NO_ID: number = -1;

        static NEXT_ID: number = 0;

        resetId() {
            ManifestationImpl.NEXT_ID = 0;
            this.mId = ManifestationImpl.NO_ID;
        }

        getId(): number {
            if (this.mId === ManifestationImpl.NO_ID)this.mId = ManifestationImpl.NEXT_ID++;
            return this.mId;
        }

        public addConstruction(c: com.vzome.core.construction.Construction) {
            this.mManifests.add(c);
        }

        public removeConstruction(c: com.vzome.core.construction.Construction) {
            this.mManifests.remove(c);
        }

        public getConstructions(): java.util.Iterator<com.vzome.core.construction.Construction> {
            return this.mManifests.iterator();
        }

        /**
         * This is different from toConstruction, because we must support
         * the legacy behavior, which used the iterator.
         * @return
         * @return {com.vzome.core.construction.Construction}
         */
        public getFirstConstruction(): com.vzome.core.construction.Construction {
            if (this.mManifests.isEmpty())return null;
            return this.mManifests.iterator().next();
        }

        public isUnnecessary(): boolean {
            return this.mManifests.isEmpty();
        }

        public getColor(): com.vzome.core.construction.Color {
            if (this.color == null && this.mRendered != null){
                this.color = this.mRendered.getColor();
            }
            return this.color;
        }

        public setColor(color: com.vzome.core.construction.Color) {
            this.color = color;
        }

        public setRenderedObject(obj: com.vzome.core.model.RenderedObject) {
            this.mRendered = <com.vzome.core.render.RenderedManifestation><any>obj;
            if (this.mRendered != null)this.color = this.mRendered.getColor();
        }

        public getRenderedObject(): com.vzome.core.model.RenderedObject {
            return this.mRendered;
        }

        public isHidden(): boolean {
            return this.hidden;
        }

        public abstract getLocation(): com.vzome.core.algebra.AlgebraicVector;

        public abstract getCentroid(): com.vzome.core.algebra.AlgebraicVector;

        /**
         * This is guaranteed to return a 3D construction,
         * and will return the same object as getFirstConstruction()
         * when possible.
         * @return
         * @return {com.vzome.core.construction.Construction}
         */
        public abstract toConstruction(): com.vzome.core.construction.Construction;

        /*private*/ mContainer: com.vzome.core.model.Group;

        public getContainer(): com.vzome.core.model.Group {
            return this.mContainer;
        }

        /**
         * 
         * @param {com.vzome.core.model.Group} container
         */
        public setContainer(container: com.vzome.core.model.Group) {
            this.mContainer = container;
        }

        public setHidden(hidden: boolean) {
            this.hidden = hidden;
        }

        public isRendered(): boolean {
            return this.mRendered != null;
        }

        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            return this.toConstruction().getXml(doc);
        }

        public abstract getLabel(): any;
        public abstract setLabel(label?: any): any;
        constructor() {
            this.mManifests = <any>(new java.util.ArrayList<any>());
            this.mRendered = null;
            this.hidden = false;
            this.mId = ManifestationImpl.NO_ID;
            if (this.color === undefined) { this.color = null; }
            if (this.mContainer === undefined) { this.mContainer = null; }
        }
    }
    ManifestationImpl["__class"] = "com.vzome.core.model.ManifestationImpl";
    ManifestationImpl["__interfaces"] = ["com.vzome.core.model.HasRenderedObject","com.vzome.core.model.GroupElement","com.vzome.core.model.Manifestation"];


}
namespace com.vzome.core.model {
    export interface Exporter {
        exportManifestation(man: com.vzome.core.model.Manifestation);

        finish();
    }
}
namespace com.vzome.core.parts {
    /**
     * @author Scott Vorthmann
     * 
     * Since every field allows octahedral symmetry, we want the richest triangular
     * tiling of that symmetry, which means we want the fundamental triangles of
     * the reflection group, by definition.  Rather than rely on any symmetry orbits,
     * we can simply hard-code the vertices of a disdyakis dodecahedron, all
     * reflections and permutations of (8,0,0), (4,4,4), and (5,5,0).
     * (This is a simple approximation with integers.)
     * These vertices correspond to blue-like, yellow-like, and green-like axes,
     * in the usual Zome coloring.
     * @param {com.vzome.core.math.symmetry.Direction} dir
     * @class
     */
    export class FastDefaultStrutGeometry implements com.vzome.core.parts.StrutGeometry {
        /*private*/ g2_vector: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ b2_vector: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ y2_vector: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ g2n_vector: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ y2n_vector: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ mAxis: com.vzome.core.math.symmetry.Axis;

        public getFast(): boolean {
            return true;
        }

        public constructor(dir: com.vzome.core.math.symmetry.Direction) {
            if (this.g2_vector === undefined) { this.g2_vector = null; }
            if (this.b2_vector === undefined) { this.b2_vector = null; }
            if (this.y2_vector === undefined) { this.y2_vector = null; }
            if (this.g2n_vector === undefined) { this.g2n_vector = null; }
            if (this.y2n_vector === undefined) { this.y2n_vector = null; }
            if (this.mAxis === undefined) { this.mAxis = null; }
            this.mAxis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 0);
            const v: com.vzome.core.algebra.AlgebraicVector = this.mAxis.normal();
            let x: number = v.getComponent(com.vzome.core.algebra.AlgebraicVector.X).evaluate();
            let y: number = v.getComponent(com.vzome.core.algebra.AlgebraicVector.Y).evaluate();
            let z: number = v.getComponent(com.vzome.core.algebra.AlgebraicVector.Z).evaluate();
            let evenParity: boolean = true;
            const xNeg: boolean = x < 0.0;
            if (xNeg){
                x = -x;
                evenParity = !evenParity;
            }
            const yNeg: boolean = y < 0.0;
            if (yNeg){
                y = -y;
                evenParity = !evenParity;
            }
            const zNeg: boolean = z < 0.0;
            if (zNeg){
                z = -z;
                evenParity = !evenParity;
            }
            let first: number;
            let second: number;
            let third: number;
            let firstNeg: boolean;
            let secondNeg: boolean;
            let thirdNeg: boolean;
            if (x >= y){
                if (y >= z){
                    first = com.vzome.core.algebra.AlgebraicVector.X;
                    firstNeg = xNeg;
                    second = com.vzome.core.algebra.AlgebraicVector.Y;
                    secondNeg = yNeg;
                    third = com.vzome.core.algebra.AlgebraicVector.Z;
                    thirdNeg = zNeg;
                } else if (x >= z){
                    first = com.vzome.core.algebra.AlgebraicVector.X;
                    firstNeg = xNeg;
                    second = com.vzome.core.algebra.AlgebraicVector.Z;
                    secondNeg = zNeg;
                    third = com.vzome.core.algebra.AlgebraicVector.Y;
                    thirdNeg = yNeg;
                    evenParity = !evenParity;
                } else {
                    first = com.vzome.core.algebra.AlgebraicVector.Z;
                    firstNeg = zNeg;
                    second = com.vzome.core.algebra.AlgebraicVector.X;
                    secondNeg = xNeg;
                    third = com.vzome.core.algebra.AlgebraicVector.Y;
                    thirdNeg = yNeg;
                }
            } else {
                if (x >= z){
                    first = com.vzome.core.algebra.AlgebraicVector.Y;
                    firstNeg = yNeg;
                    second = com.vzome.core.algebra.AlgebraicVector.X;
                    secondNeg = xNeg;
                    third = com.vzome.core.algebra.AlgebraicVector.Z;
                    thirdNeg = zNeg;
                    evenParity = !evenParity;
                } else if (y >= z){
                    first = com.vzome.core.algebra.AlgebraicVector.Y;
                    firstNeg = yNeg;
                    second = com.vzome.core.algebra.AlgebraicVector.Z;
                    secondNeg = zNeg;
                    third = com.vzome.core.algebra.AlgebraicVector.X;
                    thirdNeg = xNeg;
                } else {
                    first = com.vzome.core.algebra.AlgebraicVector.Z;
                    firstNeg = zNeg;
                    second = com.vzome.core.algebra.AlgebraicVector.Y;
                    secondNeg = yNeg;
                    third = com.vzome.core.algebra.AlgebraicVector.X;
                    thirdNeg = xNeg;
                    evenParity = !evenParity;
                }
            }
            const field: com.vzome.core.algebra.AlgebraicField = v.getField();
            const eight: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long$long'](8, 10);
            this.b2_vector = field.origin(3);
            this.b2_vector.setComponent(first, firstNeg ? eight.negate() : eight);
            const five: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long$long'](5, 10);
            this.g2_vector = field.origin(3);
            this.g2_vector.setComponent(first, firstNeg ? five.negate() : five);
            this.g2_vector.setComponent(second, secondNeg ? five.negate() : five);
            const four: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long$long'](4, 10);
            this.y2_vector = field.origin(3);
            this.y2_vector.setComponent(first, firstNeg ? four.negate() : four);
            this.y2_vector.setComponent(second, secondNeg ? four.negate() : four);
            this.y2_vector.setComponent(third, thirdNeg ? four.negate() : four);
            if (!evenParity){
                const swap: com.vzome.core.algebra.AlgebraicVector = this.y2_vector;
                this.y2_vector = this.g2_vector;
                this.g2_vector = swap;
            }
            const centroid: com.vzome.core.algebra.AlgebraicVector = com.vzome.core.algebra.AlgebraicVectors.getCentroid([this.b2_vector, this.g2_vector, this.y2_vector]);
            const b2g2: com.vzome.core.algebra.AlgebraicVector = this.g2_vector.minus(this.b2_vector);
            const y2g2: com.vzome.core.algebra.AlgebraicVector = this.g2_vector.minus(this.y2_vector);
            const normal: com.vzome.core.algebra.AlgebraicVector = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(b2g2, y2g2);
            const intersection: com.vzome.core.algebra.AlgebraicVector = com.vzome.core.algebra.AlgebraicVectors.getLinePlaneIntersection(field.origin(3), v, this.g2_vector, normal);
            const g2_offset: com.vzome.core.algebra.AlgebraicVector = this.g2_vector.minus(centroid);
            const y2_offset: com.vzome.core.algebra.AlgebraicVector = this.y2_vector.minus(centroid);
            this.g2_vector = intersection.plus(g2_offset);
            this.y2_vector = intersection.plus(y2_offset);
            this.g2n_vector = intersection.minus(g2_offset);
            this.y2n_vector = intersection.minus(y2_offset);
        }

        /**
         * 
         * @param {*} length
         * @return {com.vzome.core.math.Polyhedron}
         */
        public getStrutPolyhedron(length: com.vzome.core.algebra.AlgebraicNumber): com.vzome.core.math.Polyhedron {
            const field: com.vzome.core.algebra.AlgebraicField = this.mAxis.getDirection().getSymmetry().getField();
            const poly: com.vzome.core.math.Polyhedron = new com.vzome.core.math.Polyhedron(field);
            const strutVector: com.vzome.core.algebra.AlgebraicVector = this.mAxis.normal().scale(length);
            const g1_vector: com.vzome.core.algebra.AlgebraicVector = this.g2_vector.negate().plus(strutVector);
            const y1_vector: com.vzome.core.algebra.AlgebraicVector = this.y2_vector.negate().plus(strutVector);
            const g1n_vector: com.vzome.core.algebra.AlgebraicVector = this.g2n_vector.negate().plus(strutVector);
            const y1n_vector: com.vzome.core.algebra.AlgebraicVector = this.y2n_vector.negate().plus(strutVector);
            poly.addVertex(y1_vector);
            const y1: number = 0;
            poly.addVertex(g1_vector);
            const g1: number = 1;
            poly.addVertex(this.y2_vector);
            const y2: number = 2;
            poly.addVertex(this.g2_vector);
            const g2: number = 3;
            poly.addVertex(y1n_vector);
            const y1n: number = 4;
            poly.addVertex(g1n_vector);
            const g1n: number = 5;
            poly.addVertex(this.y2n_vector);
            const y2n: number = 6;
            poly.addVertex(this.g2n_vector);
            const g2n: number = 7;
            let face: com.vzome.core.math.Polyhedron.Face = poly.newFace();
            face.add(g2);
            face.add(y2);
            face.add(y1n);
            face.add(g1n);
            poly.addFace(face);
            face = poly.newFace();
            face.add(g2);
            face.add(g1n);
            face.add(y1);
            face.add(y2n);
            poly.addFace(face);
            face = poly.newFace();
            face.add(g2n);
            face.add(y2n);
            face.add(y1);
            face.add(g1);
            poly.addFace(face);
            face = poly.newFace();
            face.add(g2n);
            face.add(g1);
            face.add(y1n);
            face.add(y2);
            poly.addFace(face);
            face = poly.newFace();
            face.add(y2);
            face.add(g2);
            face.add(y2n);
            face.add(g2n);
            poly.addFace(face);
            face = poly.newFace();
            face.add(g1);
            face.add(y1);
            face.add(g1n);
            face.add(y1n);
            poly.addFace(face);
            return poly;
        }
    }
    FastDefaultStrutGeometry["__class"] = "com.vzome.core.parts.FastDefaultStrutGeometry";
    FastDefaultStrutGeometry["__interfaces"] = ["com.vzome.core.parts.StrutGeometry"];


}
namespace com.vzome.core.parts {
    /**
     * @author Scott Vorthmann
     * @class
     */
    export interface StrutGeometry {
        getStrutPolyhedron(length: com.vzome.core.algebra.AlgebraicNumber): com.vzome.core.math.Polyhedron;
    }
}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @class
     */
    export abstract class Construction {
        field: com.vzome.core.algebra.AlgebraicField;

        /**
         * true for "impossible" constructions
         */
        /*private*/ mImpossible: boolean;

        constructor(field: com.vzome.core.algebra.AlgebraicField) {
            if (this.field === undefined) { this.field = null; }
            this.mImpossible = false;
            this.mIndex = -1;
            this.__failed = false;
            if (this.color === undefined) { this.color = null; }
            this.field = field;
        }

        public getField(): com.vzome.core.algebra.AlgebraicField {
            return this.field;
        }

        /*private*/ mIndex: number;

        public setIndex(index: number) {
            this.mIndex = index;
        }

        public getIndex(): number {
            return this.mIndex;
        }

        public isImpossible(): boolean {
            return this.mImpossible;
        }

        public setImpossible(value: boolean) {
            this.mImpossible = value;
        }

        public abstract is3d(): boolean;

        /**
         * Update the state variables (like location) of this construction
         * according to the current parameters and attributes.
         * 
         * This function does NOT propagate updates to derivatives,
         * nor does it notify listeners or otherwise drive rendering.
         * 
         * @return {boolean} true if the state changed.
         */
        abstract mapParamsToState(): boolean;

        public abstract getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element;

        /*private*/ __failed: boolean;

        /*private*/ color: com.vzome.core.construction.Color;

        public setFailed() {
            this.__failed = true;
        }

        public failed(): boolean {
            return this.__failed;
        }

        public setColor(color: com.vzome.core.construction.Color) {
            this.color = color;
        }

        public getColor(): com.vzome.core.construction.Color {
            return this.color;
        }

        public getSignature(): string {
            return "";
        }
    }
    Construction["__class"] = "com.vzome.core.construction.Construction";

}
namespace com.vzome.core.construction {
    export interface ConstructionChanges {
        constructionAdded(c?: any, color?: any);
    }
}
namespace com.vzome.core.construction {
    /**
     * A selection in the model.
     * @class
     * @extends java.util.ArrayList
     */
    export class ConstructionList extends java.util.ArrayList<com.vzome.core.construction.Construction> {
        public addConstruction(ball: com.vzome.core.construction.Construction): ConstructionList {
            this.add(ball);
            return this;
        }

        public removeConstruction(ball: com.vzome.core.construction.Construction): ConstructionList {
            this.remove(ball);
            return this;
        }

        public getConstructions(): com.vzome.core.construction.Construction[] {
            return this.toArray<any>((s => { let a=[]; while(s-->0) a.push(null); return a; })(this.size()));
        }

        constructor() {
            super();
        }
    }
    ConstructionList["__class"] = "com.vzome.core.construction.ConstructionList";
    ConstructionList["__interfaces"] = ["java.util.RandomAccess","java.util.List","java.lang.Cloneable","java.util.Collection","java.lang.Iterable","java.io.Serializable"];


}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @param {number} r
     * @param {number} g
     * @param {number} b
     * @param {number} a
     * @class
     */
    export class Color {
        public static BLACK: Color; public static BLACK_$LI$(): Color { if (Color.BLACK == null) { Color.BLACK = new Color(0, 0, 0); }  return Color.BLACK; }

        public static WHITE: Color; public static WHITE_$LI$(): Color { if (Color.WHITE == null) { Color.WHITE = new Color(255, 255, 255); }  return Color.WHITE; }

        public static GREY_TRANSPARENT: Color; public static GREY_TRANSPARENT_$LI$(): Color { if (Color.GREY_TRANSPARENT == null) { Color.GREY_TRANSPARENT = new Color(25, 25, 25, 50); }  return Color.GREY_TRANSPARENT; }

        /*private*/ red: number;

        /*private*/ green: number;

        /*private*/ blue: number;

        /*private*/ alpha: number;

        public constructor(r?: any, g?: any, b?: any, a?: any) {
            if (((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null) && ((typeof a === 'number') || a === null)) {
                let __args = arguments;
                if (this.red === undefined) { this.red = 0; } 
                if (this.green === undefined) { this.green = 0; } 
                if (this.blue === undefined) { this.blue = 0; } 
                if (this.alpha === undefined) { this.alpha = 0; } 
                this.red = r > 255 ? 255 : (r < 0 ? 0 : r);
                this.green = g > 255 ? 255 : (g < 0 ? 0 : g);
                this.blue = b > 255 ? 255 : (b < 0 ? 0 : b);
                this.alpha = a > 255 ? 255 : (a < 0 ? 0 : a);
            } else if (((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null) && a === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let a: any = 255;
                    if (this.red === undefined) { this.red = 0; } 
                    if (this.green === undefined) { this.green = 0; } 
                    if (this.blue === undefined) { this.blue = 0; } 
                    if (this.alpha === undefined) { this.alpha = 0; } 
                    this.red = r > 255 ? 255 : (r < 0 ? 0 : r);
                    this.green = g > 255 ? 255 : (g < 0 ? 0 : g);
                    this.blue = b > 255 ? 255 : (b < 0 ? 0 : b);
                    this.alpha = a > 255 ? 255 : (a < 0 ? 0 : a);
                }
            } else if (((typeof r === 'string') || r === null) && g === undefined && b === undefined && a === undefined) {
                let __args = arguments;
                let rgbaHex: any = __args[0];
                if (this.red === undefined) { this.red = 0; } 
                if (this.green === undefined) { this.green = 0; } 
                if (this.blue === undefined) { this.blue = 0; } 
                if (this.alpha === undefined) { this.alpha = 0; } 
                const padded: string = "00000000" + rgbaHex;
                rgbaHex = padded.substring(padded.length - 8);
                const r: number = javaemul.internal.IntegerHelper.parseInt(rgbaHex.substring(0, 2), 16);
                const g: number = javaemul.internal.IntegerHelper.parseInt(rgbaHex.substring(2, 4), 16);
                const b: number = javaemul.internal.IntegerHelper.parseInt(rgbaHex.substring(4, 6), 16);
                const a: number = javaemul.internal.IntegerHelper.parseInt(rgbaHex.substring(6, 8), 16);
                this.red = r > 255 ? 255 : (r < 0 ? 0 : r);
                this.green = g > 255 ? 255 : (g < 0 ? 0 : g);
                this.blue = b > 255 ? 255 : (b < 0 ? 0 : b);
                this.alpha = a > 255 ? 255 : (a < 0 ? 0 : a);
            } else if (((typeof r === 'number') || r === null) && g === undefined && b === undefined && a === undefined) {
                let __args = arguments;
                let rgb: any = __args[0];
                {
                    let __args = arguments;
                    let r: any = (rgb >> 16) & 255;
                    let g: any = (rgb >> 8) & 255;
                    let b: any = rgb & 255;
                    {
                        let __args = arguments;
                        let a: any = 255;
                        if (this.red === undefined) { this.red = 0; } 
                        if (this.green === undefined) { this.green = 0; } 
                        if (this.blue === undefined) { this.blue = 0; } 
                        if (this.alpha === undefined) { this.alpha = 0; } 
                        this.red = r > 255 ? 255 : (r < 0 ? 0 : r);
                        this.green = g > 255 ? 255 : (g < 0 ? 0 : g);
                        this.blue = b > 255 ? 255 : (b < 0 ? 0 : b);
                        this.alpha = a > 255 ? 255 : (a < 0 ? 0 : a);
                    }
                }
            } else throw new Error('invalid overload');
        }

        public getRGBColorComponents(rgb: number[]): number[] {
            const len: number = rgb.length;
            if (len < 3 || len > 4){
                throw new java.lang.IllegalArgumentException("Expected rgb.length to be 3 or 4. Found " + len + ".");
            }
            rgb[0] = (<any>Math).fround(this.red / 255.0);
            rgb[1] = (<any>Math).fround(this.green / 255.0);
            rgb[2] = (<any>Math).fround(this.blue / 255.0);
            if (len === 4){
                rgb[3] = (<any>Math).fround(this.alpha / 255.0);
            }
            return rgb;
        }

        /**
         * 
         * @return {number}
         */
        public hashCode(): number {
            return this.getRGBA();
        }

        /**
         * 
         * @param {*} other
         * @return {boolean}
         */
        public equals(other: any): boolean {
            if (this === other)return true;
            if (other == null)return true;
            if (!(other != null && other instanceof <any>com.vzome.core.construction.Color))return false;
            const c: Color = <Color>other;
            return this.red === c.red && this.green === c.green && this.blue === c.blue && this.alpha === c.alpha;
        }

        public getPastel(): Color {
            const r: number = this.red + ((255 - this.red) / 2|0);
            const g: number = this.green + ((255 - this.green) / 2|0);
            const b: number = this.blue + ((255 - this.blue) / 2|0);
            return new Color(r, g, b, this.alpha);
        }

        /**
         * @return
         * @return {number}
         */
        public getRGBA(): number {
            return this.red * 16777216 + this.green * 65536 + this.blue * 256 + this.alpha;
        }

        public getRGB(): number {
            return this.red * 65536 + this.green * 256 + this.blue;
        }

        /**
         * 
         * @return {string}
         */
        public toString(): string {
            return this.red + "," + this.green + "," + this.blue + ((this.alpha < 255) ? "," + this.alpha : "");
        }

        public toWebString(): string {
            return javaemul.internal.StringHelper.format("#%02X%02X%02X", this.red, this.green, this.blue);
        }

        public static parseColor(str: string): Color {
            const toks: java.util.StringTokenizer = new java.util.StringTokenizer(str, ",");
            const red: string = toks.nextToken();
            const green: string = toks.nextToken();
            const blue: string = toks.nextToken();
            return new Color(javaemul.internal.IntegerHelper.parseInt(red), javaemul.internal.IntegerHelper.parseInt(green), javaemul.internal.IntegerHelper.parseInt(blue));
        }

        public static parseWebColor(colorStr: string): Color {
            return new Color(/* intValue */(javaemul.internal.IntegerHelper.valueOf(colorStr.substring(1, 3), 16)|0), /* intValue */(javaemul.internal.IntegerHelper.valueOf(colorStr.substring(3, 5), 16)|0), /* intValue */(javaemul.internal.IntegerHelper.valueOf(colorStr.substring(5, 7), 16)|0));
        }

        public getRed(): number {
            return this.red;
        }

        public getGreen(): number {
            return this.green;
        }

        public getBlue(): number {
            return this.blue;
        }

        public getAlpha(): number {
            return this.alpha;
        }

        public static getComplement(color: Color): Color {
            return (color == null) ? null : new Color((128 + color.red) % 256, (128 + color.green) % 256, (128 + color.blue) % 256, color.alpha);
        }

        public static getInverted(color: Color): Color {
            return (color == null) ? null : new Color(255 - color.red, 255 - color.green, 255 - color.blue, color.alpha);
        }

        /**
         * @param {com.vzome.core.construction.Color} color color to be modified.
         * @param {number} scale0to1 is adjusted internally to be between 0 and 1.
         * @return {com.vzome.core.construction.Color} The original color maximized then having each component
         * multiplied by the specified scale (between 0 and 1).
         * Multiplying by 0 returns BLACK.
         * Multiplying by 1 returns the maximized color.
         */
        public static getScaledTo(color: Color, scale0to1: number): Color {
            if (color == null){
                return null;
            }
            const maxColor: Color = Color.getMaximum(color);
            const scale: number = Math.min(Math.max(0.0, scale0to1), 1.0);
            if (scale === 0.0)return Color.BLACK_$LI$();
            if (scale === 1.0)return maxColor;
            const red: number = maxColor.getRed() * scale;
            const green: number = maxColor.getGreen() * scale;
            const blue: number = maxColor.getBlue() * scale;
            return new Color(/* intValue */(red|0), /* intValue */(green|0), /* intValue */(blue|0), color.getAlpha());
        }

        /**
         * @param {com.vzome.core.construction.Color} color
         * @return {com.vzome.core.construction.Color} A new color where each of the RGB components are proportional to the parameter
         * but scaled so that the component with the highest value becomes 0xFF.
         * Other components are scaled proportionally. The alpha component is unchanged.
         * If the color is null or BLACK (0,0,0) or if one or more elements are already at 0xFF
         * then the original value is returned unchanged.
         */
        public static getMaximum(color: Color): Color {
            if (color == null){
                return null;
            }
            const most: number = Math.max(Math.max(color.red, color.green), color.blue);
            return (most === 0 || most === 255) ? color : new Color((255 * color.red / most|0), (255 * color.green / most|0), (255 * color.blue / most|0), color.alpha);
        }

        public static getPastel(color: Color): Color {
            return (color == null) ? null : color.getPastel();
        }
    }
    Color["__class"] = "com.vzome.core.construction.Color";

}
namespace com.vzome.core.generic {
    /**
     * @author David Hall
     * @class
     */
    export class ArrayComparator<T extends java.lang.Comparable<T>> {
        public getContentFirstArrayComparator(): ArrayComparator.ContentFirstArrayComparator<T> {
            return <any>(new ArrayComparator.ContentFirstArrayComparator<any>());
        }

        public getLengthFirstArrayComparator(): ArrayComparator.LengthFirstArrayComparator<T> {
            return <any>(new ArrayComparator.LengthFirstArrayComparator<any>());
        }
    }
    ArrayComparator["__class"] = "com.vzome.core.generic.ArrayComparator";


    export namespace ArrayComparator {

        export class ContentFirstArrayComparator<T extends java.lang.Comparable<T>> {
            /**
             * 
             * @param {T[]} array1
             * @param {T[]} array2
             * @return {number}
             */
            public compare(array1: T[], array2: T[]): number {
                const len1: number = array1.length;
                const len2: number = array2.length;
                const smaller: number = len1 < len2 ? len1 : len2;
                for(let i: number = 0; i < smaller; i++) {{
                    const element1: T = array1[i];
                    const element2: T = array2[i];
                    const comparison: number = element1.compareTo(element2);
                    if (comparison !== 0){
                        return comparison;
                    }
                };}
                return /* compareTo */(<any>((o1: any, o2: any) => { if (o1 && o1.compareTo) { return o1.compareTo(o2); } else { return o1 < o2 ? -1 : o2 < o1 ? 1 : 0; } })(len1,len2));
            }

            constructor() {
            }
        }
        ContentFirstArrayComparator["__class"] = "com.vzome.core.generic.ArrayComparator.ContentFirstArrayComparator";
        ContentFirstArrayComparator["__interfaces"] = ["java.util.Comparator"];



        export class LengthFirstArrayComparator<T extends java.lang.Comparable<T>> {
            /**
             * 
             * @param {T[]} array1
             * @param {T[]} array2
             * @return {number}
             */
            public compare(array1: T[], array2: T[]): number {
                const len1: number = array1.length;
                const len2: number = array2.length;
                let comparison: number = /* compareTo */(<any>((o1: any, o2: any) => { if (o1 && o1.compareTo) { return o1.compareTo(o2); } else { return o1 < o2 ? -1 : o2 < o1 ? 1 : 0; } })(len1,len2));
                if (comparison !== 0){
                    return comparison;
                }
                for(let i: number = 0; i < len1; i++) {{
                    const element1: T = array1[i];
                    const element2: T = array2[i];
                    comparison = element1.compareTo(element2);
                    if (comparison !== 0){
                        return comparison;
                    }
                };}
                return comparison;
            }

            constructor() {
            }
        }
        LengthFirstArrayComparator["__class"] = "com.vzome.core.generic.ArrayComparator.LengthFirstArrayComparator";
        LengthFirstArrayComparator["__interfaces"] = ["java.util.Comparator"];


    }

}
namespace com.vzome.core.generic {
    /**
     * @author David Hall
     * Based on http://stackoverflow.com/questions/5474893/how-to-implement-this-filteringiterator
     * @class
     */
    export abstract class FilteredIterator<T, R> implements java.util.Iterator<R>, java.lang.Iterable<R> {
        /*private*/ wrappedIterator: java.util.Iterator<T>;

        /*private*/ __preFilter: (p1: T) => boolean;

        /*private*/ __postFilter: (p1: R) => boolean;

        /*private*/ nextElement: R;

        /*private*/ __hasNext: boolean;

        /**
         * Elements must match this filter before conversion
         * @param {*} element
         * @return {boolean}
         */
        preFilter(element: T): boolean {
            return this.__preFilter == null ? true : (target => (typeof target === 'function') ? target(element) : (<any>target).test(element))(this.__preFilter);
        }

        /**
         * Elements must match this filter after conversion
         * @param {*} element
         * @return {boolean}
         */
        postFilter(element: R): boolean {
            return this.__postFilter == null ? true : (target => (typeof target === 'function') ? target(element) : (<any>target).test(element))(this.__postFilter);
        }

        /**
         * Elements are converted from T to R.
         * T and R may be identical, related (e.g. sub-classed) or completely unrelated.
         * @param {*} element
         * @return {*}
         */
        abstract apply(element: T): R;

        constructor(preTest: (p1: T) => boolean, iterable: java.lang.Iterable<T>, postTest: (p1: R) => boolean) {
            if (this.wrappedIterator === undefined) { this.wrappedIterator = null; }
            if (this.__preFilter === undefined) { this.__preFilter = null; }
            if (this.__postFilter === undefined) { this.__postFilter = null; }
            this.nextElement = null;
            this.__hasNext = null;
            this.wrappedIterator = iterable.iterator();
            this.__preFilter = <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(preTest));
            this.__postFilter = <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postTest));
        }

        /**
         * 
         * @return {*}
         */
        public iterator(): java.util.Iterator<R> {
            return this;
        }

        /**
         * 
         * @return {boolean}
         */
        public hasNext(): boolean {
            if (this.__hasNext == null){
                this.nextMatch();
            }
            return this.__hasNext;
        }

        /**
         * 
         * @return {*}
         */
        public next(): R {
            if (this.__hasNext == null){
                this.nextMatch();
            }
            if (!this.__hasNext){
                throw new java.util.NoSuchElementException();
            }
            return this.nextMatch();
        }

        nextMatch(): R {
            const lastMatch: R = this.nextElement;
            while((this.wrappedIterator.hasNext())) {{
                const next: T = this.wrappedIterator.next();
                if (this.preFilter(next)){
                    const converted: R = this.apply(next);
                    if (this.postFilter(converted)){
                        this.nextElement = converted;
                        this.__hasNext = true;
                        return lastMatch;
                    }
                }
            }};
            this.__hasNext = false;
            return lastMatch;
        }

        /**
         * 
         */
        public remove() {
            this.wrappedIterator.remove();
        }
    }
    FilteredIterator["__class"] = "com.vzome.core.generic.FilteredIterator";
    FilteredIterator["__interfaces"] = ["java.util.Iterator","java.lang.Iterable"];



    export namespace FilteredIterator {

        export class Filters {
            constructor() {
            }

            /**
             * A static convenience function that may be passed as a preFilter parameter
             * @param <T>
             * @param {*} element
             * @return {boolean} {@code true} if element is not null
             */
            public static elementNotNull<T>(element: T): boolean {
                return element != null;
            }

            /**
             * A static convenience function that may be passed as a postFilter parameter
             * @param <R>
             * @param {*} result
             * @return {boolean} {@code true} if result is not null
             */
            public static resultNotNull<R>(result: R): boolean {
                return result != null;
            }

            /**
             * A static convenience function that may be used with another predicate
             * to be passed as a preFilter or postFilter parameter
             * @param <B>
             * @param {*} predicate The predicate to be negated.
             * @param {*} arg The parameter to be passed to the predicate.
             * @return {boolean} The opposite of what the predicate returns.
             */
            public static not<B>(predicate: (p1: B) => boolean, arg: B): boolean {
                return (target => (typeof target === 'function') ? target(arg) : (<any>target).test(arg))((target => (typeof target === 'function') ? target() : (<any>target).negate())(predicate));
            }

            /**
             * A static convenience function that may be used to combine two other predicates
             * to be passed as a preFilter or postFilter parameter
             * @param <B>
             * @param {*} check1 The 1st predicate to be evaluated.
             * @param {*} check2 The 2nd predicate to be evaluated.
             * @param {*} arg The parameter to be passed to the predicates.
             * @return {boolean} {@code true} only if both predicates are true.
             */
            public static and<B>(check1: (p1: B) => boolean, check2: (p1: B) => boolean, arg: B): boolean {
                return (target => (typeof target === 'function') ? target(arg) : (<any>target).test(arg))((target => (typeof target === 'function') ? target(check2) : (<any>target).and(check2))(check1));
            }

            /**
             * A static convenience function that may be used to combine two other predicates
             * to be passed as a preFilter or postFilter parameter
             * @param <B>
             * @param {*} check1 The 1st predicate to be evaluated.
             * @param {*} check2 The 2nd predicate to be evaluated.
             * @param {*} arg The parameter to be passed to the predicates.
             * @return {boolean} {@code true} if either predicate is true.
             */
            public static or<B>(check1: (p1: B) => boolean, check2: (p1: B) => boolean, arg: B): boolean {
                return (target => (typeof target === 'function') ? target(arg) : (<any>target).test(arg))((target => (typeof target === 'function') ? target(check2) : (<any>target).or(check2))(check1));
            }
        }
        Filters["__class"] = "com.vzome.core.generic.FilteredIterator.Filters";

    }

}
namespace com.vzome.core.commands {
    export class XmlSaveFormat {
        mProject4d: boolean;

        mSelectionNotSaved: boolean;

        mRationalVectors: boolean;

        mGroupingInSelection: boolean;

        /*private*/ mField: com.vzome.core.algebra.AlgebraicField;

        /*private*/ mScale: number;

        /*private*/ mMultiplier: com.vzome.core.algebra.AlgebraicNumber;

        /*private*/ writerVersion: string;

        /*private*/ version: string;

        /*private*/ capabilities: java.util.Set<string>;

        /*private*/ properties: java.util.Properties;

        public static CURRENT_FORMAT: string = "http://xml.vzome.com/vZome/4.0.0/";

        static PROJECT_4D: string = "project-4D-to-3D";

        static SELECTION_NOT_SAVED: string = "selection-not-saved";

        static FORMAT_2_1_0: string = "interim-210-format";

        static GROUPING_IN_SELECTION: string = "grouping-in-selection";

        static RATIONAL_VECTORS: string = "rational-vectors";

        static COMPACTED_COMMAND_EDITS: string = "compacted-command-edits";

        static MULTIPLE_DESIGNS: string = "multiple-designs";

        static FORMATS: java.util.Map<string, XmlSaveFormat>; public static FORMATS_$LI$(): java.util.Map<string, XmlSaveFormat> { if (XmlSaveFormat.FORMATS == null) { XmlSaveFormat.FORMATS = <any>(new java.util.HashMap<any, any>()); }  return XmlSaveFormat.FORMATS; }

        static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (XmlSaveFormat.logger == null) { XmlSaveFormat.logger = java.util.logging.Logger.getLogger("com.vzome.core.commands.XmlSaveFormat"); }  return XmlSaveFormat.logger; }

        public static UNKNOWN_COMMAND: string = "unknown.command";

        /**
         * Initialize.
         * 
         * If you're tempted to add another parameter, see if you can make it a property instead.
         * 
         * Shouldn't we just replace all the parameters with one Controller object?
         * 
         * @param root
         * @param {*} field
         * @param symms
         * @param {number} scale
         * @param {string} writerVersion
         * @param {java.util.Properties} props
         */
        public initialize(field: com.vzome.core.algebra.AlgebraicField, scale: number, writerVersion: string, props: java.util.Properties) {
            this.properties = props;
            this.writerVersion = writerVersion;
            if ((writerVersion == null) || /* isEmpty */(writerVersion.length === 0))this.writerVersion = "before 2.1 Beta 7";
            this.mField = field;
            this.mScale = scale;
            if (scale === 0)this.mMultiplier = null; else this.mMultiplier = field['createPower$int'](scale);
        }

        constructor(version: string, capabilities: string[]) {
            if (this.mProject4d === undefined) { this.mProject4d = false; }
            if (this.mSelectionNotSaved === undefined) { this.mSelectionNotSaved = false; }
            if (this.mRationalVectors === undefined) { this.mRationalVectors = false; }
            if (this.mGroupingInSelection === undefined) { this.mGroupingInSelection = false; }
            if (this.mField === undefined) { this.mField = null; }
            if (this.mScale === undefined) { this.mScale = 0; }
            if (this.mMultiplier === undefined) { this.mMultiplier = null; }
            if (this.writerVersion === undefined) { this.writerVersion = null; }
            if (this.version === undefined) { this.version = null; }
            this.capabilities = <any>(new java.util.HashSet<any>());
            if (this.properties === undefined) { this.properties = null; }
            this.version = version;
            this.capabilities.addAll(java.util.Arrays.asList<any>(capabilities));
            this.mProject4d = this.capabilities.contains(XmlSaveFormat.PROJECT_4D);
            this.mSelectionNotSaved = this.capabilities.contains(XmlSaveFormat.SELECTION_NOT_SAVED);
            this.mRationalVectors = this.capabilities.contains(XmlSaveFormat.RATIONAL_VECTORS);
            this.mGroupingInSelection = this.capabilities.contains(XmlSaveFormat.GROUPING_IN_SELECTION);
            XmlSaveFormat.FORMATS_$LI$().put(version, this);
        }

        getVersion(): string {
            return this.version;
        }

        public isMigration(): boolean {
            return !this.multipleDesigns();
        }

        public selectionsNotSaved(): boolean {
            return this.mSelectionNotSaved;
        }

        public rationalVectors(): boolean {
            return this.mRationalVectors;
        }

        public actionHistory(): boolean {
            return false;
        }

        public commandEditsCompacted(): boolean {
            return this.capabilities.contains(XmlSaveFormat.COMPACTED_COMMAND_EDITS);
        }

        public multipleDesigns(): boolean {
            return this.capabilities.contains(XmlSaveFormat.MULTIPLE_DESIGNS);
        }

        public groupingDoneInSelection(): boolean {
            return this.mGroupingInSelection && !("2.1.3" === this.writerVersion);
        }

        public groupingRecursive(): boolean {
            return !this.groupingDoneInSelection() || ("2.1.2" === this.writerVersion);
        }

        public interim210format(): boolean {
            return this.capabilities.contains(XmlSaveFormat.FORMAT_2_1_0);
        }

        parseAlgebraicVector(elem: org.w3c.dom.Element): com.vzome.core.algebra.AlgebraicVector {
            let val: string = elem.getAttribute("x");
            const x: com.vzome.core.algebra.AlgebraicNumber = (val == null || /* isEmpty */(val.length === 0)) ? this.mField.zero() : this.mField.parseLegacyNumber(val);
            val = elem.getAttribute("y");
            const y: com.vzome.core.algebra.AlgebraicNumber = (val == null || /* isEmpty */(val.length === 0)) ? this.mField.zero() : this.mField.parseLegacyNumber(val);
            val = elem.getAttribute("z");
            const z: com.vzome.core.algebra.AlgebraicNumber = (val == null || /* isEmpty */(val.length === 0)) ? this.mField.zero() : this.mField.parseLegacyNumber(val);
            val = elem.getAttribute("w");
            const threeD: boolean = val == null || /* isEmpty */(val.length === 0);
            let w: com.vzome.core.algebra.AlgebraicNumber = null;
            if (!threeD)w = this.mField.parseLegacyNumber(val);
            let value: com.vzome.core.algebra.AlgebraicVector = threeD ? new com.vzome.core.algebra.AlgebraicVector(x, y, z) : new com.vzome.core.algebra.AlgebraicVector(w, x, y, z);
            if (this.mProject4d && !threeD){
                if (!w.isZero() && XmlSaveFormat.logger_$LI$().isLoggable(java.util.logging.Level.WARNING))XmlSaveFormat.logger_$LI$().warning("stripping non-zero W component from " + value.toString());
                value = this.mField.projectTo3d(value, true);
            }
            if (this.mMultiplier != null)value = value.scale(this.mMultiplier);
            return value;
        }

        public static NOT_AN_ATTRIBUTE: any; public static NOT_AN_ATTRIBUTE_$LI$(): any { if (XmlSaveFormat.NOT_AN_ATTRIBUTE == null) { XmlSaveFormat.NOT_AN_ATTRIBUTE = <any>new Object(); }  return XmlSaveFormat.NOT_AN_ATTRIBUTE; }

        public parseAlgebraicObject(valName: string, val: org.w3c.dom.Element): any {
            let value: any = XmlSaveFormat.NOT_AN_ATTRIBUTE_$LI$();
            if (valName === ("Null"))value = null; else if (valName === ("RationalVector")){
                const nums: string = val.getAttribute("nums");
                if (nums == null || /* isEmpty */(nums.length === 0))return this.mField.origin(3);
                const denoms: string = val.getAttribute("denoms");
                let tokens: java.util.StringTokenizer = new java.util.StringTokenizer(nums);
                const result: number[] = [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1];
                for(let i: number = 0; i < this.mField.getOrder(); i++) {{
                    const token: string = tokens.nextToken();
                    if (token == null)throw new java.lang.IllegalStateException("RationalVector nums too short for field " + this.mField.getName());
                    result[i * 2] = javaemul.internal.IntegerHelper.parseInt(token);
                };}
                if (denoms != null && !/* isEmpty */(denoms.length === 0)){
                    tokens = new java.util.StringTokenizer(denoms);
                    for(let i: number = 0; i < this.mField.getOrder(); i++) {{
                        const token: string = tokens.nextToken();
                        if (token == null)throw new java.lang.IllegalStateException("RationalVector denoms too short for field " + this.mField.getName());
                        result[i * 2 + 1] = javaemul.internal.IntegerHelper.parseInt(token);
                    };}
                }
                const oneThirdLen: number = (result.length / 3|0);
                const twoThirdLen: number = oneThirdLen * 2;
                const result3d: number[][] = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return 0; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([3, oneThirdLen]);
                for(let i: number = 0; i < oneThirdLen; i++) {{
                    result3d[0][i] = result[i];
                    result3d[1][i] = result[i + oneThirdLen];
                    result3d[2][i] = result[i + twoThirdLen];
                };}
                value = this.mField.createVector(result3d);
            } else if (valName === ("GoldenVector"))value = this.parseAlgebraicVector(val); else if (valName === ("Boolean")){
                const gnum: string = val.getAttribute("value");
                value = javaemul.internal.BooleanHelper.parseBoolean(gnum);
            } else if (valName === ("Integer")){
                const gnum: string = val.getAttribute("value");
                value = javaemul.internal.IntegerHelper.parseInt(gnum);
            } else if ((valName === ("GoldenNumber")) || (valName === ("IntegralNumber"))){
                const gnum: string = val.getAttribute("value");
                value = this.mField.parseLegacyNumber(gnum);
                if (this.mMultiplier != null)value = (<com.vzome.core.algebra.AlgebraicNumber><any>value)['times$com_vzome_core_algebra_AlgebraicNumber'](this.mMultiplier);
            } else if (valName === ("String"))value = val.getTextContent();
            return value;
        }

        public parseConstruction$java_lang_String$org_w3c_dom_Element(apName: string, attrOrParam: org.w3c.dom.Element): com.vzome.core.construction.Construction {
            return this.parseConstruction$java_lang_String$org_w3c_dom_Element$boolean(apName, attrOrParam, false);
        }

        public parseConstruction$java_lang_String$org_w3c_dom_Element$boolean(apName: string, attrOrParam: org.w3c.dom.Element, projectTo3d: boolean): com.vzome.core.construction.Construction {
            let c: com.vzome.core.construction.Construction = null;
            if (apName === ("point")){
                let loc: com.vzome.core.algebra.AlgebraicVector = this.parseAlgebraicVector(attrOrParam);
                if (projectTo3d)loc = loc.projectTo3d(true);
                c = new com.vzome.core.construction.FreePoint(loc);
            } else if (apName === ("segment")){
                const start: org.w3c.dom.Element = com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element$java_lang_String(attrOrParam, "start");
                const end: org.w3c.dom.Element = com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element$java_lang_String(attrOrParam, "end");
                let sloc: com.vzome.core.algebra.AlgebraicVector = this.parseAlgebraicVector(start);
                let eloc: com.vzome.core.algebra.AlgebraicVector = this.parseAlgebraicVector(end);
                if (projectTo3d){
                    sloc = sloc.projectTo3d(true);
                    eloc = eloc.projectTo3d(true);
                }
                c = new com.vzome.core.construction.SegmentJoiningPoints(new com.vzome.core.construction.FreePoint(sloc), new com.vzome.core.construction.FreePoint(eloc));
            } else if (apName === ("polygon")){
                const kids: org.w3c.dom.NodeList = attrOrParam.getElementsByTagName("vertex");
                const pts: com.vzome.core.construction.Point[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(kids.getLength());
                for(let k: number = 0; k < kids.getLength(); k++) {{
                    let loc: com.vzome.core.algebra.AlgebraicVector = this.parseAlgebraicVector(<org.w3c.dom.Element><any>kids.item(k));
                    if (projectTo3d)loc = loc.projectTo3d(true);
                    pts[k] = new com.vzome.core.construction.FreePoint(loc);
                };}
                c = new com.vzome.core.construction.PolygonFromVertices(pts);
            }
            return c;
        }

        /**
         * this is for the old format (before rationalVectors)
         * @param {string} apName
         * @param {*} attrOrParam
         * @param {boolean} projectTo3d
         * @return {com.vzome.core.construction.Construction}
         */
        public parseConstruction(apName?: any, attrOrParam?: any, projectTo3d?: any): com.vzome.core.construction.Construction {
            if (((typeof apName === 'string') || apName === null) && ((attrOrParam != null && (attrOrParam.constructor != null && attrOrParam.constructor["__interfaces"] != null && attrOrParam.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || attrOrParam === null) && ((typeof projectTo3d === 'boolean') || projectTo3d === null)) {
                return <any>this.parseConstruction$java_lang_String$org_w3c_dom_Element$boolean(apName, attrOrParam, projectTo3d);
            } else if (((typeof apName === 'string') || apName === null) && ((attrOrParam != null && (attrOrParam.constructor != null && attrOrParam.constructor["__interfaces"] != null && attrOrParam.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || attrOrParam === null) && projectTo3d === undefined) {
                return <any>this.parseConstruction$java_lang_String$org_w3c_dom_Element(apName, attrOrParam);
            } else throw new Error('invalid overload');
        }

        public loadCommandAttributes$org_w3c_dom_Element(editElem: org.w3c.dom.Element): com.vzome.core.commands.AttributeMap {
            return this.loadCommandAttributes$org_w3c_dom_Element$boolean(editElem, false);
        }

        public loadCommandAttributes$org_w3c_dom_Element$boolean(editElem: org.w3c.dom.Element, projectTo3d: boolean): com.vzome.core.commands.AttributeMap {
            const attrs: com.vzome.core.commands.AttributeMap = new com.vzome.core.commands.AttributeMap();
            const kids: org.w3c.dom.NodeList = editElem.getChildNodes();
            for(let j: number = 0; j < kids.getLength(); j++) {{
                const node: org.w3c.dom.Node = kids.item(j);
                if (!(node != null && (node.constructor != null && node.constructor["__interfaces"] != null && node.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)))continue;
                let attrElem: org.w3c.dom.Element = <org.w3c.dom.Element><any>node;
                let elemName: string = attrElem.getLocalName();
                let attrName: string = attrElem.getAttribute("attrName");
                if (this.interim210format()){
                    attrName = attrElem.getAttribute("name");
                    const elemKid: org.w3c.dom.Element = com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element(attrElem);
                    if (elemKid != null){
                        attrElem = elemKid;
                        elemName = attrElem.getLocalName();
                    }
                }
                let value: any = this.parseAlgebraicObject(elemName, attrElem);
                if (value === XmlSaveFormat.NOT_AN_ATTRIBUTE_$LI$())if (this.rationalVectors()){
                    if (elemName === ("point"))value = this.parsePoint$org_w3c_dom_Element$java_lang_String$boolean(attrElem, "at", projectTo3d); else if (elemName === ("segment"))value = this.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String$boolean(attrElem, "start", "end", projectTo3d); else if (elemName === ("polygon"))value = this.parsePolygon$org_w3c_dom_Element$java_lang_String$boolean(attrElem, "vertex", projectTo3d); else throw new java.lang.IllegalStateException("unknown parameter construction: " + elemName);
                } else value = this.parseConstruction$java_lang_String$org_w3c_dom_Element$boolean(elemName, attrElem, projectTo3d);
                attrs.put(attrName, value);
            };}
            return attrs;
        }

        public loadCommandAttributes(editElem?: any, projectTo3d?: any): com.vzome.core.commands.AttributeMap {
            if (((editElem != null && (editElem.constructor != null && editElem.constructor["__interfaces"] != null && editElem.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || editElem === null) && ((typeof projectTo3d === 'boolean') || projectTo3d === null)) {
                return <any>this.loadCommandAttributes$org_w3c_dom_Element$boolean(editElem, projectTo3d);
            } else if (((editElem != null && (editElem.constructor != null && editElem.constructor["__interfaces"] != null && editElem.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || editElem === null) && projectTo3d === undefined) {
                return <any>this.loadCommandAttributes$org_w3c_dom_Element(editElem);
            } else throw new Error('invalid overload');
        }

        public getField(): com.vzome.core.algebra.AlgebraicField {
            return this.mField;
        }

        public getScale(): number {
            return this.mScale;
        }

        public static serializeNumber(xml: org.w3c.dom.Element, attrName: string, number: com.vzome.core.algebra.AlgebraicNumber) {
            com.vzome.xml.DomUtils.addAttribute(xml, attrName, number.toString(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
        }

        public static serializePoint(xml: org.w3c.dom.Element, attrName: string, point: com.vzome.core.construction.Point) {
            com.vzome.xml.DomUtils.addAttribute(xml, attrName, point.getLocation().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
        }

        public static serializeSegment(xml: org.w3c.dom.Element, startAttrName: string, endAttrName: string, segment: com.vzome.core.construction.Segment) {
            com.vzome.xml.DomUtils.addAttribute(xml, startAttrName, segment.getStart().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
            com.vzome.xml.DomUtils.addAttribute(xml, endAttrName, segment.getEnd().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
        }

        public static serializePolygon(xml: org.w3c.dom.Element, vertexChildName: string, polygon: com.vzome.core.construction.Polygon) {
            polygon.getXml$org_w3c_dom_Element$java_lang_String(xml, vertexChildName);
        }

        public parseRationalVector(xml: org.w3c.dom.Element, attrName: string): com.vzome.core.algebra.AlgebraicVector {
            const nums: string = xml.getAttribute(attrName);
            if (nums == null || /* isEmpty */(nums.length === 0))return null;
            const loc: com.vzome.core.algebra.AlgebraicVector = this.mField.parseVector(nums);
            return loc;
        }

        public parseRationalNumber(xml: org.w3c.dom.Element, attrName: string): com.vzome.core.algebra.AlgebraicNumber {
            const nums: string = xml.getAttribute(attrName);
            if (nums == null || /* isEmpty */(nums.length === 0))return null;
            const loc: com.vzome.core.algebra.AlgebraicNumber = this.mField.parseNumber(nums);
            return loc;
        }

        public parsePoint$org_w3c_dom_Element$java_lang_String(xml: org.w3c.dom.Element, attrName: string): com.vzome.core.construction.Point {
            return this.parsePoint$org_w3c_dom_Element$java_lang_String$boolean(xml, attrName, false);
        }

        public parsePoint$org_w3c_dom_Element$java_lang_String$boolean(xml: org.w3c.dom.Element, attrName: string, projectTo3d: boolean): com.vzome.core.construction.Point {
            const nums: string = xml.getAttribute(attrName);
            if (nums == null || /* isEmpty */(nums.length === 0))return null;
            let loc: com.vzome.core.algebra.AlgebraicVector = this.mField.parseVector(nums);
            if (projectTo3d)loc = loc.projectTo3d(true);
            return new com.vzome.core.construction.FreePoint(loc);
        }

        public parsePoint(xml?: any, attrName?: any, projectTo3d?: any): com.vzome.core.construction.Point {
            if (((xml != null && (xml.constructor != null && xml.constructor["__interfaces"] != null && xml.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || xml === null) && ((typeof attrName === 'string') || attrName === null) && ((typeof projectTo3d === 'boolean') || projectTo3d === null)) {
                return <any>this.parsePoint$org_w3c_dom_Element$java_lang_String$boolean(xml, attrName, projectTo3d);
            } else if (((xml != null && (xml.constructor != null && xml.constructor["__interfaces"] != null && xml.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || xml === null) && ((typeof attrName === 'string') || attrName === null) && projectTo3d === undefined) {
                return <any>this.parsePoint$org_w3c_dom_Element$java_lang_String(xml, attrName);
            } else throw new Error('invalid overload');
        }

        public parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml: org.w3c.dom.Element, startAttrName: string, endAttrName: string): com.vzome.core.construction.Segment {
            return this.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String$boolean(xml, startAttrName, endAttrName, false);
        }

        public parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String$boolean(xml: org.w3c.dom.Element, startAttrName: string, endAttrName: string, projectTo3d: boolean): com.vzome.core.construction.Segment {
            let nums: string = xml.getAttribute(endAttrName);
            if (nums == null || /* isEmpty */(nums.length === 0))return null;
            let eloc: com.vzome.core.algebra.AlgebraicVector = this.mField.parseVector(nums);
            nums = xml.getAttribute(startAttrName);
            let sloc: com.vzome.core.algebra.AlgebraicVector = (nums == null || /* isEmpty */(nums.length === 0)) ? this.mField.origin(eloc.dimension()) : this.mField.parseVector(nums);
            if (projectTo3d){
                sloc = sloc.projectTo3d(true);
                eloc = eloc.projectTo3d(true);
            }
            return new com.vzome.core.construction.SegmentJoiningPoints(new com.vzome.core.construction.FreePoint(sloc), new com.vzome.core.construction.FreePoint(eloc));
        }

        public parseSegment(xml?: any, startAttrName?: any, endAttrName?: any, projectTo3d?: any): com.vzome.core.construction.Segment {
            if (((xml != null && (xml.constructor != null && xml.constructor["__interfaces"] != null && xml.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || xml === null) && ((typeof startAttrName === 'string') || startAttrName === null) && ((typeof endAttrName === 'string') || endAttrName === null) && ((typeof projectTo3d === 'boolean') || projectTo3d === null)) {
                return <any>this.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String$boolean(xml, startAttrName, endAttrName, projectTo3d);
            } else if (((xml != null && (xml.constructor != null && xml.constructor["__interfaces"] != null && xml.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || xml === null) && ((typeof startAttrName === 'string') || startAttrName === null) && ((typeof endAttrName === 'string') || endAttrName === null) && projectTo3d === undefined) {
                return <any>this.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, startAttrName, endAttrName);
            } else throw new Error('invalid overload');
        }

        public parsePolygon$org_w3c_dom_Element$java_lang_String(xml: org.w3c.dom.Element, vertexChildName: string): com.vzome.core.construction.Polygon {
            return this.parsePolygon$org_w3c_dom_Element$java_lang_String$boolean(xml, vertexChildName, false);
        }

        public parsePolygon$org_w3c_dom_Element$java_lang_String$boolean(xml: org.w3c.dom.Element, vertexChildName: string, projectTo3d: boolean): com.vzome.core.construction.Polygon {
            const kids: org.w3c.dom.NodeList = xml.getElementsByTagName(vertexChildName);
            const pts: com.vzome.core.construction.Point[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(kids.getLength());
            for(let k: number = 0; k < kids.getLength(); k++) {{
                const nums: string = (<org.w3c.dom.Element><any>kids.item(k)).getAttribute("at");
                let loc: com.vzome.core.algebra.AlgebraicVector = this.mField.parseVector(nums);
                if (projectTo3d)loc = loc.projectTo3d(true);
                pts[k] = new com.vzome.core.construction.FreePoint(loc);
            };}
            return new com.vzome.core.construction.PolygonFromVertices(pts);
        }

        public parsePolygon(xml?: any, vertexChildName?: any, projectTo3d?: any): com.vzome.core.construction.Polygon {
            if (((xml != null && (xml.constructor != null && xml.constructor["__interfaces"] != null && xml.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || xml === null) && ((typeof vertexChildName === 'string') || vertexChildName === null) && ((typeof projectTo3d === 'boolean') || projectTo3d === null)) {
                return <any>this.parsePolygon$org_w3c_dom_Element$java_lang_String$boolean(xml, vertexChildName, projectTo3d);
            } else if (((xml != null && (xml.constructor != null && xml.constructor["__interfaces"] != null && xml.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || xml === null) && ((typeof vertexChildName === 'string') || vertexChildName === null) && projectTo3d === undefined) {
                return <any>this.parsePolygon$org_w3c_dom_Element$java_lang_String(xml, vertexChildName);
            } else throw new Error('invalid overload');
        }

        public parsePolygonReversed(xml: org.w3c.dom.Element, vertexChildName: string): com.vzome.core.construction.Polygon {
            const kids: org.w3c.dom.NodeList = xml.getElementsByTagName(vertexChildName);
            const pts: com.vzome.core.construction.Point[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(kids.getLength());
            const kmax: number = kids.getLength() - 1;
            for(let k: number = 0; k < kids.getLength(); k++) {{
                const nums: string = (<org.w3c.dom.Element><any>kids.item(k)).getAttribute("at");
                const loc: com.vzome.core.algebra.AlgebraicVector = this.mField.parseVector(nums);
                pts[kmax - k] = new com.vzome.core.construction.FreePoint(loc);
            };}
            return new com.vzome.core.construction.PolygonFromVertices(pts);
        }

        public parseNumber(xml: org.w3c.dom.Element, attrName: string): com.vzome.core.algebra.AlgebraicNumber {
            const nums: string = xml.getAttribute(attrName);
            if (nums == null || /* isEmpty */(nums.length === 0))return null;
            return this.mField.parseNumber(nums);
        }

        public static escapeNewlines(input: string): string {
            const buf: java.lang.StringBuffer = new java.lang.StringBuffer();
            const br: java.io.BufferedReader = new java.io.BufferedReader(new java.io.StringReader(input));
            let line: string = null;
            try {
                while(((line = br.readLine()) != null)) {{
                    const comment: number = line.indexOf("//");
                    if (comment >= 0){
                        line = line.substring(0, comment);
                    }
                    buf.append(line + "\n");
                }};
            } catch(e) {
            }
            return buf.toString();
        }

        public loadToRender(): boolean {
            return !("true" === this.properties.getProperty("no.rendering"));
        }

        public getToolVersion(element: org.w3c.dom.Element): string {
            let fileEdition: string = element.getAttribute("edition");
            if (fileEdition == null || /* isEmpty */(fileEdition.length === 0))fileEdition = "vZome";
            return fileEdition + " " + this.writerVersion;
        }
    }
    XmlSaveFormat["__class"] = "com.vzome.core.commands.XmlSaveFormat";

}
namespace com.vzome.core.commands {
    /**
     * @author David Hall
     * This class doesn't add anything to the TreeMap,
     * but there were so many places that were using Map<String, Object>,
     * that I decided to use this class to clarify which ones were using it
     * for managing attributes. It also avoids cluttering the code
     * with Map<String, Object> which is just needed for type safety,
     * but which does nothing for describing the intended use of the variables.
     * 
     * Note that in XmlSaveFormat, AttributeMap replaces TreeMap<>,
     * but in other places (such as CommandEdit), it replaces HashMap<>.
     * XmlSaveFormat requires the Map<> to be ordered, but I assume
     * that other places can safely use any implementation of Map<>.
     * Therefore, I have used TreeMap<> rather than HashMap<> as the basis
     * for AttributeMap across the board.
     * @class
     * @extends java.util.TreeMap
     */
    export class AttributeMap extends java.util.TreeMap<string, any> {
        static __com_vzome_core_commands_AttributeMap_serialVersionUID: number = 1;

        constructor() {
            super();
        }
    }
    AttributeMap["__class"] = "com.vzome.core.commands.AttributeMap";
    AttributeMap["__interfaces"] = ["java.lang.Cloneable","java.util.Map","java.util.NavigableMap","java.util.SortedMap","java.io.Serializable"];


}
namespace com.vzome.core.commands {
    export abstract class AbstractCommand implements com.vzome.core.commands.Command {
        /**
         * This default behavior deserializes in the old way, before XmlSaveFormat .COMPACTED_COMMAND_EDITS
         * @param attributes
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         * @return
         * @return {com.vzome.core.commands.AttributeMap}
         */
        public setXml(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat): com.vzome.core.commands.AttributeMap {
            const attrs: com.vzome.core.commands.AttributeMap = format.loadCommandAttributes$org_w3c_dom_Element(xml);
            this.setFixedAttributes(attrs, format);
            return attrs;
        }

        public setFixedAttributes(attributes: com.vzome.core.commands.AttributeMap, format: com.vzome.core.commands.XmlSaveFormat) {
            attributes.put(com.vzome.core.commands.Command.FIELD_ATTR_NAME, format.getField());
        }

        /**
         * This default behavior serializes in the old way, before XmlSaveFormat .COMPACTED_COMMAND_EDITS
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @return
         * @param {*} result
         */
        public getXml(result: org.w3c.dom.Element, attributes: com.vzome.core.commands.AttributeMap) {
            if (attributes == null)return;
            for(let index=attributes.keySet().iterator();index.hasNext();) {
                let key = index.next();
                {
                    if (key === com.vzome.core.commands.Command.FIELD_ATTR_NAME)continue;
                    if (key === com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME)continue;
                    if (key === com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME)continue;
                    if (key === com.vzome.core.commands.CommandImportVEFData.FIELD_ATTR_NAME)continue;
                    const value: any = attributes.get(key);
                    if (value != null && value instanceof <any>com.vzome.core.math.symmetry.IcosahedralSymmetry)continue;
                    AbstractCommand.saveCommandAttribute(result, key, value);
                }
            }
        }

        public static saveCommandAttribute(command: org.w3c.dom.Element, attrName: string, value: any) {
            const doc: org.w3c.dom.Document = command.getOwnerDocument();
            let valElem: org.w3c.dom.Element = null;
            if (value != null && value instanceof <any>Array && (value.length == 0 || value[0] == null ||typeof value[0] === 'number')){
                const v: number[] = <number[]>value;
                valElem = command.getOwnerDocument().createElement("RationalVector");
                let allOnes: boolean = true;
                let allZeros: boolean = true;
                for(let i: number = 0; i < (v.length / 2|0); i++) {{
                    allZeros = allZeros && (v[2 * i] === 0);
                    allOnes = allOnes && (v[2 * i + 1] === 1);
                };}
                if (!allZeros){
                    const numerators: java.lang.StringBuffer = new java.lang.StringBuffer();
                    for(let i: number = 0; i < (v.length / 2|0); i++) {{
                        if (i > 0)numerators.append(" ");
                        numerators.append(v[2 * i]);
                    };}
                    com.vzome.xml.DomUtils.addAttribute(valElem, "nums", numerators.toString());
                    if (!allOnes){
                        const denominators: java.lang.StringBuffer = new java.lang.StringBuffer();
                        for(let i: number = 0; i < (v.length / 2|0); i++) {{
                            if (i > 0)denominators.append(" ");
                            denominators.append(v[2 * i + 1]);
                        };}
                        com.vzome.xml.DomUtils.addAttribute(valElem, "denoms", denominators.toString());
                    }
                }
            } else if (value != null && value instanceof <any>com.vzome.core.math.symmetry.Axis){
                valElem = doc.createElement("Axis");
                (<com.vzome.core.math.symmetry.Axis>value).getXML(valElem);
            } else if (typeof value === 'boolean'){
                valElem = doc.createElement("Boolean");
                com.vzome.xml.DomUtils.addAttribute(valElem, "value", (<boolean>value).toString());
            } else if (typeof value === 'number'){
                valElem = doc.createElement("Integer");
                com.vzome.xml.DomUtils.addAttribute(valElem, "value", (<number>value).toString());
            } else if (value != null && value instanceof <any>com.vzome.core.construction.Construction){
                valElem = (<com.vzome.core.construction.Construction>value).getXml(command.getOwnerDocument());
            } else if (typeof value === 'string'){
                valElem = doc.createElement("String");
                const str: string = com.vzome.core.commands.XmlSaveFormat.escapeNewlines(<string>value);
                valElem.appendChild(doc.createTextNode(str));
            } else if (value != null && value instanceof <any>com.vzome.core.math.symmetry.QuaternionicSymmetry){
                valElem = doc.createElement("QuaternionicSymmetry");
                com.vzome.xml.DomUtils.addAttribute(valElem, "name", (<com.vzome.core.math.symmetry.QuaternionicSymmetry>value).getName());
            } else if (value != null && (value.constructor != null && value.constructor["__interfaces"] != null && value.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)){
                valElem = doc.createElement("Symmetry");
                com.vzome.xml.DomUtils.addAttribute(valElem, "name", (<com.vzome.core.math.symmetry.Symmetry><any>value).getName());
            } else if (value == null){
                valElem = doc.createElement("Null");
            } else {
                throw new java.lang.IllegalStateException("unable to save " + /* getName */(c => typeof c === 'string' ? c : c["__class"] ? c["__class"] : c["name"])((<any>value.constructor)));
            }
            com.vzome.xml.DomUtils.addAttribute(valElem, "attrName", attrName);
            command.appendChild(valElem);
        }

        public attributeIs3D(attrName: string): boolean {
            return true;
        }

        public setQuaternion(offset: com.vzome.core.algebra.AlgebraicVector) {
        }

        public ordersSelection(): boolean {
            return false;
        }

        public abstract apply(parameters?: any, attributes?: any, effects?: any): any;
        public abstract getAttributeSignature(): any;
        public abstract getParameterSignature(): any;
        constructor() {
        }
    }
    AbstractCommand["__class"] = "com.vzome.core.commands.AbstractCommand";
    AbstractCommand["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @class
     */
    export interface Command {
        /**
         * Get the parameter signature for this command.
         * Parameter are an ordered list of pre-existing Constructions.
         * Each parameter has a name (for UI purposes), and an abstract Construction type
         * (Point, Line, Segment, Plane, ...).
         * @return {java.lang.Object[][]} an array of { String, Class } pairs, one for each parameter.
         */
        getParameterSignature(): any[][];

        /**
         * Get the attribute signature for this command.
         * Attributes are an unordered set of primitive values.
         * Each attribute has a name , and a primitive type
         * (GoldenNumber, GoldenVector, Axis, Direction, GoldenMatrix, ...).
         * @return {java.lang.Object[][]} an array of { String, Class } pairs, one for each attribute.
         */
        getAttributeSignature(): any[][];

        apply(parameters: com.vzome.core.construction.ConstructionList, attributes: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList;
    }

    export namespace Command {

        export const LOADING_FROM_FILE: string = "org.vorthmann.zome.editor.Command.LOADING_FROM_FILE";

        export const FIELD_ATTR_NAME: string = "org.vorthmann.zome.commands.Command.ALGEBRAIC_FIELD";

        export const GENERIC_PARAM_NAME: string = "org.vorthmann.zome.editor.Command.GENERIC_PARAM";
    }


    export namespace Command {

        export interface Registry {
            getCommand(name: string): com.vzome.core.commands.Command;
        }

        export interface FailureChannel {
            reportFailure(f: Command.Failure);
        }

        /**
         * @param {string} message
         * @param {java.lang.Throwable} cause
         * @class
         * @extends java.lang.Exception
         */
        export class Failure extends Error {
            static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (Failure.logger == null) { Failure.logger = java.util.logging.Logger.getLogger("org.vorthmann.zome.commands"); }  return Failure.logger; }

            public constructor(message?: any, cause?: any) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof <any>Error) || cause === null)) {
                    let __args = arguments;
                    super(message); this.message=message;
                    Failure.logger_$LI$().log(java.util.logging.Level.INFO, "command failure: " + message, cause);
                } else if (((typeof message === 'string') || message === null) && cause === undefined) {
                    let __args = arguments;
                    super(message); this.message=message;
                    if (Failure.logger_$LI$().isLoggable(java.util.logging.Level.FINE))Failure.logger_$LI$().log(java.util.logging.Level.FINE, "command failure: " + message);
                } else if (((message != null && message instanceof <any>Error) || message === null) && cause === undefined) {
                    let __args = arguments;
                    let cause: any = __args[0];
                    super(cause); this.message=cause;
                    Failure.logger_$LI$().log(java.util.logging.Level.INFO, "command failure", cause);
                } else if (message === undefined && cause === undefined) {
                    let __args = arguments;
                    super();
                } else throw new Error('invalid overload');
            }
        }
        Failure["__class"] = "com.vzome.core.commands.Command.Failure";
        Failure["__interfaces"] = ["java.io.Serializable"];


    }

}
namespace com.vzome.core.exporters2d {
    export class QuartzXMLExporter {
        /*private*/ output: java.io.PrintWriter;

        /*private*/ mSnapshot: com.vzome.core.exporters2d.Java2dSnapshot;

        /*private*/ height: number;

        public constructor(snapshot: com.vzome.core.exporters2d.Java2dSnapshot) {
            if (this.output === undefined) { this.output = null; }
            if (this.mSnapshot === undefined) { this.mSnapshot = null; }
            if (this.height === undefined) { this.height = 0; }
            this.mSnapshot = snapshot;
        }

        public exportQuartzXML(writer: java.io.Writer) {
            this.output = new java.io.PrintWriter(writer);
            this.height = (<any>Math).fround(this.mSnapshot.getRect().getHeight());
            const width: number = (<any>Math).fround(this.mSnapshot.getRect().getWidth());
            this.output.println$java_lang_Object("<?xml version=\'1.0\'?>");
            this.output.println$java_lang_Object("<quartz>");
            this.output.println$();
            this.output.println$java_lang_Object("  <beginPage height=\'" + this.height + "\' width=\'" + width + "\'/>");
            let rgb: number[] = this.mSnapshot.getBackgroundColor().getRGBColorComponents(null);
            this.setRGBFillColor(rgb[0], rgb[1], rgb[2]);
            this.beginPath();
            this.output.println$java_lang_Object("    <addRect x=\'0\' y=\'0\' width=\'" + width + "\' height=\'" + this.height + "\'/>");
            this.closePath();
            this.fillPath();
            this.output.println$();
            this.output.println$java_lang_Object("    <setLineWidth width=\'" + this.mSnapshot.getStrokeWidth() + "\'/>");
            for(let index=this.mSnapshot.getPolygons().iterator();index.hasNext();) {
                let polygon = index.next();
                {
                    this.renderPath(polygon.getPath());
                    rgb = polygon.getColor().getRGBColorComponents(null);
                    this.setRGBFillColor(rgb[0], rgb[1], rgb[2]);
                    this.fillPath();
                    this.renderPath(polygon.getPath());
                    this.strokePath();
                }
            }
            this.output.println$();
            this.output.println$java_lang_Object("  <endPage/>");
            this.output.println$java_lang_Object("</quartz>");
            this.output.flush();
            this.output.close();
        }

        public renderPath(path: java.awt.geom.GeneralPath) {
            this.beginPath();
            const segments: java.awt.geom.PathIterator = path.getPathIterator(null);
            while((!segments.isDone())) {{
                const coords: number[] = [0, 0, 0, 0, 0, 0];
                const step: number = segments.currentSegment(coords);
                switch((step)) {
                case java.awt.geom.PathIterator.SEG_MOVETO:
                    this.moveToPoint(coords[0], (<any>Math).fround(this.height - coords[1]));
                    break;
                case java.awt.geom.PathIterator.SEG_LINETO:
                    this.addLineToPoint(coords[0], (<any>Math).fround(this.height - coords[1]));
                    break;
                case java.awt.geom.PathIterator.SEG_CLOSE:
                    this.closePath();
                    break;
                default:
                    break;
                }
                segments.next();
            }};
        }

        /*private*/ setRGBFillColor(r: number, g: number, b: number) {
            this.output.println$();
            this.output.println$();
            this.output.print("    <setRGBFillColor r=\"");
            this.output.print(r + "\" g=\"");
            this.output.print(g + "\" b=\"");
            this.output.println$java_lang_Object(b + "\"/>");
        }

        /*private*/ beginPath() {
            this.output.println$java_lang_Object("    <beginPath/>");
        }

        /*private*/ moveToPoint(x: number, y: number) {
            this.output.print("        <moveToPoint ");
            this.output.println$java_lang_Object(" x=\"" + x + "\" y=\"" + y + "\"/>");
        }

        /*private*/ addLineToPoint(x: number, y: number) {
            this.output.print("        <addLineToPoint ");
            this.output.println$java_lang_Object(" x=\"" + x + "\" y=\"" + y + "\"/>");
        }

        /*private*/ closePath() {
            this.output.println$java_lang_Object("    <closePath/>");
        }

        /*private*/ fillPath() {
            this.output.println$java_lang_Object("    <fillPath/>");
        }

        /*private*/ strokePath() {
            this.output.println$java_lang_Object("    <strokePath/>");
        }
    }
    QuartzXMLExporter["__class"] = "com.vzome.core.exporters2d.QuartzXMLExporter";

}
namespace com.vzome.core.exporters2d {
    export class Java2dSnapshot {
        /*private*/ polygons: java.util.List<Java2dSnapshot.Polygon>;

        /*private*/ lines: java.util.List<Java2dSnapshot.LineSegment>;

        /*private*/ mRect: java.awt.geom.Rectangle2D;

        /*private*/ strokeWidth: number;

        /*private*/ backgroundColor: java.awt.Color;

        public getBackgroundColor(): java.awt.Color {
            return this.backgroundColor;
        }

        public isLineDrawing(): boolean {
            return !this.lines.isEmpty();
        }

        public addPolygon(polygon: Java2dSnapshot.Polygon) {
            this.polygons.add(polygon);
        }

        public addLineSegment(color: java.awt.Color, start: com.vzome.core.math.RealVector, end: com.vzome.core.math.RealVector) {
            this.lines.add(new Java2dSnapshot.LineSegment(color, start, end));
        }

        public depthSort() {
            if (this.isLineDrawing())java.util.Collections.sort<any>(this.lines); else java.util.Collections.sort<any>(this.polygons);
        }

        public setRect(rect: java.awt.geom.Rectangle2D) {
            this.mRect = rect;
        }

        public setStrokeWidth(strokeWidth: number) {
            this.strokeWidth = strokeWidth;
        }

        public getRect(): java.awt.geom.Rectangle2D {
            return this.mRect;
        }

        public getStrokeWidth(): number {
            return this.strokeWidth;
        }

        public getDimension(): java.awt.Dimension {
            return new java.awt.Dimension((<number>this.mRect.getWidth()|0), (<number>this.mRect.getHeight()|0));
        }

        public getLines(): java.util.List<Java2dSnapshot.LineSegment> {
            return this.lines;
        }

        public getPolygons(): java.util.List<Java2dSnapshot.Polygon> {
            return this.polygons;
        }

        public clear() {
            this.lines.clear();
            this.polygons.clear();
        }

        public setBackgroundColor(backgroundColor: java.awt.Color) {
            this.backgroundColor = backgroundColor;
        }

        constructor() {
            this.polygons = <any>(new java.util.ArrayList<any>());
            this.lines = <any>(new java.util.ArrayList<any>());
            if (this.mRect === undefined) { this.mRect = null; }
            if (this.strokeWidth === undefined) { this.strokeWidth = 0; }
            if (this.backgroundColor === undefined) { this.backgroundColor = null; }
        }
    }
    Java2dSnapshot["__class"] = "com.vzome.core.exporters2d.Java2dSnapshot";


    export namespace Java2dSnapshot {

        export class LineSegment implements java.lang.Comparable<Java2dSnapshot.LineSegment> {
            mPath: java.awt.geom.GeneralPath;

            mDepth: number;

            mPolyColor: java.awt.Color;

            public getPath(): java.awt.geom.GeneralPath {
                return this.mPath;
            }

            public constructor(color: java.awt.Color, start: com.vzome.core.math.RealVector, end: com.vzome.core.math.RealVector) {
                if (this.mPath === undefined) { this.mPath = null; }
                if (this.mDepth === undefined) { this.mDepth = 0; }
                if (this.mPolyColor === undefined) { this.mPolyColor = null; }
                this.mPolyColor = color;
                this.mPath = new java.awt.geom.GeneralPath();
                this.mPath.moveTo(start.x, start.y);
                this.mPath.lineTo(end.x, end.y);
                this.mDepth = (<any>Math).fround(((<any>Math).fround(start.z + end.z)) / 2.0);
            }

            public getColor(): java.awt.Color {
                return this.mPolyColor;
            }

            /**
             * 
             * @param {com.vzome.core.exporters2d.Java2dSnapshot.LineSegment} other
             * @return {number}
             */
            public compareTo(other: Java2dSnapshot.LineSegment): number {
                const otherZ: number = other.mDepth;
                if (this.mDepth > otherZ)return 1;
                if (this.mDepth < otherZ)return -1;
                return 0;
            }
        }
        LineSegment["__class"] = "com.vzome.core.exporters2d.Java2dSnapshot.LineSegment";
        LineSegment["__interfaces"] = ["java.lang.Comparable"];



        export class Polygon implements java.lang.Comparable<Java2dSnapshot.Polygon> {
            mPath: java.awt.geom.GeneralPath;

            mDepth: number;

            mSize: number;

            mPolyColor: java.awt.Color;

            public getPath(): java.awt.geom.GeneralPath {
                return this.mPath;
            }

            public size(): number {
                return this.mSize;
            }

            public addVertex(vertex: com.vzome.core.math.RealVector) {
                ++this.mSize;
                if (this.mSize === 1){
                    this.mPath.moveTo(vertex.x, vertex.y);
                    this.mDepth = vertex.z;
                } else {
                    this.mPath.lineTo(vertex.x, vertex.y);
                    this.mDepth += vertex.z;
                }
            }

            public close() {
                this.mDepth /= this.mSize;
                this.mPath.closePath();
            }

            public constructor(color: java.awt.Color) {
                if (this.mPath === undefined) { this.mPath = null; }
                if (this.mDepth === undefined) { this.mDepth = 0; }
                this.mSize = 0;
                if (this.mPolyColor === undefined) { this.mPolyColor = null; }
                this.mPolyColor = color;
                this.mPath = new java.awt.geom.GeneralPath();
            }

            public getColor(): java.awt.Color {
                return this.mPolyColor;
            }

            /**
             * 
             * @param {com.vzome.core.exporters2d.Java2dSnapshot.Polygon} other
             * @return {number}
             */
            public compareTo(other: Java2dSnapshot.Polygon): number {
                const otherZ: number = other.mDepth;
                if (this.mDepth > otherZ)return 1;
                if (this.mDepth < otherZ)return -1;
                return 0;
            }

            public applyLighting(normal: com.vzome.core.math.RealVector, lightDirs: com.vzome.core.math.RealVector[], lightColors: java.awt.Color[], ambient: java.awt.Color) {
                let redIntensity: number = (<any>Math).fround(ambient.getRed() / 255.0);
                let greenIntensity: number = (<any>Math).fround(ambient.getGreen() / 255.0);
                let blueIntensity: number = (<any>Math).fround(ambient.getBlue() / 255.0);
                for(let i: number = 0; i < lightColors.length; i++) {{
                    const intensity: number = Math.max(normal.dot(lightDirs[i]), 0.0);
                    redIntensity += intensity * ((<any>Math).fround(lightColors[i].getRed() / 255.0));
                    greenIntensity += intensity * ((<any>Math).fround(lightColors[i].getGreen() / 255.0));
                    blueIntensity += intensity * ((<any>Math).fround(lightColors[i].getBlue() / 255.0));
                };}
                const red: number = (<number>((<any>Math).fround(this.mPolyColor.getRed() * Math.min(redIntensity, 1.0)))|0);
                const green: number = (<number>((<any>Math).fround(this.mPolyColor.getGreen() * Math.min(greenIntensity, 1.0)))|0);
                const blue: number = (<number>((<any>Math).fround(this.mPolyColor.getBlue() * Math.min(blueIntensity, 1.0)))|0);
                this.mPolyColor = new java.awt.Color(red, green, blue);
            }
        }
        Polygon["__class"] = "com.vzome.core.exporters2d.Java2dSnapshot.Polygon";
        Polygon["__interfaces"] = ["java.lang.Comparable"];


    }

}
namespace com.vzome.core.exporters2d {
    /**
     * Builds a Java2dSnapshot, for use in rendering to a Snapshot2dPanel
     * or exporting via a SnapshotExporter.
     * @author vorth
     * @class
     */
    export class Java2dExporter {
        /*private*/ viewTransform: com.vzome.core.math.RealMatrix4;

        /*private*/ eyeTrans: com.vzome.core.math.RealMatrix4;

        public render2d(model: com.vzome.core.render.RenderedModel, viewTransform: com.vzome.core.math.RealMatrix4, eyeTransform: com.vzome.core.math.RealMatrix4, lights: com.vzome.core.viewing.Lights, height: number, width: number, drawLines: boolean, doLighting: boolean): com.vzome.core.exporters2d.Java2dSnapshot {
            this.viewTransform = viewTransform;
            this.eyeTrans = eyeTransform;
            const lightDirs: com.vzome.core.math.RealVector[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(lights.size());
            const lightColors: java.awt.Color[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(lights.size());
            let ambientLight: java.awt.Color;
            let background: java.awt.Color;
            const snapshot: com.vzome.core.exporters2d.Java2dSnapshot = new com.vzome.core.exporters2d.Java2dSnapshot();
            for(let i: number = 0; i < lightDirs.length; i++) {{
                lightDirs[i] = lights.getDirectionalLightVector(i).normalize().negate();
                lightColors[i] = new java.awt.Color(lights.getDirectionalLightColor(i).getRGB());
            };}
            ambientLight = new java.awt.Color(lights.getAmbientColor().getRGB());
            background = new java.awt.Color(lights.getBackgroundColor().getRGB());
            snapshot.setStrokeWidth(0.5);
            snapshot.setRect(new java.awt.geom.Rectangle2D.Float(0.0, 0.0, width, height));
            snapshot.setBackgroundColor(background);
            const mappedVertices: java.util.List<com.vzome.core.math.RealVector> = <any>(new java.util.ArrayList<any>(60));
            for(let index=model.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    const shape: com.vzome.core.math.Polyhedron = rm.getShape();
                    const c: com.vzome.core.construction.Color = rm.getColor();
                    const color: java.awt.Color = (c == null) ? java.awt.Color.WHITE_$LI$() : new java.awt.Color(c.getRGB());
                    if (drawLines){
                        const m: com.vzome.core.model.Manifestation = rm.getManifestation();
                        if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                            const start: com.vzome.core.algebra.AlgebraicVector = (<com.vzome.core.model.Strut><any>m).getLocation();
                            const end: com.vzome.core.algebra.AlgebraicVector = (<com.vzome.core.model.Strut><any>m).getEnd();
                            const v0: com.vzome.core.math.RealVector = this.mapCoordinates(model.renderVector(start), height, width);
                            const v1: com.vzome.core.math.RealVector = this.mapCoordinates(model.renderVector(end), height, width);
                            snapshot.addLineSegment(color, v0, v1);
                        }
                        continue;
                    }
                    const vertices: java.util.List<com.vzome.core.algebra.AlgebraicVector> = shape.getVertexList();
                    const partOrientation: com.vzome.core.algebra.AlgebraicMatrix = rm.getOrientation();
                    const location: com.vzome.core.math.RealVector = rm.getLocation();
                    if (location == null)continue;
                    mappedVertices.clear();
                    for(let i: number = 0; i < vertices.size(); i++) {{
                        let gv: com.vzome.core.algebra.AlgebraicVector = vertices.get(i);
                        gv = partOrientation.timesColumn(gv);
                        const rv: com.vzome.core.math.RealVector = location.plus(model.renderVector(gv));
                        const v: com.vzome.core.math.RealVector = this.mapCoordinates(rv, height, width);
                        mappedVertices.add(v);
                    };}
                    for(let index=shape.getFaceSet().iterator();index.hasNext();) {
                        let face = index.next();
                        {
                            const arity: number = face.size();
                            const path: com.vzome.core.exporters2d.Java2dSnapshot.Polygon = new com.vzome.core.exporters2d.Java2dSnapshot.Polygon(color);
                            let backFacing: boolean = false;
                            let v1: com.vzome.core.math.RealVector = null;
                            let v2: com.vzome.core.math.RealVector = null;
                            for(let j: number = 0; j < arity; j++) {{
                                const index: number = face.get(j);
                                const v: com.vzome.core.math.RealVector = mappedVertices.get(index);
                                path.addVertex(v);
                                switch((path.size())) {
                                case 1:
                                    v1 = <com.vzome.core.math.RealVector>/* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(v);
                                    break;
                                case 2:
                                    v2 = <com.vzome.core.math.RealVector>/* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(v);
                                    break;
                                case 3:
                                    let v3: com.vzome.core.math.RealVector = <com.vzome.core.math.RealVector>/* clone */((o: any) => { if (o.clone != undefined) { return (<any>o).clone(); } else { let clone = Object.create(o); for(let p in o) { if (o.hasOwnProperty(p)) clone[p] = o[p]; } return clone; } })(v);
                                    v3 = v3.minus(v2);
                                    v2 = v2.minus(v1);
                                    const normal: com.vzome.core.math.RealVector = v2.cross(v3);
                                    backFacing = normal.z > 0;
                                    break;
                                default:
                                    break;
                                }
                            };}
                            path.close();
                            if (!backFacing){
                                if (doLighting){
                                    const faceNormal: com.vzome.core.algebra.AlgebraicVector = partOrientation.timesColumn(face.getNormal(vertices));
                                    const normal: com.vzome.core.math.RealVector = model.renderVector(faceNormal).normalize();
                                    let normalV: com.vzome.core.math.RealVector = new com.vzome.core.math.RealVector(normal.x, normal.y, normal.z);
                                    normalV = this.viewTransform.transform3dVec(normalV);
                                    path.applyLighting(normalV, lightDirs, lightColors, ambientLight);
                                }
                                snapshot.addPolygon(path);
                            }
                        }
                    }
                }
            }
            snapshot.depthSort();
            return snapshot;
        }

        /*private*/ mapCoordinates(rv: com.vzome.core.math.RealVector, height: number, width: number): com.vzome.core.math.RealVector {
            const xscale: number = (<any>Math).fround(width / 2.0);
            rv = this.viewTransform.transform3dPt(rv);
            let p4: number[] = [rv.x, rv.y, rv.z, 1.0];
            p4 = this.eyeTrans.transform4d(p4);
            let x: number = (<any>Math).fround(p4[0] / p4[3]);
            let y: number = (<any>Math).fround(p4[1] / p4[3]);
            const z: number = (<any>Math).fround(p4[2] / p4[3]);
            x = (<any>Math).fround(xscale * ((<any>Math).fround(x + 1.0)));
            y = (<any>Math).fround(((<any>Math).fround(height - ((<any>Math).fround(width * y)))) / 2.0);
            return new com.vzome.core.math.RealVector(x, y, z);
        }

        constructor() {
            if (this.viewTransform === undefined) { this.viewTransform = null; }
            if (this.eyeTrans === undefined) { this.eyeTrans = null; }
        }
    }
    Java2dExporter["__class"] = "com.vzome.core.exporters2d.Java2dExporter";

}
namespace com.vzome.core.edits {
    /**
     * @author David Hall
     * @class
     */
    export class ManifestationColorMappers {
        static __static_initialized: boolean = false;
        static __static_initialize() { if (!ManifestationColorMappers.__static_initialized) { ManifestationColorMappers.__static_initialized = true; ManifestationColorMappers.__static_initializer_0(); } }

        static colorMappers: java.util.Map<string, ManifestationColorMappers.ManifestationColorMapper>; public static colorMappers_$LI$(): java.util.Map<string, ManifestationColorMappers.ManifestationColorMapper> { ManifestationColorMappers.__static_initialize(); if (ManifestationColorMappers.colorMappers == null) { ManifestationColorMappers.colorMappers = <any>(new java.util.HashMap<any, any>()); }  return ManifestationColorMappers.colorMappers; }

        static  __static_initializer_0() {
            ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.RadialCentroidColorMap());
            ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.RadialStandardBasisColorMap());
            ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.CanonicalOrientationColorMap());
            ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.NormalPolarityColorMap());
            ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.CentroidByOctantAndDirectionColorMap());
            ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.CoordinatePlaneColorMap());
            ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.Identity());
            ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.ColorComplementor());
            ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.ColorInverter());
            ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.ColorMaximizer());
            ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.ColorSoftener());
        }

        public static RegisterMapper(mapper: ManifestationColorMappers.ManifestationColorMapper) {
            if (mapper != null){
                ManifestationColorMappers.colorMappers_$LI$().put(mapper.getName(), mapper);
                if (mapper.getName() === ("ColorComplementor"))ManifestationColorMappers.colorMappers_$LI$().put("ColorComplimentor", mapper);
            }
        }

        static getColorMapper$java_lang_String(mapperName: string): ManifestationColorMappers.ManifestationColorMapper {
            const strTransparency: string = "TransparencyMapper@";
            if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(mapperName, strTransparency)){
                const strAlpha: string = mapperName.substring(strTransparency.length);
                const alpha: number = javaemul.internal.IntegerHelper.parseInt(strAlpha);
                return new ManifestationColorMappers.TransparencyMapper(alpha);
            }
            switch((mapperName)) {
            case "TransparencyMapper":
                return new ManifestationColorMappers.TransparencyMapper(255);
            case "DarkenWithDistance":
                return new ManifestationColorMappers.DarkenWithDistance();
            case "DarkenNearOrigin":
                return new ManifestationColorMappers.DarkenNearOrigin();
            case "CopyLastSelectedColor":
                return new ManifestationColorMappers.CopyLastSelectedColor();
            }
            return ManifestationColorMappers.colorMappers_$LI$().get(mapperName);
        }

        public static getColorMapper$java_lang_String$com_vzome_core_editor_api_OrbitSource(mapperName: string, symmetry: com.vzome.core.editor.api.OrbitSource): ManifestationColorMappers.ManifestationColorMapper {
            let colorMapper: ManifestationColorMappers.ManifestationColorMapper = mapperName === ("SystemColorMap") ? new ManifestationColorMappers.SystemColorMap(symmetry) : mapperName === ("SystemCentroidColorMap") ? new ManifestationColorMappers.SystemCentroidColorMap(symmetry) : mapperName === ("NearestSpecialOrbitColorMap") ? new ManifestationColorMappers.NearestSpecialOrbitColorMap(symmetry) : mapperName === ("CentroidNearestSpecialOrbitColorMap") ? new ManifestationColorMappers.CentroidNearestSpecialOrbitColorMap(symmetry) : mapperName === ("NearestPredefinedOrbitColorMap") ? new ManifestationColorMappers.NearestPredefinedOrbitColorMap(symmetry) : mapperName === ("CentroidNearestPredefinedOrbitColorMap") ? new ManifestationColorMappers.CentroidNearestPredefinedOrbitColorMap(symmetry) : ManifestationColorMappers.getColorMapper$java_lang_String(mapperName);
            if (colorMapper == null){
                colorMapper = new ManifestationColorMappers.Identity();
            }
            return colorMapper;
        }

        public static getColorMapper(mapperName?: any, symmetry?: any): ManifestationColorMappers.ManifestationColorMapper {
            if (((typeof mapperName === 'string') || mapperName === null) && ((symmetry != null && (symmetry.constructor != null && symmetry.constructor["__interfaces"] != null && symmetry.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.OrbitSource") >= 0)) || symmetry === null)) {
                return <any>com.vzome.core.edits.ManifestationColorMappers.getColorMapper$java_lang_String$com_vzome_core_editor_api_OrbitSource(mapperName, symmetry);
            } else if (((typeof mapperName === 'string') || mapperName === null) && symmetry === undefined) {
                return <any>com.vzome.core.edits.ManifestationColorMappers.getColorMapper$java_lang_String(mapperName);
            } else throw new Error('invalid overload');
        }

        static mapPolarity(vector: com.vzome.core.algebra.AlgebraicVector, alpha: number): com.vzome.core.construction.Color {
            const polarity: number = vector.compareTo(vector.negate());
            const mid: number = 128;
            const diff: number = 64;
            const shade: number = polarity < 0 ? mid - diff : polarity > 0 ? mid + diff : mid;
            return new com.vzome.core.construction.Color(shade, shade, shade, alpha);
        }

        /**
         * @param {com.vzome.core.algebra.AlgebraicVector} vector could be midpoint, start, end, normal, or any basis for mapping to a color
         * @param {number} alpha the transparency component of the resulting color.
         * @return
         * @return {com.vzome.core.construction.Color}
         */
        static mapRadially(vector: com.vzome.core.algebra.AlgebraicVector, alpha: number): com.vzome.core.construction.Color {
            const midPoint: number = 127;
            const rgb: number[] = [midPoint, midPoint, midPoint];
            const parts: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(rgb.length);
            const dimensions: number = Math.min(rgb.length, vector.dimension());
            let whole: number = 0.0;
            for(let i: number = 0; i < dimensions; i++) {{
                const component: com.vzome.core.algebra.AlgebraicNumber = vector.getComponent(i);
                parts[i] = component.evaluate();
                whole += Math.abs(parts[i]);
            };}
            if (whole !== 0.0){
                for(let i: number = 0; i < parts.length; i++) {{
                    const part: number = (parts[i] / whole);
                    const contribution: number = part * midPoint;
                    rgb[i] = /* intValue */(contribution|0) + midPoint;
                    rgb[i] = Math.min(255, rgb[i]);
                    rgb[i] = Math.max(0, rgb[i]);
                };}
            }
            return new com.vzome.core.construction.Color(rgb[0], rgb[1], rgb[2], alpha);
        }

        /**
         * @param {com.vzome.core.algebra.AlgebraicVector} vector could be midpoint, start, end, normal, or any basis for mapping to a color
         * @param {number} alpha the transparency component of the resulting color.
         * @param {number} neg the R, G or B level of vectors with a negative value in the corresponding X, Y, or Z dimension.
         * @param {number} zero the R, G or B level of vectors with a zero value in the corresponding X, Y, or Z dimension.
         * @param {number} pos the R, G or B level of vectors with a positive value in the corresponding X, Y, or Z dimension.
         * @return
         * @return {com.vzome.core.construction.Color}
         */
        static mapToOctant(vector: com.vzome.core.algebra.AlgebraicVector, alpha: number, neg: number, zero: number, pos: number): com.vzome.core.construction.Color {
            const src: number[] = [neg, zero, pos];
            const rgb: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(src.length);
            const dimensions: number = Math.min(rgb.length, vector.dimension());
            for(let i: number = 0; i < dimensions; i++) {{
                const component: com.vzome.core.algebra.AlgebraicNumber = vector.getComponent(i);
                const dir: number = /* signum */(f => { if (f > 0) { return 1; } else if (f < 0) { return -1; } else { return 0; } })(component.evaluate());
                const index: number = /* intValue */(dir|0) + 1;
                rgb[i] = src[index];
            };}
            return new com.vzome.core.construction.Color(rgb[0], rgb[1], rgb[2], alpha);
        }

        static mapToMagnitude(vector: com.vzome.core.algebra.AlgebraicVector, offset: number, fullScaleSquared: number, initialColor: com.vzome.core.construction.Color): com.vzome.core.construction.Color {
            if (vector == null || initialColor == null){
                return initialColor;
            }
            const magnitudeSquared: number = com.vzome.core.algebra.AlgebraicVectors.getMagnitudeSquared(vector).evaluate();
            const denominator: number = (fullScaleSquared === 0.0) ? 1.0E-4 : fullScaleSquared;
            const scale: number = Math.abs(offset - magnitudeSquared) / denominator;
            return com.vzome.core.construction.Color.getScaledTo(initialColor, scale);
        }
    }
    ManifestationColorMappers["__class"] = "com.vzome.core.edits.ManifestationColorMappers";


    export namespace ManifestationColorMappers {

        /**
         * Common abstract base class adds xml persistence
         * and late loading of criteria based on selection and/or model
         * @class
         */
        export abstract class ManifestationColorMapper implements com.vzome.core.edits.ColorMappers.ColorMapper<com.vzome.core.model.Manifestation> {
            /* Default method injected from com.vzome.core.edits.ColorMappers.ColorMapper */
            public requiresOrderedSelection(): boolean {
                return false;
            }
            constructor() {
            }

            /**
             * Optional opportunity to initialize parameters that were not available at time of the constructor
             * but are determined based on the selection or model iterator
             * just before apply is called on each individual manifestation.
             * @param selection
             * @param model
             * @param {com.vzome.core.editor.api.Manifestations.ManifestationIterator} manifestations
             */
            public initialize(manifestations: com.vzome.core.editor.api.Manifestations.ManifestationIterator) {
            }

            public apply$com_vzome_core_model_Manifestation(man: com.vzome.core.model.Manifestation): com.vzome.core.construction.Color {
                return (man == null || !man.isRendered()) ? null : this.applyTo(man);
            }

            /**
             * 
             * @param {*} man
             * @return {com.vzome.core.construction.Color}
             */
            public apply(man?: any): com.vzome.core.construction.Color {
                if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null)) {
                    return <any>this.apply$com_vzome_core_model_Manifestation(man);
                } else throw new Error('invalid overload');
            }

            applyTo(manifestation: com.vzome.core.model.Manifestation): com.vzome.core.construction.Color {
                let color: com.vzome.core.construction.Color = manifestation.getColor();
                if (color == null){
                    color = com.vzome.core.construction.Color.WHITE_$LI$();
                }
                return color;
            }

            /**
             * subclasses should call {@code result.setAttribute()} if they have any parameters to persist
             * @param {*} result
             */
            getXmlAttributes(result: org.w3c.dom.Element) {
            }

            /**
             * subclasses should call {@code xml.getAttribute()} to retrieve any persisted parameters
             * @param {*} xml
             */
            setXmlAttributes(xml: org.w3c.dom.Element) {
            }

            public abstract getName(): any;        }
        ManifestationColorMapper["__class"] = "com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper";
        ManifestationColorMapper["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * returns current color
         * @class
         * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
         */
        export class Identity extends ManifestationColorMappers.ManifestationColorMapper {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "Identity";
            }

            /**
             * 
             * @param {*} rendered
             * @return {com.vzome.core.construction.Color}
             */
            applyTo(rendered: com.vzome.core.model.Manifestation): com.vzome.core.construction.Color {
                return rendered.getColor();
            }

            constructor() {
                super();
            }
        }
        Identity["__class"] = "com.vzome.core.edits.ManifestationColorMappers.Identity";
        Identity["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * returns complementary color
         * @class
         * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
         */
        export class ColorComplementor extends ManifestationColorMappers.ManifestationColorMapper {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "ColorComplementor";
            }

            /**
             * 
             * @param {*} rendered
             * @return {com.vzome.core.construction.Color}
             */
            applyTo(rendered: com.vzome.core.model.Manifestation): com.vzome.core.construction.Color {
                return com.vzome.core.construction.Color.getComplement(super.applyTo(rendered));
            }

            constructor() {
                super();
            }
        }
        ColorComplementor["__class"] = "com.vzome.core.edits.ManifestationColorMappers.ColorComplementor";
        ColorComplementor["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * returns inverted color
         * @class
         * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
         */
        export class ColorInverter extends ManifestationColorMappers.ManifestationColorMapper {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "ColorInverter";
            }

            /**
             * 
             * @param {*} rendered
             * @return {com.vzome.core.construction.Color}
             */
            applyTo(rendered: com.vzome.core.model.Manifestation): com.vzome.core.construction.Color {
                return com.vzome.core.construction.Color.getInverted(super.applyTo(rendered));
            }

            constructor() {
                super();
            }
        }
        ColorInverter["__class"] = "com.vzome.core.edits.ManifestationColorMappers.ColorInverter";
        ColorInverter["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * returns maximized color
         * @class
         * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
         */
        export class ColorMaximizer extends ManifestationColorMappers.ManifestationColorMapper {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "ColorMaximizer";
            }

            /**
             * 
             * @param {*} rendered
             * @return {com.vzome.core.construction.Color}
             */
            applyTo(rendered: com.vzome.core.model.Manifestation): com.vzome.core.construction.Color {
                return com.vzome.core.construction.Color.getMaximum(super.applyTo(rendered));
            }

            constructor() {
                super();
            }
        }
        ColorMaximizer["__class"] = "com.vzome.core.edits.ManifestationColorMappers.ColorMaximizer";
        ColorMaximizer["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * returns pastel of current color
         * @class
         * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
         */
        export class ColorSoftener extends ManifestationColorMappers.ManifestationColorMapper {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "ColorSoftener";
            }

            /**
             * 
             * @param {*} rendered
             * @return {com.vzome.core.construction.Color}
             */
            applyTo(rendered: com.vzome.core.model.Manifestation): com.vzome.core.construction.Color {
                return com.vzome.core.construction.Color.getPastel(super.applyTo(rendered));
            }

            constructor() {
                super();
            }
        }
        ColorSoftener["__class"] = "com.vzome.core.edits.ManifestationColorMappers.ColorSoftener";
        ColorSoftener["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        export class TransparencyMapper extends ManifestationColorMappers.ManifestationColorMapper {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "TransparencyMapper";
            }

            alpha: number;

            public constructor(alpha: number) {
                super();
                if (this.alpha === undefined) { this.alpha = 0; }
                this.setAlpha(alpha);
            }

            setAlpha(value: number) {
                this.alpha = Math.min(255, Math.max(1, value));
            }

            static ALPHA_ATTR_NAME: string = "alpha";

            /**
             * 
             * @param {*} xml
             */
            setXmlAttributes(xml: org.w3c.dom.Element) {
                this.alpha = javaemul.internal.IntegerHelper.parseInt(xml.getAttribute(TransparencyMapper.ALPHA_ATTR_NAME));
            }

            /**
             * 
             * @param {*} result
             */
            getXmlAttributes(result: org.w3c.dom.Element) {
                result.setAttribute(TransparencyMapper.ALPHA_ATTR_NAME, /* toString */(''+(this.alpha)));
            }

            /**
             * 
             * @param {*} rendered
             * @return {com.vzome.core.construction.Color}
             */
            applyTo(rendered: com.vzome.core.model.Manifestation): com.vzome.core.construction.Color {
                const color: com.vzome.core.construction.Color = super.applyTo(rendered);
                return new com.vzome.core.construction.Color(color.getRed(), color.getGreen(), color.getBlue(), this.alpha);
            }
        }
        TransparencyMapper["__class"] = "com.vzome.core.edits.ManifestationColorMappers.TransparencyMapper";
        TransparencyMapper["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        export class CopyLastSelectedColor extends ManifestationColorMappers.ManifestationColorMapper {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "CopyLastSelectedColor";
            }

            color: com.vzome.core.construction.Color;

            /**
             * 
             * @return {boolean}
             */
            public requiresOrderedSelection(): boolean {
                return true;
            }

            /**
             * 
             * @param {com.vzome.core.editor.api.Manifestations.ManifestationIterator} selection
             */
            public initialize(selection: com.vzome.core.editor.api.Manifestations.ManifestationIterator) {
                if (this.color == null){
                    let last: com.vzome.core.model.Manifestation = null;
                    for(let index=selection.iterator();index.hasNext();) {
                        let man = index.next();
                        {
                            if (man != null && man.isRendered()){
                                last = man;
                            }
                        }
                    }
                    if (last != null){
                        this.color = last.getColor();
                    }
                }
                if (this.color == null){
                    throw new com.vzome.core.commands.Command.Failure("select a ball, strut or panel as the color to be copied.");
                }
            }

            /**
             * 
             * @param {*} xml
             */
            setXmlAttributes(xml: org.w3c.dom.Element) {
                const red: string = xml.getAttribute("red");
                const green: string = xml.getAttribute("green");
                const blue: string = xml.getAttribute("blue");
                const alphaStr: string = xml.getAttribute("alpha");
                const alpha: number = (alphaStr == null || /* isEmpty */(alphaStr.length === 0)) ? 255 : javaemul.internal.IntegerHelper.parseInt(alphaStr);
                this.color = new com.vzome.core.construction.Color(javaemul.internal.IntegerHelper.parseInt(red), javaemul.internal.IntegerHelper.parseInt(green), javaemul.internal.IntegerHelper.parseInt(blue), alpha);
            }

            /**
             * 
             * @param {*} result
             */
            getXmlAttributes(result: org.w3c.dom.Element) {
                result.setAttribute("red", "" + this.color.getRed());
                result.setAttribute("green", "" + this.color.getGreen());
                result.setAttribute("blue", "" + this.color.getBlue());
                const alpha: number = this.color.getAlpha();
                if (alpha < 255)result.setAttribute("alpha", "" + alpha);
            }

            /**
             * 
             * @param {*} rendered
             * @return {com.vzome.core.construction.Color}
             */
            applyTo(rendered: com.vzome.core.model.Manifestation): com.vzome.core.construction.Color {
                return this.color;
            }

            constructor() {
                super();
                if (this.color === undefined) { this.color = null; }
            }
        }
        CopyLastSelectedColor["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CopyLastSelectedColor";
        CopyLastSelectedColor["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * Handles getting the centroid and calling overloaded methods to map the subClass specific AlgebraicVector
         * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
         * @class
         */
        export abstract class CentroidColorMapper extends ManifestationColorMappers.ManifestationColorMapper {
            constructor() {
                super();
            }

            public applyTo$com_vzome_core_model_Manifestation(rendered: com.vzome.core.model.Manifestation): com.vzome.core.construction.Color {
                const color: com.vzome.core.construction.Color = rendered.getColor();
                const alpha: number = color == null ? 255 : color.getAlpha();
                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(rendered.getCentroid(), alpha);
            }

            public applyTo$com_vzome_core_algebra_AlgebraicVector$int(centroid: com.vzome.core.algebra.AlgebraicVector, alpha: number): com.vzome.core.construction.Color { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }

            public applyTo(centroid?: any, alpha?: any): com.vzome.core.construction.Color {
                if (((centroid != null && centroid instanceof <any>com.vzome.core.algebra.AlgebraicVector) || centroid === null) && ((typeof alpha === 'number') || alpha === null)) {
                    return <any>this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(centroid, alpha);
                } else if (((centroid != null && (centroid.constructor != null && centroid.constructor["__interfaces"] != null && centroid.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || centroid === null) && alpha === undefined) {
                    return <any>this.applyTo$com_vzome_core_model_Manifestation(centroid);
                } else throw new Error('invalid overload');
            }
        }
        CentroidColorMapper["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CentroidColorMapper";
        CentroidColorMapper["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * Scales the intensity of the current color of each Manifestation
         * based on the distance of its centroid from the origin.
         * A position ranging from the origin to the fullScale vector position
         * adjusts the intensity of the current color from darkest to lightest.
         * @class
         * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
         */
        export class DarkenNearOrigin extends ManifestationColorMappers.ManifestationColorMapper {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "DarkenNearOrigin";
            }

            offset: number;

            fullScaleSquared: number;

            /**
             * 
             * @param {com.vzome.core.editor.api.Manifestations.ManifestationIterator} manifestations
             */
            public initialize(manifestations: com.vzome.core.editor.api.Manifestations.ManifestationIterator) {
                if (this.fullScaleSquared === 0){
                    const fullScale: com.vzome.core.algebra.AlgebraicVector = DarkenNearOrigin.getMostDistantPoint(manifestations);
                    if (fullScale == null){
                        throw new com.vzome.core.commands.Command.Failure("unable to determine most distant point");
                    }
                    if (fullScale.isOrigin()){
                        throw new com.vzome.core.commands.Command.Failure("select at least one point other than the origin");
                    }
                    this.fullScaleSquared = com.vzome.core.algebra.AlgebraicVectors.getMagnitudeSquared(fullScale).evaluate();
                }
            }

            static getMostDistantPoint(manifestations: com.vzome.core.editor.api.Manifestations.ManifestationIterator): com.vzome.core.algebra.AlgebraicVector {
                const centroids: java.util.List<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>());
                for(let index=manifestations.iterator();index.hasNext();) {
                    let man = index.next();
                    {
                        centroids.add(man.getCentroid());
                    }
                }
                if (centroids.isEmpty()){
                    return null;
                }
                const mostDistant: java.util.TreeSet<com.vzome.core.algebra.AlgebraicVector> = com.vzome.core.algebra.AlgebraicVectors.getMostDistantFromOrigin(centroids);
                return mostDistant.isEmpty() ? null : mostDistant.first();
            }

            /**
             * 
             * @param {*} rendered
             * @return {com.vzome.core.construction.Color}
             */
            applyTo(rendered: com.vzome.core.model.Manifestation): com.vzome.core.construction.Color {
                const centroid: com.vzome.core.algebra.AlgebraicVector = rendered.getCentroid();
                const initialColor: com.vzome.core.construction.Color = super.applyTo(rendered);
                return ManifestationColorMappers.mapToMagnitude(centroid, this.offset, this.fullScaleSquared, initialColor);
            }

            FULLSCALESQUARED_ATTR_NAME: string;

            /**
             * 
             * @param {*} result
             */
            getXmlAttributes(result: org.w3c.dom.Element) {
                result.setAttribute(this.FULLSCALESQUARED_ATTR_NAME, /* toString */(''+(this.fullScaleSquared)));
            }

            /**
             * 
             * @param {*} xml
             */
            setXmlAttributes(xml: org.w3c.dom.Element) {
                const attr: string = xml.getAttribute(this.FULLSCALESQUARED_ATTR_NAME);
                this.fullScaleSquared = javaemul.internal.DoubleHelper.parseDouble(attr);
            }

            constructor() {
                super();
                this.offset = 0;
                this.fullScaleSquared = 0;
                this.FULLSCALESQUARED_ATTR_NAME = "fullScaleSquared";
            }
        }
        DarkenNearOrigin["__class"] = "com.vzome.core.edits.ManifestationColorMappers.DarkenNearOrigin";
        DarkenNearOrigin["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * Abstract base class which calls subclass specific abstract overloads for all known subtypes.
         * @class
         * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
         */
        export abstract class ManifestationSubclassColorMapper extends ManifestationColorMappers.ManifestationColorMapper {
            /**
             * 
             * @param {*} man
             * @return {com.vzome.core.construction.Color}
             */
            applyTo(man: com.vzome.core.model.Manifestation): com.vzome.core.construction.Color {
                const color: com.vzome.core.construction.Color = man.getColor();
                const alpha: number = color == null ? 255 : color.getAlpha();
                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                    return this.applyToBall(<com.vzome.core.model.Connector><any>man, alpha);
                } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                    return this.applyToStrut(<com.vzome.core.model.Strut><any>man, alpha);
                } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                    return this.applyToPanel(<com.vzome.core.model.Panel><any>man, alpha);
                }
                return null;
            }

            abstract applyToBall(ball: com.vzome.core.model.Connector, alpha: number): com.vzome.core.construction.Color;

            abstract applyToStrut(strut: com.vzome.core.model.Strut, alpha: number): com.vzome.core.construction.Color;

            abstract applyToPanel(panel: com.vzome.core.model.Panel, alpha: number): com.vzome.core.construction.Color;

            constructor() {
                super();
            }
        }
        ManifestationSubclassColorMapper["__class"] = "com.vzome.core.edits.ManifestationColorMappers.ManifestationSubclassColorMapper";
        ManifestationSubclassColorMapper["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * Maps vector XYZ components to RGB
         * such that each RGB component is weighted by the contribution
         * of the corresponding XYZ component
         * and offset by half of the color range so that a
         * + directions map between 0x7F and 0xFF color element
         * 0 direction maps to a midrange    0x7F color element
         * - directions map between 0x00 and 0x7F color element
         * 
         * Polarity info IS retained by this mapping.
         * @class
         * @extends com.vzome.core.edits.ManifestationColorMappers.CentroidColorMapper
         */
        export class RadialCentroidColorMap extends ManifestationColorMappers.CentroidColorMapper {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "RadialCentroidColorMap";
            }

            public applyTo$com_vzome_core_algebra_AlgebraicVector$int(centroid: com.vzome.core.algebra.AlgebraicVector, alpha: number): com.vzome.core.construction.Color {
                return ManifestationColorMappers.mapRadially(centroid, alpha);
            }

            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} centroid
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            public applyTo(centroid?: any, alpha?: any): com.vzome.core.construction.Color {
                if (((centroid != null && centroid instanceof <any>com.vzome.core.algebra.AlgebraicVector) || centroid === null) && ((typeof alpha === 'number') || alpha === null)) {
                    return <any>this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(centroid, alpha);
                } else if (((centroid != null && (centroid.constructor != null && centroid.constructor["__interfaces"] != null && centroid.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || centroid === null) && alpha === undefined) {
                    return <any>this.applyTo$com_vzome_core_model_Manifestation(centroid);
                } else throw new Error('invalid overload');
            }

            constructor() {
                super();
            }
        }
        RadialCentroidColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.RadialCentroidColorMap";
        RadialCentroidColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * Maps vector XYZ components to RGB by Octant
         * 
         * Polarity info IS retained by this mapping.
         * @class
         * @extends com.vzome.core.edits.ManifestationColorMappers.CentroidColorMapper
         */
        export class CentroidByOctantAndDirectionColorMap extends ManifestationColorMappers.CentroidColorMapper {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "CentroidByOctantAndDirectionColorMap";
            }

            public applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector: com.vzome.core.algebra.AlgebraicVector, alpha: number): com.vzome.core.construction.Color {
                return com.vzome.core.construction.Color.getMaximum(ManifestationColorMappers.mapToOctant(vector, alpha, 0, 127, 255));
            }

            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} vector
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            public applyTo(vector?: any, alpha?: any): com.vzome.core.construction.Color {
                if (((vector != null && vector instanceof <any>com.vzome.core.algebra.AlgebraicVector) || vector === null) && ((typeof alpha === 'number') || alpha === null)) {
                    return <any>this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha);
                } else if (((vector != null && (vector.constructor != null && vector.constructor["__interfaces"] != null && vector.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || vector === null) && alpha === undefined) {
                    return <any>this.applyTo$com_vzome_core_model_Manifestation(vector);
                } else throw new Error('invalid overload');
            }

            constructor() {
                super();
            }
        }
        CentroidByOctantAndDirectionColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CentroidByOctantAndDirectionColorMap";
        CentroidByOctantAndDirectionColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * Maps vector XYZ components to RGB
         * corresponding to the X, Y or Z coordinate plane.
         * 
         * Polarity info IS NOT retained by this mapping.
         * @class
         * @extends com.vzome.core.edits.ManifestationColorMappers.CentroidColorMapper
         */
        export class CoordinatePlaneColorMap extends ManifestationColorMappers.CentroidColorMapper {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "CoordinatePlaneColorMap";
            }

            public applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector: com.vzome.core.algebra.AlgebraicVector, alpha: number): com.vzome.core.construction.Color {
                return com.vzome.core.construction.Color.getInverted(ManifestationColorMappers.mapToOctant(vector, alpha, 0, 255, 0));
            }

            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} vector
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            public applyTo(vector?: any, alpha?: any): com.vzome.core.construction.Color {
                if (((vector != null && vector instanceof <any>com.vzome.core.algebra.AlgebraicVector) || vector === null) && ((typeof alpha === 'number') || alpha === null)) {
                    return <any>this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha);
                } else if (((vector != null && (vector.constructor != null && vector.constructor["__interfaces"] != null && vector.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || vector === null) && alpha === undefined) {
                    return <any>this.applyTo$com_vzome_core_model_Manifestation(vector);
                } else throw new Error('invalid overload');
            }

            constructor() {
                super();
            }
        }
        CoordinatePlaneColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CoordinatePlaneColorMap";
        CoordinatePlaneColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * Maps standard SymmetrySystem colors
         * to the Manifestation's Centroid instead of the normal vector
         * @extends com.vzome.core.edits.ManifestationColorMappers.CentroidColorMapper
         * @class
         */
        export class SystemCentroidColorMap extends ManifestationColorMappers.CentroidColorMapper {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "SystemCentroidColorMap";
            }

            symmetrySystem: com.vzome.core.editor.api.OrbitSource;

            constructor(symmetry: com.vzome.core.editor.api.OrbitSource) {
                super();
                if (this.symmetrySystem === undefined) { this.symmetrySystem = null; }
                this.symmetrySystem = symmetry;
            }

            public applyTo$com_vzome_core_algebra_AlgebraicVector$int(centroid: com.vzome.core.algebra.AlgebraicVector, alpha: number): com.vzome.core.construction.Color {
                return this.symmetrySystem.getVectorColor(centroid);
            }

            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} centroid
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            public applyTo(centroid?: any, alpha?: any): com.vzome.core.construction.Color {
                if (((centroid != null && centroid instanceof <any>com.vzome.core.algebra.AlgebraicVector) || centroid === null) && ((typeof alpha === 'number') || alpha === null)) {
                    return <any>this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(centroid, alpha);
                } else if (((centroid != null && (centroid.constructor != null && centroid.constructor["__interfaces"] != null && centroid.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || centroid === null) && alpha === undefined) {
                    return <any>this.applyTo$com_vzome_core_model_Manifestation(centroid);
                } else throw new Error('invalid overload');
            }

            /**
             * 
             * @param {*} element
             */
            getXmlAttributes(element: org.w3c.dom.Element) {
                if (this.symmetrySystem != null){
                    com.vzome.xml.DomUtils.addAttribute(element, "symmetry", this.symmetrySystem.getName());
                }
            }
        }
        SystemCentroidColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.SystemCentroidColorMap";
        SystemCentroidColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * Same as {@code DarkenNearOrigin} except that
         * the color mapping is reversed from lightest to darkest
         * @class
         * @extends com.vzome.core.edits.ManifestationColorMappers.DarkenNearOrigin
         */
        export class DarkenWithDistance extends ManifestationColorMappers.DarkenNearOrigin {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "DarkenWithDistance";
            }

            /**
             * 
             * @param {com.vzome.core.editor.api.Manifestations.ManifestationIterator} manifestations
             */
            public initialize(manifestations: com.vzome.core.editor.api.Manifestations.ManifestationIterator) {
                super.initialize(manifestations);
                this.offset = this.fullScaleSquared;
            }

            constructor() {
                super();
            }
        }
        DarkenWithDistance["__class"] = "com.vzome.core.edits.ManifestationColorMappers.DarkenWithDistance";
        DarkenWithDistance["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * Polarity info is retained by this mapping
         * so that inverted struts and panels will be mapped to inverted colors.
         * @class
         * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationSubclassColorMapper
         */
        export class RadialStandardBasisColorMap extends ManifestationColorMappers.ManifestationSubclassColorMapper {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "RadialStandardBasisColorMap";
            }

            /**
             * 
             * @param {*} ball
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            applyToBall(ball: com.vzome.core.model.Connector, alpha: number): com.vzome.core.construction.Color {
                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(ball.getLocation(), alpha);
            }

            /**
             * 
             * @param {*} strut
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            applyToStrut(strut: com.vzome.core.model.Strut, alpha: number): com.vzome.core.construction.Color {
                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(strut.getOffset(), alpha);
            }

            /**
             * 
             * @param {*} panel
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            applyToPanel(panel: com.vzome.core.model.Panel, alpha: number): com.vzome.core.construction.Color {
                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(panel['getNormal$'](), alpha);
            }

            public applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector: com.vzome.core.algebra.AlgebraicVector, alpha: number): com.vzome.core.construction.Color {
                return ManifestationColorMappers.mapRadially(vector, alpha);
            }

            public applyTo(vector?: any, alpha?: any): com.vzome.core.construction.Color {
                if (((vector != null && vector instanceof <any>com.vzome.core.algebra.AlgebraicVector) || vector === null) && ((typeof alpha === 'number') || alpha === null)) {
                    return <any>this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha);
                } else if (((vector != null && (vector.constructor != null && vector.constructor["__interfaces"] != null && vector.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || vector === null) && alpha === undefined) {
                    return super.applyTo(vector);
                } else throw new Error('invalid overload');
            }

            constructor() {
                super();
            }
        }
        RadialStandardBasisColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.RadialStandardBasisColorMap";
        RadialStandardBasisColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * Gets standard color mapping from the OrbitSource
         * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationSubclassColorMapper
         * @class
         */
        export class SystemColorMap extends ManifestationColorMappers.ManifestationSubclassColorMapper {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "SystemColorMap";
            }

            symmetrySystem: com.vzome.core.editor.api.OrbitSource;

            constructor(symmetry: com.vzome.core.editor.api.OrbitSource) {
                super();
                if (this.symmetrySystem === undefined) { this.symmetrySystem = null; }
                this.symmetrySystem = symmetry;
            }

            /**
             * 
             * @param {*} ball
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            applyToBall(ball: com.vzome.core.model.Connector, alpha: number): com.vzome.core.construction.Color {
                return this.symmetrySystem.getVectorColor(null);
            }

            /**
             * 
             * @param {*} strut
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            applyToStrut(strut: com.vzome.core.model.Strut, alpha: number): com.vzome.core.construction.Color {
                return this.applyToVector(strut.getOffset());
            }

            /**
             * 
             * @param {*} panel
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            applyToPanel(panel: com.vzome.core.model.Panel, alpha: number): com.vzome.core.construction.Color {
                return this.applyToVector(panel['getNormal$']()).getPastel();
            }

            applyToVector(vector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.construction.Color {
                return this.symmetrySystem.getVectorColor(vector);
            }

            /**
             * 
             * @param {*} element
             */
            getXmlAttributes(element: org.w3c.dom.Element) {
                if (this.symmetrySystem != null){
                    com.vzome.xml.DomUtils.addAttribute(element, "symmetry", this.symmetrySystem.getName());
                }
            }
        }
        SystemColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.SystemColorMap";
        SystemColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * Polarity info is intentionally removed by this mapping for struts and panels, but not balls
         * so that parallel struts and the panels normal to them will be the same color.
         * @class
         * @extends com.vzome.core.edits.ManifestationColorMappers.RadialStandardBasisColorMap
         */
        export class CanonicalOrientationColorMap extends ManifestationColorMappers.RadialStandardBasisColorMap {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "CanonicalOrientationColorMap";
            }

            /**
             * 
             * @param {*} ball
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            applyToBall(ball: com.vzome.core.model.Connector, alpha: number): com.vzome.core.construction.Color {
                return super.applyToBall(ball, alpha);
            }

            public applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector: com.vzome.core.algebra.AlgebraicVector, alpha: number): com.vzome.core.construction.Color {
                return super.applyTo$com_vzome_core_algebra_AlgebraicVector$int(com.vzome.core.algebra.AlgebraicVectors.getCanonicalOrientation(vector), alpha);
            }

            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} vector
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            public applyTo(vector?: any, alpha?: any): com.vzome.core.construction.Color {
                if (((vector != null && vector instanceof <any>com.vzome.core.algebra.AlgebraicVector) || vector === null) && ((typeof alpha === 'number') || alpha === null)) {
                    return <any>this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha);
                } else if (((vector != null && (vector.constructor != null && vector.constructor["__interfaces"] != null && vector.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || vector === null) && alpha === undefined) {
                    return super.applyTo(vector);
                } else throw new Error('invalid overload');
            }

            constructor() {
                super();
            }
        }
        CanonicalOrientationColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CanonicalOrientationColorMap";
        CanonicalOrientationColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * Polarity info is the ONLY basis for this mapping
         * @class
         * @extends com.vzome.core.edits.ManifestationColorMappers.RadialStandardBasisColorMap
         */
        export class NormalPolarityColorMap extends ManifestationColorMappers.RadialStandardBasisColorMap {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "NormalPolarityColorMap";
            }

            public applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector: com.vzome.core.algebra.AlgebraicVector, alpha: number): com.vzome.core.construction.Color {
                return ManifestationColorMappers.mapPolarity(vector, alpha);
            }

            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} vector
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            public applyTo(vector?: any, alpha?: any): com.vzome.core.construction.Color {
                if (((vector != null && vector instanceof <any>com.vzome.core.algebra.AlgebraicVector) || vector === null) && ((typeof alpha === 'number') || alpha === null)) {
                    return <any>this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha);
                } else if (((vector != null && (vector.constructor != null && vector.constructor["__interfaces"] != null && vector.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || vector === null) && alpha === undefined) {
                    return super.applyTo(vector);
                } else throw new Error('invalid overload');
            }

            constructor() {
                super();
            }
        }
        NormalPolarityColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.NormalPolarityColorMap";
        NormalPolarityColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * Gets standard color of the nearest special orbit using the standard color basis
         * @extends com.vzome.core.edits.ManifestationColorMappers.SystemColorMap
         * @class
         */
        export class NearestSpecialOrbitColorMap extends ManifestationColorMappers.SystemColorMap {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "NearestSpecialOrbitColorMap";
            }

            specialOrbits: java.util.Set<com.vzome.core.math.symmetry.Direction>;

            constructor(symm: com.vzome.core.editor.api.OrbitSource) {
                super(symm);
                this.specialOrbits = <any>(new java.util.LinkedHashSet<any>());
                this.specialOrbits.add(symm.getSymmetry().getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.BLUE));
                this.specialOrbits.add(symm.getSymmetry().getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.YELLOW));
                this.specialOrbits.add(symm.getSymmetry().getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.RED));
            }

            /**
             * 
             * @param {*} ball
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            applyToBall(ball: com.vzome.core.model.Connector, alpha: number): com.vzome.core.construction.Color {
                return this.applyToVector(ball.getLocation());
            }

            /**
             * 
             * @param {*} strut
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            applyToStrut(strut: com.vzome.core.model.Strut, alpha: number): com.vzome.core.construction.Color {
                return this.applyToVector(strut.getOffset());
            }

            /**
             * 
             * @param {*} panel
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            applyToPanel(panel: com.vzome.core.model.Panel, alpha: number): com.vzome.core.construction.Color {
                return this.applyToVector(panel['getNormal$']()).getPastel();
            }

            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} vector
             * @return {com.vzome.core.construction.Color}
             */
            applyToVector(vector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.construction.Color {
                if (vector.isOrigin()){
                    return this.symmetrySystem.getVectorColor(null);
                }
                const nearestSpecialOrbit: com.vzome.core.math.symmetry.Axis = this.symmetrySystem.getSymmetry()['getAxis$com_vzome_core_math_RealVector$java_util_Collection'](vector.toRealVector(), this.specialOrbits);
                const normal: com.vzome.core.algebra.AlgebraicVector = nearestSpecialOrbit.normal();
                return this.symmetrySystem.getVectorColor(normal);
            }
        }
        NearestSpecialOrbitColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.NearestSpecialOrbitColorMap";
        NearestSpecialOrbitColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * Gets standard color of the nearest special orbit based on the Centroid
         * @extends com.vzome.core.edits.ManifestationColorMappers.NearestSpecialOrbitColorMap
         * @class
         */
        export class CentroidNearestSpecialOrbitColorMap extends ManifestationColorMappers.NearestSpecialOrbitColorMap {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "CentroidNearestSpecialOrbitColorMap";
            }

            constructor(symm: com.vzome.core.editor.api.OrbitSource) {
                super(symm);
            }

            /**
             * 
             * @param {*} ball
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            applyToBall(ball: com.vzome.core.model.Connector, alpha: number): com.vzome.core.construction.Color {
                return this.applyToVector(ball.getCentroid());
            }

            /**
             * 
             * @param {*} strut
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            applyToStrut(strut: com.vzome.core.model.Strut, alpha: number): com.vzome.core.construction.Color {
                return this.applyToVector(strut.getCentroid());
            }

            /**
             * 
             * @param {*} panel
             * @param {number} alpha
             * @return {com.vzome.core.construction.Color}
             */
            applyToPanel(panel: com.vzome.core.model.Panel, alpha: number): com.vzome.core.construction.Color {
                return this.applyToVector(panel.getCentroid()).getPastel();
            }
        }
        CentroidNearestSpecialOrbitColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CentroidNearestSpecialOrbitColorMap";
        CentroidNearestSpecialOrbitColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * Gets standard color of the nearest predefined orbit using the symmetry's standard color scheme
         * @extends com.vzome.core.edits.ManifestationColorMappers.NearestSpecialOrbitColorMap
         * @class
         */
        export class NearestPredefinedOrbitColorMap extends ManifestationColorMappers.NearestSpecialOrbitColorMap {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "NearestPredefinedOrbitColorMap";
            }

            constructor(symm: com.vzome.core.editor.api.OrbitSource) {
                super(symm);
                this.specialOrbits = null;
            }
        }
        NearestPredefinedOrbitColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.NearestPredefinedOrbitColorMap";
        NearestPredefinedOrbitColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];



        /**
         * Gets standard color of the nearest predefined orbit based on the centroid of each manifestation
         * @extends com.vzome.core.edits.ManifestationColorMappers.CentroidNearestSpecialOrbitColorMap
         * @class
         */
        export class CentroidNearestPredefinedOrbitColorMap extends ManifestationColorMappers.CentroidNearestSpecialOrbitColorMap {
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "CentroidNearestPredefinedOrbitColorMap";
            }

            constructor(symm: com.vzome.core.editor.api.OrbitSource) {
                super(symm);
                this.specialOrbits = null;
            }
        }
        CentroidNearestPredefinedOrbitColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CentroidNearestPredefinedOrbitColorMap";
        CentroidNearestPredefinedOrbitColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper","java.util.function.Function"];


    }

}
namespace com.vzome.core.edits {
    /**
     * @author David Hall
     * @class
     */
    export class ColorMappers {    }
    ColorMappers["__class"] = "com.vzome.core.edits.ColorMappers";


    export namespace ColorMappers {

        export interface ColorMapper<T> {
            /**
             * 
             * @param {*} src
             * @return {com.vzome.core.construction.Color}
             */
            apply(src: T): com.vzome.core.construction.Color;

            requiresOrderedSelection(): boolean;

            /**
             * We had a default implementation here, using reflection, but that gave me problems
             * when transpiled to JavaScript with JSweet.  Now each class simply implements the method.
             * @return
             * @return {string}
             */
            getName(): string;
        }
    }

}
namespace com.vzome.core.editor {
    /**
     * @author Scott Vorthmann
     * @class
     */
    export class SelectionImpl implements com.vzome.core.editor.api.Selection {
        /*private*/ mManifestations: java.util.Collection<com.vzome.core.model.Manifestation>;

        /*private*/ mListeners: java.util.List<com.vzome.core.model.ManifestationChanges>;

        /*private*/ mSelectedGroup: com.vzome.core.model.Group;

        static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (SelectionImpl.logger == null) { SelectionImpl.logger = java.util.logging.Logger.getLogger("com.vzome.core.editor.selection"); }  return SelectionImpl.logger; }

        /**
         * 
         * @param {*} target
         */
        public copy(target: java.util.List<com.vzome.core.model.Manifestation>) {
            target.addAll(this.mManifestations);
        }

        public addListener(listener: com.vzome.core.model.ManifestationChanges) {
            this.mListeners.add(listener);
        }

        public removeListener(listener: com.vzome.core.model.ManifestationChanges) {
            this.mListeners.remove(listener);
        }

        /**
         * 
         * @param {*} m
         * @return {boolean}
         */
        public manifestationSelected(m: com.vzome.core.model.Manifestation): boolean {
            return this.mManifestations.contains(m);
        }

        public isEmpty(): boolean {
            return this.mManifestations.isEmpty();
        }

        /**
         * 
         * @return {*}
         */
        public iterator(): java.util.Iterator<com.vzome.core.model.Manifestation> {
            return this.mManifestations.iterator();
        }

        /**
         * 
         * @param {*} m
         */
        public select(m: com.vzome.core.model.Manifestation) {
            if (this.mManifestations.contains(m))return;
            this.mManifestations.add(m);
            if (SelectionImpl.logger_$LI$().isLoggable(java.util.logging.Level.FINER))SelectionImpl.logger_$LI$().finer("  select: " + m.toString());
            for(let index=this.mListeners.iterator();index.hasNext();) {
                let mc = index.next();
                {
                    mc.manifestationAdded(m);
                }
            }
        }

        /**
         * 
         * @param {*} m
         */
        public unselect(m: com.vzome.core.model.Manifestation) {
            if (this.mManifestations.remove(m)){
                if (SelectionImpl.logger_$LI$().isLoggable(java.util.logging.Level.FINER))SelectionImpl.logger_$LI$().finer("deselect: " + m.toString());
                for(let index=this.mListeners.iterator();index.hasNext();) {
                    let mc = index.next();
                    {
                        mc.manifestationRemoved(m);
                    }
                }
            }
        }

        /**
         * 
         * @param {*} m
         */
        public selectWithGrouping(m: com.vzome.core.model.Manifestation) {
            if (this.mManifestations.contains(m))return;
            if (m == null)return;
            const group: com.vzome.core.model.Group = com.vzome.core.editor.api.Selection.biggestGroup(m);
            if (group == null)this.add(m); else this.selectGroup(group);
            this.mSelectedGroup = group;
        }

        /**
         * 
         * @param {*} m
         */
        public unselectWithGrouping(m: com.vzome.core.model.Manifestation) {
            if (this.mManifestations.contains(m)){
                const group: com.vzome.core.model.Group = com.vzome.core.editor.api.Selection.biggestGroup(m);
                if (group == null)this.remove(m); else this.unselectGroup(group);
                this.mSelectedGroup = null;
            }
        }

        /*private*/ add(m: com.vzome.core.model.Manifestation) {
            this.mManifestations.add(m);
            if (SelectionImpl.logger_$LI$().isLoggable(java.util.logging.Level.FINER))SelectionImpl.logger_$LI$().finer("  select: " + m.toString());
            for(let index=this.mListeners.iterator();index.hasNext();) {
                let mc = index.next();
                {
                    mc.manifestationAdded(m);
                }
            }
        }

        /*private*/ remove(m: com.vzome.core.model.Manifestation) {
            if (this.mManifestations.remove(m)){
                if (SelectionImpl.logger_$LI$().isLoggable(java.util.logging.Level.FINER))SelectionImpl.logger_$LI$().finer("deselect: " + m.toString());
                for(let index=this.mListeners.iterator();index.hasNext();) {
                    let mc = index.next();
                    {
                        mc.manifestationRemoved(m);
                    }
                }
            }
        }

        /*private*/ selectGroup(group: com.vzome.core.model.Group) {
            for(let index=group.iterator();index.hasNext();) {
                let next = index.next();
                {
                    if (next != null && next instanceof <any>com.vzome.core.model.Group)this.selectGroup(<com.vzome.core.model.Group><any>next); else this.add(<com.vzome.core.model.Manifestation><any>next);
                }
            }
        }

        /*private*/ unselectGroup(group: com.vzome.core.model.Group) {
            for(let index=group.iterator();index.hasNext();) {
                let next = index.next();
                {
                    if (next != null && next instanceof <any>com.vzome.core.model.Group)this.unselectGroup(<com.vzome.core.model.Group><any>next); else this.remove(<com.vzome.core.model.Manifestation><any>next);
                }
            }
        }

        /**
         * 
         * @param {java.lang.Class} kind
         * @return {*}
         */
        public getSingleSelection(kind: any): com.vzome.core.model.Manifestation {
            let count: number = 0;
            let result: com.vzome.core.model.Manifestation = null;
            for(let index=this.mManifestations.iterator();index.hasNext();) {
                let next = index.next();
                {
                    if ((kind === "com.vzome.core.model.Connector" && (next != null && (next.constructor != null && next.constructor["__interfaces"] != null && next.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))) || (kind === "com.vzome.core.model.Strut" && (next != null && (next.constructor != null && next.constructor["__interfaces"] != null && next.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))) || (kind === "com.vzome.core.model.Panel" && (next != null && (next.constructor != null && next.constructor["__interfaces"] != null && next.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)))){
                        ++count;
                        result = next;
                    }
                }
            }
            if (count === 1)return result; else return null;
        }

        /**
         * 
         * @return {boolean}
         */
        public isSelectionAGroup(): boolean {
            return this.getSelectedGroup(false) != null;
        }

        /*private*/ getSelectedGroup(onlyOne: boolean): com.vzome.core.model.Group {
            let selectedGroup: com.vzome.core.model.Group = null;
            for(let index=this.mManifestations.iterator();index.hasNext();) {
                let m = index.next();
                {
                    if (onlyOne && (selectedGroup != null))return selectedGroup;
                    const group: com.vzome.core.model.Group = com.vzome.core.editor.api.Selection.biggestGroup(m);
                    if (group == null)return null; else if (selectedGroup == null)selectedGroup = group; else if (group !== selectedGroup)return null;
                }
            }
            return selectedGroup;
        }

        /**
         * 
         */
        public gatherGroup() {
            const newGroup: com.vzome.core.model.Group = new com.vzome.core.model.Group();
            for(let index=this.mManifestations.iterator();index.hasNext();) {
                let m = index.next();
                {
                    const group: com.vzome.core.model.Group = com.vzome.core.editor.api.Selection.biggestGroup(m);
                    if (group === newGroup); else if (group == null){
                        newGroup.add(m);
                        m.setContainer(newGroup);
                    } else {
                        newGroup.add(group);
                        group.setContainer(newGroup);
                    }
                }
            }
        }

        /**
         * 
         */
        public scatterGroup() {
            const selectedGroup: com.vzome.core.model.Group = this.getSelectedGroup(true);
            if (selectedGroup == null)return;
            for(const ms: java.util.Iterator<com.vzome.core.model.GroupElement> = selectedGroup.iterator(); ms.hasNext(); ) {{
                const next: com.vzome.core.model.GroupElement = ms.next();
                ms.remove();
                next.setContainer(null);
            };}
        }

        /**
         * 
         */
        public gatherGroup211() {
            if (this.mSelectedGroup != null)return;
            this.mSelectedGroup = new com.vzome.core.model.Group();
            for(let index=this.mManifestations.iterator();index.hasNext();) {
                let m = index.next();
                {
                    const group: com.vzome.core.model.Group = com.vzome.core.editor.api.Selection.biggestGroup(m);
                    if (group == null){
                        this.mSelectedGroup.add(m);
                    } else {
                        this.mSelectedGroup.add(group);
                    }
                }
            }
            for(let index=this.mSelectedGroup.iterator();index.hasNext();) {
                let next = index.next();
                {
                    next.setContainer(this.mSelectedGroup);
                }
            }
        }

        /**
         * 
         */
        public scatterGroup211() {
            if (this.mSelectedGroup == null)return;
            for(const ms: java.util.Iterator<com.vzome.core.model.GroupElement> = this.mSelectedGroup.iterator(); ms.hasNext(); ) {{
                const next: com.vzome.core.model.GroupElement = ms.next();
                ms.remove();
                next.setContainer(null);
            };}
        }

        public refresh(on: boolean, otherSelection: SelectionImpl) {
            for(let index=this.mManifestations.iterator();index.hasNext();) {
                let m = index.next();
                {
                    if (otherSelection == null || !otherSelection.mManifestations.contains(m)){
                        if (on){
                            for(let index=this.mListeners.iterator();index.hasNext();) {
                                let mc = index.next();
                                {
                                    mc.manifestationAdded(m);
                                }
                            }
                        } else {
                            for(let index=this.mListeners.iterator();index.hasNext();) {
                                let mc = index.next();
                                {
                                    mc.manifestationRemoved(m);
                                }
                            }
                        }
                    }
                }
            }
        }

        /**
         * 
         * @return {number}
         */
        public size(): number {
            return this.mManifestations.size();
        }

        /**
         * 
         */
        public clear() {
            if (!this.mManifestations.isEmpty()){
                if (SelectionImpl.logger_$LI$().isLoggable(java.util.logging.Level.FINER)){
                    SelectionImpl.logger_$LI$().finer("clearing selection");
                }
                const temp: java.util.Collection<com.vzome.core.model.Manifestation> = <any>(new java.util.LinkedHashSet<any>(this.mManifestations));
                for(let index=temp.iterator();index.hasNext();) {
                    let m = index.next();
                    {
                        this.unselect(m);
                    }
                }
            }
        }

        constructor() {
            this.mManifestations = <any>(new java.util.LinkedHashSet<any>());
            this.mListeners = <any>(new java.util.ArrayList<any>());
            this.mSelectedGroup = null;
        }
    }
    SelectionImpl["__class"] = "com.vzome.core.editor.SelectionImpl";
    SelectionImpl["__interfaces"] = ["com.vzome.core.editor.api.Selection","java.lang.Iterable"];


}
namespace com.vzome.core.editor {
    export class ToolsModel extends java.util.TreeMap<string, com.vzome.core.editor.Tool> implements com.vzome.core.editor.Tool.Source {
        /*private*/ editor: com.vzome.core.editor.api.EditorModel;

        /*private*/ lastId: number;

        /*private*/ pcs: java.beans.PropertyChangeSupport;

        /*private*/ context: com.vzome.core.editor.api.Context;

        /*private*/ originPoint: com.vzome.core.construction.Point;

        /*private*/ toolLabels: java.util.Map<string, string>;

        /*private*/ toolDeleteInputs: java.util.Map<string, boolean>;

        /*private*/ toolSelectInputs: java.util.Map<string, boolean>;

        /*private*/ toolCopyColors: java.util.Map<string, boolean>;

        /*private*/ hiddenTools: java.util.Set<string>;

        /*private*/ customTools: java.util.List<string>;

        /*private*/ customBookmarks: java.util.List<string>;

        public constructor(context: com.vzome.core.editor.api.Context, originPoint: com.vzome.core.construction.Point) {
            super();
            if (this.editor === undefined) { this.editor = null; }
            this.lastId = 0;
            this.pcs = new java.beans.PropertyChangeSupport(this);
            if (this.context === undefined) { this.context = null; }
            if (this.originPoint === undefined) { this.originPoint = null; }
            this.toolLabels = <any>(new java.util.HashMap<any, any>());
            this.toolDeleteInputs = <any>(new java.util.HashMap<any, any>());
            this.toolSelectInputs = <any>(new java.util.HashMap<any, any>());
            this.toolCopyColors = <any>(new java.util.HashMap<any, any>());
            this.hiddenTools = <any>(new java.util.HashSet<any>());
            this.customTools = <any>(new java.util.ArrayList<any>());
            this.customBookmarks = <any>(new java.util.ArrayList<any>());
            this.context = context;
            this.originPoint = originPoint;
        }

        public reserveId(): number {
            return this.lastId++;
        }

        /**
         * Only called during load of a document, before any new tool creations with reserveId.
         * @param {number} id
         */
        public setMaxId(id: number) {
            if (id >= this.lastId)this.lastId = id + 1;
        }

        /**
         * 
         * @param {string} key
         * @param {com.vzome.core.editor.Tool} tool
         * @return {com.vzome.core.editor.Tool}
         */
        public put(key: string, tool: com.vzome.core.editor.Tool): com.vzome.core.editor.Tool {
            const result: com.vzome.core.editor.Tool = super.put(key, tool);
            this.pcs.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("tool.instances", null, tool);
            if (!tool.isPredefined() && !tool.isHidden()){
                if (tool.getCategory() === com.vzome.core.tools.BookmarkTool.ID){
                    this.customBookmarks.add(key);
                    this.pcs.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("customBookmarks", null, this.getToolIDs(true));
                } else {
                    this.customTools.add(key);
                    this.pcs.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("customTools", null, this.getToolIDs(false));
                }
            }
            return result;
        }

        public getToolIDs(bookmarks: boolean): string[] {
            return bookmarks ? this.customBookmarks.toArray<any>([]) : this.customTools.toArray<any>([]);
        }

        public createEdit(className: string): com.vzome.core.editor.api.UndoableEdit {
            switch((className)) {
            case "ToolApplied":
                return new com.vzome.core.editor.ApplyTool(this, null, false, false, false, false, false, true);
            case "ApplyTool":
                return new com.vzome.core.editor.ApplyTool(this, null, false, false, false, false, true, true);
            case "SelectToolParameters":
                return new com.vzome.core.editor.SelectToolParameters(this, null);
            default:
                return null;
            }
        }

        public applyTool(tool: com.vzome.core.editor.Tool, selectInputs: boolean, deleteInputs: boolean, createOutputs: boolean, selectOutputs: boolean, copyColors: boolean) {
            const edit: com.vzome.core.editor.api.UndoableEdit = new com.vzome.core.editor.ApplyTool(this, tool, selectInputs, deleteInputs, createOutputs, selectOutputs, true, copyColors);
            this.getContext().performAndRecord(edit);
        }

        public selectToolParameters(tool: com.vzome.core.editor.Tool) {
            const edit: com.vzome.core.editor.api.UndoableEdit = new com.vzome.core.editor.SelectToolParameters(this, tool);
            this.getContext().performAndRecord(edit);
        }

        public addPropertyListener(listener: java.beans.PropertyChangeListener) {
            this.pcs.addPropertyChangeListener$java_beans_PropertyChangeListener(listener);
        }

        public removePropertyListener(listener: java.beans.PropertyChangeListener) {
            this.pcs.removePropertyChangeListener$java_beans_PropertyChangeListener(listener);
        }

        public setEditorModel(editor: com.vzome.core.editor.api.EditorModel) {
            this.editor = editor;
        }

        public getEditorModel(): com.vzome.core.editor.api.EditorModel {
            return this.editor;
        }

        /**
         * 
         * @param {string} id
         * @return {com.vzome.core.editor.Tool}
         */
        public getPredefinedTool(id: string): com.vzome.core.editor.Tool {
            return this.get(id);
        }

        public getContext(): com.vzome.core.editor.api.Context {
            return this.context;
        }

        public getOriginPoint(): com.vzome.core.construction.Point {
            return this.originPoint;
        }

        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const result: org.w3c.dom.Element = doc.createElement("Tools");
            for(let index=this.values().iterator();index.hasNext();) {
                let tool = index.next();
                if (!tool.isPredefined()){
                    const toolElem: org.w3c.dom.Element = doc.createElement("Tool");
                    com.vzome.xml.DomUtils.addAttribute(toolElem, "id", tool.getId());
                    com.vzome.xml.DomUtils.addAttribute(toolElem, "label", tool.getLabel());
                    if (tool.isHidden())com.vzome.xml.DomUtils.addAttribute(toolElem, "hidden", "true");
                    toolElem.setAttribute("selectInputs", javaemul.internal.BooleanHelper.toString(tool.isSelectInputs()));
                    toolElem.setAttribute("deleteInputs", javaemul.internal.BooleanHelper.toString(tool.isDeleteInputs()));
                    toolElem.setAttribute("copyColors", javaemul.internal.BooleanHelper.toString(tool.isCopyColors()));
                    result.appendChild(toolElem);
                }
            }
            return result;
        }

        loadFromXml(xml: org.w3c.dom.Element) {
            const nodes: org.w3c.dom.NodeList = xml.getChildNodes();
            for(let i: number = 0; i < nodes.getLength(); i++) {{
                const node: org.w3c.dom.Node = nodes.item(i);
                if (node != null && (node.constructor != null && node.constructor["__interfaces"] != null && node.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)){
                    const toolElem: org.w3c.dom.Element = <org.w3c.dom.Element><any>node;
                    const id: string = toolElem.getAttribute("id");
                    const label: string = toolElem.getAttribute("label");
                    this.toolLabels.put(id, label);
                    let value: string = toolElem.getAttribute("selectInputs");
                    if (value != null && !(value === ("")))this.toolSelectInputs.put(id, javaemul.internal.BooleanHelper.parseBoolean(value));
                    value = toolElem.getAttribute("deleteInputs");
                    if (value != null && !(value === ("")))this.toolDeleteInputs.put(id, javaemul.internal.BooleanHelper.parseBoolean(value));
                    value = toolElem.getAttribute("copyColors");
                    if (value != null && !(value === ("")))this.toolCopyColors.put(id, javaemul.internal.BooleanHelper.parseBoolean(value));
                    const hiddenStr: string = toolElem.getAttribute("hidden");
                    if (hiddenStr != null && (hiddenStr === ("true")))this.hiddenTools.add(id);
                }
            };}
        }

        public setConfiguration(tool: com.vzome.core.editor.Tool) {
            const id: string = tool.getId();
            const label: string = this.toolLabels.get(id);
            if (label != null)tool.setLabel(label);
            if (this.toolDeleteInputs.containsKey(id) || this.toolSelectInputs.containsKey(id)){
                const deleteInputs: boolean = this.toolDeleteInputs.containsKey(id) ? this.toolDeleteInputs.get(id) : true;
                const selectInputs: boolean = this.toolSelectInputs.containsKey(id) ? this.toolSelectInputs.get(id) : false;
                tool.setInputBehaviors(selectInputs, deleteInputs);
            }
            if (this.toolCopyColors.containsKey(id)){
                tool.setCopyColors(this.toolCopyColors.get(id));
            }
            tool.setHidden(this.hiddenTools.contains(id));
        }

        public hideTool(tool: com.vzome.core.editor.Tool) {
            this.pcs.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("tool.instances", tool, null);
            if (tool.getCategory() === com.vzome.core.tools.BookmarkTool.ID){
                this.customBookmarks.remove(tool.getId());
                this.pcs.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("customBookmarks", null, this.getToolIDs(true));
            } else {
                this.customTools.remove(tool.getId());
                this.pcs.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("customTools", null, this.getToolIDs(false));
            }
        }
    }
    ToolsModel["__class"] = "com.vzome.core.editor.ToolsModel";
    ToolsModel["__interfaces"] = ["java.lang.Cloneable","com.vzome.api.Tool.Source","java.util.Map","java.util.NavigableMap","java.util.SortedMap","java.io.Serializable"];


}
namespace com.vzome.core.editor {
    export class Duplicator {
        /*private*/ vertexData: java.util.Map<com.vzome.core.algebra.AlgebraicVector, com.vzome.core.construction.Point>;

        /*private*/ edit: com.vzome.core.editor.api.ChangeManifestations;

        /*private*/ offset: com.vzome.core.algebra.AlgebraicVector;

        public constructor(edit: com.vzome.core.editor.api.ChangeManifestations, offset: com.vzome.core.algebra.AlgebraicVector) {
            this.vertexData = <any>(new java.util.HashMap<any, any>());
            if (this.edit === undefined) { this.edit = null; }
            if (this.offset === undefined) { this.offset = null; }
            this.edit = edit;
            this.offset = offset;
        }

        public duplicateManifestation(man: com.vzome.core.model.Manifestation) {
            const constr: com.vzome.core.construction.Construction = this.duplicateConstruction(man);
            this.edit.manifestConstruction(constr);
        }

        public duplicateConstruction(man: com.vzome.core.model.Manifestation): com.vzome.core.construction.Construction {
            if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                const vector: com.vzome.core.algebra.AlgebraicVector = (<com.vzome.core.model.Connector><any>man).getLocation();
                return this.getVertex(vector);
            } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                const strut: com.vzome.core.model.Strut = <com.vzome.core.model.Strut><any>man;
                const p1: com.vzome.core.construction.Point = this.getVertex(strut.getLocation());
                const p2: com.vzome.core.construction.Point = this.getVertex(strut.getEnd());
                return new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
            } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                const vs: java.util.List<com.vzome.core.construction.Point> = <any>(new java.util.ArrayList<any>());
                for(let index=(<com.vzome.core.model.Panel><any>man).iterator();index.hasNext();) {
                    let v = index.next();
                    {
                        vs.add(this.getVertex(v));
                    }
                }
                return new com.vzome.core.construction.PolygonFromVertices(vs.toArray<any>([]));
            }
            return null;
        }

        getVertex(vertexVector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.construction.Point {
            let result: com.vzome.core.construction.Point = this.vertexData.get(vertexVector);
            if (result == null){
                const key: com.vzome.core.algebra.AlgebraicVector = vertexVector;
                if (this.offset != null)vertexVector = vertexVector.plus(this.offset);
                result = new com.vzome.core.construction.FreePoint(vertexVector);
                this.vertexData.put(key, result);
            }
            return result;
        }
    }
    Duplicator["__class"] = "com.vzome.core.editor.Duplicator";

}
namespace com.vzome.core.editor {
    export class SelectionSummary implements com.vzome.core.model.ManifestationChanges {
        static LOGGER: java.util.logging.Logger; public static LOGGER_$LI$(): java.util.logging.Logger { if (SelectionSummary.LOGGER == null) { SelectionSummary.LOGGER = java.util.logging.Logger.getLogger("com.vzome.core.editor.SelectionSummary"); }  return SelectionSummary.LOGGER; }

        /*private*/ balls: number;

        /*private*/ struts: number;

        /*private*/ panels: number;

        /*private*/ listeners: java.util.Collection<SelectionSummary.Listener>;

        /*private*/ selection: com.vzome.core.editor.api.Selection;

        public constructor(selection: com.vzome.core.editor.api.Selection) {
            this.balls = 0;
            this.struts = 0;
            this.panels = 0;
            this.listeners = <any>(new java.util.ArrayList<SelectionSummary.Listener>());
            if (this.selection === undefined) { this.selection = null; }
            this.selection = selection;
        }

        public notifyListeners() {
            for(let index=this.listeners.iterator();index.hasNext();) {
                let listener = index.next();
                {
                    listener.selectionChanged(this.selection.size(), this.balls, this.struts, this.panels);
                }
            }
        }

        /**
         * 
         * @param {*} m
         */
        public manifestationAdded(m: com.vzome.core.model.Manifestation) {
            if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))++this.balls; else if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))++this.struts; else if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0))++this.panels;
            this.verifyCounts();
        }

        /**
         * 
         * @param {*} m
         */
        public manifestationRemoved(m: com.vzome.core.model.Manifestation) {
            if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))--this.balls; else if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))--this.struts; else if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0))--this.panels;
            this.verifyCounts();
        }

        verifyCounts() {
            if (this.balls + this.struts + this.panels !== this.selection.size()){
                if (SelectionSummary.LOGGER_$LI$().isLoggable(java.util.logging.Level.WARNING)){
                    SelectionSummary.LOGGER_$LI$().warning("Incorrect total for balls, struts and panels: " + this.balls + " + " + this.struts + " + " + this.panels + " != " + this.selection.size());
                }
                this.balls = this.struts = this.panels = 0;
                for(let index=this.selection.iterator();index.hasNext();) {
                    let m = index.next();
                    {
                        if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))++this.balls; else if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))++this.struts; else if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0))++this.panels;
                    }
                }
                if (SelectionSummary.LOGGER_$LI$().isLoggable(java.util.logging.Level.WARNING)){
                    SelectionSummary.LOGGER_$LI$().warning("SelectionSummary resynced on thread: " + java.lang.Thread.currentThread() + ". " + this.balls + " + " + this.struts + " + " + this.panels + " = " + this.selection.size());
                }
            }
        }

        /**
         * 
         * @param {*} m
         * @param {com.vzome.core.construction.Color} color
         */
        public manifestationColored(m: com.vzome.core.model.Manifestation, color: com.vzome.core.construction.Color) {
        }

        /**
         * 
         * @param {*} m
         * @param {string} label
         */
        public manifestationLabeled(m: com.vzome.core.model.Manifestation, label: string) {
        }

        public addListener(listener: SelectionSummary.Listener) {
            this.listeners.add(listener);
        }
    }
    SelectionSummary["__class"] = "com.vzome.core.editor.SelectionSummary";
    SelectionSummary["__interfaces"] = ["com.vzome.core.model.ManifestationChanges"];



    export namespace SelectionSummary {

        export interface Listener {
            selectionChanged(total: number, balls: number, struts: number, panels: number);
        }
    }

}
namespace com.vzome.core.editor.api {
    export interface LegacyEditorModel extends com.vzome.core.editor.api.ImplicitSymmetryParameters {
        addFailedConstruction(cons: com.vzome.core.construction.Construction);

        hasFailedConstruction(cons: com.vzome.core.construction.Construction): boolean;
    }
}
namespace com.vzome.core.editor.api {
    export abstract class UndoableEdit {
        public abstract configure(props: java.util.Map<string, any>);

        public abstract perform();

        public abstract undo();

        public abstract redo();

        public abstract isNoOp(): boolean;

        public abstract isVisible(): boolean;

        public abstract getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element;

        public abstract loadAndPerform(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat, context: com.vzome.core.editor.api.Context);

        /**
         * True when this edit must cause a persistent history branch.
         * @return
         * @return {boolean}
         */
        public abstract isSticky(): boolean;

        /**
         * True when this edit invalidates redoable edits.
         * @return
         * @return {boolean}
         */
        public abstract isDestructive(): boolean;

        public abstract getDetailXml(doc: org.w3c.dom.Document): org.w3c.dom.Element;

        /*private*/ __com_vzome_core_editor_EditHistory_DeferredEdit_hasBreakpoint: boolean;

        /*private*/ lineNumber: number;

        public hasBreakpoint(): boolean {
            return this.__com_vzome_core_editor_EditHistory_DeferredEdit_hasBreakpoint;
        }

        public setBreakpoint(value: boolean) {
            this.__com_vzome_core_editor_EditHistory_DeferredEdit_hasBreakpoint = value;
        }

        public getLineNumber(): number {
            return this.lineNumber;
        }

        public setLineNumber(lineNumber: number) {
            this.lineNumber = lineNumber;
        }

        constructor() {
            this.__com_vzome_core_editor_EditHistory_DeferredEdit_hasBreakpoint = false;
            this.lineNumber = -1;
        }
    }
    UndoableEdit["__class"] = "com.vzome.core.editor.api.UndoableEdit";

}
namespace com.vzome.core.editor.api {
    export class ManifestConstructions extends java.util.ArrayList<com.vzome.core.construction.Construction> implements com.vzome.core.construction.ConstructionChanges {
        /*private*/ edit: com.vzome.core.editor.api.ChangeManifestations;

        public constructor(edit: com.vzome.core.editor.api.ChangeManifestations) {
            super();
            if (this.edit === undefined) { this.edit = null; }
            this.edit = edit;
        }

        public constructionAdded$com_vzome_core_construction_Construction(c: com.vzome.core.construction.Construction) {
            this.edit.manifestConstruction(c);
            this.edit.redo();
        }

        public constructionAdded$com_vzome_core_construction_Construction$com_vzome_core_construction_Color(c: com.vzome.core.construction.Construction, color: com.vzome.core.construction.Color) {
            const manifestation: com.vzome.core.model.Manifestation = this.edit.manifestConstruction(c);
            if (color != null)this.edit.colorManifestation(manifestation, color);
            this.edit.select$com_vzome_core_model_Manifestation(manifestation);
            this.edit.redo();
        }

        /**
         * 
         * @param {com.vzome.core.construction.Construction} c
         * @param {com.vzome.core.construction.Color} color
         */
        public constructionAdded(c?: any, color?: any) {
            if (((c != null && c instanceof <any>com.vzome.core.construction.Construction) || c === null) && ((color != null && color instanceof <any>com.vzome.core.construction.Color) || color === null)) {
                return <any>this.constructionAdded$com_vzome_core_construction_Construction$com_vzome_core_construction_Color(c, color);
            } else if (((c != null && c instanceof <any>com.vzome.core.construction.Construction) || c === null) && color === undefined) {
                return <any>this.constructionAdded$com_vzome_core_construction_Construction(c);
            } else throw new Error('invalid overload');
        }
    }
    ManifestConstructions["__class"] = "com.vzome.core.editor.api.ManifestConstructions";
    ManifestConstructions["__interfaces"] = ["java.util.RandomAccess","java.util.List","java.lang.Cloneable","com.vzome.core.construction.ConstructionChanges","java.util.Collection","java.lang.Iterable","java.io.Serializable"];


}
namespace com.vzome.core.editor.api {
    export interface EditorModel extends com.vzome.core.editor.api.SymmetryAware {
        getRealizedModel(): com.vzome.core.model.RealizedModel;

        getSelection(): com.vzome.core.editor.api.Selection;

        addSelectionSummaryListener(listener: com.vzome.core.editor.SelectionSummary.Listener);
    }
}
namespace com.vzome.core.editor.api {
    export interface SymmetryAware {
        getSymmetrySystem(name?: any): com.vzome.core.editor.api.OrbitSource;

        get4dSymmetries(): com.vzome.core.math.symmetry.Symmetries4D;
    }
}
namespace com.vzome.core.editor.api {
    export interface Selection extends java.lang.Iterable<com.vzome.core.model.Manifestation> {
        clear();

        manifestationSelected(man: com.vzome.core.model.Manifestation): boolean;

        selectWithGrouping(mMan: com.vzome.core.model.Manifestation);

        unselectWithGrouping(mMan: com.vzome.core.model.Manifestation);

        select(mMan: com.vzome.core.model.Manifestation);

        unselect(mMan: com.vzome.core.model.Manifestation);

        getSingleSelection(kind: any): com.vzome.core.model.Manifestation;

        gatherGroup();

        gatherGroup211();

        scatterGroup();

        scatterGroup211();

        isSelectionAGroup(): boolean;

        size(): number;

        copy(bookmarkedSelection: java.util.List<com.vzome.core.model.Manifestation>);
    }

    export namespace Selection {

        export function biggestGroup(m: com.vzome.core.model.Manifestation): com.vzome.core.model.Group {
            let parent: com.vzome.core.model.Group = m.getContainer();
            let group: com.vzome.core.model.Group = parent;
            while((parent != null)) {{
                parent = group.getContainer();
                if (parent == null)break;
                group = parent;
            }};
            return group;
        }
    }

}
namespace com.vzome.core.editor.api {
    export interface Context {
        createEdit(xml: org.w3c.dom.Element): com.vzome.core.editor.api.UndoableEdit;

        createLegacyCommand(cmdName: string): com.vzome.core.commands.Command;

        performAndRecord(edit: com.vzome.core.editor.api.UndoableEdit);

        doEdit(action: string, props: java.util.Map<string, any>): boolean;
    }
}
namespace com.vzome.core.editor.api {
    export interface OrbitSource {
        getSymmetry(): com.vzome.core.math.symmetry.Symmetry;

        getAxis(vector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.math.symmetry.Axis;

        getColor(orbit: com.vzome.core.math.symmetry.Direction): com.vzome.core.construction.Color;

        getVectorColor(vector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.construction.Color;

        getOrbits(): com.vzome.core.math.symmetry.OrbitSet;

        getShapes(): com.vzome.core.editor.api.Shapes;

        getName(): string;

        getZone(orbit: string, orientation: number): com.vzome.core.math.symmetry.Axis;

        getEmbedding(): number[];

        getOrientations(rowMajor?: any): number[][];
    }
}
namespace com.vzome.core.editor.api {
    export interface Shapes {
        getName(): string;

        getAlias(): string;

        getConnectorShape(): com.vzome.core.math.Polyhedron;

        getStrutShape(dir: com.vzome.core.math.symmetry.Direction, length: com.vzome.core.algebra.AlgebraicNumber): com.vzome.core.math.Polyhedron;

        getPanelShape(vertexCount: number, quadrea: com.vzome.core.algebra.AlgebraicNumber, zone: com.vzome.core.math.symmetry.Axis, vertices: java.lang.Iterable<com.vzome.core.algebra.AlgebraicVector>, oneSidedPanels: boolean): com.vzome.core.math.Polyhedron;

        getSymmetry(): com.vzome.core.math.symmetry.Symmetry;

        getPackage(): string;

        getColor(dir: com.vzome.core.math.symmetry.Direction): com.vzome.core.construction.Color;

        hasColors(): boolean;

        getCmScaling(): number;
    }
}
namespace com.vzome.core.editor.api {
    export interface SideEffect {
        undo();

        getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element;

        redo();
    }
}
namespace com.vzome.core.editor.api {
    export interface ImplicitSymmetryParameters extends com.vzome.core.editor.api.EditorModel {
        getCenterPoint(): com.vzome.core.construction.Point;

        setCenterPoint(point: com.vzome.core.construction.Construction);

        getSymmetrySegment(): com.vzome.core.construction.Segment;

        setSymmetrySegment(segment: com.vzome.core.construction.Segment);

        getSelectedConstruction(kind: any): com.vzome.core.construction.Construction;
    }
}
namespace com.vzome.core.editor.api {
    export enum ActionEnum {
        IGNORE, SELECT, DESELECT
    }
}
namespace com.vzome.core.editor {
    export interface SymmetryPerspective {
        getGeometries(): java.util.List<com.vzome.core.editor.api.Shapes>;

        getDefaultGeometry(): com.vzome.core.editor.api.Shapes;

        getName(): string;

        getSymmetry(): com.vzome.core.math.symmetry.Symmetry;

        createToolFactories(kind: com.vzome.api.Tool.Kind, model: com.vzome.core.editor.ToolsModel): java.util.List<com.vzome.api.Tool.Factory>;

        predefineTools(kind: com.vzome.api.Tool.Kind, model: com.vzome.core.editor.ToolsModel): java.util.List<com.vzome.api.Tool>;

        /**
         * These commands should all be symmetry-DEPENDANT.
         * Contrast with {@code FieldApplication.getLegacyCommand(action) }.
         * @param {string} action
         * @return
         * @return {*}
         */
        getLegacyCommand(action: string): com.vzome.core.commands.Command;

        getModelResourcePath(): string;

        orbitIsStandard(orbit: com.vzome.core.math.symmetry.Direction): boolean;

        orbitIsBuildDefault(orbit: com.vzome.core.math.symmetry.Direction): boolean;

        getOrbitUnitLength(orbit: com.vzome.core.math.symmetry.Direction): com.vzome.core.algebra.AlgebraicNumber;

        getLabel(): string;
    }
}
namespace com.vzome.core.editor {
    export abstract class AbstractToolFactory implements com.vzome.api.Tool.Factory, com.vzome.core.editor.SelectionSummary.Listener {
        /*private*/ enabled: boolean;

        /*private*/ pcs: java.beans.PropertyChangeSupport;

        /*private*/ tools: com.vzome.core.editor.ToolsModel;

        /*private*/ label: string;

        /*private*/ tooltip: string;

        /*private*/ id: string;

        /*private*/ symmetry: com.vzome.core.math.symmetry.Symmetry;

        public constructor(tools: com.vzome.core.editor.ToolsModel, symmetry: com.vzome.core.math.symmetry.Symmetry, id: string, label: string, tooltip: string) {
            this.enabled = false;
            if (this.pcs === undefined) { this.pcs = null; }
            if (this.tools === undefined) { this.tools = null; }
            if (this.label === undefined) { this.label = null; }
            if (this.tooltip === undefined) { this.tooltip = null; }
            if (this.id === undefined) { this.id = null; }
            if (this.symmetry === undefined) { this.symmetry = null; }
            this.tools = tools;
            this.symmetry = symmetry;
            this.id = id;
            this.label = label;
            this.tooltip = tooltip;
            this.pcs = new java.beans.PropertyChangeSupport(this);
        }

        /**
         * 
         * @param {number} total
         * @param {number} balls
         * @param {number} struts
         * @param {number} panels
         */
        public selectionChanged(total: number, balls: number, struts: number, panels: number) {
            const wasEnabled: boolean = this.enabled;
            if (this.countsAreValid(total, balls, struts, panels))this.enabled = this.bindParameters(this.getSelection()); else this.enabled = false;
            if (wasEnabled !== this.enabled)this.pcs.firePropertyChange$java_lang_String$boolean$boolean("enabled", wasEnabled, this.enabled);
        }

        public getSymmetry(): com.vzome.core.math.symmetry.Symmetry {
            return this.symmetry;
        }

        public getId(): string {
            return this.id;
        }

        public getLabel(): string {
            return this.label;
        }

        public getToolTip(): string {
            return this.tooltip;
        }

        getToolsModel(): com.vzome.core.editor.ToolsModel {
            return this.tools;
        }

        getEditorModel(): com.vzome.core.editor.api.EditorModel {
            return this.tools.getEditorModel();
        }

        getSelection(): com.vzome.core.editor.api.Selection {
            return this.getEditorModel().getSelection();
        }

        getModel(): com.vzome.core.model.RealizedModel {
            return this.getEditorModel().getRealizedModel();
        }

        /**
         * 
         * @return {boolean}
         */
        public isEnabled(): boolean {
            return this.enabled;
        }

        public addListener(listener: java.beans.PropertyChangeListener) {
            this.pcs.addPropertyChangeListener$java_beans_PropertyChangeListener(listener);
        }

        static NEW_PREFIX: string = "tool-";

        /**
         * 
         * @return {com.vzome.core.editor.Tool}
         */
        public createTool(): com.vzome.core.editor.Tool {
            const index: number = this.tools.reserveId();
            const tool: com.vzome.core.editor.Tool = this.createToolInternal(AbstractToolFactory.NEW_PREFIX + index);
            tool.setCategory(this.getId());
            tool.setLabel(this.getId() + " " + index);
            if (tool != null && tool instanceof <any>com.vzome.core.editor.api.UndoableEdit)this.tools.getContext().performAndRecord(<com.vzome.core.editor.api.UndoableEdit>tool); else this.tools.put(tool.getId(), tool);
            return tool;
        }

        public createPredefinedTool(label: string): com.vzome.core.editor.Tool {
            const tool: com.vzome.core.editor.Tool = this.createToolInternal(this.getId() + ".builtin/" + label);
            tool.setLabel(label);
            tool.setCategory(this.getId());
            tool.setPredefined(true);
            tool.checkSelection(true);
            this.tools.put(tool.getId(), tool);
            return tool;
        }

        public deserializeTool(id: string): com.vzome.core.editor.Tool {
            const tool: com.vzome.core.editor.Tool = this.createToolInternal(id);
            if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(id, AbstractToolFactory.NEW_PREFIX)){
                const num: number = javaemul.internal.IntegerHelper.parseInt(id.substring(AbstractToolFactory.NEW_PREFIX.length));
                this.tools.setMaxId(num);
            }
            const nextDot: number = id.indexOf(".");
            if (nextDot > 0){
                tool.setCategory(id.substring(0, nextDot));
            } else {
                tool.setCategory(this.getId());
            }
            this.tools.setConfiguration(tool);
            return tool;
        }

        public abstract createToolInternal(id: string): com.vzome.core.editor.Tool;

        abstract countsAreValid(total: number, balls: number, struts: number, panels: number): boolean;

        abstract bindParameters(selection: com.vzome.core.editor.api.Selection): boolean;
    }
    AbstractToolFactory["__class"] = "com.vzome.core.editor.AbstractToolFactory";
    AbstractToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


}
namespace com.vzome.core.editor {
    export interface FieldApplication extends com.vzome.core.math.symmetry.Symmetries4D {
        getField(): com.vzome.core.algebra.AlgebraicField;

        getSymmetryPerspectives(): java.util.Collection<com.vzome.core.editor.SymmetryPerspective>;

        getDefaultSymmetryPerspective(): com.vzome.core.editor.SymmetryPerspective;

        getSymmetryPerspective(name: string): com.vzome.core.editor.SymmetryPerspective;

        getName(): string;

        getLabel(): string;

        registerToolFactories(toolFactories: java.util.Map<string, com.vzome.api.Tool.Factory>, tools: com.vzome.core.editor.ToolsModel);

        /**
         * These commands should all be symmetry-INDEPENDANT.
         * Contrast with {@code FieldApplication.SymmetryPerspective.getLegacyCommand(action) }.
         * @param {string} action
         * @return
         * @return {*}
         */
        getLegacyCommand(action: string): com.vzome.core.commands.Command;
    }
}
namespace com.vzome.core.editor {
    export class SymmetrySystem implements com.vzome.core.editor.api.OrbitSource {
        /* Default method injected from com.vzome.core.editor.api.OrbitSource */
        getOrientations$(): number[][] {
            return this.getOrientations(false);
        }
        /* Default method injected from com.vzome.core.editor.api.OrbitSource */
        getEmbedding(): number[] {
            const symmetry: com.vzome.core.math.symmetry.Symmetry = this.getSymmetry();
            const field: com.vzome.core.algebra.AlgebraicField = symmetry.getField();
            const embedding: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(16);
            for(let i: number = 0; i < 3; i++) {{
                const columnSelect: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, i);
                const colRV: com.vzome.core.math.RealVector = symmetry.embedInR3(columnSelect);
                embedding[i * 4 + 0] = colRV.x;
                embedding[i * 4 + 1] = colRV.y;
                embedding[i * 4 + 2] = colRV.z;
                embedding[i * 4 + 3] = 0.0;
            };}
            embedding[12] = 0.0;
            embedding[13] = 0.0;
            embedding[14] = 0.0;
            embedding[15] = 1.0;
            return embedding;
        }
        /* Default method injected from com.vzome.core.editor.api.OrbitSource */
        getZone(orbit: string, orientation: number): com.vzome.core.math.symmetry.Axis {
            return this.getSymmetry().getDirection(orbit).getAxis(com.vzome.core.math.symmetry.Symmetry.PLUS, orientation);
        }
        /* Default method injected from com.vzome.core.editor.api.OrbitSource */
        public getOrientations(rowMajor?: any): number[][] {
            if (((typeof rowMajor === 'boolean') || rowMajor === null)) {
                let __args = arguments;
                if (this.symmetry === undefined) { this.symmetry = null; } 
                if (this.orbits === undefined) { this.orbits = null; } 
                if (this.shapes === undefined) { this.shapes = null; } 
                if (this.symmetryPerspective === undefined) { this.symmetryPerspective = null; } 
                if (this.context === undefined) { this.context = null; } 
                if (this.editor === undefined) { this.editor = null; } 
                if (this.colors === undefined) { this.colors = null; } 
                this.nextNewAxis = 0;
                this.orbitColors = <any>(new java.util.HashMap<any, any>());
                this.vectorToAxis = <any>(new java.util.HashMap<any, any>());
                this.noKnownDirections = false;
                this.toolFactoryLists = <any>(new java.util.HashMap<any, any>());
                this.toolLists = <any>(new java.util.HashMap<any, any>());
                return <any>(() => {
                    const symmetry: com.vzome.core.math.symmetry.Symmetry = this.getSymmetry();
                    const field: com.vzome.core.algebra.AlgebraicField = symmetry.getField();
                    const order: number = symmetry.getChiralOrder();
                    const orientations: number[][] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(order);
                    for(let orientation: number = 0; orientation < order; orientation++) {{
                        if (rowMajor){
                            orientations[orientation] = symmetry.getMatrix(orientation).getRowMajorRealElements();
                            continue;
                        }
                        const asFloats: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(16);
                        const transform: com.vzome.core.algebra.AlgebraicMatrix = symmetry.getMatrix(orientation);
                        for(let i: number = 0; i < 3; i++) {{
                            const columnSelect: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, i);
                            const columnI: com.vzome.core.algebra.AlgebraicVector = transform.timesColumn(columnSelect);
                            const colRV: com.vzome.core.math.RealVector = columnI.toRealVector();
                            asFloats[i * 4 + 0] = colRV.x;
                            asFloats[i * 4 + 1] = colRV.y;
                            asFloats[i * 4 + 2] = colRV.z;
                            asFloats[i * 4 + 3] = 0.0;
                        };}
                        asFloats[12] = 0.0;
                        asFloats[13] = 0.0;
                        asFloats[14] = 0.0;
                        asFloats[15] = 1.0;
                        orientations[orientation] = asFloats;
                    };}
                    return orientations;
                })();
            } else if (rowMajor === undefined) {
                return <any>this.getOrientations$();
            } else throw new Error('invalid overload');
        }
        static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (SymmetrySystem.logger == null) { SymmetrySystem.logger = java.util.logging.Logger.getLogger("com.vzome.core.editor"); }  return SymmetrySystem.logger; }

        /*private*/ nextNewAxis: number;

        /*private*/ symmetry: com.vzome.core.math.symmetry.Symmetry;

        /*private*/ orbits: com.vzome.core.math.symmetry.OrbitSet;

        /*private*/ orbitColors: java.util.Map<string, com.vzome.core.construction.Color>;

        /*private*/ shapes: com.vzome.core.editor.api.Shapes;

        /*private*/ vectorToAxis: java.util.Map<string, com.vzome.core.math.symmetry.Axis>;

        /*private*/ noKnownDirections: boolean;

        /*private*/ symmetryPerspective: com.vzome.core.editor.SymmetryPerspective;

        /*private*/ toolFactoryLists: java.util.Map<com.vzome.api.Tool.Kind, java.util.List<com.vzome.api.Tool.Factory>>;

        /*private*/ toolLists: java.util.Map<com.vzome.api.Tool.Kind, java.util.List<com.vzome.api.Tool>>;

        /*private*/ context: com.vzome.core.editor.api.Context;

        /*private*/ editor: com.vzome.core.editor.api.EditorModel;

        /*private*/ colors: com.vzome.core.render.Colors;

        public constructor(symmXml: org.w3c.dom.Element, symmetryPerspective: com.vzome.core.editor.SymmetryPerspective, context: com.vzome.core.editor.api.Context, colors: com.vzome.core.render.Colors, allowNonstandard: boolean) {
            this.nextNewAxis = 0;
            if (this.symmetry === undefined) { this.symmetry = null; }
            if (this.orbits === undefined) { this.orbits = null; }
            this.orbitColors = <any>(new java.util.HashMap<any, any>());
            if (this.shapes === undefined) { this.shapes = null; }
            this.vectorToAxis = <any>(new java.util.HashMap<any, any>());
            this.noKnownDirections = false;
            if (this.symmetryPerspective === undefined) { this.symmetryPerspective = null; }
            this.toolFactoryLists = <any>(new java.util.HashMap<any, any>());
            this.toolLists = <any>(new java.util.HashMap<any, any>());
            if (this.context === undefined) { this.context = null; }
            if (this.editor === undefined) { this.editor = null; }
            if (this.colors === undefined) { this.colors = null; }
            this.symmetryPerspective = symmetryPerspective;
            this.context = context;
            this.colors = colors;
            this.symmetry = symmetryPerspective.getSymmetry();
            let styleName: string = symmetryPerspective.getDefaultGeometry().getName();
            this.orbits = new com.vzome.core.math.symmetry.OrbitSet(this.symmetry);
            if (symmXml == null){
                for(let index=this.symmetry.getOrbitSet().getDirections().iterator();index.hasNext();) {
                    let orbit = index.next();
                    {
                        if (symmetryPerspective.orbitIsStandard(orbit) || allowNonstandard)this.orbits.add(orbit);
                        const color: com.vzome.core.construction.Color = colors.getColor(com.vzome.core.render.Colors.DIRECTION_$LI$() + orbit.getName());
                        this.orbitColors.put(orbit.getName(), color);
                    }
                }
            } else {
                styleName = symmXml.getAttribute("renderingStyle");
                const nodes: org.w3c.dom.NodeList = symmXml.getChildNodes();
                for(let i: number = 0; i < nodes.getLength(); i++) {{
                    const node: org.w3c.dom.Node = nodes.item(i);
                    if (node != null && (node.constructor != null && node.constructor["__interfaces"] != null && node.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)){
                        const dirElem: org.w3c.dom.Element = <org.w3c.dom.Element><any>node;
                        const name: string = dirElem.getAttribute("name");
                        let orbit: com.vzome.core.math.symmetry.Direction = null;
                        const nums: string = dirElem.getAttribute("prototype");
                        if (nums != null && !/* isEmpty */(nums.length === 0)){
                            try {
                                const prototype: com.vzome.core.algebra.AlgebraicVector = this.symmetry.getField().parseVector(nums);
                                orbit = this.symmetry.createNewZoneOrbit(name, 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, prototype);
                            } catch(e) {
                                console.error("Integer overflow happened while creating orbit: " + name);
                                continue;
                            }
                            orbit.setAutomatic(true);
                            try {
                                const autoNum: number = javaemul.internal.IntegerHelper.parseInt(name);
                                this.nextNewAxis = Math.max(this.nextNewAxis, autoNum + 1);
                            } catch(e) {
                                console.error(e.message);
                            }
                        } else {
                            orbit = this.symmetry.getDirection(name);
                            if (orbit == null)continue;
                        }
                        this.orbits.add(orbit);
                        let color: com.vzome.core.construction.Color = colors.getColor(com.vzome.core.render.Colors.DIRECTION_$LI$() + orbit.getCanonicalName());
                        const str: string = dirElem.getAttribute("color");
                        if (str != null && !/* isEmpty */(str.length === 0) && !(str === ("255,255,255"))){
                            color = com.vzome.core.construction.Color.parseColor(str);
                        }
                        this.orbitColors.put(orbit.getName(), color);
                        this.orbitColors.put(orbit.getCanonicalName(), color);
                    }
                };}
                for(let index=this.symmetry.getOrbitSet().getDirections().iterator();index.hasNext();) {
                    let orbit = index.next();
                    {
                        if (this.orbits.contains(orbit))continue;
                        if (orbit.isStandard() || allowNonstandard)this.orbits.add(orbit);
                        const color: com.vzome.core.construction.Color = colors.getColor(com.vzome.core.render.Colors.DIRECTION_$LI$() + orbit.getCanonicalName());
                        this.orbitColors.put(orbit.getName(), color);
                        this.orbitColors.put(orbit.getCanonicalName(), color);
                    }
                }
            }
            this.setStyle(styleName);
        }

        public setEditorModel(editor: com.vzome.core.editor.api.EditorModel) {
            this.editor = editor;
        }

        public createToolFactories(tools: com.vzome.core.editor.ToolsModel) {
            {
                let array = /* Enum.values */function() { let result: com.vzome.api.Tool.Kind[] = []; for(let val in com.vzome.api.Tool.Kind) { if (!isNaN(<any>val)) { result.push(parseInt(val,10)); } } return result; }();
                for(let index = 0; index < array.length; index++) {
                    let kind = array[index];
                    {
                        const list: java.util.List<com.vzome.api.Tool.Factory> = this.symmetryPerspective.createToolFactories(kind, tools);
                        this.toolFactoryLists.put(kind, list);
                        const toolList: java.util.List<com.vzome.api.Tool> = this.symmetryPerspective.predefineTools(kind, tools);
                        this.toolLists.put(kind, toolList);
                    }
                }
            }
        }

        public getName(): string {
            return this.symmetry.getName();
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} vector
         * @return {com.vzome.core.math.symmetry.Axis}
         */
        public getAxis(vector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.math.symmetry.Axis {
            if (vector.isOrigin()){
                return null;
            }
            let line: com.vzome.core.math.symmetry.Axis = this.vectorToAxis.get(vector.toString());
            if (line != null)return line;
            if (!this.noKnownDirections){
                line = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_math_symmetry_OrbitSet'](vector, this.orbits);
                if (line != null){
                    this.vectorToAxis.put(vector.toString(), line);
                    return line;
                }
            }
            const dir: com.vzome.core.math.symmetry.Direction = this.createAnonymousOrbit(vector);
            line = dir.getAxis$com_vzome_core_algebra_AlgebraicVector(vector);
            this.vectorToAxis.put(vector.toString(), line);
            return line;
        }

        public createAnonymousOrbit(vector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.math.symmetry.Direction {
            const symm: com.vzome.core.math.symmetry.Symmetry = this.orbits.getSymmetry();
            const field: com.vzome.core.algebra.AlgebraicField = symm.getField();
            const longer: com.vzome.core.algebra.AlgebraicNumber = field['createPower$int'](1);
            const shorter: com.vzome.core.algebra.AlgebraicNumber = field['createPower$int'](-1);
            const rv: com.vzome.core.math.RealVector = vector.toRealVector();
            let longVector: com.vzome.core.algebra.AlgebraicVector = vector;
            let shortVector: com.vzome.core.algebra.AlgebraicVector = vector;
            let longLen: number = 2.0;
            let shortLen: number = 2.0;
            const len: number = rv.length();
            if (len > 2.0){
                longLen = len;
                longVector = vector;
                while((longLen > 2.0)) {{
                    shortVector = longVector.scale(shorter);
                    shortLen = shortVector.toRealVector().length();
                    if (shortLen <= 2.0)break;
                    longLen = shortLen;
                    longVector = shortVector;
                }};
            } else {
                shortLen = len;
                shortVector = vector;
                while((shortLen <= 2.0)) {{
                    longVector = shortVector.scale(longer);
                    longLen = longVector.toRealVector().length();
                    if (longLen > 2.0)break;
                    shortLen = longLen;
                    shortVector = longVector;
                }};
            }
            if ((2.0 / shortLen) > longLen)vector = longVector; else vector = shortVector;
            const colorName: string = "" + this.nextNewAxis++;
            const orbit: com.vzome.core.math.symmetry.Direction = symm.createNewZoneOrbit(colorName, 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vector);
            orbit.setAutomatic(true);
            this.orbits.add(orbit);
            let color: com.vzome.core.construction.Color = this.colors.getColor(com.vzome.core.render.Colors.DIRECTION_$LI$() + orbit.getCanonicalName());
            if (color == null)color = com.vzome.core.construction.Color.WHITE_$LI$();
            this.orbitColors.put(orbit.getName(), color);
            this.orbitColors.put(orbit.getCanonicalName(), color);
            return orbit;
        }

        public getVectorColor(vector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.construction.Color {
            if (vector == null || vector.isOrigin()){
                return this.colors.getColor(com.vzome.core.render.Colors.CONNECTOR_$LI$());
            }
            let line: com.vzome.core.math.symmetry.Axis = this.vectorToAxis.get(vector.toString());
            if (line == null){
                line = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_math_symmetry_OrbitSet'](vector, this.orbits);
            }
            return (line == null) ? com.vzome.core.construction.Color.WHITE_$LI$() : this.getColor(line.getDirection());
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Direction} orbit
         * @return {com.vzome.core.construction.Color}
         */
        public getColor(orbit: com.vzome.core.math.symmetry.Direction): com.vzome.core.construction.Color {
            if (orbit == null)return this.colors.getColor(com.vzome.core.render.Colors.CONNECTOR_$LI$());
            let shapeColor: com.vzome.core.construction.Color = this.shapes.getColor(orbit);
            if (shapeColor == null)shapeColor = this.orbitColors.get(orbit.getName());
            if (shapeColor == null)return com.vzome.core.construction.Color.WHITE_$LI$();
            return shapeColor;
        }

        /**
         * 
         * @return {*}
         */
        public getSymmetry(): com.vzome.core.math.symmetry.Symmetry {
            return this.symmetry;
        }

        /**
         * 
         * @return {com.vzome.core.math.symmetry.OrbitSet}
         */
        public getOrbits(): com.vzome.core.math.symmetry.OrbitSet {
            return this.orbits;
        }

        public disableKnownDirection() {
            this.noKnownDirections = true;
        }

        public getRenderingStyle(): com.vzome.core.editor.api.Shapes {
            return this.shapes;
        }

        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const result: org.w3c.dom.Element = doc.createElement("SymmetrySystem");
            com.vzome.xml.DomUtils.addAttribute(result, "name", this.getSymmetry().getName());
            com.vzome.xml.DomUtils.addAttribute(result, "renderingStyle", this.shapes.getName());
            for(let index=this.orbits.getDirections().iterator();index.hasNext();) {
                let dir = index.next();
                {
                    const dirElem: org.w3c.dom.Element = doc.createElement("Direction");
                    if (dir.isAutomatic())com.vzome.xml.DomUtils.addAttribute(dirElem, "prototype", dir.getPrototype().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                    com.vzome.xml.DomUtils.addAttribute(dirElem, "name", dir.getName());
                    com.vzome.xml.DomUtils.addAttribute(dirElem, "orbit", dir.getCanonicalName());
                    {
                        const color: com.vzome.core.construction.Color = this.getColor(dir);
                        if (color != null)com.vzome.xml.DomUtils.addAttribute(dirElem, "color", color.toString());
                    };
                    result.appendChild(dirElem);
                }
            }
            return result;
        }

        public getStyle$java_lang_String(styleName: string): com.vzome.core.editor.api.Shapes {
            const found: java.util.Optional<com.vzome.core.editor.api.Shapes> = this.symmetryPerspective.getGeometries().stream().filter((e) => (styleName === e.getName()) || (styleName === e.getAlias()) || (styleName === e.getPackage())).findFirst();
            if (found.isPresent())return found.get(); else return null;
        }

        public getStyle(styleName?: any): com.vzome.core.editor.api.Shapes {
            if (((typeof styleName === 'string') || styleName === null)) {
                return <any>this.getStyle$java_lang_String(styleName);
            } else if (styleName === undefined) {
                return <any>this.getStyle$();
            } else throw new Error('invalid overload');
        }

        public setStyle(styleName: string) {
            const result: com.vzome.core.editor.api.Shapes = this.getStyle$java_lang_String(styleName);
            if (result != null)this.shapes = result; else {
                SymmetrySystem.logger_$LI$().warning("UNKNOWN STYLE NAME: " + styleName);
                this.shapes = this.symmetryPerspective.getDefaultGeometry();
            }
        }

        public getStyleNames(): string[] {
            return this.symmetryPerspective.getGeometries().stream().map<any>((e) => e.getName()).toArray<any>((arg0) => { return new Array<string>(arg0) });
        }

        public getStyle$(): com.vzome.core.editor.api.Shapes {
            return this.shapes;
        }

        /**
         * 
         * @return {*}
         */
        public getShapes(): com.vzome.core.editor.api.Shapes {
            return this.shapes;
        }

        public getShape$com_vzome_core_algebra_AlgebraicVector(offset: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.math.Polyhedron {
            return this.getShape$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_editor_api_Shapes(offset, this.shapes);
        }

        public getShape$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_editor_api_Shapes(offset: com.vzome.core.algebra.AlgebraicVector, shapes: com.vzome.core.editor.api.Shapes): com.vzome.core.math.Polyhedron {
            if (offset == null)return shapes.getConnectorShape(); else {
                if (offset.isOrigin())return null;
                const axis: com.vzome.core.math.symmetry.Axis = this.getAxis(offset);
                if (axis == null)return null;
                const orbit: com.vzome.core.math.symmetry.Direction = axis.getDirection();
                const len: com.vzome.core.algebra.AlgebraicNumber = axis.getLength(offset);
                return shapes.getStrutShape(orbit, len);
            }
        }

        public getShape(offset?: any, shapes?: any): com.vzome.core.math.Polyhedron {
            if (((offset != null && offset instanceof <any>com.vzome.core.algebra.AlgebraicVector) || offset === null) && ((shapes != null && (shapes.constructor != null && shapes.constructor["__interfaces"] != null && shapes.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.Shapes") >= 0)) || shapes === null)) {
                return <any>this.getShape$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_editor_api_Shapes(offset, shapes);
            } else if (((offset != null && offset instanceof <any>com.vzome.core.algebra.AlgebraicVector) || offset === null) && shapes === undefined) {
                return <any>this.getShape$com_vzome_core_algebra_AlgebraicVector(offset);
            } else throw new Error('invalid overload');
        }

        public getToolFactories(kind: com.vzome.api.Tool.Kind): java.util.List<com.vzome.api.Tool.Factory> {
            return this.toolFactoryLists.get(kind);
        }

        public getPredefinedTools(kind: com.vzome.api.Tool.Kind): java.util.List<com.vzome.api.Tool> {
            return this.toolLists.get(kind);
        }

        public doAction(action: string): boolean {
            const command: com.vzome.core.commands.Command = this.symmetryPerspective.getLegacyCommand(action);
            if (command != null){
                const edit: com.vzome.core.editor.CommandEdit = new com.vzome.core.editor.CommandEdit(<com.vzome.core.commands.AbstractCommand><any>command, this.editor);
                this.context.performAndRecord(edit);
                return true;
            }
            return false;
        }

        public getModelResourcePath(): string {
            return this.symmetryPerspective.getModelResourcePath();
        }

        public orbitIsStandard(orbit: com.vzome.core.math.symmetry.Direction): boolean {
            return this.symmetryPerspective.orbitIsStandard(orbit);
        }

        public orbitIsBuildDefault(orbit: com.vzome.core.math.symmetry.Direction): boolean {
            return this.symmetryPerspective.orbitIsBuildDefault(orbit);
        }

        public getOrbitUnitLength(orbit: com.vzome.core.math.symmetry.Direction): com.vzome.core.algebra.AlgebraicNumber {
            return this.symmetryPerspective.getOrbitUnitLength(orbit);
        }

        public resetColors() {
            for(let index=this.symmetry.getOrbitSet().getDirections().iterator();index.hasNext();) {
                let orbit = index.next();
                {
                    const color: com.vzome.core.construction.Color = this.colors.getColor(com.vzome.core.render.Colors.DIRECTION_$LI$() + orbit.getName());
                    this.orbitColors.put(orbit.getName(), color);
                }
            }
        }
    }
    SymmetrySystem["__class"] = "com.vzome.core.editor.SymmetrySystem";
    SymmetrySystem["__interfaces"] = ["com.vzome.core.editor.api.OrbitSource"];


}
namespace com.vzome.core.algebra {
    export class Vector3dHomogeneous {
        e1: com.vzome.core.algebra.AlgebraicNumber;

        e2: com.vzome.core.algebra.AlgebraicNumber;

        e3: com.vzome.core.algebra.AlgebraicNumber;

        e0: com.vzome.core.algebra.AlgebraicNumber;

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        public constructor(e1?: any, e2?: any, e3?: any, e0?: any, field?: any) {
            if (((e1 != null && (e1.constructor != null && e1.constructor["__interfaces"] != null && e1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e1 === null) && ((e2 != null && (e2.constructor != null && e2.constructor["__interfaces"] != null && e2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e2 === null) && ((e3 != null && (e3.constructor != null && e3.constructor["__interfaces"] != null && e3.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e3 === null) && ((e0 != null && (e0.constructor != null && e0.constructor["__interfaces"] != null && e0.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e0 === null) && ((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null)) {
                let __args = arguments;
                if (this.e1 === undefined) { this.e1 = null; } 
                if (this.e2 === undefined) { this.e2 = null; } 
                if (this.e3 === undefined) { this.e3 = null; } 
                if (this.e0 === undefined) { this.e0 = null; } 
                if (this.field === undefined) { this.field = null; } 
                this.e1 = e1;
                this.e2 = e2;
                this.e3 = e3;
                this.e0 = e0;
                this.field = field;
            } else if (((e1 != null && (e1.constructor != null && e1.constructor["__interfaces"] != null && e1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e1 === null) && ((e2 != null && (e2.constructor != null && e2.constructor["__interfaces"] != null && e2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e2 === null) && ((e3 != null && (e3.constructor != null && e3.constructor["__interfaces"] != null && e3.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e3 === null) && ((e0 != null && (e0.constructor != null && e0.constructor["__interfaces"] != null && e0.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || e0 === null) && field === undefined) {
                let __args = arguments;
                let field: any = __args[3];
                {
                    let __args = arguments;
                    let e2: any = __args[0];
                    let e3: any = __args[0];
                    let e0: any = __args[4].one();
                    if (this.e1 === undefined) { this.e1 = null; } 
                    if (this.e2 === undefined) { this.e2 = null; } 
                    if (this.e3 === undefined) { this.e3 = null; } 
                    if (this.e0 === undefined) { this.e0 = null; } 
                    if (this.field === undefined) { this.field = null; } 
                    this.e1 = e1;
                    this.e2 = e2;
                    this.e3 = e3;
                    this.e0 = e0;
                    this.field = field;
                }
            } else if (((e1 != null && e1 instanceof <any>com.vzome.core.algebra.AlgebraicVector) || e1 === null) && ((e2 != null && (e2.constructor != null && e2.constructor["__interfaces"] != null && e2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || e2 === null) && e3 === undefined && e0 === undefined && field === undefined) {
                let __args = arguments;
                let v: any = __args[0];
                let field: any = __args[1];
                {
                    let __args = arguments;
                    let e1: any = v.getComponent(0);
                    let e2: any = v.getComponent(1);
                    let e3: any = v.getComponent(2);
                    {
                        let __args = arguments;
                        let e2: any = __args[0];
                        let e3: any = __args[0];
                        let e0: any = __args[4].one();
                        if (this.e1 === undefined) { this.e1 = null; } 
                        if (this.e2 === undefined) { this.e2 = null; } 
                        if (this.e3 === undefined) { this.e3 = null; } 
                        if (this.e0 === undefined) { this.e0 = null; } 
                        if (this.field === undefined) { this.field = null; } 
                        this.e1 = e1;
                        this.e2 = e2;
                        this.e3 = e3;
                        this.e0 = e0;
                        this.field = field;
                    }
                }
            } else throw new Error('invalid overload');
        }

        public outer(that: Vector3dHomogeneous): com.vzome.core.algebra.Bivector3dHomogeneous {
            const e12: com.vzome.core.algebra.AlgebraicNumber = this.e1['times$com_vzome_core_algebra_AlgebraicNumber'](that.e2)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e2['times$com_vzome_core_algebra_AlgebraicNumber'](that.e1));
            const e23: com.vzome.core.algebra.AlgebraicNumber = this.e2['times$com_vzome_core_algebra_AlgebraicNumber'](that.e3)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e3['times$com_vzome_core_algebra_AlgebraicNumber'](that.e2));
            const e31: com.vzome.core.algebra.AlgebraicNumber = this.e3['times$com_vzome_core_algebra_AlgebraicNumber'](that.e1)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e1['times$com_vzome_core_algebra_AlgebraicNumber'](that.e3));
            const e10: com.vzome.core.algebra.AlgebraicNumber = this.e1['times$com_vzome_core_algebra_AlgebraicNumber'](that.e0)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e0['times$com_vzome_core_algebra_AlgebraicNumber'](that.e1));
            const e20: com.vzome.core.algebra.AlgebraicNumber = this.e2['times$com_vzome_core_algebra_AlgebraicNumber'](that.e0)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e0['times$com_vzome_core_algebra_AlgebraicNumber'](that.e2));
            const e30: com.vzome.core.algebra.AlgebraicNumber = this.e3['times$com_vzome_core_algebra_AlgebraicNumber'](that.e0)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e0['times$com_vzome_core_algebra_AlgebraicNumber'](that.e3));
            return new com.vzome.core.algebra.Bivector3dHomogeneous(e12, e23, e31, e10, e20, e30, this.field);
        }

        public getVector(): com.vzome.core.algebra.AlgebraicVector {
            return new com.vzome.core.algebra.AlgebraicVector(this.e1.dividedBy(this.e0), this.e2.dividedBy(this.e0), this.e3.dividedBy(this.e0));
        }

        public dot(v: com.vzome.core.algebra.Bivector3dHomogeneous): Vector3dHomogeneous {
            const e1: com.vzome.core.algebra.AlgebraicNumber = this.e3['times$com_vzome_core_algebra_AlgebraicNumber'](v.e31)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e2['times$com_vzome_core_algebra_AlgebraicNumber'](v.e12))['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e0['times$com_vzome_core_algebra_AlgebraicNumber'](v.e10));
            const e2: com.vzome.core.algebra.AlgebraicNumber = this.e1['times$com_vzome_core_algebra_AlgebraicNumber'](v.e12)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e3['times$com_vzome_core_algebra_AlgebraicNumber'](v.e23))['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e0['times$com_vzome_core_algebra_AlgebraicNumber'](v.e20));
            const e3: com.vzome.core.algebra.AlgebraicNumber = this.e2['times$com_vzome_core_algebra_AlgebraicNumber'](v.e23)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e1['times$com_vzome_core_algebra_AlgebraicNumber'](v.e31))['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e0['times$com_vzome_core_algebra_AlgebraicNumber'](v.e30));
            const e0: com.vzome.core.algebra.AlgebraicNumber = this.e1['times$com_vzome_core_algebra_AlgebraicNumber'](v.e10)['plus$com_vzome_core_algebra_AlgebraicNumber'](this.e2['times$com_vzome_core_algebra_AlgebraicNumber'](v.e20))['plus$com_vzome_core_algebra_AlgebraicNumber'](this.e3['times$com_vzome_core_algebra_AlgebraicNumber'](v.e30));
            return new Vector3dHomogeneous(e1, e2, e3, e0, this.field);
        }

        public exists(): boolean {
            return !this.e0.isZero();
        }
    }
    Vector3dHomogeneous["__class"] = "com.vzome.core.algebra.Vector3dHomogeneous";

}
namespace com.vzome.core.algebra {
    export class Bivector3dHomogeneous {
        e12: com.vzome.core.algebra.AlgebraicNumber;

        e23: com.vzome.core.algebra.AlgebraicNumber;

        e31: com.vzome.core.algebra.AlgebraicNumber;

        e10: com.vzome.core.algebra.AlgebraicNumber;

        e20: com.vzome.core.algebra.AlgebraicNumber;

        e30: com.vzome.core.algebra.AlgebraicNumber;

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        public constructor(e12: com.vzome.core.algebra.AlgebraicNumber, e23: com.vzome.core.algebra.AlgebraicNumber, e31: com.vzome.core.algebra.AlgebraicNumber, e10: com.vzome.core.algebra.AlgebraicNumber, e20: com.vzome.core.algebra.AlgebraicNumber, e30: com.vzome.core.algebra.AlgebraicNumber, field: com.vzome.core.algebra.AlgebraicField) {
            if (this.e12 === undefined) { this.e12 = null; }
            if (this.e23 === undefined) { this.e23 = null; }
            if (this.e31 === undefined) { this.e31 = null; }
            if (this.e10 === undefined) { this.e10 = null; }
            if (this.e20 === undefined) { this.e20 = null; }
            if (this.e30 === undefined) { this.e30 = null; }
            if (this.field === undefined) { this.field = null; }
            this.e12 = e12;
            this.e23 = e23;
            this.e31 = e31;
            this.e10 = e10;
            this.e20 = e20;
            this.e30 = e30;
            this.field = field;
        }

        public outer(that: com.vzome.core.algebra.Vector3dHomogeneous): com.vzome.core.algebra.Trivector3dHomogeneous {
            const e123: com.vzome.core.algebra.AlgebraicNumber = this.e12['times$com_vzome_core_algebra_AlgebraicNumber'](that.e3)['plus$com_vzome_core_algebra_AlgebraicNumber'](this.e23['times$com_vzome_core_algebra_AlgebraicNumber'](that.e1))['plus$com_vzome_core_algebra_AlgebraicNumber'](this.e31['times$com_vzome_core_algebra_AlgebraicNumber'](that.e2));
            const e310: com.vzome.core.algebra.AlgebraicNumber = this.e10['times$com_vzome_core_algebra_AlgebraicNumber'](that.e3)['plus$com_vzome_core_algebra_AlgebraicNumber'](this.e31['times$com_vzome_core_algebra_AlgebraicNumber'](that.e0))['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e30['times$com_vzome_core_algebra_AlgebraicNumber'](that.e1));
            const e320: com.vzome.core.algebra.AlgebraicNumber = this.e20['times$com_vzome_core_algebra_AlgebraicNumber'](that.e3)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e30['times$com_vzome_core_algebra_AlgebraicNumber'](that.e2))['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e23['times$com_vzome_core_algebra_AlgebraicNumber'](that.e0));
            const e120: com.vzome.core.algebra.AlgebraicNumber = this.e12['times$com_vzome_core_algebra_AlgebraicNumber'](that.e0)['plus$com_vzome_core_algebra_AlgebraicNumber'](this.e20['times$com_vzome_core_algebra_AlgebraicNumber'](that.e1))['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e10['times$com_vzome_core_algebra_AlgebraicNumber'](that.e2));
            return new com.vzome.core.algebra.Trivector3dHomogeneous(e123, e310, e320, e120, this.field);
        }
    }
    Bivector3dHomogeneous["__class"] = "com.vzome.core.algebra.Bivector3dHomogeneous";

}
namespace com.vzome.core.algebra {
    export class AlgebraicMatrix {
        /**
         * 
         * @return {number}
         */
        public hashCode(): number {
            const prime: number = 31;
            let result: number = 1;
            for(let index = 0; index < this.matrix.length; index++) {
                let m = this.matrix[index];
                {
                    result = prime * result + java.util.Arrays.hashCode(m);
                }
            }
            return result;
        }

        /**
         * 
         * @param {*} obj
         * @return {boolean}
         */
        public equals(obj: any): boolean {
            if (this === obj)return true;
            if (obj == null)return false;
            if ((<any>this.constructor) !== (<any>obj.constructor))return false;
            const other: AlgebraicMatrix = <AlgebraicMatrix>obj;
            return java.util.Arrays.deepEquals(this.matrix, other.matrix);
        }

        matrix: com.vzome.core.algebra.AlgebraicNumber[][];

        public getMatrix(): com.vzome.core.algebra.AlgebraicNumber[][] {
            return this.matrix;
        }

        public getRowMajorRealElements(): number[] {
            const result: number[] = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            for(let i: number = 0; i < 3; i++) {{
                for(let j: number = 0; j < 3; j++) {{
                    result[i * 4 + j] = (<any>Math).fround(this.getElement(i, j).evaluate());
                };}
            };}
            return result;
        }

        public constructor(x?: any, y?: any, z?: any, w?: any) {
            if (((x != null && x instanceof <any>com.vzome.core.algebra.AlgebraicVector) || x === null) && ((y != null && y instanceof <any>com.vzome.core.algebra.AlgebraicVector) || y === null) && ((z != null && z instanceof <any>com.vzome.core.algebra.AlgebraicVector) || z === null) && ((w != null && w instanceof <any>com.vzome.core.algebra.AlgebraicVector) || w === null)) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let columns: any = [x, y, z, w];
                    if (this.matrix === undefined) { this.matrix = null; } 
                    const rows: number = columns[0].dimension();
                    const cols: number = columns.length;
                    this.matrix = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([rows, cols]);
                    for(let i: number = 0; i < rows; i++) {{
                        for(let j: number = 0; j < cols; j++) {{
                            this.matrix[i][j] = columns[j].getComponent(i);
                        };}
                    };}
                }
            } else if (((x != null && x instanceof <any>com.vzome.core.algebra.AlgebraicVector) || x === null) && ((y != null && y instanceof <any>com.vzome.core.algebra.AlgebraicVector) || y === null) && ((z != null && z instanceof <any>com.vzome.core.algebra.AlgebraicVector) || z === null) && w === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let columns: any = [x, y, z];
                    if (this.matrix === undefined) { this.matrix = null; } 
                    const rows: number = columns[0].dimension();
                    const cols: number = columns.length;
                    this.matrix = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([rows, cols]);
                    for(let i: number = 0; i < rows; i++) {{
                        for(let j: number = 0; j < cols; j++) {{
                            this.matrix[i][j] = columns[j].getComponent(i);
                        };}
                    };}
                }
            } else if (((x != null && (x.constructor != null && x.constructor["__interfaces"] != null && x.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null) && w === undefined) {
                let __args = arguments;
                let field: any = __args[0];
                let rows: any = __args[1];
                let cols: any = __args[2];
                if (this.matrix === undefined) { this.matrix = null; } 
                this.matrix = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([rows, cols]);
                for(let i: number = 0; i < rows; i++) {{
                    for(let j: number = 0; j < cols; j++) {{
                        this.matrix[i][j] = field.zero();
                    };}
                };}
            } else if (((x != null && x instanceof <any>com.vzome.core.algebra.AlgebraicVector) || x === null) && ((y != null && y instanceof <any>com.vzome.core.algebra.AlgebraicVector) || y === null) && z === undefined && w === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let columns: any = [x, y];
                    if (this.matrix === undefined) { this.matrix = null; } 
                    const rows: number = columns[0].dimension();
                    const cols: number = columns.length;
                    this.matrix = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([rows, cols]);
                    for(let i: number = 0; i < rows; i++) {{
                        for(let j: number = 0; j < cols; j++) {{
                            this.matrix[i][j] = columns[j].getComponent(i);
                        };}
                    };}
                }
            } else if (((x != null && (x.constructor != null && x.constructor["__interfaces"] != null && x.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || x === null) && ((typeof y === 'number') || y === null) && z === undefined && w === undefined) {
                let __args = arguments;
                let field: any = __args[0];
                let dim: any = __args[1];
                if (this.matrix === undefined) { this.matrix = null; } 
                this.matrix = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([dim, dim]);
                for(let i: number = 0; i < dim; i++) {{
                    for(let j: number = 0; j < dim; j++) {{
                        if (i === j)this.matrix[i][j] = field.one(); else this.matrix[i][j] = field.zero();
                    };}
                };}
            } else if (((x != null && x instanceof <any>Array && (x.length == 0 || x[0] == null ||(x[0] != null && x[0] instanceof <any>com.vzome.core.algebra.AlgebraicVector))) || x === null) && y === undefined && z === undefined && w === undefined) {
                let __args = arguments;
                let columns: any = __args[0];
                if (this.matrix === undefined) { this.matrix = null; } 
                const rows: number = columns[0].dimension();
                const cols: number = columns.length;
                this.matrix = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([rows, cols]);
                for(let i: number = 0; i < rows; i++) {{
                    for(let j: number = 0; j < cols; j++) {{
                        this.matrix[i][j] = columns[j].getComponent(i);
                    };}
                };}
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {string}
         */
        public toString(): string {
            const buf: java.lang.StringBuilder = new java.lang.StringBuilder();
            for(let index = 0; index < this.matrix.length; index++) {
                let m = this.matrix[index];
                {
                    buf.append(java.util.Arrays.toString(m));
                    buf.append(", ");
                }
            }
            return "[ " + buf.toString() + " ]";
        }

        public negate(): AlgebraicMatrix {
            const field: com.vzome.core.algebra.AlgebraicField = this.matrix[0][0].getField();
            const result: AlgebraicMatrix = new AlgebraicMatrix(field, this.matrix.length);
            for(let i: number = 0; i < this.matrix.length; i++) {{
                for(let j: number = 0; j < this.matrix[i].length; j++) {{
                    result.matrix[i][j] = this.matrix[i][j].negate();
                };}
            };}
            return result;
        }

        public inverse(): AlgebraicMatrix {
            if (!this.isSquare()){
                throw new java.lang.IllegalArgumentException("matrix is not square");
            }
            const field: com.vzome.core.algebra.AlgebraicField = this.matrix[0][0].getField();
            const result: AlgebraicMatrix = new AlgebraicMatrix(field, this.matrix.length);
            const rank: number = com.vzome.core.algebra.Fields.gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A$com_vzome_core_algebra_Fields_Element_A_A(this.matrix, result.matrix);
            if (rank !== this.matrix.length){
                const message: string = "AlgebraicMatrix inverse expects matrix rank to be " + this.matrix.length + ", but it is " + rank + ".";
                console.error(message);
            }
            return result;
        }

        public transpose(): AlgebraicMatrix {
            const field: com.vzome.core.algebra.AlgebraicField = this.matrix[0][0].getField();
            const result: AlgebraicMatrix = new AlgebraicMatrix(field, this.matrix[0].length, this.matrix.length);
            for(let i: number = 0; i < result.matrix.length; i++) {{
                for(let j: number = 0; j < this.matrix.length; j++) {{
                    result.matrix[i][j] = this.matrix[j][i];
                };}
            };}
            return result;
        }

        public times(that: AlgebraicMatrix): AlgebraicMatrix {
            const field: com.vzome.core.algebra.AlgebraicField = this.matrix[0][0].getField();
            const result: AlgebraicMatrix = new AlgebraicMatrix(field, this.matrix.length, that.matrix[0].length);
            com.vzome.core.algebra.Fields.matrixMultiplication<any>(this.matrix, that.matrix, result.matrix);
            return result;
        }

        public timesRow(rowVector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            const colLength: number = rowVector.dimension();
            if (this.matrix.length !== colLength)throw new java.lang.IllegalArgumentException("vector length incorrect for this matrix: " + rowVector);
            const rowLength: number = this.matrix[0].length;
            const resultComponents: com.vzome.core.algebra.AlgebraicNumber[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(rowLength);
            const field: com.vzome.core.algebra.AlgebraicField = this.matrix[0][0].getField();
            for(let j: number = 0; j < rowLength; j++) {{
                resultComponents[j] = field.zero();
                for(let i: number = 0; i < colLength; i++) {{
                    const product: com.vzome.core.algebra.AlgebraicNumber = rowVector.getComponent(i)['times$com_vzome_core_algebra_AlgebraicNumber'](this.matrix[i][j]);
                    resultComponents[j] = resultComponents[j]['plus$com_vzome_core_algebra_AlgebraicNumber'](product);
                };}
            };}
            return new com.vzome.core.algebra.AlgebraicVector(resultComponents);
        }

        public timesColumn(columnVector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            const rowLength: number = columnVector.dimension();
            if (this.matrix[0].length !== rowLength)throw new java.lang.IllegalArgumentException("vector length incorrect for this matrix: " + columnVector);
            const colLength: number = this.matrix.length;
            const resultComponents: com.vzome.core.algebra.AlgebraicNumber[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(colLength);
            const field: com.vzome.core.algebra.AlgebraicField = this.matrix[0][0].getField();
            for(let i: number = 0; i < colLength; i++) {{
                resultComponents[i] = field.zero();
                for(let j: number = 0; j < rowLength; j++) {{
                    const product: com.vzome.core.algebra.AlgebraicNumber = columnVector.getComponent(j)['times$com_vzome_core_algebra_AlgebraicNumber'](this.matrix[i][j]);
                    resultComponents[i] = resultComponents[i]['plus$com_vzome_core_algebra_AlgebraicNumber'](product);
                };}
            };}
            return new com.vzome.core.algebra.AlgebraicVector(resultComponents);
        }

        public timesScalar(scalar: com.vzome.core.algebra.AlgebraicNumber): AlgebraicMatrix {
            const result: AlgebraicMatrix = new AlgebraicMatrix(scalar.getField(), this.matrix.length);
            for(let i: number = 0; i < this.matrix.length; i++) {{
                for(let j: number = 0; j < this.matrix[i].length; j++) {{
                    result.matrix[i][j] = this.matrix[i][j]['times$com_vzome_core_algebra_AlgebraicNumber'](scalar);
                };}
            };}
            return result;
        }

        public isSquare(): boolean {
            return this.matrix.length === this.matrix[0].length;
        }

        public trace(): com.vzome.core.algebra.AlgebraicNumber {
            if (!this.isSquare()){
                throw new java.lang.IllegalArgumentException("matrix is not square");
            }
            let trace: com.vzome.core.algebra.AlgebraicNumber = this.matrix[0][0].getField().zero();
            for(let i: number = 0; i < this.matrix.length; i++) {{
                trace = trace['plus$com_vzome_core_algebra_AlgebraicNumber'](this.matrix[i][i]);
            };}
            return trace;
        }

        public determinant(): com.vzome.core.algebra.AlgebraicNumber {
            return AlgebraicMatrix.laplaceDeterminant(this.matrix);
        }

        public static laplaceDeterminant(matrix: com.vzome.core.algebra.AlgebraicNumber[][]): com.vzome.core.algebra.AlgebraicNumber {
            if (matrix.length !== matrix[0].length){
                throw new java.lang.IllegalArgumentException("matrix is not square");
            }
            let determinant: com.vzome.core.algebra.AlgebraicNumber = null;
            switch((matrix.length)) {
            case 3:
                determinant = (matrix[0][0]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][1])['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[2][2]))['plus$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][1]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][2])['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[2][0]))['plus$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][2]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][0])['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[2][1]))['minus$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][2]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][1])['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[2][0]))['minus$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][0]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][2])['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[2][1]))['minus$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][1]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][0])['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[2][2]));
                break;
            case 2:
                determinant = (matrix[0][0]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][1]))['minus$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][1]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][0]));
                break;
            case 1:
                determinant = matrix[0][0];
                break;
            default:
                determinant = matrix[0][0].getField().zero();
                const auxLength: number = matrix.length - 1;
                let sign: com.vzome.core.algebra.AlgebraicNumber = matrix[0][0].getField().one();
                for(let i: number = 0; i < matrix.length; i++) {{
                    if (!matrix[0][i].isZero()){
                        const aux: com.vzome.core.algebra.AlgebraicNumber[][] = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([auxLength, auxLength]);
                        let iAux: number = 0;
                        let jAux: number = 0;
                        for(let row: number = 1; row < matrix.length; row++) {{
                            for(let col: number = 0; col < matrix.length; col++) {{
                                if (col !== i){
                                    aux[iAux][jAux] = matrix[row][col];
                                    jAux++;
                                }
                            };}
                            iAux++;
                            jAux = 0;
                        };}
                        determinant = determinant['plus$com_vzome_core_algebra_AlgebraicNumber'](sign['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][i])['times$com_vzome_core_algebra_AlgebraicNumber'](AlgebraicMatrix.laplaceDeterminant(aux)));
                    }
                    sign = sign.negate();
                };}
            }
            return determinant;
        }

        public setElement(i: number, j: number, value: com.vzome.core.algebra.AlgebraicNumber): AlgebraicMatrix {
            this.matrix[i][j] = value;
            return this;
        }

        public getElement(i: number, j: number): com.vzome.core.algebra.AlgebraicNumber {
            return this.matrix[i][j];
        }
    }
    AlgebraicMatrix["__class"] = "com.vzome.core.algebra.AlgebraicMatrix";

}
namespace com.vzome.core.algebra {
    /**
     * A collection of static helper methods for the AlgebraicVector class
     * @class
     */
    export class AlgebraicVectors {
        constructor() {
        }

        public static getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v1: com.vzome.core.algebra.AlgebraicVector, v2: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            return v1.cross(v2);
        }

        public static getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0: com.vzome.core.algebra.AlgebraicVector, v1: com.vzome.core.algebra.AlgebraicVector, v2: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            return AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v1.minus(v0), v2.minus(v0));
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} v0
         * @param {com.vzome.core.algebra.AlgebraicVector} v1
         * @param {com.vzome.core.algebra.AlgebraicVector} v2
         * @return {com.vzome.core.algebra.AlgebraicVector} normal to vectors v1 and v2,
         * with both v1 and v2 positioned at v0
         * using the righthand rule.
         */
        public static getNormal(v0?: any, v1?: any, v2?: any): com.vzome.core.algebra.AlgebraicVector {
            if (((v0 != null && v0 instanceof <any>com.vzome.core.algebra.AlgebraicVector) || v0 === null) && ((v1 != null && v1 instanceof <any>com.vzome.core.algebra.AlgebraicVector) || v1 === null) && ((v2 != null && v2 instanceof <any>com.vzome.core.algebra.AlgebraicVector) || v2 === null)) {
                return <any>com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2);
            } else if (((v0 != null && v0 instanceof <any>com.vzome.core.algebra.AlgebraicVector) || v0 === null) && ((v1 != null && v1 instanceof <any>com.vzome.core.algebra.AlgebraicVector) || v1 === null) && v2 === undefined) {
                return <any>com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1);
            } else if (((v0 != null && (v0.constructor != null && v0.constructor["__interfaces"] != null && v0.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || v0 === null) && v1 === undefined && v2 === undefined) {
                return <any>com.vzome.core.algebra.AlgebraicVectors.getNormal$java_util_Collection(v0);
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} v1
         * @param {com.vzome.core.algebra.AlgebraicVector} v2
         * @return {boolean} true if vectors v1 and v2 are parallel, otherwise false.
         * Considered as position vectors, this is the same as testing if they are collinear with the origin.
         */
        public static areParallel(v1: com.vzome.core.algebra.AlgebraicVector, v2: com.vzome.core.algebra.AlgebraicVector): boolean {
            return AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v1, v2).isOrigin();
        }

        public static getNormal$java_util_Collection(vectors: java.util.Collection<com.vzome.core.algebra.AlgebraicVector>): com.vzome.core.algebra.AlgebraicVector {
            if (vectors.size() < 3){
                throw new java.lang.IllegalArgumentException("Three vertices are required to calculate a normal. Found " + vectors.size());
            }
            let v0: com.vzome.core.algebra.AlgebraicVector = null;
            let v1: com.vzome.core.algebra.AlgebraicVector = null;
            let normal: com.vzome.core.algebra.AlgebraicVector = null;
            for(let index=vectors.iterator();index.hasNext();) {
                let vector = index.next();
                {
                    if (v0 == null){
                        v0 = vector;
                    } else if (v1 == null){
                        if (vector !== v0){
                            v1 = vector;
                        }
                    } else {
                        normal = AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, vector);
                        if (!normal.isOrigin()){
                            return normal;
                        }
                    }
                }
            }
            return normal;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} vector
         * @return {number} index of the vector component having the greatest absolute value.
         * If more than one component has the same absolute value,
         * the greatest index will be returned.
         */
        public static getMaxComponentIndex(vector: com.vzome.core.algebra.AlgebraicVector): number {
            let maxIndex: number = 0;
            let maxSq: com.vzome.core.algebra.AlgebraicNumber = vector.getField().zero();
            for(let i: number = 0; i < vector.dimension(); i++) {{
                const n: com.vzome.core.algebra.AlgebraicNumber = vector.getComponent(i);
                const sq: com.vzome.core.algebra.AlgebraicNumber = n['times$com_vzome_core_algebra_AlgebraicNumber'](n);
                if (!sq.lessThan(maxSq)){
                    maxIndex = i;
                    maxSq = sq;
                }
            };}
            return maxIndex;
        }

        public static areCoplanar(vectors: java.util.Collection<com.vzome.core.algebra.AlgebraicVector>): boolean {
            if (vectors.size() < 4){
                return true;
            }
            const normal: com.vzome.core.algebra.AlgebraicVector = AlgebraicVectors.getNormal$java_util_Collection(vectors);
            if (normal.isOrigin() || normal.dimension() < 3){
                return true;
            }
            return AlgebraicVectors.areOrthogonalTo(normal, vectors);
        }

        public static areOrthogonalTo(normal: com.vzome.core.algebra.AlgebraicVector, vectors: java.util.Collection<com.vzome.core.algebra.AlgebraicVector>): boolean {
            if (normal.isOrigin()){
                throw new java.lang.IllegalArgumentException("Normal vector cannot be the origin");
            }
            let v0: com.vzome.core.algebra.AlgebraicVector = null;
            for(let index=vectors.iterator();index.hasNext();) {
                let vector = index.next();
                {
                    if (v0 == null){
                        v0 = vector;
                    } else if (!vector.minus(v0).dot(normal).isZero()){
                        return false;
                    }
                }
            }
            return true;
        }

        public static areCollinear$java_util_Collection(vectors: java.util.Collection<com.vzome.core.algebra.AlgebraicVector>): boolean {
            return (vectors.size() < 3) ? true : AlgebraicVectors.getNormal$java_util_Collection(vectors).isOrigin();
        }

        public static areCollinear$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0: com.vzome.core.algebra.AlgebraicVector, v1: com.vzome.core.algebra.AlgebraicVector, v2: com.vzome.core.algebra.AlgebraicVector): boolean {
            return AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2).isOrigin();
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} v0
         * @param {com.vzome.core.algebra.AlgebraicVector} v1
         * @param {com.vzome.core.algebra.AlgebraicVector} v2
         * @return {boolean} true if position vectors v0, v1 and v2 are collinear, otherwise false.
         */
        public static areCollinear(v0?: any, v1?: any, v2?: any): boolean {
            if (((v0 != null && v0 instanceof <any>com.vzome.core.algebra.AlgebraicVector) || v0 === null) && ((v1 != null && v1 instanceof <any>com.vzome.core.algebra.AlgebraicVector) || v1 === null) && ((v2 != null && v2 instanceof <any>com.vzome.core.algebra.AlgebraicVector) || v2 === null)) {
                return <any>com.vzome.core.algebra.AlgebraicVectors.areCollinear$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2);
            } else if (((v0 != null && (v0.constructor != null && v0.constructor["__interfaces"] != null && v0.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || v0 === null) && v1 === undefined && v2 === undefined) {
                return <any>com.vzome.core.algebra.AlgebraicVectors.areCollinear$java_util_Collection(v0);
            } else throw new Error('invalid overload');
        }

        public static getLinePlaneIntersection(lineStart: com.vzome.core.algebra.AlgebraicVector, lineDirection: com.vzome.core.algebra.AlgebraicVector, planeCenter: com.vzome.core.algebra.AlgebraicVector, planeNormal: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            const denom: com.vzome.core.algebra.AlgebraicNumber = planeNormal.dot(lineDirection);
            if (denom.isZero())return null;
            const p1p3: com.vzome.core.algebra.AlgebraicVector = planeCenter.minus(lineStart);
            const numerator: com.vzome.core.algebra.AlgebraicNumber = planeNormal.dot(p1p3);
            const u: com.vzome.core.algebra.AlgebraicNumber = numerator.dividedBy(denom);
            return lineStart.plus(lineDirection.scale(u));
        }

        public static calculateCentroid(vectors: java.util.Collection<com.vzome.core.algebra.AlgebraicVector>): com.vzome.core.algebra.AlgebraicVector {
            return AlgebraicVectors.getCentroid(vectors.toArray<any>((s => { let a=[]; while(s-->0) a.push(null); return a; })(vectors.size())));
        }

        public static getCentroid(vectors: com.vzome.core.algebra.AlgebraicVector[]): com.vzome.core.algebra.AlgebraicVector {
            const field: com.vzome.core.algebra.AlgebraicField = vectors[0].getField();
            let sum: com.vzome.core.algebra.AlgebraicVector = new com.vzome.core.algebra.AlgebraicVector(field, vectors[0].dimension());
            for(let index = 0; index < vectors.length; index++) {
                let vector = vectors[index];
                {
                    sum = sum.plus(vector);
                }
            }
            return sum.scale(field['createRational$long$long'](1, vectors.length));
        }

        public static getMagnitudeSquared(v: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicNumber {
            return v.dot(v);
        }

        /**
         * @param {com.vzome.core.algebra.AlgebraicVector} vector
         * @return {com.vzome.core.algebra.AlgebraicVector} the greater of {@code vector} and its inverse.
         * The comparison is based on a canonical (not mathematical) comparison as implemented in {@code AlgebraicVector.compareTo()}.
         * There is no reasonable mathematical sense of ordering vectors,
         * but this provides a way to map a vector and its inverse to a common vector for such purposes as sorting and color mapping.
         */
        public static getCanonicalOrientation(vector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            const negate: com.vzome.core.algebra.AlgebraicVector = vector.negate();
            return vector.compareTo(negate) > 0 ? vector : negate;
        }

        /**
         * getMostDistantFromOrigin() is is used by a few ColorMapper classes, but I think it can eventually be useful elsewhere as well, for example, a zoom-to-fit command or in deriving a convex hull. I've made it a static method of the AlgebraicVector class to encourage such reuse.
         * 
         * @param {*} vectors A collection of vectors to be evaluated.
         * @return {java.util.TreeSet} A canonically sorted subset (maybe all) of the {@code vectors} collection. All of the returned vectors will be the same distance from the origin. That distance will be the maximum distance from the origin of any of the vectors in the original collection. If the original collection contains only the origin then so will the result.
         */
        public static getMostDistantFromOrigin(vectors: java.util.Collection<com.vzome.core.algebra.AlgebraicVector>): java.util.TreeSet<com.vzome.core.algebra.AlgebraicVector> {
            const mostDistant: java.util.TreeSet<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.TreeSet<any>());
            let maxDistanceSquared: number = 0.0;
            for(let index=vectors.iterator();index.hasNext();) {
                let vector = index.next();
                {
                    const magnitudeSquared: number = AlgebraicVectors.getMagnitudeSquared(vector).evaluate();
                    if (magnitudeSquared >= maxDistanceSquared){
                        if (magnitudeSquared > maxDistanceSquared){
                            mostDistant.clear();
                        }
                        maxDistanceSquared = magnitudeSquared;
                        mostDistant.add(vector);
                    }
                }
            }
            return mostDistant;
        }
    }
    AlgebraicVectors["__class"] = "com.vzome.core.algebra.AlgebraicVectors";

}
namespace com.vzome.core.algebra {
    export class AlgebraicSeries {
        public series: com.vzome.core.algebra.AlgebraicNumber[];

        public constructor(field: com.vzome.core.algebra.AbstractAlgebraicField, power: number) {
            if (this.series === undefined) { this.series = null; }
            let sequence: java.util.List<number> = <any>(new java.util.ArrayList<any>());
            sequence.add(0);
            let divisor: com.vzome.core.algebra.AlgebraicNumber = field.getUnitTerm(1);
            divisor = divisor['times$com_vzome_core_algebra_AlgebraicNumber'](divisor);
            for(let i: number = 0; i < power + 2; i++) {{
                sequence = field.recurrence(sequence);
            };}
            this.series = (s => { let a=[]; while(s-->0) a.push(null); return a; })(sequence.size() + 1);
            this.series[0] = field.zero();
            let prevIndex: number = 0;
            for(let index=sequence.iterator();index.hasNext();) {
                let integer = index.next();
                {
                    const prev: com.vzome.core.algebra.AlgebraicNumber = this.series[prevIndex++];
                    const step: com.vzome.core.algebra.AlgebraicNumber = field.getUnitTerm(integer).dividedBy(divisor);
                    this.series[prevIndex] = prev['plus$com_vzome_core_algebra_AlgebraicNumber'](step);
                }
            }
        }

        public nearestAlgebraicNumber(target: number): com.vzome.core.algebra.AlgebraicNumber {
            const negative: boolean = target < 0.0;
            if (negative)target = -target;
            const positive: com.vzome.core.algebra.AlgebraicNumber = this.checkRange(0, this.series.length - 1, target);
            if (negative)return positive.negate(); else return positive;
        }

        /*private*/ checkRange(minIndex: number, maxIndex: number, target: number): com.vzome.core.algebra.AlgebraicNumber {
            if (minIndex >= maxIndex)return this.series[maxIndex]; else {
                const lowDiff: number = target - this.series[minIndex].evaluate();
                const highDiff: number = this.series[maxIndex].evaluate() - target;
                if (maxIndex === minIndex + 1){
                    return (highDiff < lowDiff) ? this.series[maxIndex] : this.series[minIndex];
                } else {
                    const midIndex: number = (<number>Math.floor(((maxIndex + minIndex) / 2|0))|0);
                    return (highDiff < lowDiff) ? this.checkRange(midIndex, maxIndex, target) : this.checkRange(minIndex, midIndex, target);
                }
            }
        }

        /**
         * 
         * @return {string}
         */
        public toString(): string {
            let result: string = "";
            for(let index = 0; index < this.series.length; index++) {
                let algebraicNumber = this.series[index];
                {
                    result += algebraicNumber.toString() + ", ";
                }
            }
            return result;
        }
    }
    AlgebraicSeries["__class"] = "com.vzome.core.algebra.AlgebraicSeries";

}
namespace com.vzome.core.algebra {
    /**
     * @author vorth
     * @param {*} n1
     * @param {*} n2
     * @param {*} n3
     * @param {*} n4
     * @param {*} n5
     * @class
     */
    export class AlgebraicVector implements java.lang.Comparable<AlgebraicVector> {
        public static X: number = 0;

        public static Y: number = 1;

        public static Z: number = 2;

        public static W4: number = 0;

        public static X4: number = 1;

        public static Y4: number = 2;

        public static Z4: number = 3;

        /*private*/ coordinates: com.vzome.core.algebra.AlgebraicNumber[];

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        public constructor(n1?: any, n2?: any, n3?: any, n4?: any, n5?: any) {
            if (((n1 != null && (n1.constructor != null && n1.constructor["__interfaces"] != null && n1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n1 === null) && ((n2 != null && (n2.constructor != null && n2.constructor["__interfaces"] != null && n2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n2 === null) && ((n3 != null && (n3.constructor != null && n3.constructor["__interfaces"] != null && n3.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n3 === null) && ((n4 != null && (n4.constructor != null && n4.constructor["__interfaces"] != null && n4.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n4 === null) && ((n5 != null && (n5.constructor != null && n5.constructor["__interfaces"] != null && n5.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n5 === null)) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let field: any = n1.getField();
                    let dims: any = 5;
                    if (this.coordinates === undefined) { this.coordinates = null; } 
                    if (this.field === undefined) { this.field = null; } 
                    this.coordinates = (s => { let a=[]; while(s-->0) a.push(null); return a; })(dims);
                    for(let i: number = 0; i < dims; i++) {{
                        this.coordinates[i] = field.zero();
                    };}
                    this.field = field;
                }
                (() => {
                    this.coordinates[0] = n1;
                    this.coordinates[1] = n2;
                    this.coordinates[2] = n3;
                    this.coordinates[3] = n4;
                    this.coordinates[4] = n5;
                })();
            } else if (((n1 != null && (n1.constructor != null && n1.constructor["__interfaces"] != null && n1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n1 === null) && ((n2 != null && (n2.constructor != null && n2.constructor["__interfaces"] != null && n2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n2 === null) && ((n3 != null && (n3.constructor != null && n3.constructor["__interfaces"] != null && n3.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n3 === null) && ((n4 != null && (n4.constructor != null && n4.constructor["__interfaces"] != null && n4.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n4 === null) && n5 === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let field: any = n1.getField();
                    let dims: any = 4;
                    if (this.coordinates === undefined) { this.coordinates = null; } 
                    if (this.field === undefined) { this.field = null; } 
                    this.coordinates = (s => { let a=[]; while(s-->0) a.push(null); return a; })(dims);
                    for(let i: number = 0; i < dims; i++) {{
                        this.coordinates[i] = field.zero();
                    };}
                    this.field = field;
                }
                (() => {
                    this.coordinates[0] = n1;
                    this.coordinates[1] = n2;
                    this.coordinates[2] = n3;
                    this.coordinates[3] = n4;
                })();
            } else if (((n1 != null && (n1.constructor != null && n1.constructor["__interfaces"] != null && n1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n1 === null) && ((n2 != null && (n2.constructor != null && n2.constructor["__interfaces"] != null && n2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n2 === null) && ((n3 != null && (n3.constructor != null && n3.constructor["__interfaces"] != null && n3.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n3 === null) && n4 === undefined && n5 === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let field: any = n1.getField();
                    let dims: any = 3;
                    if (this.coordinates === undefined) { this.coordinates = null; } 
                    if (this.field === undefined) { this.field = null; } 
                    this.coordinates = (s => { let a=[]; while(s-->0) a.push(null); return a; })(dims);
                    for(let i: number = 0; i < dims; i++) {{
                        this.coordinates[i] = field.zero();
                    };}
                    this.field = field;
                }
                (() => {
                    this.coordinates[0] = n1;
                    this.coordinates[1] = n2;
                    this.coordinates[2] = n3;
                })();
            } else if (((n1 != null && (n1.constructor != null && n1.constructor["__interfaces"] != null && n1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n1 === null) && ((n2 != null && (n2.constructor != null && n2.constructor["__interfaces"] != null && n2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n2 === null) && n3 === undefined && n4 === undefined && n5 === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let field: any = n1.getField();
                    let dims: any = 2;
                    if (this.coordinates === undefined) { this.coordinates = null; } 
                    if (this.field === undefined) { this.field = null; } 
                    this.coordinates = (s => { let a=[]; while(s-->0) a.push(null); return a; })(dims);
                    for(let i: number = 0; i < dims; i++) {{
                        this.coordinates[i] = field.zero();
                    };}
                    this.field = field;
                }
                (() => {
                    this.coordinates[0] = n1;
                    this.coordinates[1] = n2;
                })();
            } else if (((n1 != null && (n1.constructor != null && n1.constructor["__interfaces"] != null && n1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || n1 === null) && ((typeof n2 === 'number') || n2 === null) && n3 === undefined && n4 === undefined && n5 === undefined) {
                let __args = arguments;
                let field: any = __args[0];
                let dims: any = __args[1];
                if (this.coordinates === undefined) { this.coordinates = null; } 
                if (this.field === undefined) { this.field = null; } 
                this.coordinates = (s => { let a=[]; while(s-->0) a.push(null); return a; })(dims);
                for(let i: number = 0; i < dims; i++) {{
                    this.coordinates[i] = field.zero();
                };}
                this.field = field;
            } else if (((n1 != null && n1 instanceof <any>Array && (n1.length == 0 || n1[0] == null ||(n1[0] != null && (n1[0].constructor != null && n1[0].constructor["__interfaces"] != null && n1[0].constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)))) || n1 === null) && n2 === undefined && n3 === undefined && n4 === undefined && n5 === undefined) {
                let __args = arguments;
                let n: any = __args[0];
                if (this.coordinates === undefined) { this.coordinates = null; } 
                if (this.field === undefined) { this.field = null; } 
                this.coordinates = (s => { let a=[]; while(s-->0) a.push(null); return a; })(n.length);
                java.lang.System.arraycopy(n, 0, this.coordinates, 0, n.length);
                this.field = n[0].getField();
            } else if (((n1 != null && (n1.constructor != null && n1.constructor["__interfaces"] != null && n1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n1 === null) && n2 === undefined && n3 === undefined && n4 === undefined && n5 === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let field: any = n1.getField();
                    let dims: any = 1;
                    if (this.coordinates === undefined) { this.coordinates = null; } 
                    if (this.field === undefined) { this.field = null; } 
                    this.coordinates = (s => { let a=[]; while(s-->0) a.push(null); return a; })(dims);
                    for(let i: number = 0; i < dims; i++) {{
                        this.coordinates[i] = field.zero();
                    };}
                    this.field = field;
                }
                (() => {
                    this.coordinates[0] = n1;
                })();
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {number}
         */
        public hashCode(): number {
            const prime: number = 31;
            let result: number = 1;
            result = prime * result + java.util.Arrays.hashCode(this.coordinates);
            return result;
        }

        /**
         * 
         * @param {*} obj
         * @return {boolean}
         */
        public equals(obj: any): boolean {
            if (this === obj)return true;
            if (obj == null)return false;
            if ((<any>this.constructor) !== (<any>obj.constructor))return false;
            const other: AlgebraicVector = <AlgebraicVector>obj;
            if (!/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(this.field,other.field))){
                const reason: string = "Invalid comparison of " + /* getSimpleName */(c => typeof c === 'string' ? (<any>c).substring((<any>c).lastIndexOf('.')+1) : c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.')+1) : c["name"].substring(c["name"].lastIndexOf('.')+1))((<any>this.constructor)) + "swith different fields: " + this.field.getName() + " and " + other.field.getName();
                throw new java.lang.IllegalStateException(reason);
            }
            return java.util.Arrays.equals(this.coordinates, other.coordinates);
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} other
         * @return {number}
         */
        public compareTo(other: AlgebraicVector): number {
            if (this === other){
                return 0;
            }
            if (other.equals(this)){
                return 0;
            }
            let comparison: number = /* compare */(this.coordinates.length - other.coordinates.length);
            if (comparison !== 0){
                return comparison;
            }
            for(let i: number = 0; i < this.coordinates.length; i++) {{
                const n1: com.vzome.core.algebra.AlgebraicNumber = this.coordinates[i];
                const n2: com.vzome.core.algebra.AlgebraicNumber = other.coordinates[i];
                comparison = n1.compareTo(n2);
                if (comparison !== 0){
                    return comparison;
                }
            };}
            return comparison;
        }

        public toRealVector(): com.vzome.core.math.RealVector {
            return new com.vzome.core.math.RealVector(this.coordinates[0].evaluate(), this.coordinates[1].evaluate(), this.coordinates[2].evaluate());
        }

        public to3dDoubleVector(): number[] {
            return [this.coordinates[0].evaluate(), this.coordinates[1].evaluate(), this.coordinates[2].evaluate()];
        }

        /**
         * @return {string} A String with no extended characters so it's suitable for writing
         * to an 8 bit stream such as System.out or an ASCII text log file in Windows.
         * Contrast this with {@link toString()} which contains extended characters (e.g. φ (phi))
         */
        public toASCIIString(): string {
            return this.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.EXPRESSION_FORMAT);
        }

        /**
         * @return {string} A String representation that can be persisted to XML and parsed by XmlSaveFormat.parseRationalVector().
         */
        public toParsableString(): string {
            return this.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT);
        }

        public toString(format: number = com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT): string {
            return this.getVectorExpression$int(format);
        }

        public getComponent(i: number): com.vzome.core.algebra.AlgebraicNumber {
            return this.coordinates[i];
        }

        public getComponents(): com.vzome.core.algebra.AlgebraicNumber[] {
            return this.coordinates;
        }

        public setComponent(component: number, coord: com.vzome.core.algebra.AlgebraicNumber): AlgebraicVector {
            this.coordinates[component] = coord;
            return this;
        }

        public negate(): AlgebraicVector {
            const result: com.vzome.core.algebra.AlgebraicNumber[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.coordinates.length);
            for(let i: number = 0; i < result.length; i++) {{
                result[i] = this.coordinates[i].negate();
            };}
            return new AlgebraicVector(result);
        }

        public scale(scale: com.vzome.core.algebra.AlgebraicNumber): AlgebraicVector {
            const result: com.vzome.core.algebra.AlgebraicNumber[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.coordinates.length);
            for(let i: number = 0; i < result.length; i++) {{
                result[i] = this.coordinates[i]['times$com_vzome_core_algebra_AlgebraicNumber'](scale);
            };}
            return new AlgebraicVector(result);
        }

        public isOrigin(): boolean {
            for(let index = 0; index < this.coordinates.length; index++) {
                let coordinate = this.coordinates[index];
                {
                    if (!coordinate.isZero()){
                        return false;
                    }
                }
            }
            return true;
        }

        public plus(that: AlgebraicVector): AlgebraicVector {
            const result: com.vzome.core.algebra.AlgebraicNumber[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.coordinates.length);
            for(let i: number = 0; i < result.length; i++) {{
                result[i] = this.coordinates[i]['plus$com_vzome_core_algebra_AlgebraicNumber'](that.coordinates[i]);
            };}
            return new AlgebraicVector(result);
        }

        public minus(that: AlgebraicVector): AlgebraicVector {
            const result: com.vzome.core.algebra.AlgebraicNumber[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.coordinates.length);
            for(let i: number = 0; i < result.length; i++) {{
                result[i] = this.coordinates[i]['minus$com_vzome_core_algebra_AlgebraicNumber'](that.coordinates[i]);
            };}
            return new AlgebraicVector(result);
        }

        public dimension(): number {
            return this.coordinates.length;
        }

        public cross(that: AlgebraicVector): AlgebraicVector {
            const result: com.vzome.core.algebra.AlgebraicNumber[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.coordinates.length);
            for(let i: number = 0; i < result.length; i++) {{
                const j: number = (i + 1) % 3;
                const k: number = (i + 2) % 3;
                result[i] = this.coordinates[j]['times$com_vzome_core_algebra_AlgebraicNumber'](that.coordinates[k])['minus$com_vzome_core_algebra_AlgebraicNumber'](this.coordinates[k]['times$com_vzome_core_algebra_AlgebraicNumber'](that.coordinates[j]));
            };}
            return new AlgebraicVector(result);
        }

        public inflateTo4d$(): AlgebraicVector {
            return this.inflateTo4d$boolean(true);
        }

        public inflateTo4d$boolean(wFirst: boolean): AlgebraicVector {
            if (this.coordinates.length === 4){
                if (wFirst)return this; else return new AlgebraicVector([this.coordinates[1], this.coordinates[2], this.coordinates[3], this.coordinates[0]]);
            }
            if (wFirst)return new AlgebraicVector([this.field.zero(), this.coordinates[0], this.coordinates[1], this.coordinates[2]]); else return new AlgebraicVector([this.coordinates[0], this.coordinates[1], this.coordinates[2], this.field.zero()]);
        }

        public inflateTo4d(wFirst?: any): AlgebraicVector {
            if (((typeof wFirst === 'boolean') || wFirst === null)) {
                return <any>this.inflateTo4d$boolean(wFirst);
            } else if (wFirst === undefined) {
                return <any>this.inflateTo4d$();
            } else throw new Error('invalid overload');
        }

        public projectTo3d(wFirst: boolean): AlgebraicVector {
            if (this.dimension() === 3)return this;
            if (wFirst)return new AlgebraicVector([this.coordinates[1], this.coordinates[2], this.coordinates[3]]); else return new AlgebraicVector([this.coordinates[0], this.coordinates[1], this.coordinates[2]]);
        }

        public getVectorExpression$java_lang_StringBuffer$int(buf: java.lang.StringBuffer, format: number) {
            if (format === com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT)buf.append("(");
            for(let i: number = 0; i < this.coordinates.length; i++) {{
                if (i > 0)if (format === com.vzome.core.algebra.AlgebraicField.VEF_FORMAT || format === com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT)buf.append(" "); else buf.append(", ");
                this.coordinates[i].getNumberExpression(buf, format);
            };}
            if (format === com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT)buf.append(")");
        }

        /**
         * 
         * @param {java.lang.StringBuffer} buf a StringBuffer to which the formatted vector will be appended.
         * @param {number} format may be any of the following:
         * {@code AlgebraicField.DEFAULT_FORMAT = 0; // 4 + 3φ}
         * {@code AlgebraicField.EXPRESSION_FORMAT = 1; // 4 +3*phi}
         * {@code AlgebraicField.ZOMIC_FORMAT = 2; // 4 3}
         * {@code AlgebraicField.VEF_FORMAT = 3; // (3,4)}
         */
        public getVectorExpression(buf?: any, format?: any) {
            if (((buf != null && buf instanceof <any>java.lang.StringBuffer) || buf === null) && ((typeof format === 'number') || format === null)) {
                return <any>this.getVectorExpression$java_lang_StringBuffer$int(buf, format);
            } else if (((typeof buf === 'number') || buf === null) && format === undefined) {
                return <any>this.getVectorExpression$int(buf);
            } else throw new Error('invalid overload');
        }

        public getVectorExpression$int(format: number): string {
            const buf: java.lang.StringBuffer = new java.lang.StringBuffer();
            this.getVectorExpression$java_lang_StringBuffer$int(buf, format);
            return buf.toString();
        }

        public dot(that: AlgebraicVector): com.vzome.core.algebra.AlgebraicNumber {
            let result: com.vzome.core.algebra.AlgebraicNumber = this.field.zero();
            for(let i: number = 0; i < that.dimension(); i++) {{
                result = result['plus$com_vzome_core_algebra_AlgebraicNumber'](this.coordinates[i]['times$com_vzome_core_algebra_AlgebraicNumber'](that.coordinates[i]));
            };}
            return result;
        }

        public getLength(unit: AlgebraicVector): com.vzome.core.algebra.AlgebraicNumber {
            for(let i: number = 0; i < this.coordinates.length; i++) {{
                if (this.coordinates[i].isZero())continue;
                return this.coordinates[i].dividedBy(unit.coordinates[i]);
            };}
            throw new java.lang.IllegalStateException("vector is the origin!");
        }

        public getField(): com.vzome.core.algebra.AlgebraicField {
            return this.field;
        }
    }
    AlgebraicVector["__class"] = "com.vzome.core.algebra.AlgebraicVector";
    AlgebraicVector["__interfaces"] = ["java.lang.Comparable"];


}
namespace com.vzome.core.algebra {
    export abstract class AbstractAlgebraicField implements com.vzome.core.algebra.AlgebraicField {
        /* Default method injected from com.vzome.core.algebra.AlgebraicField */
        supportsSubfield(fieldName: string): boolean {
            if (fieldName === this.getName())return true;
            return (fieldName === ("golden")) && this.getGoldenRatio() != null;
        }
        abstract multiply(v1: com.vzome.core.algebra.BigRational[], v2: com.vzome.core.algebra.BigRational[]): com.vzome.core.algebra.BigRational[];

        abstract evaluateNumber(factors: com.vzome.core.algebra.BigRational[]): number;

        abstract scaleBy(factors: com.vzome.core.algebra.BigRational[], whichIrrational: number): com.vzome.core.algebra.BigRational[];

        public abstract getCoefficients(): number[];

        /**
         * The integers should be the same indices used by getUnitTerm().
         * Subclasses must override to usefully participate in the generation
         * of AlgebraicSeries.
         * @param {*} input
         * @return
         * @return {*}
         */
        public recurrence(input: java.util.List<number>): java.util.List<number> {
            return input;
        }

        normalize(factors: com.vzome.core.algebra.BigRational[]) {
        }

        /**
         * 
         * @return {number}
         */
        public getOrder(): number {
            return this.order;
        }

        /**
         * 
         * @return {number}
         */
        public getNumIrrationals(): number {
            return this.order - 1;
        }

        /**
         * 
         * @return {boolean}
         */
        public scale4dRoots(): boolean {
            return false;
        }

        /**
         * 
         * @return {boolean}
         */
        public doubleFrameVectors(): boolean {
            return false;
        }

        /**
         * 
         * @param {string} name
         * @return {*}
         */
        public getNumberByName(name: string): com.vzome.core.algebra.AlgebraicNumber {
            switch((name)) {
            case "zero":
                return this.zero();
            case "one":
                return this.one();
            case "phi":
            case "\u03c6":
                return this.getGoldenRatio();
            case "\u221a5":
            case "root5":
            case "sqrt5":
                {
                    const n: com.vzome.core.algebra.AlgebraicNumber = this.getGoldenRatio();
                    return n == null ? null : n['plus$com_vzome_core_algebra_AlgebraicNumber'](n)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.one());
                };
            case "\u221a8":
            case "root8":
            case "sqrt8":
                {
                    const n: com.vzome.core.algebra.AlgebraicNumber = this.getNumberByName("sqrt2");
                    return n == null ? null : n['times$com_vzome_core_algebra_AlgebraicNumber'](this.createRational$long(2));
                };
            default:
                for(let format: number = AbstractAlgebraicField.DEFAULT_FORMAT; format <= AbstractAlgebraicField.EXPRESSION_FORMAT; format++) {{
                    for(let i: number = 1; i < this.getOrder(); i++) {{
                        if (this['getIrrational$int$int'](i, format) === name){
                            return this.getUnitTerm(i);
                        }
                    };}
                };}
            }
            return null;
        }

        public getIrrational$int(i: number): string {
            return this['getIrrational$int$int'](i, AbstractAlgebraicField.DEFAULT_FORMAT);
        }

        name: string;

        /*private*/ order: number;

        /*private*/ __hashCode: number;

        __one: com.vzome.core.algebra.AlgebraicNumber;

        __zero: com.vzome.core.algebra.AlgebraicNumber;

        /**
         * Positive powers of the irrationals.
         */
        /*private*/ positivePowers: java.util.ArrayList<com.vzome.core.algebra.AlgebraicNumber>[];

        /**
         * Negative powers of the irrationals.
         */
        /*private*/ negativePowers: java.util.ArrayList<com.vzome.core.algebra.AlgebraicNumber>[];

        static SMALL_SERIES_THRESHOLD: number = 30.0;

        /*private*/ smallSeries: com.vzome.core.algebra.AlgebraicSeries;

        numberFactory: com.vzome.core.algebra.AlgebraicNumberFactory;

        public constructor(name: string, order: number, factory: com.vzome.core.algebra.AlgebraicNumberFactory) {
            if (this.name === undefined) { this.name = null; }
            if (this.order === undefined) { this.order = 0; }
            if (this.__hashCode === undefined) { this.__hashCode = null; }
            if (this.__one === undefined) { this.__one = null; }
            if (this.__zero === undefined) { this.__zero = null; }
            if (this.positivePowers === undefined) { this.positivePowers = null; }
            if (this.negativePowers === undefined) { this.negativePowers = null; }
            if (this.smallSeries === undefined) { this.smallSeries = null; }
            if (this.numberFactory === undefined) { this.numberFactory = null; }
            this.name = name;
            this.order = order;
            this.numberFactory = factory;
            this.__zero = this.numberFactory.createRational(this, 0, 1);
            this.__one = this.numberFactory.createRational(this, 1, 1);
            this.positivePowers = (s => { let a=[]; while(s-->0) a.push(null); return a; })(order - 1);
            this.negativePowers = (s => { let a=[]; while(s-->0) a.push(null); return a; })(order - 1);
        }

        /*private*/ initSmallSeries() {
            if (this.smallSeries == null){
                this.smallSeries = this.generateSeries(AbstractAlgebraicField.SMALL_SERIES_THRESHOLD);
            }
        }

        public nearestAlgebraicNumber(target: number): com.vzome.core.algebra.AlgebraicNumber {
            this.initSmallSeries();
            return this.smallSeries.nearestAlgebraicNumber(target);
        }

        /**
         * 
         * @param {com.vzome.core.math.RealVector} target
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public nearestAlgebraicVector(target: com.vzome.core.math.RealVector): com.vzome.core.algebra.AlgebraicVector {
            this.initSmallSeries();
            return new com.vzome.core.algebra.AlgebraicVector(this.smallSeries.nearestAlgebraicNumber(target.x), this.smallSeries.nearestAlgebraicNumber(target.y), this.smallSeries.nearestAlgebraicNumber(target.z));
        }

        /**
         * 
         * @return {string}
         */
        public getName(): string {
            return this.name;
        }

        /**
         * 
         * @return {string}
         */
        public toString(): string {
            return this.getName();
        }

        /**
         * 
         * @return {number}
         */
        public hashCode(): number {
            if (this.__hashCode == null){
                const prime: number = 43;
                this.__hashCode = 7;
                const coefficients: number[] = this.getCoefficients();
                for(let i: number = 0; i < coefficients.length; i++) {{
                    const coefficient: number = coefficients[i];
                    this.__hashCode = prime * this.__hashCode + /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})(coefficient));
                };}
            }
            return this.__hashCode;
        }

        /**
         * With the use of parameterized fields, it's possible for two fields
         * of different classes to be equal
         * or for two fields of the same class to not be equal.
         * For example RootTwoField equals SqrtField(2)
         * but SqrtField(2) does not equal SqrtField(3).
         * Similarly, PolygonField(4) equals SqrtField(2)
         * and PolygonField(6) equals SqrtField(3).
         * 
         * @param {*} obj
         * @return {boolean}
         */
        public equals(obj: any): boolean {
            if (this === obj){
                return true;
            }
            if (obj == null){
                return false;
            }
            if (!(obj != null && obj instanceof <any>com.vzome.core.algebra.AbstractAlgebraicField)){
                return false;
            }
            const that: AbstractAlgebraicField = <AbstractAlgebraicField>obj;
            if (this.getName() === that.getName()){
                return true;
            }
            if (this.getOrder() !== that.getOrder()){
                return false;
            }
            const thisCoefficients: number[] = this.getCoefficients();
            const thatCoefficients: number[] = that.getCoefficients();
            for(let i: number = 0; i < thisCoefficients.length; i++) {{
                if (thisCoefficients[i] - thatCoefficients[i] !== 0.0){
                    return false;
                }
            };}
            return true;
        }

        /**
         * This method is intended to allow subclasses to intercept a 4 element int array
         * representing the numerators and denominators of a pair of terms (units and phis)
         * from the golden field and remap them as needed for that field.
         * Otherwise, the terms are returned unchanged.
         * @param terms
         * @return
         * @param {long[]} pairs
         * @return {long[]}
         */
        convertGoldenNumberPairs(pairs: number[]): number[] {
            if (pairs.length === 2 * this.order)return pairs; else {
                const newPairs: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(2 * this.order);
                for(let i: number = 0; i < this.order; i++) {{
                    newPairs[2 * i + 0] = (i >= 2) ? 0 : pairs[2 * i + 0];
                    newPairs[2 * i + 1] = (i >= 2) ? 1 : pairs[2 * i + 1];
                };}
                return newPairs;
            }
        }

        public createAlgebraicNumber$int_A(terms: number[]): com.vzome.core.algebra.AlgebraicNumber {
            return this.numberFactory.createAlgebraicNumber(this, terms, 1);
        }

        /**
         * Generates an AlgebraicNumber from a "trailing divisor" int array representation.
         * @param {int[]} trailingDivisorForm numerators trailed by a common denominator for all numerators
         * @return
         * @return {*}
         */
        public createAlgebraicNumberFromTD(trailingDivisorForm: number[]): com.vzome.core.algebra.AlgebraicNumber {
            let terms: number = trailingDivisorForm.length - 1;
            if (terms === 2 && this.getOrder() > 2){
                let pairs: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(2 * terms);
                const divisor: number = trailingDivisorForm[terms];
                for(let i: number = 0; i < terms; i++) {{
                    pairs[2 * i + 0] = trailingDivisorForm[i];
                    pairs[2 * i + 1] = divisor;
                };}
                pairs = this.convertGoldenNumberPairs(pairs);
                terms = (pairs.length / 2|0);
                trailingDivisorForm = (s => { let a=[]; while(s-->0) a.push(0); return a; })(terms + 1);
                trailingDivisorForm[terms] = (<number>pairs[1]|0);
                for(let i: number = 0; i < (pairs.length / 2|0); i++) {{
                    trailingDivisorForm[i] = (<number>pairs[2 * i]|0);
                };}
            }
            return this.numberFactory.createAlgebraicNumberFromTD(this, trailingDivisorForm);
        }

        public createAlgebraicNumber$int_A$int(numerators: number[], denominator: number): com.vzome.core.algebra.AlgebraicNumber {
            return this.numberFactory.createAlgebraicNumber(this, numerators, denominator);
        }

        public createAlgebraicNumber$int$int$int$int(ones: number, irrat: number, denominator: number, scalePower: number): com.vzome.core.algebra.AlgebraicNumber {
            const factors: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.order + 1);
            factors[0] = ones;
            factors[1] = irrat;
            for(let i: number = 2; i < this.order; i++) {{
                factors[i] = 0;
            };}
            factors[this.order] = denominator;
            const result: com.vzome.core.algebra.AlgebraicNumber = this.numberFactory.createAlgebraicNumberFromTD(this, factors);
            if (scalePower !== 0){
                const multiplier: com.vzome.core.algebra.AlgebraicNumber = this.createPower$int(scalePower);
                return result['times$com_vzome_core_algebra_AlgebraicNumber'](multiplier);
            } else return result;
        }

        /**
         * 
         * @param {number} ones
         * @param {number} irrat
         * @param {number} denominator
         * @param {number} scalePower
         * @return {*}
         */
        public createAlgebraicNumber(ones?: any, irrat?: any, denominator?: any, scalePower?: any): com.vzome.core.algebra.AlgebraicNumber {
            if (((typeof ones === 'number') || ones === null) && ((typeof irrat === 'number') || irrat === null) && ((typeof denominator === 'number') || denominator === null) && ((typeof scalePower === 'number') || scalePower === null)) {
                return <any>this.createAlgebraicNumber$int$int$int$int(ones, irrat, denominator, scalePower);
            } else if (((ones != null && ones instanceof <any>Array && (ones.length == 0 || ones[0] == null ||(typeof ones[0] === 'number'))) || ones === null) && ((typeof irrat === 'number') || irrat === null) && denominator === undefined && scalePower === undefined) {
                return <any>this.createAlgebraicNumber$int_A$int(ones, irrat);
            } else if (((ones != null && ones instanceof <any>Array && (ones.length == 0 || ones[0] == null ||(typeof ones[0] === 'number'))) || ones === null) && irrat === undefined && denominator === undefined && scalePower === undefined) {
                return <any>this.createAlgebraicNumber$int_A(ones);
            } else throw new Error('invalid overload');
        }

        /**
         * The golden ratio (and thus icosahedral symmetry and related tools)
         * can be generated by some fields even though it's not one of their irrational coefficients.
         * For example, SqrtField(5) and PolygonField(10) can both generate the golden ratio
         * so they can support icosa symmetry and related tools.
         * In some such cases, the resulting AlgebraicNumber
         * may have multiple terms and/or factors other than one.
         * 
         * @return {*} An AlgebraicNumber which evaluates to the golden ratio, or null if not possible in this field.
         */
        public getGoldenRatio(): com.vzome.core.algebra.AlgebraicNumber {
            return null;
        }

        public createPower$int(power: number): com.vzome.core.algebra.AlgebraicNumber {
            return this.createPower$int$int(power, 1);
        }

        public createPower$int$int(power: number, irr: number): com.vzome.core.algebra.AlgebraicNumber {
            const one: com.vzome.core.algebra.AlgebraicNumber = this.one();
            if (power === 0 || irr === 0)return one;
            irr -= 1;
            if (power > 0){
                if (this.positivePowers[irr] == null)this.positivePowers[irr] = <any>(new java.util.ArrayList<any>(8));
                if (power >= this.positivePowers[irr].size()){
                    if (this.positivePowers[irr].isEmpty()){
                        this.positivePowers[irr].add(one);
                        this.positivePowers[irr].add(this.getUnitTerm(irr + 1));
                    }
                    const size: number = this.positivePowers[irr].size();
                    const irrat: com.vzome.core.algebra.AlgebraicNumber = this.positivePowers[irr].get(1);
                    let last: com.vzome.core.algebra.AlgebraicNumber = this.positivePowers[irr].get(size - 1);
                    for(let i: number = size; i <= power; i++) {{
                        const next: com.vzome.core.algebra.AlgebraicNumber = last['times$com_vzome_core_algebra_AlgebraicNumber'](irrat);
                        this.positivePowers[irr].add(next);
                        last = next;
                    };}
                }
                return this.positivePowers[irr].get(power);
            } else {
                power = -power;
                if (this.negativePowers[irr] == null)this.negativePowers[irr] = <any>(new java.util.ArrayList<any>(8));
                if (power >= this.negativePowers[irr].size()){
                    if (this.negativePowers[irr].isEmpty()){
                        this.negativePowers[irr].add(one);
                        this.negativePowers[irr].add(this.getUnitTerm(irr + 1).reciprocal());
                    }
                    const size: number = this.negativePowers[irr].size();
                    const irrat: com.vzome.core.algebra.AlgebraicNumber = this.negativePowers[irr].get(1);
                    let last: com.vzome.core.algebra.AlgebraicNumber = this.negativePowers[irr].get(size - 1);
                    for(let i: number = size; i <= power; i++) {{
                        const next: com.vzome.core.algebra.AlgebraicNumber = last['times$com_vzome_core_algebra_AlgebraicNumber'](irrat);
                        this.negativePowers[irr].add(next);
                        last = next;
                    };}
                }
                return this.negativePowers[irr].get(power);
            }
        }

        /**
         * 
         * @param {number} power
         * @param {number} irr
         * @return {*}
         */
        public createPower(power?: any, irr?: any): com.vzome.core.algebra.AlgebraicNumber {
            if (((typeof power === 'number') || power === null) && ((typeof irr === 'number') || irr === null)) {
                return <any>this.createPower$int$int(power, irr);
            } else if (((typeof power === 'number') || power === null) && irr === undefined) {
                return <any>this.createPower$int(power);
            } else throw new Error('invalid overload');
        }

        public createRational$long(wholeNumber: number): com.vzome.core.algebra.AlgebraicNumber {
            return this.numberFactory.createRational(this, wholeNumber, 1);
        }

        public createRational$long$long(numerator: number, denominator: number): com.vzome.core.algebra.AlgebraicNumber {
            return this.numberFactory.createRational(this, numerator, denominator);
        }

        /**
         * @param {number} numerator
         * @param {number} denominator
         * @return {*} AlgebraicNumber
         */
        public createRational(numerator?: any, denominator?: any): com.vzome.core.algebra.AlgebraicNumber {
            if (((typeof numerator === 'number') || numerator === null) && ((typeof denominator === 'number') || denominator === null)) {
                return <any>this.createRational$long$long(numerator, denominator);
            } else if (((typeof numerator === 'number') || numerator === null) && denominator === undefined) {
                return <any>this.createRational$long(numerator);
            } else throw new Error('invalid overload');
        }

        /**
         * @return {*} The AlgebraicNumber to be use for the Chord Ratio construction in the given field.
         * This method can be used to generalize an AffinePolygon tool and a PolygonalAntiprismSymmetry.
         * This base class returns one, which is the scalar for an affine square and works in any field.
         * Derived classes should override this method if they can be used to generate any other affine polygon.
         */
        public getAffineScalar(): com.vzome.core.algebra.AlgebraicNumber {
            return this.__one;
        }

        /**
         * @param {number} n specifies the ordinal of the term in the AlgebraicNumber which will be set to one.
         * When {@code n == 0}, the result is the same as {@code createRational(1)}.
         * When {@code n == 1}, the result is the same as {@code createPower(1)}.
         * When {@code n < 0}, the result will be {@code zero()}.
         * When {@code n >= getOrder()}, an IndexOutOfBoundsException will be thrown.
         * @return {*} an AlgebraicNumber with the factor specified by {@code n} set to one.
         */
        public getUnitTerm(n: number): com.vzome.core.algebra.AlgebraicNumber {
            if (n < 0){
                return this.zero();
            }
            const factors: number[] = this.zero().toTrailingDivisor();
            factors[n] = factors[factors.length - 1];
            return this.numberFactory.createAlgebraicNumberFromTD(this, factors);
        }

        /**
         * Drop one coordinate from the 4D vector. If wFirst (the usual), then drop
         * the first coordinate, taking the "imaginary part" of the vector. If
         * !wFirst (for old VEF import, etc.), drop the last coordinate.
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} source
         * @param {boolean} wFirst
         * @return
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public projectTo3d(source: com.vzome.core.algebra.AlgebraicVector, wFirst: boolean): com.vzome.core.algebra.AlgebraicVector {
            if (source.dimension() === 3)return source; else {
                const result: com.vzome.core.algebra.AlgebraicVector = this.origin(3);
                for(let i: number = 0; i < 3; i++) {result.setComponent(i, source.getComponent(wFirst ? i + 1 : i));}
                return result;
            }
        }

        /**
         * 
         * @param {number} dims
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public origin(dims: number): com.vzome.core.algebra.AlgebraicVector {
            return new com.vzome.core.algebra.AlgebraicVector(this, dims);
        }

        /**
         * 
         * @param {number} dims
         * @param {number} axis
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public basisVector(dims: number, axis: number): com.vzome.core.algebra.AlgebraicVector {
            const result: com.vzome.core.algebra.AlgebraicVector = this.origin(dims);
            return result.setComponent(axis, this.one());
        }

        reciprocal(fieldElement: com.vzome.core.algebra.BigRational[]): com.vzome.core.algebra.BigRational[] {
            const length: number = fieldElement.length;
            const representation: com.vzome.core.algebra.BigRational[][] = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([length, length]);
            let isZero: boolean = true;
            for(let i: number = 0; i < length; i++) {{
                isZero = isZero && fieldElement[i].isZero();
                representation[0][i] = fieldElement[i];
            };}
            if (isZero)throw new java.lang.RuntimeException("Denominator is zero");
            for(let j: number = 1; j < length; j++) {{
                const column: com.vzome.core.algebra.BigRational[] = this.scaleBy(fieldElement, j);
                java.lang.System.arraycopy(column, 0, representation[j], 0, length);
            };}
            const reciprocal: com.vzome.core.algebra.BigRational[][] = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([length, length]);
            for(let j: number = 0; j < length; j++) {{
                for(let i: number = 0; i < length; i++) {{
                    reciprocal[j][i] = (i === j) ? this.numberFactory.one() : this.numberFactory.zero();
                };}
            };}
            const rank: number = com.vzome.core.algebra.Fields.gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A$com_vzome_core_algebra_Fields_Element_A_A(representation, reciprocal);
            const reciprocalFactors: com.vzome.core.algebra.BigRational[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(length);
            java.lang.System.arraycopy(reciprocal[0], 0, reciprocalFactors, 0, length);
            return (rank === length) ? reciprocalFactors : this.onReciprocalRankDeficient(rank, reciprocal, reciprocalFactors);
        }

        /**
         * Subclasses can overloading this method to handle special cases. (e.g. SqrtField of a perfect square)
         * @param {number} rank
         * @param {com.vzome.core.algebra.BigRational[][]} reciprocal
         * @param {com.vzome.core.algebra.BigRational[]} reciprocalFactors
         * @throws IllegalStateException
         * @return {com.vzome.core.algebra.BigRational[]}
         */
        onReciprocalRankDeficient(rank: number, reciprocal: com.vzome.core.algebra.BigRational[][], reciprocalFactors: com.vzome.core.algebra.BigRational[]): com.vzome.core.algebra.BigRational[] {
            const msg: string = this.getName() + " expects reciprocal matrix to be full rank (" + reciprocal.length + "), but it is " + rank + ".";
            console.error(msg);
            throw new java.lang.IllegalStateException(msg);
        }

        public static DEFAULT_FORMAT: number = 0;

        public static EXPRESSION_FORMAT: number = 1;

        public static ZOMIC_FORMAT: number = 2;

        public static VEF_FORMAT: number = 3;

        /**
         * 
         * @return {*}
         */
        public zero(): com.vzome.core.algebra.AlgebraicNumber {
            return this.__zero;
        }

        /**
         * 
         * @return {*}
         */
        public one(): com.vzome.core.algebra.AlgebraicNumber {
            return this.__one;
        }

        /**
         * 
         * @param {int[][]} nums is an array of integer arrays: One array of coordinate terms per dimension.
         * Initially, this is designed to simplify migration of order 2 golden directions
         * to new fields of higher order having golden subfields as their first two factors.
         * {@code
         * field.createVector( new int[]  {  0,1,2,3,   4,5,6,7,   8,9,0,1  } );   // older code like this...
         * field.createVector( new int[][]{ {0,1,2,3}, {4,5,6,7}, {8,9,0,1} } );   // should be replaced by this.
         * }
         * The older code shown in the first example requires an order 2 field.
         * The second example will work with any field of order 2 or greater.
         * This new overload has the advantage that the internal arrays representing the individual dimensions are more clearly delineated and controlled.
         * Inner arrays require an even number of elements since they represent a sequence of numerator/denominator pairs.
         * 
         * createVector is currently limited to int valued vectors, not long, and definitely not BigInteger
         * In most cases, this is adequate, but in the case where it's called by XmlSaveFormat.parseAlgebraicObject(),
         * it seems possible that a value larger than Integer.MAX_VALUE could be saved to the XML which could not subsequently be parsed.
         * TODO: Consider refactoring createVector to use long[][] instead of int[][] if this becomes an issue.
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector} an AlgebraicVector
         */
        public createVector(nums: number[][]): com.vzome.core.algebra.AlgebraicVector {
            const dims: number = nums.length;
            const coords: com.vzome.core.algebra.AlgebraicNumber[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(dims);
            for(let c: number = 0; c < coords.length; c++) {{
                const coordLength: number = nums[c].length;
                if (coordLength % 2 !== 0){
                    throw new java.lang.IllegalStateException("Vector dimension " + c + " has " + coordLength + " components. An even number is required.");
                }
                const nTerms: number = (coordLength / 2|0);
                if (nTerms > this.getOrder()){
                    throw new java.lang.IllegalStateException("Vector dimension " + c + " has " + ((coordLength / 2|0)) + " terms. Each dimension of the " + this.getName() + " field is limited to " + this.getOrder() + " terms. Each term consists of a numerator and a denominator.");
                }
                let pairs: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(nums[c].length);
                for(let i: number = 0; i < pairs.length; i++) {{
                    pairs[i] = nums[c][i];
                };}
                if (pairs.length === 4 && this.getOrder() > 2){
                    pairs = this.convertGoldenNumberPairs(pairs);
                }
                coords[c] = this.numberFactory.createAlgebraicNumberFromPairs(this, pairs);
            };}
            return new com.vzome.core.algebra.AlgebraicVector(coords);
        }

        /**
         * 
         * @param {int[][]} nums
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public createVectorFromTDs(nums: number[][]): com.vzome.core.algebra.AlgebraicVector {
            const dims: number = nums.length;
            const coords: com.vzome.core.algebra.AlgebraicNumber[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(dims);
            for(let c: number = 0; c < coords.length; c++) {{
                coords[c] = this.createAlgebraicNumberFromTD(nums[c]);
            };}
            return new com.vzome.core.algebra.AlgebraicVector(coords);
        }

        /**
         * Generates an AlgebraicVector with all AlgebraicNumber terms being integers (having unit denominators).
         * Contrast this with {@code createVector(int[][] nums)} which requires all denominators to be specified.
         * @param {int[][]} nums is a 2 dimensional integer array. The length of nums becomes the number of dimensions in the resulting AlgebraicVector.
         * For example, {@code (new PentagonField()).createIntegerVector( new int[][]{ {0,-1}, {2,3}, {4,5} } ); }
         * generates the 3 dimensional vector (-φ, 2 +3φ, 4 +5φ) having all integer terms.
         * @return {com.vzome.core.algebra.AlgebraicVector} an AlgebraicVector
         */
        public createIntegerVector(nums: number[][]): com.vzome.core.algebra.AlgebraicVector {
            const dims: number = nums.length;
            const result: com.vzome.core.algebra.AlgebraicVector = this.origin(dims);
            for(let dim: number = 0; dim < dims; dim++) {{
                result.setComponent(dim, this.createAlgebraicNumber$int_A(nums[dim]));
            };}
            return result;
        }

        /**
         * Create a 3x3 square matrix from integer data.
         * TODO: Generalize this method to create a matrix with dimensions matching the dimensions of the data array
         * Sample input data for an order-4 field:
         * {{{7,5,0,1,-4,5,0,1},{-2,5,0,1,4,5,0,1},{0,1,-8,5,0,1,6,5}},
         * {{-2,5,0,1,4,5,0,1},{7,5,0,1,-4,5,0,1},{0,1,8,5,0,1,-6,5}},
         * {{0,1,-8,5,0,1,6,5},{0,1,8,5,0,1,-6,5},{-9,5,0,1,8,5,0,1}}}
         * @param field
         * @param {int[][][]} data integer coordinates, in row-major order, complete with denominators.
         * @return
         * @return {com.vzome.core.algebra.AlgebraicMatrix}
         */
        public createMatrix(data: number[][][]): com.vzome.core.algebra.AlgebraicMatrix {
            const col1: com.vzome.core.algebra.AlgebraicVector = this.createVector([data[0][0], data[1][0], data[2][0]]);
            const col2: com.vzome.core.algebra.AlgebraicVector = this.createVector([data[0][1], data[1][1], data[2][1]]);
            const col3: com.vzome.core.algebra.AlgebraicVector = this.createVector([data[0][2], data[1][2], data[2][2]]);
            return new com.vzome.core.algebra.AlgebraicMatrix(col1, col2, col3);
        }

        /**
         * 
         * @param {java.lang.StringBuffer} buf
         * @param {com.vzome.core.algebra.BigRational[]} factors
         * @param {number} format must be one of the following values.
         * The result is formatted as follows:
         * <br>
         * {@code DEFAULT_FORMAT    // 4 + 3φ}<br>
         * {@code EXPRESSION_FORMAT // 4 +3*phi}<br>
         * {@code ZOMIC_FORMAT      // 4 3}<br>
         * {@code VEF_FORMAT        // (3,4)}
         */
        getNumberExpression(buf: java.lang.StringBuffer, factors: com.vzome.core.algebra.BigRational[], format: number) {
            switch((format)) {
            case 2 /* ZOMIC_FORMAT */:
                for(let i: number = 0; i < factors.length; i++) {{
                    if (i > 0)buf.append(" ");
                    buf.append(factors[i].toString());
                };}
                break;
            case 3 /* VEF_FORMAT */:
                buf.append("(");
                for(let i: number = factors.length; i > 0; i--) {{
                    buf.append(factors[i - 1].toString());
                    if (i > 1)buf.append(",");
                };}
                buf.append(")");
                break;
            default:
                let first: number = 0;
                for(let i: number = 0; i < factors.length; i++) {{
                    let factor: com.vzome.core.algebra.BigRational = factors[i];
                    if (factor.isZero()){
                        ++first;
                        continue;
                    }
                    if (i > first){
                        buf.append(" ");
                    }
                    if (factor.isNegative()){
                        factor = factor.negate();
                        buf.append("-");
                    } else if (i > first){
                        buf.append("+");
                    }
                    if (i === 0)buf.append(factor.toString()); else {
                        if (!factor.isOne()){
                            buf.append(factor.toString());
                            if (format === AbstractAlgebraicField.EXPRESSION_FORMAT)buf.append("*");
                        }
                        const multiplier: string = this['getIrrational$int$int'](i, format);
                        buf.append(multiplier);
                    }
                };}
                if (first === factors.length)buf.append("0");
                break;
            }
        }

        /**
         * 
         * @param {string} val
         * @return {*}
         */
        public parseLegacyNumber(val: string): com.vzome.core.algebra.AlgebraicNumber {
            throw new java.lang.IllegalStateException("This field does not support vZome 2.x files.");
        }

        /**
         * 
         * @param {string} string
         * @param {boolean} isRational
         * @return {*}
         */
        public parseVefNumber(string: string, isRational: boolean): com.vzome.core.algebra.AlgebraicNumber {
            let pairs: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.getOrder() * 2);
            for(let i: number = 1; i < pairs.length; i += 2) {{
                pairs[i] = 1;
            };}
            if ((!isRational) && /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(string, "(") && /* endsWith */((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(string, ")")){
                const tokens: java.util.StringTokenizer = new java.util.StringTokenizer(string.substring(1, string.length - 1), ",");
                const numStack: java.util.Stack<number> = <any>(new java.util.Stack<any>());
                const denomStack: java.util.Stack<number> = <any>(new java.util.Stack<any>());
                while((tokens.hasMoreTokens())) {{
                    if (numStack.size() >= this.getOrder()){
                        throw new java.lang.RuntimeException("VEF format error: \"" + string + "\" has too many factors for " + this.getName() + " field");
                    }
                    const parts: string[] = tokens.nextToken().split("/");
                    numStack.push(javaemul.internal.IntegerHelper.parseInt(parts[0]));
                    denomStack.push((parts.length > 1) ? javaemul.internal.IntegerHelper.parseInt(parts[1]) : 1);
                }};
                let i: number = 0;
                while((!numStack.empty())) {{
                    pairs[i++] = numStack.pop();
                    pairs[i++] = denomStack.pop();
                }};
                if (i === 4 && this.getOrder() > 2){
                    pairs = this.convertGoldenNumberPairs([pairs[0], pairs[1], pairs[2], pairs[3]]);
                }
            } else {
                const parts: string[] = string.split("/");
                pairs[0] = javaemul.internal.IntegerHelper.parseInt(parts[0]);
                pairs[1] = (parts.length > 1) ? javaemul.internal.IntegerHelper.parseInt(parts[1]) : 1;
            }
            return this.numberFactory.createAlgebraicNumberFromPairs(this, pairs);
        }

        public parseNumber$java_lang_String(nums: string): com.vzome.core.algebra.AlgebraicNumber {
            const tokens: java.util.StringTokenizer = new java.util.StringTokenizer(nums, " ");
            return this.parseNumber$java_util_StringTokenizer(tokens);
        }

        /**
         * 
         * @param {string} nums
         * @return {*}
         */
        public parseNumber(nums?: any): com.vzome.core.algebra.AlgebraicNumber {
            if (((typeof nums === 'string') || nums === null)) {
                return <any>this.parseNumber$java_lang_String(nums);
            } else if (((nums != null && nums instanceof <any>java.util.StringTokenizer) || nums === null)) {
                return <any>this.parseNumber$java_util_StringTokenizer(nums);
            } else throw new Error('invalid overload');
        }

        /*private*/ parseNumber$java_util_StringTokenizer(tokens: java.util.StringTokenizer): com.vzome.core.algebra.AlgebraicNumber {
            const order: number = this.getOrder();
            const pairs: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(order * 2);
            for(let i: number = 0; i < order; i++) {{
                const digit: string = tokens.nextToken();
                const parts: string[] = digit.split("/");
                pairs[i * 2] = javaemul.internal.LongHelper.parseLong(parts[0]);
                if (parts.length > 1)pairs[i * 2 + 1] = javaemul.internal.LongHelper.parseLong(parts[1]); else pairs[i * 2 + 1] = 1;
            };}
            return this.numberFactory.createAlgebraicNumberFromPairs(this, pairs);
        }

        /**
         * 
         * @param {string} nums
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public parseVector(nums: string): com.vzome.core.algebra.AlgebraicVector {
            const tokens: java.util.StringTokenizer = new java.util.StringTokenizer(nums, " ");
            const numToks: number = tokens.countTokens();
            if (numToks % this.getOrder() !== 0)throw new java.lang.IllegalStateException("Field order (" + this.getOrder() + ") does not divide token count: " + numToks + ", for \'" + nums + "\'");
            const dims: number = (numToks / this.getOrder()|0);
            const coords: com.vzome.core.algebra.AlgebraicNumber[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(dims);
            for(let i: number = 0; i < dims; i++) {{
                coords[i] = this.parseNumber$java_util_StringTokenizer(tokens);
            };}
            return new com.vzome.core.algebra.AlgebraicVector(coords);
        }

        /**
         * 
         * @param {number} dims
         * @return {com.vzome.core.algebra.AlgebraicMatrix}
         */
        public identityMatrix(dims: number): com.vzome.core.algebra.AlgebraicMatrix {
            const columns: com.vzome.core.algebra.AlgebraicVector[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(dims);
            for(let i: number = 0; i < columns.length; i++) {{
                columns[i] = this.basisVector(dims, i);
            };}
            return new com.vzome.core.algebra.AlgebraicMatrix(columns);
        }

        /**
         * @return {number} the number of independent multipliers in this field.
         * These are the primitive elements of the field.
         * The value should be less than or equal to getNumIrrationals.
         * It will be less whenever the irrationals are dependent.
         * For example, in the field for sqrt(phi), there is only one
         * multiplier, since the other irrational is just the square of that one.
         */
        public getNumMultipliers(): number {
            return this.getNumIrrationals();
        }

        public generateSeries(threshold: number): com.vzome.core.algebra.AlgebraicSeries {
            const multiplier: com.vzome.core.algebra.AlgebraicNumber = this.createPower$int$int(1, this.getNumIrrationals());
            let cover: com.vzome.core.algebra.AlgebraicNumber = this.one();
            let power: number = 0;
            while((cover.evaluate() < threshold)) {{
                cover = cover['times$com_vzome_core_algebra_AlgebraicNumber'](multiplier);
                ++power;
            }};
            return new com.vzome.core.algebra.AlgebraicSeries(this, power);
        }

        public getMathML(factors: com.vzome.core.algebra.BigRational[]): string {
            const buf: java.lang.StringBuffer = new java.lang.StringBuffer();
            let first: number = 0;
            for(let i: number = 0; i < factors.length; i++) {{
                let factor: com.vzome.core.algebra.BigRational = factors[i];
                if (factor.isZero()){
                    ++first;
                    continue;
                }
                if (factor.isNegative()){
                    factor = factor.negate();
                    buf.append("<mo>-</mo>");
                } else if (i > first){
                    buf.append("<mo>+</mo>");
                }
                if (i === 0)buf.append(factor.getMathML()); else {
                    if (!factor.isOne()){
                        buf.append(factor.getMathML());
                    }
                    const multiplier: string = this['getIrrational$int$int'](i, AbstractAlgebraicField.DEFAULT_FORMAT);
                    buf.append("<mi>");
                    buf.append(multiplier);
                    buf.append("</mi>");
                }
            };}
            if (first === factors.length)return "<mn>0</mn>"; else if (factors.length - first > 1)return "<mrow>" + buf.toString() + "</mrow>"; else return buf.toString();
        }

        /**
         * 
         * @param {string} script
         * @param {string} language
         * @param {com.vzome.core.construction.Point} offset
         * @param {*} symmetry
         * @param {*} effects
         */
        public interpretScript(script: string, language: string, offset: com.vzome.core.construction.Point, symmetry: com.vzome.core.math.symmetry.Symmetry, effects: com.vzome.core.construction.ConstructionChanges) {
            throw new Error("Scripts are only supported in the golden field.");
        }

        public abstract getIrrational(i?: any, format?: any): any;    }
    AbstractAlgebraicField["__class"] = "com.vzome.core.algebra.AbstractAlgebraicField";
    AbstractAlgebraicField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];


}
namespace com.vzome.core.algebra {
    export class VefVectorExporter {
        output: java.io.PrintWriter;

        field: com.vzome.core.algebra.AlgebraicField;

        sortedVertexList: java.util.ArrayList<com.vzome.core.algebra.AlgebraicVector>;

        /*private*/ vertices: java.util.SortedSet<com.vzome.core.algebra.AlgebraicVector>;

        /*private*/ ballLocations: java.util.SortedSet<com.vzome.core.algebra.AlgebraicVector>;

        strutEnds: java.util.SortedSet<com.vzome.core.algebra.AlgebraicVector[]>;

        panelVertices: java.util.SortedSet<com.vzome.core.algebra.AlgebraicVector[]>;

        scale: com.vzome.core.algebra.AlgebraicNumber;

        includeOffset: boolean;

        exportedOffset: com.vzome.core.algebra.AlgebraicVector;

        strTip: string;

        public constructor(writer?: any, field?: any, scale?: any, withOffset?: any) {
            if (((writer != null && writer instanceof <any>java.io.Writer) || writer === null) && ((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((scale != null && (scale.constructor != null && scale.constructor["__interfaces"] != null && scale.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || scale === null) && ((typeof withOffset === 'boolean') || withOffset === null)) {
                let __args = arguments;
                if (this.output === undefined) { this.output = null; } 
                if (this.field === undefined) { this.field = null; } 
                if (this.strutEnds === undefined) { this.strutEnds = null; } 
                if (this.panelVertices === undefined) { this.panelVertices = null; } 
                if (this.scale === undefined) { this.scale = null; } 
                if (this.includeOffset === undefined) { this.includeOffset = false; } 
                this.sortedVertexList = null;
                this.vertices = <any>(new java.util.TreeSet<any>());
                this.ballLocations = <any>(new java.util.TreeSet<any>());
                this.exportedOffset = null;
                this.strTip = "tip";
                this.strMiddle = "middle";
                this.includeOffset = withOffset;
                this.scale = scale;
                this.output = new java.io.PrintWriter(writer);
                this.field = field;
                const arrayComparator: com.vzome.core.generic.ArrayComparator<com.vzome.core.algebra.AlgebraicVector> = <any>(new com.vzome.core.generic.ArrayComparator<any>());
                this.strutEnds = <any>(new java.util.TreeSet<any>(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0, arg1) =>  (funcInst['compare'] ? funcInst['compare'] : funcInst) .call(funcInst, arg0, arg1)})(arrayComparator.getContentFirstArrayComparator()))));
                this.panelVertices = <any>(new java.util.TreeSet<any>(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0, arg1) =>  (funcInst['compare'] ? funcInst['compare'] : funcInst) .call(funcInst, arg0, arg1)})(arrayComparator.getLengthFirstArrayComparator()))));
            } else if (((writer != null && writer instanceof <any>java.io.Writer) || writer === null) && ((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && scale === undefined && withOffset === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let scale: any = null;
                    let withOffset: any = false;
                    if (this.output === undefined) { this.output = null; } 
                    if (this.field === undefined) { this.field = null; } 
                    if (this.strutEnds === undefined) { this.strutEnds = null; } 
                    if (this.panelVertices === undefined) { this.panelVertices = null; } 
                    if (this.scale === undefined) { this.scale = null; } 
                    if (this.includeOffset === undefined) { this.includeOffset = false; } 
                    this.sortedVertexList = null;
                    this.vertices = <any>(new java.util.TreeSet<any>());
                    this.ballLocations = <any>(new java.util.TreeSet<any>());
                    this.exportedOffset = null;
                    this.strTip = "tip";
                    this.strMiddle = "middle";
                    this.includeOffset = withOffset;
                    this.scale = scale;
                    this.output = new java.io.PrintWriter(writer);
                    this.field = field;
                    const arrayComparator: com.vzome.core.generic.ArrayComparator<com.vzome.core.algebra.AlgebraicVector> = <any>(new com.vzome.core.generic.ArrayComparator<any>());
                    this.strutEnds = <any>(new java.util.TreeSet<any>(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0, arg1) =>  (funcInst['compare'] ? funcInst['compare'] : funcInst) .call(funcInst, arg0, arg1)})(arrayComparator.getContentFirstArrayComparator()))));
                    this.panelVertices = <any>(new java.util.TreeSet<any>(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0, arg1) =>  (funcInst['compare'] ? funcInst['compare'] : funcInst) .call(funcInst, arg0, arg1)})(arrayComparator.getLengthFirstArrayComparator()))));
                }
            } else throw new Error('invalid overload');
        }

        public exportPoint(pt: com.vzome.core.algebra.AlgebraicVector) {
            this.vertices.add(pt);
            this.ballLocations.add(pt);
            if (this.includeOffset){
                this.exportedOffset = pt;
            }
        }

        public exportSegment(start: com.vzome.core.algebra.AlgebraicVector, end: com.vzome.core.algebra.AlgebraicVector) {
            const ends: com.vzome.core.algebra.AlgebraicVector[] = [start, end];
            this.vertices.add(ends[0]);
            this.vertices.add(ends[1]);
            this.strutEnds.add(ends);
        }

        public exportPolygon(corners: java.util.List<com.vzome.core.algebra.AlgebraicVector>) {
            this.vertices.addAll(corners);
            const cornerArray: com.vzome.core.algebra.AlgebraicVector[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(corners.size());
            corners.toArray<any>(cornerArray);
            this.panelVertices.add(cornerArray);
        }

        strMiddle: string;

        /**
         * @param {java.lang.StringBuffer} buffer = Don't assume that buffer starts out empty. Results will be appended.
         * @param {com.vzome.core.algebra.AlgebraicVector} vector = Value to be converted to a zero-padded 4D String which will be
         * prefixed and/or padded with field specific zeroes
         * depending on the number of dimensions in vector as follows:
         * 1D : 0 X 0 0
         * 2D : 0 X Y 0
         * 3D : 0 X Y Z
         * 4D : W X Y Z
         * @param {*} scale
         */
        public static appendVector(buffer: java.lang.StringBuffer, vector: com.vzome.core.algebra.AlgebraicVector, scale: com.vzome.core.algebra.AlgebraicNumber) {
            const zeroString: string = vector.getField().zero().toString(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT);
            const dims: number = vector.dimension();
            if (dims < 4){
                buffer.append(zeroString);
                buffer.append(" ");
            }
            if (scale != null)vector = vector.scale(scale);
            vector.getVectorExpression$java_lang_StringBuffer$int(buffer, com.vzome.core.algebra.AlgebraicField.VEF_FORMAT);
            for(let d: number = dims + 1; d < 4; d++) {{
                buffer.append(" ");
                buffer.append(zeroString);
            };}
        }

        public static exportPolyhedron(polyhedron: com.vzome.core.math.Polyhedron): string {
            const out: java.io.StringWriter = new java.io.StringWriter();
            const exporter: VefVectorExporter = new VefVectorExporter(out, polyhedron.getField());
            const vertexList: java.util.List<com.vzome.core.algebra.AlgebraicVector> = polyhedron.getVertexList();
            for(let index=polyhedron.getFaceSet().iterator();index.hasNext();) {
                let face = index.next();
                {
                    const vertices: java.util.List<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>(face.size()));
                    for(let i: number = 0; i < face.size(); i++) {{
                        const vertexIndex: number = face.getVertex(i);
                        vertices.add(vertexList.get(vertexIndex));
                    };}
                    exporter.exportPolygon(vertices);
                }
            }
            exporter.finishExport();
            return out.toString();
        }

        public finishExport() {
            this.sortedVertexList = <any>(new java.util.ArrayList<any>(this.vertices));
            this.vertices = null;
            const version: number = (this.exportedOffset == null) ? com.vzome.core.math.VefParser.VERSION_EXPLICIT_BALLS : com.vzome.core.math.VefParser.VERSION_EXPLICIT_OFFSET;
            this.output.println$java_lang_Object("vZome VEF " + version + " field " + this.field.getName());
            if (this.exportedOffset != null){
                const buf: java.lang.StringBuffer = new java.lang.StringBuffer();
                buf.append("\noffset ");
                VefVectorExporter.appendVector(buf, this.exportedOffset.negate(), null);
                buf.append("\n");
                this.output.println$java_lang_Object(buf.toString());
            }
            this.output.println$java_lang_Object("\n" + this.sortedVertexList.size());
            {
                const buf: java.lang.StringBuffer = new java.lang.StringBuffer();
                for(let index=this.sortedVertexList.iterator();index.hasNext();) {
                    let vector = index.next();
                    {
                        VefVectorExporter.appendVector(buf, vector, this.scale);
                        buf.append("\n");
                    }
                }
                buf.append("\n");
                this.output.println$java_lang_Object(buf.toString());
            };
            this.output.println$java_lang_Object("\n" + this.strutEnds.size());
            for(let index=this.strutEnds.iterator();index.hasNext();) {
                let ends = index.next();
                {
                    this.output.print(this.sortedVertexList.indexOf(ends[0]) + " ");
                    this.output.println$java_lang_Object(this.sortedVertexList.indexOf(ends[1]));
                }
            }
            this.output.println$java_lang_Object("\n");
            this.output.println$java_lang_Object("\n" + this.panelVertices.size());
            for(let index=this.panelVertices.iterator();index.hasNext();) {
                let corners = index.next();
                {
                    this.output.print(corners.length + "  ");
                    for(let index = 0; index < corners.length; index++) {
                        let corner = corners[index];
                        {
                            this.output.print(this.sortedVertexList.indexOf(corner) + " ");
                        }
                    }
                    this.output.println$();
                }
            }
            this.output.println$java_lang_Object("\n");
            this.output.println$java_lang_Object("\n" + this.ballLocations.size());
            let i: number = 0;
            for(let index=this.ballLocations.iterator();index.hasNext();) {
                let ball = index.next();
                {
                    this.output.print(this.sortedVertexList.indexOf(ball) + " ");
                    if (++i % 10 === 0){
                        this.output.println$();
                    }
                }
            }
            this.output.println$java_lang_Object("\n");
            this.output.flush();
        }
    }
    VefVectorExporter["__class"] = "com.vzome.core.algebra.VefVectorExporter";

}
namespace com.vzome.core.algebra {
    export class Fields {
        public static rows(matrix: any[][]): number {
            return matrix.length;
        }

        public static columns(matrix: any[][]): number {
            return matrix[0].length;
        }

        public static matrixMultiplication<T extends Fields.Element<T>>(left: T[][], right: T[][], product: T[][]) {
            if (Fields.rows(right) !== Fields.columns(left))throw new java.lang.IllegalArgumentException("matrices cannot be multiplied");
            if (Fields.rows(product) !== Fields.rows(left))throw new java.lang.IllegalArgumentException("product matrix has wrong number of rows");
            if (Fields.columns(right) !== Fields.columns(product))throw new java.lang.IllegalArgumentException("product matrix has wrong number of columns");
            for(let i: number = 0; i < Fields.rows(product); i++) {{
                for(let j: number = 0; j < Fields.columns(product); j++) {{
                    let sum: T = null;
                    for(let j2: number = 0; j2 < Fields.columns(left); j2++) {{
                        const prod: T = left[i][j2].times(right[j2][j]);
                        if (sum == null)sum = prod; else sum = sum.plus(prod);
                    };}
                    product[i][j] = sum;
                };}
            };}
        }

        public static gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A<T extends Fields.Element<T>>(matrix: T[][]): number {
            return Fields.gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A$com_vzome_core_algebra_Fields_Element_A_A(matrix, matrix);
        }

        public static gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A$com_vzome_core_algebra_Fields_Element_A_A<T extends Fields.Element<T>>(immutableMatrix: T[][], adjoined: T[][]): number {
            const nRows: number = Fields.rows(immutableMatrix);
            const matrix: any[][] = Fields.copyOf<any>(immutableMatrix);
            let rank: number = 0;
            for(let col: number = 0; col < Fields.columns(matrix); col++) {{
                let pivotRow: number = -1;
                for(let row: number = rank; row < nRows; row++) {{
                    const element: T = <T><any>matrix[row][col];
                    if (!element.isZero()){
                        pivotRow = row;
                        break;
                    }
                };}
                if (pivotRow >= 0){
                    if (pivotRow !== rank){
                        Fields.swap(matrix, rank, pivotRow);
                        Fields.swap(adjoined, rank, pivotRow);
                        pivotRow = rank;
                    }
                    let scalar: T = <T><any>matrix[pivotRow][col];
                    if (!scalar.isOne()){
                        scalar = scalar.reciprocal();
                        Fields.scale<any>(<T[]>matrix[pivotRow], scalar);
                        Fields.scale<any>(adjoined[pivotRow], scalar);
                    }
                    for(let row: number = 0; row < nRows; row++) {{
                        if (row !== pivotRow){
                            scalar = (<T><any>matrix[row][col]);
                            if (!scalar.isZero()){
                                scalar = scalar.negate();
                                Fields.pivot<any>(matrix, row, scalar, pivotRow);
                                Fields.pivot<any>(adjoined, row, scalar, pivotRow);
                            }
                        }
                    };}
                    rank++;
                }
            };}
            return rank;
        }

        public static gaussJordanReduction<T0 = any>(immutableMatrix?: any, adjoined?: any): number {
            if (((immutableMatrix != null && immutableMatrix instanceof <any>Array && (immutableMatrix.length == 0 || immutableMatrix[0] == null ||immutableMatrix[0] instanceof Array)) || immutableMatrix === null) && ((adjoined != null && adjoined instanceof <any>Array && (adjoined.length == 0 || adjoined[0] == null ||adjoined[0] instanceof Array)) || adjoined === null)) {
                return <any>com.vzome.core.algebra.Fields.gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A$com_vzome_core_algebra_Fields_Element_A_A(immutableMatrix, adjoined);
            } else if (((immutableMatrix != null && immutableMatrix instanceof <any>Array && (immutableMatrix.length == 0 || immutableMatrix[0] == null ||immutableMatrix[0] instanceof Array)) || immutableMatrix === null) && adjoined === undefined) {
                return <any>com.vzome.core.algebra.Fields.gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A(immutableMatrix);
            } else throw new Error('invalid overload');
        }

        static copyOf<T extends Fields.Element<T>>(matrix: T[][]): any[][] {
            const nRows: number = Fields.rows(matrix);
            const nCols: number = Fields.columns(matrix);
            const copy: any[][] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(nRows);
            for(let i: number = 0; i < nRows; i++) {{
                copy[i] = java.util.Arrays.copyOf<any>(matrix[i], nCols);
            };}
            return copy;
        }

        /**
         * 
         * @param {java.lang.Object[]} array of elements to be swapped
         * @param {number} r index of the first element to be swapped
         * @param {number} s index of the second element to be swapped
         * <br/>
         * Note that since Java implements a multi-dimensional array as an array of arrays,
         * the {@code array} parameter can be an {@code Object[][]} in which case
         * entire rows are swapped rather than an element at a time.
         * Besides being more efficient at run time, this also means
         * that rows of multi-dimensional arrays do not necessarily have to be the same length.
         * @private
         */
        static swap(array: any[], r: number, s: number) {
            const temp: any = array[r];
            array[r] = array[s];
            array[s] = temp;
        }

        static scale<T extends Fields.Element<T>>(array: T[], scalar: T) {
            for(let col: number = 0; col < array.length; col++) {{
                array[col] = scalar.times(array[col]);
            };}
        }

        static pivot<T extends Fields.Element<T>>(matrix: any[][], row: number, scalar: T, rank: number) {
            for(let col: number = 0; col < Fields.columns(matrix); col++) {{
                matrix[row][col] = (<T><any>matrix[row][col]).plus((<T><any>matrix[rank][col]).times(scalar));
            };}
        }
    }
    Fields["__class"] = "com.vzome.core.algebra.Fields";


    export namespace Fields {

        export interface RationalElement<R, T> extends Fields.Element<T> {
            getNumerator(): R;

            getDenominator(): R;

            dividedBy(that: T): T;
        }

        export interface Element<T> {
            times(that: T): T;

            timesInt(that: number): T;

            plus(that: T): T;

            minus(that: T): T;

            reciprocal(): T;

            negate(): T;

            isZero(): boolean;

            isOne(): boolean;

            evaluate(): number;

            getMathML(): string;
        }
    }

}
namespace com.vzome.core.algebra {
    /**
     * Immutable Abstract Data Type for arbitrarily large rational numbers.
     * @class
     */
    export interface BigRational extends com.vzome.core.algebra.Fields.Element<BigRational> {
        isNegative(): boolean;
    }
}
namespace com.vzome.core.algebra {
    export interface AlgebraicNumberFactory {
        zero(): com.vzome.core.algebra.BigRational;

        one(): com.vzome.core.algebra.BigRational;

        createBigRational(numerator: number, denominator: number): com.vzome.core.algebra.BigRational;

        createAlgebraicNumber(field: com.vzome.core.algebra.AlgebraicField, numerators: number[], divisor: number): com.vzome.core.algebra.AlgebraicNumber;

        createAlgebraicNumberFromTD(field: com.vzome.core.algebra.AlgebraicField, trailingDivisorForm: number[]): com.vzome.core.algebra.AlgebraicNumber;

        createAlgebraicNumberFromPairs(field: com.vzome.core.algebra.AlgebraicField, pairs: number[]): com.vzome.core.algebra.AlgebraicNumber;

        createRational(field: com.vzome.core.algebra.AlgebraicField, numerator: number, denominator: number): com.vzome.core.algebra.AlgebraicNumber;

        isPrime(n: number): boolean;

        nextPrime(n: number): number;
    }
}
namespace com.vzome.core.algebra {
    export interface AlgebraicField {
        getOrder(): number;

        getNumIrrationals(): number;

        /**
         * Returns the label using the specified format for the irrational term with ordinal i. <br>
         * i=0 refers to the rational term.
         * @param {number} i
         * @param {number} format must be either {@code DEFAULT_FORMAT = 0} or
         * {@code EXPRESSION_FORMAT = 1}
         * @return
         * @return {string}
         */
        getIrrational(i?: any, format?: any): string;

        nearestAlgebraicVector(target: com.vzome.core.math.RealVector): com.vzome.core.algebra.AlgebraicVector;

        getName(): string;

        /**
         * Generates an AlgebraicNumber from a "trailing divisor" int array representation.
         * @param {int[]} trailingDivisorForm numerators trailed by a common denominator for all numerators
         * @return
         * @return {*}
         */
        createAlgebraicNumberFromTD(trailingDivisorForm: number[]): com.vzome.core.algebra.AlgebraicNumber;

        createAlgebraicNumber(ones?: any, irrat?: any, denominator?: any, scalePower?: any): com.vzome.core.algebra.AlgebraicNumber;

        /**
         * The golden ratio (and thus icosahedral symmetry and related tools)
         * can be generated by some fields even though it's not one of their irrational coefficients.
         * For example, SqrtField(5) and PolygonField(10) can both generate the golden ratio
         * so they can support icosa symmetry and related tools.
         * In some such cases, the resulting AlgebraicNumber
         * may have multiple terms and/or factors other than one.
         * 
         * @return {*} An AlgebraicNumber which evaluates to the golden ratio, or null if not possible in this field.
         */
        getGoldenRatio(): com.vzome.core.algebra.AlgebraicNumber;

        createPower(power?: any, irr?: any): com.vzome.core.algebra.AlgebraicNumber;

        /**
         * @param {number} numerator
         * @param {number} denominator
         * @return {*} AlgebraicNumber
         */
        createRational(numerator?: any, denominator?: any): com.vzome.core.algebra.AlgebraicNumber;

        /**
         * @return {*} The AlgebraicNumber to be use for the Chord Ratio construction in the given field.
         * This method can be used to generalize an AffinePolygon tool and a PolygonalAntiprismSymmetry.
         * This base class returns one, which is the scalar for an affine square and works in any field.
         * Derived classes should override this method if they can be used to generate any other affine polygon.
         */
        getAffineScalar(): com.vzome.core.algebra.AlgebraicNumber;

        /**
         * @param {number} n specifies the ordinal of the term in the AlgebraicNumber which will be set to one.
         * When {@code n == 0}, the result is the same as {@code createRational(1)}.
         * When {@code n == 1}, the result is the same as {@code createPower(1)}.
         * When {@code n < 0}, the result will be {@code zero()}.
         * When {@code n >= getOrder()}, an IndexOutOfBoundsException will be thrown.
         * @return {*} an AlgebraicNumber with the factor specified by {@code n} set to one.
         */
        getUnitTerm(n: number): com.vzome.core.algebra.AlgebraicNumber;

        /**
         * Drop one coordinate from the 4D vector. If wFirst (the usual), then drop
         * the first coordinate, taking the "imaginary part" of the vector. If
         * !wFirst (for old VEF import, etc.), drop the last coordinate.
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} source
         * @param {boolean} wFirst
         * @return
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        projectTo3d(source: com.vzome.core.algebra.AlgebraicVector, wFirst: boolean): com.vzome.core.algebra.AlgebraicVector;

        origin(dims: number): com.vzome.core.algebra.AlgebraicVector;

        basisVector(dims: number, axis: number): com.vzome.core.algebra.AlgebraicVector;

        zero(): com.vzome.core.algebra.AlgebraicNumber;

        one(): com.vzome.core.algebra.AlgebraicNumber;

        /**
         * 
         * @param {int[][]} nums is an array of integer arrays: One array of coordinate terms per dimension.
         * Initially, this is designed to simplify migration of order 2 golden directions
         * to new fields of higher order having golden subfields as their first two factors.
         * {@code
         * field.createVector( new int[]  {  0,1,2,3,   4,5,6,7,   8,9,0,1  } );   // older code like this...
         * field.createVector( new int[][]{ {0,1,2,3}, {4,5,6,7}, {8,9,0,1} } );   // should be replaced by this...
         * field.createVector( new int[][]{ {0,1,2,3}, {4,5,6,7}, {8,9    } } );   // ... or even this.
         * }
         * The older code shown in the first example requires an order 2 field.
         * The second example will work with any field of order 2 or greater.
         * This new overload has the advantage that the internal arrays representing the individual dimensions are more clearly delineated and controlled.
         * As shown in the third example, the internal arrays need not be all the same length. Trailing zero terms can be omitted as shown.
         * Inner arrays require an even number of elements since they represent a sequence of numerator/denominator pairs.
         * 
         * createVector is currently limited to int valued vectors, not long, and definitely not BigInteger
         * In most cases, this is adequate, but in the case where it's called by XmlSaveFormat.parseAlgebraicObject(),
         * it seems possible that a value larger than Integer.MAX_VALUE could be saved to the XML which could not subsequently be parsed.
         * TODO: Consider refactoring createVector to use long[][] instead of int[][] if this becomes an issue.
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector} an AlgebraicVector
         */
        createVector(nums: number[][]): com.vzome.core.algebra.AlgebraicVector;

        /**
         * 
         * @param {int[][]} nums nums is an array of integer arrays: One array of coordinate terms per dimension.
         * Each inner array is in "trailing divisor" form, to represent a rational AlgebraicNumber.
         * If the order of the field is N, each inner array will be of length N+1, with the last
         * element being the divisor.
         * @return
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        createVectorFromTDs(nums: number[][]): com.vzome.core.algebra.AlgebraicVector;

        /**
         * Generates an AlgebraicVector with all AlgebraicNumber terms being integers (having unit denominators).
         * Contrast this with {@code createVector(int[][] nums)} which requires all denominators to be specified.
         * @param {int[][]} nums is a 2 dimensional integer array. The length of nums becomes the number of dimensions in the resulting AlgebraicVector.
         * For example, {@code (new PentagonField()).createIntegerVector( new int[][]{ {0,-1}, {2,3}, {4,5} } ); }
         * generates the 3 dimensional vector (-φ, 2 +3φ, 4 +5φ) having all integer terms.
         * @return {com.vzome.core.algebra.AlgebraicVector} an AlgebraicVector
         */
        createIntegerVector(nums: number[][]): com.vzome.core.algebra.AlgebraicVector;

        /**
         * Create a 3x3 square matrix from integer data.
         * TODO: Generalize this method to create a matrix with dimensions matching the dimensions of the data array
         * Sample input data for an order-4 field:
         * {{{7,5,0,1,-4,5,0,1},{-2,5,0,1,4,5,0,1},{0,1,-8,5,0,1,6,5}},
         * {{-2,5,0,1,4,5,0,1},{7,5,0,1,-4,5,0,1},{0,1,8,5,0,1,-6,5}},
         * {{0,1,-8,5,0,1,6,5},{0,1,8,5,0,1,-6,5},{-9,5,0,1,8,5,0,1}}}
         * @param field
         * @param {int[][][]} data integer coordinates, in row-major order, complete with denominators.
         * @return
         * @return {com.vzome.core.algebra.AlgebraicMatrix}
         */
        createMatrix(data: number[][][]): com.vzome.core.algebra.AlgebraicMatrix;

        parseLegacyNumber(val: string): com.vzome.core.algebra.AlgebraicNumber;

        parseNumber(nums: string): com.vzome.core.algebra.AlgebraicNumber;

        parseVector(nums: string): com.vzome.core.algebra.AlgebraicVector;

        identityMatrix(dims: number): com.vzome.core.algebra.AlgebraicMatrix;

        /**
         * @return {number} the number of independent multipliers in this field.
         * These are the primitive elements of the field.
         * The value should be less than or equal to getNumIrrationals.
         * It will be less whenever the irrationals are dependent.
         * For example, in the field for sqrt(phi), there is only one
         * multiplier, since the other irrational is just the square of that one.
         */
        getNumMultipliers(): number;

        parseVefNumber(string: string, isRational: boolean): com.vzome.core.algebra.AlgebraicNumber;

        scale4dRoots(): boolean;

        doubleFrameVectors(): boolean;

        /**
         * If the field supports the value having the common name specified,
         * this method returns an AlgebraicNumber having that value.
         * Note that the value may not correspond to a unique term in the AlgebraicField (e.g. {"phi" for @code PolygonField(10)}). <br>
         * For example, {@code getNumberByName("phi")}
         * should return the same value as {@code getGoldenRatio()}
         * @param {string} name
         * @return {*} An AlgebraicNumber which evaluates to the specified name, or null if not possible in this field.
         */
        getNumberByName(name: string): com.vzome.core.algebra.AlgebraicNumber;

        supportsSubfield(fieldName: string): boolean;

        interpretScript(script: string, language: string, offset: com.vzome.core.construction.Point, symmetry: com.vzome.core.math.symmetry.Symmetry, effects: com.vzome.core.construction.ConstructionChanges);
    }

    export namespace AlgebraicField {

        export const DEFAULT_FORMAT: number = 0;

        export const EXPRESSION_FORMAT: number = 1;

        export const ZOMIC_FORMAT: number = 2;

        export const VEF_FORMAT: number = 3;

        export function getIrrationals(field: AlgebraicField): string[] {
            const len: number = field.getNumIrrationals();
            const result: string[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(len);
            for(let i: number = 0; i < result.length; i++) {{
                result[i] = field['getIrrational$int'](i + 1);
            };}
            return result;
        }

        export function getMultipliers(field: AlgebraicField): string[] {
            const len: number = field.getNumMultipliers();
            const result: string[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(len);
            for(let i: number = 0; i < result.length; i++) {{
                result[i] = field['getIrrational$int'](i + 1);
            };}
            return result;
        }
    }


    export namespace AlgebraicField {

        export interface Registry {
            getField(name: string): com.vzome.core.algebra.AlgebraicField;
        }
    }

}
namespace com.vzome.core.algebra {
    export class Bivector3d {
        /*private*/ a: com.vzome.core.algebra.AlgebraicNumber;

        /*private*/ b: com.vzome.core.algebra.AlgebraicNumber;

        /*private*/ c: com.vzome.core.algebra.AlgebraicNumber;

        public constructor(a: com.vzome.core.algebra.AlgebraicNumber, b: com.vzome.core.algebra.AlgebraicNumber, c: com.vzome.core.algebra.AlgebraicNumber) {
            if (this.a === undefined) { this.a = null; }
            if (this.b === undefined) { this.b = null; }
            if (this.c === undefined) { this.c = null; }
            this.a = a;
            this.b = b;
            this.c = c;
        }

        /**
         * 
         * @return {number}
         */
        public hashCode(): number {
            const prime: number = 31;
            let result: number = 1;
            result = prime * result + ((this.a == null) ? 0 : /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})(this.a)));
            result = prime * result + ((this.b == null) ? 0 : /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})(this.b)));
            result = prime * result + ((this.c == null) ? 0 : /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})(this.c)));
            return result;
        }

        /**
         * 
         * @param {*} obj
         * @return {boolean}
         */
        public equals(obj: any): boolean {
            if (this === obj){
                return true;
            }
            if (obj == null){
                return false;
            }
            if ((<any>this.constructor) !== (<any>obj.constructor)){
                return false;
            }
            const other: Bivector3d = <Bivector3d>obj;
            if (this.a == null){
                if (other.a != null){
                    return false;
                }
            } else if (!/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(this.a,other.a))){
                return false;
            }
            if (this.b == null){
                if (other.b != null){
                    return false;
                }
            } else if (!/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(this.b,other.b))){
                return false;
            }
            if (this.c == null){
                if (other.c != null){
                    return false;
                }
            } else if (!/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(this.c,other.c))){
                return false;
            }
            return true;
        }

        /**
         * The pseudoscalar is implied in the result.
         * @param {com.vzome.core.algebra.Vector3d} v
         * @return
         * @return {*}
         */
        public outer(v: com.vzome.core.algebra.Vector3d): com.vzome.core.algebra.AlgebraicNumber {
            const a: com.vzome.core.algebra.AlgebraicNumber = this.a['times$com_vzome_core_algebra_AlgebraicNumber'](v.c);
            const b: com.vzome.core.algebra.AlgebraicNumber = this.b['times$com_vzome_core_algebra_AlgebraicNumber'](v.a);
            const c: com.vzome.core.algebra.AlgebraicNumber = this.c['times$com_vzome_core_algebra_AlgebraicNumber'](v.b);
            return a['plus$com_vzome_core_algebra_AlgebraicNumber'](b)['plus$com_vzome_core_algebra_AlgebraicNumber'](c);
        }
    }
    Bivector3d["__class"] = "com.vzome.core.algebra.Bivector3d";

}
namespace com.vzome.core.algebra {
    export class Trivector3dHomogeneous {
        e123: com.vzome.core.algebra.AlgebraicNumber;

        e310: com.vzome.core.algebra.AlgebraicNumber;

        e320: com.vzome.core.algebra.AlgebraicNumber;

        e120: com.vzome.core.algebra.AlgebraicNumber;

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        public constructor(e123: com.vzome.core.algebra.AlgebraicNumber, e310: com.vzome.core.algebra.AlgebraicNumber, e320: com.vzome.core.algebra.AlgebraicNumber, e120: com.vzome.core.algebra.AlgebraicNumber, field: com.vzome.core.algebra.AlgebraicField) {
            if (this.e123 === undefined) { this.e123 = null; }
            if (this.e310 === undefined) { this.e310 = null; }
            if (this.e320 === undefined) { this.e320 = null; }
            if (this.e120 === undefined) { this.e120 = null; }
            if (this.field === undefined) { this.field = null; }
            this.e123 = e123;
            this.e310 = e310;
            this.e320 = e320;
            this.e120 = e120;
            this.field = field;
        }

        public dual(): com.vzome.core.algebra.Vector3dHomogeneous {
            return new com.vzome.core.algebra.Vector3dHomogeneous(this.e320.negate(), this.e310, this.e120, this.e123.negate(), this.field);
        }
    }
    Trivector3dHomogeneous["__class"] = "com.vzome.core.algebra.Trivector3dHomogeneous";

}
namespace com.vzome.core.algebra {
    /**
     * 
     * Immutable representation of an Algebraic Number
     * @class
     */
    export interface AlgebraicNumber extends com.vzome.core.algebra.Fields.Element<AlgebraicNumber>, java.lang.Comparable<AlgebraicNumber> {
        greaterThan(other: AlgebraicNumber): boolean;

        lessThan(other: AlgebraicNumber): boolean;

        greaterThanOrEqualTo(other: AlgebraicNumber): boolean;

        lessThanOrEqualTo(other: AlgebraicNumber): boolean;

        getField(): com.vzome.core.algebra.AlgebraicField;

        /**
         * 
         * @param {number} n is the value to be added
         * @return {*} this + n
         */
        plusInt(n: number): AlgebraicNumber;

        /**
         * 
         * @param {number} num is the numerator of the rational value to be added
         * @param {number} den is the denominator of the rational value to be added
         * @return {*} this + (num / den)
         */
        plusRational(num: number, den: number): AlgebraicNumber;

        /**
         * 
         * @param {*} that is the value to be added
         * @return {*} this + n
         */
        plus(that?: any): any;

        /**
         * 
         * @param {number} n is the value to be multiplied
         * @return {*} this * n
         */
        timesInt(n: number): AlgebraicNumber;

        /**
         * 
         * @param {number} num is the numerator of the rational value to be multiplied
         * @param {number} den is the denominator of the rational value to be multiplied
         * @return {*} this * (num / den)
         */
        timesRational(num: number, den: number): AlgebraicNumber;

        /**
         * 
         * @param {*} that
         * @return {*}
         */
        times(that?: any): any;

        /**
         * 
         * @param {number} n is the value to be subtracted
         * @return {*} this - n
         */
        minusInt(n: number): AlgebraicNumber;

        /**
         * 
         * @param {number} num is the numerator of the rational value to be subtracted
         * @param {number} den is the denominator of the rational value to be subtracted
         * @return {*} this - (num / den)
         */
        minusRational(num: number, den: number): AlgebraicNumber;

        /**
         * 
         * @param {*} that is the value to be subtracted
         * @return {*} this - n
         */
        minus(that?: any): any;

        /**
         * 
         * @param {number} divisor
         * @return {*} this / divisor
         */
        dividedByInt(divisor: number): AlgebraicNumber;

        /**
         * 
         * @param {number} num is the numerator of the divisor
         * @param {number} den is the denominator of the divisor
         * @return {*} this / (num / den)
         */
        dividedByRational(num: number, den: number): AlgebraicNumber;

        dividedBy(that: AlgebraicNumber): AlgebraicNumber;

        evaluate(): number;

        isRational(): boolean;

        /**
         * 
         * @return {boolean}
         */
        isZero(): boolean;

        /**
         * 
         * @return {boolean}
         */
        isOne(): boolean;

        signum(): number;

        /**
         * 
         * @return {*}
         */
        negate(): AlgebraicNumber;

        /**
         * 
         * @return {*}
         */
        reciprocal(): AlgebraicNumber;

        /**
         * 
         * @param {java.lang.StringBuffer} buf
         * @param {number} format must be one of the following values.
         * The result is formatted as follows:
         * <br>
         * {@code DEFAULT_FORMAT    // 4 + 3φ}<br>
         * {@code EXPRESSION_FORMAT // 4 +3*phi}<br>
         * {@code ZOMIC_FORMAT      // 4 3}<br>
         * {@code VEF_FORMAT        // (3,4)}<br>
         */
        getNumberExpression(buf: java.lang.StringBuffer, format: number);

        /**
         * 
         * @param {number} format must be one of the following values.
         * The result is formatted as follows:
         * <br>
         * {@code DEFAULT_FORMAT    // 4 + 3φ}<br>
         * {@code EXPRESSION_FORMAT // 4 +3*phi}<br>
         * {@code ZOMIC_FORMAT      // 4 3}<br>
         * {@code VEF_FORMAT        // (3,4)}
         * @return {string}
         */
        toString(format: number): string;

        toTrailingDivisor(): number[];
    }

    export namespace AlgebraicNumber {

        export class Views {
            constructor() {
            }
        }
        Views["__class"] = "com.vzome.core.algebra.AlgebraicNumber.Views";


        export namespace Views {

            export interface TrailingDivisor {            }

            export interface Rational {            }

            export interface Real {            }
        }

    }

}
namespace com.vzome.core.algebra {
    export class Vector3d {
        a: com.vzome.core.algebra.AlgebraicNumber;

        b: com.vzome.core.algebra.AlgebraicNumber;

        c: com.vzome.core.algebra.AlgebraicNumber;

        public constructor(a?: any, b?: any, c?: any) {
            if (((a != null && (a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || a === null) && ((b != null && (b.constructor != null && b.constructor["__interfaces"] != null && b.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || b === null) && ((c != null && (c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || c === null)) {
                let __args = arguments;
                if (this.a === undefined) { this.a = null; } 
                if (this.b === undefined) { this.b = null; } 
                if (this.c === undefined) { this.c = null; } 
                this.a = a;
                this.b = b;
                this.c = c;
            } else if (((a != null && a instanceof <any>com.vzome.core.algebra.AlgebraicVector) || a === null) && b === undefined && c === undefined) {
                let __args = arguments;
                let v: any = __args[0];
                if (this.a === undefined) { this.a = null; } 
                if (this.b === undefined) { this.b = null; } 
                if (this.c === undefined) { this.c = null; } 
                this.a = v.getComponent(0);
                this.b = v.getComponent(1);
                this.c = v.getComponent(2);
            } else throw new Error('invalid overload');
        }

        public outer(that: Vector3d): com.vzome.core.algebra.Bivector3d {
            const a: com.vzome.core.algebra.AlgebraicNumber = this.a['times$com_vzome_core_algebra_AlgebraicNumber'](that.b)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.b['times$com_vzome_core_algebra_AlgebraicNumber'](that.a));
            const b: com.vzome.core.algebra.AlgebraicNumber = this.b['times$com_vzome_core_algebra_AlgebraicNumber'](that.c)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.c['times$com_vzome_core_algebra_AlgebraicNumber'](that.b));
            const c: com.vzome.core.algebra.AlgebraicNumber = this.c['times$com_vzome_core_algebra_AlgebraicNumber'](that.a)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.a['times$com_vzome_core_algebra_AlgebraicNumber'](that.c));
            return new com.vzome.core.algebra.Bivector3d(a, b, c);
        }
    }
    Vector3d["__class"] = "com.vzome.core.algebra.Vector3d";

}
namespace com.vzome.core.algebra {
    export class Quaternion {
        /**
         * 
         * @return {string}
         */
        public toString(): string {
            return "Quaternion: " + this.vector.toString();
        }

        representation: com.vzome.core.algebra.AlgebraicMatrix;

        transpose: com.vzome.core.algebra.AlgebraicMatrix;

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        /*private*/ vector: com.vzome.core.algebra.AlgebraicVector;

        public constructor(field: com.vzome.core.algebra.AlgebraicField, vector: com.vzome.core.algebra.AlgebraicVector) {
            if (this.representation === undefined) { this.representation = null; }
            if (this.transpose === undefined) { this.transpose = null; }
            if (this.field === undefined) { this.field = null; }
            if (this.vector === undefined) { this.vector = null; }
            this.field = field;
            this.vector = vector;
            let w_offset: number = 0;
            let factor: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long'](0);
            if (vector.dimension() > 3){
                factor = vector.getComponent(0);
                w_offset = 1;
            }
            this.representation = field.identityMatrix(4).timesScalar(factor);
            factor = vector.getComponent(0 + w_offset);
            this.representation.setElement(1, 0, factor);
            this.representation.setElement(3, 2, factor);
            factor = factor.negate();
            this.representation.setElement(0, 1, factor);
            this.representation.setElement(2, 3, factor);
            factor = vector.getComponent(1 + w_offset);
            this.representation.setElement(1, 3, factor);
            this.representation.setElement(2, 0, factor);
            factor = factor.negate();
            this.representation.setElement(3, 1, factor);
            this.representation.setElement(0, 2, factor);
            factor = vector.getComponent(2 + w_offset);
            this.representation.setElement(3, 0, factor);
            this.representation.setElement(2, 1, factor);
            factor = factor.negate();
            this.representation.setElement(1, 2, factor);
            this.representation.setElement(0, 3, factor);
            if (w_offset === 1)factor = vector.getComponent(0); else factor = field['createRational$long'](0);
            this.transpose = field.identityMatrix(4).timesScalar(factor);
            factor = vector.getComponent(0 + w_offset);
            this.transpose.setElement(0, 1, factor);
            this.transpose.setElement(2, 3, factor);
            factor = factor.negate();
            this.transpose.setElement(1, 0, factor);
            this.transpose.setElement(3, 2, factor);
            factor = vector.getComponent(1 + w_offset);
            this.transpose.setElement(3, 1, factor);
            this.transpose.setElement(0, 2, factor);
            factor = factor.negate();
            this.transpose.setElement(1, 3, factor);
            this.transpose.setElement(2, 0, factor);
            factor = vector.getComponent(2 + w_offset);
            this.transpose.setElement(1, 2, factor);
            this.transpose.setElement(0, 3, factor);
            factor = factor.negate();
            this.transpose.setElement(3, 0, factor);
            this.transpose.setElement(2, 1, factor);
        }

        public getVector(): com.vzome.core.algebra.AlgebraicVector {
            return this.vector;
        }

        /*private*/ conjugate(q: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            const result: com.vzome.core.algebra.AlgebraicVector = this.field.origin(4);
            result.setComponent(3, q.getComponent(3).negate());
            result.setComponent(1, q.getComponent(1).negate());
            result.setComponent(2, q.getComponent(2).negate());
            result.setComponent(0, q.getComponent(0));
            return result;
        }

        public reflect(v: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            let reflection: com.vzome.core.algebra.AlgebraicVector = this.rightMultiply(this.conjugate(v));
            reflection = this.leftMultiply(reflection);
            return reflection.negate();
        }

        /**
         * Compute the product this * q.
         * @param {com.vzome.core.algebra.AlgebraicVector} q
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public rightMultiply(q: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            return this.representation.timesColumn(q);
        }

        /**
         * Compute the product q*this.
         * This is computed using the identities:
         * 
         * conjugate( q*this ) == conjugate( this ) * conjugate( q )
         * 
         * q * this == conjugate( conjugate( this ) * conjugate( q ) )
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} q
         * @return
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public leftMultiply(q: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            let result: com.vzome.core.algebra.AlgebraicVector = this.conjugate(q);
            result = this.transpose.timesColumn(result);
            return this.conjugate(result);
        }
    }
    Quaternion["__class"] = "com.vzome.core.algebra.Quaternion";

}
namespace com.vzome.xml {
    export class DomUtils {
        public static addAttribute(elem: org.w3c.dom.Element, name: string, value: string) {
            elem.setAttribute(name, value);
        }

        public static getFirstChildElement$org_w3c_dom_Element$java_lang_String(elem: org.w3c.dom.Element, name: string): org.w3c.dom.Element {
            const elems: org.w3c.dom.NodeList = elem.getElementsByTagName(name);
            return <org.w3c.dom.Element><any>elems.item(0);
        }

        public static getFirstChildElement(elem?: any, name?: any): org.w3c.dom.Element {
            if (((elem != null && (elem.constructor != null && elem.constructor["__interfaces"] != null && elem.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || elem === null) && ((typeof name === 'string') || name === null)) {
                return <any>com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element$java_lang_String(elem, name);
            } else if (((elem != null && (elem.constructor != null && elem.constructor["__interfaces"] != null && elem.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || elem === null) && name === undefined) {
                return <any>com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element(elem);
            } else throw new Error('invalid overload');
        }

        public static preserveSpace(contentElem: org.w3c.dom.Element) {
            contentElem.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
        }

        public static getFirstChildElement$org_w3c_dom_Element(parent: org.w3c.dom.Element): org.w3c.dom.Element {
            const children: org.w3c.dom.NodeList = parent.getChildNodes();
            if (children.getLength() === 0)return null;
            for(let k: number = 0; k < children.getLength(); k++) {{
                const kid: org.w3c.dom.Node = children.item(k);
                if (kid != null && (kid.constructor != null && kid.constructor["__interfaces"] != null && kid.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)){
                    return <org.w3c.dom.Element><any>kid;
                }
            };}
            return null;
        }

        public static getChild(parent: org.w3c.dom.Element, i: number): org.w3c.dom.Element {
            const children: org.w3c.dom.NodeList = parent.getChildNodes();
            if (children.getLength() === 0)return null;
            let count: number = 0;
            for(let k: number = 0; k < children.getLength(); k++) {{
                const kid: org.w3c.dom.Node = children.item(k);
                if (kid != null && (kid.constructor != null && kid.constructor["__interfaces"] != null && kid.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)){
                    if (count === i)return <org.w3c.dom.Element><any>kid; else ++count;
                }
            };}
            return null;
        }

        /**
         * This is required for JSweet, which ignores the radix in Integer.toString( i, 2 )
         * @param {number} i
         * @return
         * @return {string}
         */
        public static byteToBinary(i: number): string {
            let result: string = "";
            result += ((i / 8|0) === 1) ? "1" : "0";
            i = i % 8;
            result += ((i / 4|0) === 1) ? "1" : "0";
            i = i % 4;
            result += ((i / 2|0) === 1) ? "1" : "0";
            i = i % 2;
            result += (i === 1) ? "1" : "0";
            return result;
        }
    }
    DomUtils["__class"] = "com.vzome.xml.DomUtils";

}
namespace com.vzome.xml {
    export class LocationData {
        public static LOCATION_DATA_KEY: string = "locationDataKey";

        /*private*/ systemId: string;

        /*private*/ startLine: number;

        /*private*/ startColumn: number;

        /*private*/ endLine: number;

        /*private*/ endColumn: number;

        public constructor(systemId: string, startLine: number, startColumn: number, endLine: number, endColumn: number) {
            if (this.systemId === undefined) { this.systemId = null; }
            if (this.startLine === undefined) { this.startLine = 0; }
            if (this.startColumn === undefined) { this.startColumn = 0; }
            if (this.endLine === undefined) { this.endLine = 0; }
            if (this.endColumn === undefined) { this.endColumn = 0; }
            this.systemId = systemId;
            this.startLine = startLine;
            this.startColumn = startColumn;
            this.endLine = endLine;
            this.endColumn = endColumn;
        }

        public getSystemId(): string {
            return this.systemId;
        }

        public getStartLine(): number {
            return this.startLine;
        }

        public getStartColumn(): number {
            return this.startColumn;
        }

        public getEndLine(): number {
            return this.endLine;
        }

        public getEndColumn(): number {
            return this.endColumn;
        }

        /**
         * 
         * @return {string}
         */
        public toString(): string {
            return this.getSystemId() + "[line " + this.startLine + ":" + this.startColumn + " to line " + this.endLine + ":" + this.endColumn + "]";
        }
    }
    LocationData["__class"] = "com.vzome.xml.LocationData";

}
namespace com.vzome.xml {
    export class ResourceLoader {
        static RESOURCE_LOADER: ResourceLoader; public static RESOURCE_LOADER_$LI$(): ResourceLoader { if (ResourceLoader.RESOURCE_LOADER == null) { ResourceLoader.RESOURCE_LOADER = new ResourceLoader(); }  return ResourceLoader.RESOURCE_LOADER; }

        static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (ResourceLoader.logger == null) { ResourceLoader.logger = java.util.logging.Logger.getLogger("com.vzome.xml.ResourceLoader"); }  return ResourceLoader.logger; }

        public static setResourceLoader(loader: ResourceLoader) {
            ResourceLoader.RESOURCE_LOADER = loader;
        }

        public static loadStringResource(path: string): string {
            return ResourceLoader.RESOURCE_LOADER_$LI$().loadTextResource(path);
        }

        public loadTextResource(path: string): string {
            try {
                const input: java.io.InputStream = ResourceLoader.getClassLoader().getResourceAsStream(path);
                if (input == null)return null;
                const out: java.io.ByteArrayOutputStream = new java.io.ByteArrayOutputStream();
                const buf: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(1024);
                let num: number;
                while(((num = input.read(buf, 0, 1024)) > 0)) {out.write(buf, 0, num)};
                input.close();
                return <string>new String(out.toByteArray());
            } catch(e) {
                if (ResourceLoader.logger_$LI$().isLoggable(java.util.logging.Level.FINE))ResourceLoader.logger_$LI$().fine("problem loading resource: " + path);
                return null;
            }
        }
    }
    ResourceLoader["__class"] = "com.vzome.xml.ResourceLoader";

}
namespace com.vzome.api {
    export interface Tool {
        apply(selectInputs: boolean, deleteInputs: boolean, createOutputs: boolean, selectOutputs: boolean, copyColors: boolean);

        selectParameters();

        isPredefined(): boolean;

        getId(): string;

        getCategory(): string;

        getLabel(): string;

        setLabel(label: string);

        isSelectInputs(): boolean;

        isDeleteInputs(): boolean;

        isCopyColors(): boolean;

        setInputBehaviors(selectInputs: boolean, deleteInputs: boolean);

        setCopyColors(value: boolean);

        isHidden(): boolean;

        setHidden(hidden: boolean);
    }

    export namespace Tool {

        export enum Kind {
            SYMMETRY, TRANSFORM, LINEAR_MAP
        }

        export interface Factory {
            addListener(listener: java.beans.PropertyChangeListener);

            createTool(): com.vzome.api.Tool;

            isEnabled(): boolean;

            getToolTip(): string;

            getLabel(): string;

            getId(): string;
        }

        export interface Source {
            getPredefinedTool(id: string): com.vzome.api.Tool;
        }
    }

}
namespace com.vzome.desktop.controller {
    export interface AnimationController {
        getImageSize(): number;

        finished(): boolean;

        rotate();
    }
}
namespace com.vzome.desktop.controller {
    export class SymmetrySnapper implements com.vzome.desktop.controller.OrbitSnapper {
        /*private*/ orbitSet: com.vzome.core.math.symmetry.OrbitSet;

        /*private*/ embedding: com.vzome.core.math.symmetry.Embedding;

        public constructor(orbitSet: com.vzome.core.math.symmetry.OrbitSet) {
            if (this.orbitSet === undefined) { this.orbitSet = null; }
            if (this.embedding === undefined) { this.embedding = null; }
            this.orbitSet = orbitSet;
            this.embedding = orbitSet.getSymmetry();
        }

        /**
         * 
         * @param {com.vzome.core.math.RealVector} zIn
         * @return {com.vzome.core.math.RealVector}
         */
        public snapZ(zIn: com.vzome.core.math.RealVector): com.vzome.core.math.RealVector {
            const lookZone: com.vzome.core.math.symmetry.Axis = this.orbitSet.getAxis(zIn);
            if (lookZone == null)return zIn;
            return this.embedding.embedInR3(lookZone.normal());
        }

        /**
         * 
         * @param {com.vzome.core.math.RealVector} zOut
         * @param {com.vzome.core.math.RealVector} yIn
         * @return {com.vzome.core.math.RealVector}
         */
        public snapY(zOut: com.vzome.core.math.RealVector, yIn: com.vzome.core.math.RealVector): com.vzome.core.math.RealVector {
            const upZone: com.vzome.core.math.symmetry.Axis = this.orbitSet.getAxis(yIn);
            if (upZone == null)return yIn;
            yIn = this.embedding.embedInR3(upZone.normal());
            const left: com.vzome.core.math.RealVector = zOut.cross(yIn);
            return left.cross(zOut);
        }
    }
    SymmetrySnapper["__class"] = "com.vzome.desktop.controller.SymmetrySnapper";
    SymmetrySnapper["__interfaces"] = ["com.vzome.desktop.controller.OrbitSnapper"];


}
namespace com.vzome.desktop.controller {
    export class DefaultController implements com.vzome.desktop.api.Controller {
        /*private*/ pcs: java.beans.PropertyChangeSupport;

        mErrors: Controller.ErrorChannel;

        mNextController: DefaultController;

        /*private*/ subcontrollers: java.util.Map<string, com.vzome.desktop.api.Controller>;

        /*private*/ name: string;

        static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (DefaultController.logger == null) { DefaultController.logger = java.util.logging.Logger.getLogger("org.vorthmann.zome.controller"); }  return DefaultController.logger; }

        properggties(): java.beans.PropertyChangeSupport {
            return this.pcs;
        }

        /**
         * 
         * @param {*} source
         * @param {string} action
         */
        public actionPerformed(source: any, action: string) {
            try {
                if (DefaultController.logger_$LI$().isLoggable(java.util.logging.Level.FINE))DefaultController.logger_$LI$().fine("ACTION: " + this.getPath() + "||" + action);
                this.doAction(action);
            } catch(ex) {
                console.error(ex.message, ex);
                this.mErrors.reportError(com.vzome.desktop.api.Controller.UNKNOWN_ERROR_CODE, [ex]);
            }
        }

        /**
         * This is only overridden or called in Javascript code, in vZome Online.
         * @param {*} source
         * @param {string} action
         * @param {java.util.Properties} params
         */
        public paramActionPerformed(source: any, action: string, params: java.util.Properties) {
            try {
                if (DefaultController.logger_$LI$().isLoggable(java.util.logging.Level.FINE))DefaultController.logger_$LI$().fine("PARAM ACTION: " + this.getPath() + "||" + action);
                this.doParamAction(action, params);
            } catch(ex) {
                console.error(ex.message, ex);
                this.mErrors.reportError(com.vzome.desktop.api.Controller.UNKNOWN_ERROR_CODE, [ex]);
            }
        }

        /*private*/ getPath(): string {
            if (this.mNextController == null)return this.name; else return this.mNextController.getPath() + "::" + this.name;
        }

        /**
         * 
         * @param {*} listener
         */
        public addPropertyListener(listener: java.beans.PropertyChangeListener) {
            this.pcs.addPropertyChangeListener$java_beans_PropertyChangeListener(listener);
        }

        /**
         * 
         * @param {*} listener
         */
        public removePropertyListener(listener: java.beans.PropertyChangeListener) {
            this.pcs.removePropertyChangeListener$java_beans_PropertyChangeListener(listener);
        }

        doAction(action: string) {
            if (this.mNextController != null)this.mNextController.doAction(action); else this.mErrors.reportError(com.vzome.desktop.api.Controller.UNKNOWN_ACTION, [action]);
        }

        /**
         * This is only overridden or called in Javascript code, in vZome Online.
         * @param source
         * @param {string} action
         * @param {java.util.Properties} params
         */
        doParamAction(action: string, params: java.util.Properties) {
            if (this.mNextController != null)this.mNextController.doParamAction(action, params); else this.mErrors.reportError(com.vzome.desktop.api.Controller.UNKNOWN_ACTION, [action]);
        }

        /**
         * 
         * @param {string} command
         * @param {java.io.File} file
         */
        public doFileAction(command: string, file: java.io.File) {
            if (this.mNextController != null)this.mNextController.doFileAction(command, file); else this.mErrors.reportError(com.vzome.desktop.api.Controller.UNKNOWN_ACTION, [command]);
        }

        /**
         * 
         * @param {string} command
         * @param {string} script
         */
        public doScriptAction(command: string, script: string) {
            if (this.mNextController != null)this.mNextController.doScriptAction(command, script); else this.mErrors.reportError(com.vzome.desktop.api.Controller.UNKNOWN_ACTION, [command]);
        }

        /**
         * 
         * @param {string} listName
         * @return {java.lang.String[]}
         */
        public getCommandList(listName: string): string[] {
            if (this.mNextController != null)return this.mNextController.getCommandList(listName); else return [];
        }

        /**
         * 
         * @param {string} string
         * @return {boolean[]}
         */
        public getCommandListDefaultStates(string: string): boolean[] {
            return null;
        }

        /**
         * 
         * @param {string} string
         * @return {string}
         */
        public getProperty(string: string): string {
            if (this.mNextController != null)return this.mNextController.getProperty(string);
            return null;
        }

        /**
         * 
         * @param {string} propName
         * @return {boolean}
         */
        public propertyIsTrue(propName: string): boolean {
            return "true" === this.getProperty(propName);
        }

        /**
         * 
         * @param {string} name
         * @param {*} sub
         */
        public addSubController(name: string, sub: com.vzome.desktop.api.Controller) {
            (<DefaultController><any>sub).name = name;
            this.subcontrollers.put(name, sub);
            (<DefaultController><any>sub).setNextController(this, name);
        }

        /**
         * 
         * @param {string} name
         * @return {*}
         */
        public getSubController(name: string): com.vzome.desktop.api.Controller {
            const subc: com.vzome.desktop.api.Controller = this.subcontrollers.get(name);
            if (subc != null)return subc;
            if (this.mNextController != null)return this.mNextController.getSubController(name);
            return null;
        }

        /**
         * 
         * @param {*} errors
         */
        public setErrorChannel(errors: Controller.ErrorChannel) {
            this.mErrors = errors;
        }

        /**
         * 
         * @param {string} name
         * @param {*} value
         */
        public setProperty(name: string, value: any) {
            if (DefaultController.logger_$LI$().isLoggable(java.util.logging.Level.FINE))DefaultController.logger_$LI$().fine("SETPROP: " + this.getPath() + "||" + name + "=" + value);
            this.setModelProperty(name, value);
        }

        public setModelProperty(name: string, value: any) {
            if (this.mNextController != null)this.mNextController.setProperty(name, value);
        }

        /*private*/ setNextController(controller: com.vzome.desktop.api.Controller, name: string) {
            this.name = name;
            this.mNextController = <DefaultController><any>controller;
            this.mNextController.addPropertyListener(new DefaultController.DefaultController$0(this));
            if (this.mNextController != null && this.mNextController instanceof <any>com.vzome.desktop.controller.DefaultController)this.mErrors = this.mNextController.mErrors;
        }

        firePropertyChange$java_beans_PropertyChangeEvent(event: java.beans.PropertyChangeEvent) {
            if (DefaultController.logger_$LI$().isLoggable(java.util.logging.Level.FINE))DefaultController.logger_$LI$().fine("CHGEVENT: " + this.getPath() + "||" + event.getPropertyName() + "=" + event.getNewValue());
            this.pcs.firePropertyChange$java_beans_PropertyChangeEvent(event);
        }

        public firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propName: string, oldValue: any, newValue: any) {
            if (DefaultController.logger_$LI$().isLoggable(java.util.logging.Level.FINE))DefaultController.logger_$LI$().fine("CHGEVENT: " + this.getPath() + "||" + propName + "=" + newValue);
            this.pcs.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propName, oldValue, newValue);
        }

        public firePropertyChange(propName?: any, oldValue?: any, newValue?: any) {
            if (((typeof propName === 'string') || propName === null) && ((oldValue != null) || oldValue === null) && ((newValue != null) || newValue === null)) {
                return <any>this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propName, oldValue, newValue);
            } else if (((propName != null && propName instanceof <any>java.beans.PropertyChangeEvent) || propName === null) && oldValue === undefined && newValue === undefined) {
                return <any>this.firePropertyChange$java_beans_PropertyChangeEvent(propName);
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {string} propName
         * @return {boolean}
         */
        public userHasEntitlement(propName: string): boolean {
            if (this.mNextController != null)return this.mNextController.userHasEntitlement(propName);
            return false;
        }

        openApplication(file: java.io.File) {
            if (this.mNextController != null)this.mNextController.openApplication(file);
        }

        runScript(script: string, file: java.io.File) {
            if (this.mNextController != null)this.mNextController.runScript(script, file);
        }

        constructor() {
            this.pcs = new java.beans.PropertyChangeSupport(this);
            if (this.mErrors === undefined) { this.mErrors = null; }
            if (this.mNextController === undefined) { this.mNextController = null; }
            this.subcontrollers = <any>(new java.util.HashMap<any, any>());
            this.name = "";
        }
    }
    DefaultController["__class"] = "com.vzome.desktop.controller.DefaultController";
    DefaultController["__interfaces"] = ["com.vzome.desktop.api.Controller"];



    export namespace DefaultController {

        export class DefaultController$0 implements java.beans.PropertyChangeListener {
            public __parent: any;
            /**
             * 
             * @param {java.beans.PropertyChangeEvent} event
             */
            public propertyChange(event: java.beans.PropertyChangeEvent) {
                this.__parent.pcs.firePropertyChange$java_beans_PropertyChangeEvent(event);
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }
        DefaultController$0["__interfaces"] = ["java.util.EventListener","java.beans.PropertyChangeListener"];


    }

}
namespace com.vzome.desktop.controller {
    export interface OrbitSnapper {
        snapZ(zIn: com.vzome.core.math.RealVector): com.vzome.core.math.RealVector;

        /**
         * Snap the Y-axis.
         * @param {com.vzome.core.math.RealVector} zOut already-snapped Z-axis
         * @param {com.vzome.core.math.RealVector} yIn
         * @return
         * @return {com.vzome.core.math.RealVector}
         */
        snapY(zOut: com.vzome.core.math.RealVector, yIn: com.vzome.core.math.RealVector): com.vzome.core.math.RealVector;
    }
}
namespace com.vzome.desktop.controller {
    /**
     * Transducer: turns trackball roll events into zone (Axis) change events.
     * 
     * @author Scott Vorthmann
     * @class
     */
    export abstract class ZoneVectorBall {
        /*private*/ orbits: com.vzome.core.math.symmetry.OrbitSet;

        /*private*/ zoneVector3d: com.vzome.core.math.RealVector;

        /*private*/ zone: com.vzome.core.math.symmetry.Axis;

        static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (ZoneVectorBall.logger == null) { ZoneVectorBall.logger = java.util.logging.Logger.getLogger("com.vzome.desktop.controller.ZoneVectorBall"); }  return ZoneVectorBall.logger; }

        public initializeZone(orbits: com.vzome.core.math.symmetry.OrbitSet, worldEye: com.vzome.core.math.RealVector): com.vzome.core.math.symmetry.Axis {
            this.orbits = orbits;
            this.zoneVector3d = new com.vzome.core.math.RealVector(worldEye.x, worldEye.y, worldEye.z);
            this.mapVectorToAxis(false);
            return this.zone;
        }

        public trackballRolled(rotation: com.vzome.core.math.RealVector[]) {
            const x: number = rotation[0].dot(this.zoneVector3d);
            const y: number = rotation[1].dot(this.zoneVector3d);
            const z: number = rotation[2].dot(this.zoneVector3d);
            this.zoneVector3d = new com.vzome.core.math.RealVector(x, y, z);
            this.mapVectorToAxis(true);
        }

        /**
         * This is used when we're doing some non-trackball drag
         * to define a new vector, as for the working plane.
         * @param {com.vzome.core.math.RealVector} vector
         */
        public setVector(vector: com.vzome.core.math.RealVector) {
            this.zoneVector3d = vector;
            this.mapVectorToAxis(true);
        }

        /*private*/ mapVectorToAxis(notify: boolean) {
            const vector: com.vzome.core.math.RealVector = new com.vzome.core.math.RealVector(this.zoneVector3d.x, this.zoneVector3d.y, this.zoneVector3d.z);
            const oldAxis: com.vzome.core.math.symmetry.Axis = this.zone;
            this.zone = this.orbits.getAxis(vector);
            if (this.zone == null && oldAxis == null){
                if (ZoneVectorBall.logger_$LI$().isLoggable(java.util.logging.Level.FINER))ZoneVectorBall.logger_$LI$().finer("mapVectorToAxis null zone for " + vector);
                return;
            }
            if (this.zone != null && this.zone.equals(oldAxis)){
                if (ZoneVectorBall.logger_$LI$().isLoggable(java.util.logging.Level.FINER))ZoneVectorBall.logger_$LI$().finer("mapVectorToAxis  zone " + this.zone + " unchanged for " + vector);
                return;
            }
            if (ZoneVectorBall.logger_$LI$().isLoggable(java.util.logging.Level.FINER))ZoneVectorBall.logger_$LI$().finer("preview finished at  " + this.zone + " for " + vector);
            if (notify)this.zoneChanged(oldAxis, this.zone);
        }

        abstract zoneChanged(oldZone: com.vzome.core.math.symmetry.Axis, newZone: com.vzome.core.math.symmetry.Axis);

        constructor() {
            if (this.orbits === undefined) { this.orbits = null; }
            if (this.zoneVector3d === undefined) { this.zoneVector3d = null; }
            this.zone = null;
        }
    }
    ZoneVectorBall["__class"] = "com.vzome.desktop.controller.ZoneVectorBall";

}
namespace com.vzome.desktop.api {
    /**
     * Controller portion of model-view-controller architecture.
     * 
     * MVC principles in vZome:
     * 
     * - UI code can know other UI classes, preferably top-down only (no knowledge of parent context)
     * - UI code only knows this generic Controller interface
     * - UI code gets Controllers using Controller .getSubController()
     * - UI code cannot know of any specific Controller subclasses or any model classes
     * - Controller code cannot know any UI classes; ActionListeners let the controller trigger UI effects
     * - Controller code can know other Controller subclasses, and Model classes
     * - Model classes can only know other Model classes, preferably top-down only (no knowledge of parent context)
     * - Model classes can trigger PropertyChangeEvents, but usually the Controllers do it
     * 
     * @author vorth
     * @class
     */
    export interface Controller {
        setErrorChannel(errors: Controller.ErrorChannel);

        getCommandList(listName: string): string[];

        actionPerformed(source: any, action: string);

        getCommandListDefaultStates(string: string): boolean[];

        doFileAction(command: string, file: java.io.File);

        doScriptAction(command: string, script: string);

        getProperty(string: string): string;

        setProperty(cmd: string, value: any);

        propertyIsTrue(propName: string): boolean;

        userHasEntitlement(propName: string): boolean;

        addPropertyListener(listener: java.beans.PropertyChangeListener);

        removePropertyListener(listener: java.beans.PropertyChangeListener);

        getSubController(string: string): Controller;

        addSubController(name: string, sub: Controller);
    }

    export namespace Controller {

        export const USER_ERROR_CODE: string = "user.command.error";

        export const UNKNOWN_ERROR_CODE: string = "unknown.exception";

        export const UNKNOWN_ACTION: string = "unknown.action";

        export const UNKNOWN_PROPERTY: string = "unknown.property";
    }


    export namespace Controller {

        export interface ErrorChannel {
            reportError(errorCode: string, args: any[]);

            clearError();
        }
    }

}
namespace com.vzome.core.exporters2d {
    /**
     * Exports a Java2dSnapshot to a character Writer.
     * Subclassed by SVGExporter and PDFExporter.
     * 
     * @author Scott Vorthmann
     * @class
     */
    export abstract class SnapshotExporter {
        output: SnapshotExporter.CountingPrintWriter;

        height: number;

        width: number;

        RGB_FORMAT: java.text.NumberFormat;

        XY_FORMAT: java.text.NumberFormat;

        public includeFile(rsrcName: string) {
            const boilerplate: string = com.vzome.xml.ResourceLoader.loadStringResource(rsrcName);
            this.output.write$java_lang_String(boilerplate);
        }

        public export(snapshot: com.vzome.core.exporters2d.Java2dSnapshot, writer: java.io.Writer, doOutlines: boolean, monochrome: boolean, showBackground: boolean) {
            this.XY_FORMAT.setGroupingUsed(false);
            this.XY_FORMAT.setMaximumFractionDigits(2);
            this.RGB_FORMAT.setMaximumFractionDigits(3);
            this.output = new SnapshotExporter.CountingPrintWriter(writer);
            const rect: java.awt.geom.Rectangle2D = snapshot.getRect();
            this.height = (<any>Math).fround(rect.getHeight());
            this.width = (<any>Math).fround(rect.getWidth());
            const lines: java.util.List<com.vzome.core.exporters2d.Java2dSnapshot.LineSegment> = snapshot.getLines();
            let strokeWidth: number = snapshot.getStrokeWidth();
            if (!snapshot.isLineDrawing() && !doOutlines)strokeWidth = -1.0;
            this.outputPrologue(snapshot.getRect(), strokeWidth);
            const bgColor: java.awt.Color = snapshot.getBackgroundColor();
            if (bgColor != null && showBackground)this.outputBackground(bgColor);
            if (!lines.isEmpty())for(let index=lines.iterator();index.hasNext();) {
                let line = index.next();
                {
                    this.outputLine(line, monochrome);
                }
            } else for(let index=snapshot.getPolygons().iterator();index.hasNext();) {
                let polygon = index.next();
                {
                    this.outputPolygon(polygon, strokeWidth > 0);
                }
            }
            this.outputPostlogue();
            this.output.flush();
            this.output.close();
        }

        /**
         * @param height2
         * @param width
         * @param {java.awt.Color} bgColor
         */
        abstract outputBackground(bgColor: java.awt.Color);

        abstract outputPrologue(rect: java.awt.geom.Rectangle2D, strokeWidth: number);

        abstract outputPostlogue();

        outputLine(line: com.vzome.core.exporters2d.Java2dSnapshot.LineSegment, monochrome: boolean) {
            this.renderPath(line.getPath());
            const rgb: number[] = line.getColor().getRGBColorComponents(null);
            if (!monochrome)this.setRGBStrokeColor(rgb[0], rgb[1], rgb[2]);
            this.strokePath();
        }

        outputPolygon(polygon: com.vzome.core.exporters2d.Java2dSnapshot.Polygon, doOutline: boolean) {
            this.renderPath(polygon.getPath());
            const rgb: number[] = polygon.getColor().getRGBColorComponents(null);
            this.setRGBFillColor(rgb[0], rgb[1], rgb[2]);
            this.fillPath();
            if (doOutline){
                this.renderPath(polygon.getPath());
                this.setBlackStrokeColor();
                this.strokePath();
            }
        }

        renderPath(path: java.awt.geom.GeneralPath) {
            this.beginPath();
            const segments: java.awt.geom.PathIterator = path.getPathIterator(null);
            while((!segments.isDone())) {{
                const coords: number[] = [0, 0, 0, 0, 0, 0];
                const step: number = segments.currentSegment(coords);
                switch((step)) {
                case java.awt.geom.PathIterator.SEG_MOVETO:
                    this.moveToPoint(coords[0], (<any>Math).fround(this.height - coords[1]));
                    break;
                case java.awt.geom.PathIterator.SEG_LINETO:
                    this.addLineToPoint(coords[0], (<any>Math).fround(this.height - coords[1]));
                    break;
                case java.awt.geom.PathIterator.SEG_CLOSE:
                    this.closePath();
                    break;
                default:
                    break;
                }
                segments.next();
            }};
        }

        setBlackStrokeColor() {
        }

        abstract setRGBStrokeColor(r: number, g: number, b: number);

        abstract setRGBFillColor(r: number, g: number, b: number);

        abstract beginPath();

        abstract moveToPoint(x: number, y: number);

        abstract addLineToPoint(x: number, y: number);

        abstract closePath();

        abstract fillPath();

        abstract strokePath();

        constructor() {
            if (this.output === undefined) { this.output = null; }
            if (this.height === undefined) { this.height = 0; }
            if (this.width === undefined) { this.width = 0; }
            this.RGB_FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US);
            this.XY_FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US);
        }
    }
    SnapshotExporter["__class"] = "com.vzome.core.exporters2d.SnapshotExporter";


    export namespace SnapshotExporter {

        export class CountingPrintWriter extends java.io.PrintWriter {
            mTotal: number;

            public constructor(writer: java.io.Writer) {
                super(writer);
                this.mTotal = 0;
            }

            public write$char_A$int$int(buf: string[], offset: number, len: number) {
                super.write$char_A$int$int(buf, offset, len);
                this.mTotal += len;
            }

            /**
             * 
             * @param {char[]} buf
             * @param {number} offset
             * @param {number} len
             */
            public write(buf?: any, offset?: any, len?: any) {
                if (((buf != null && buf instanceof <any>Array && (buf.length == 0 || buf[0] == null ||(typeof buf[0] === 'string'))) || buf === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                    return <any>this.write$char_A$int$int(buf, offset, len);
                } else if (((typeof buf === 'string') || buf === null) && offset === undefined && len === undefined) {
                    return <any>this.write$java_lang_String(buf);
                } else throw new Error('invalid overload');
            }

            public write$java_lang_String(str: string) {
                super.write$java_lang_String(str);
                this.mTotal += str.length;
            }

            public getBytesTotal(): number {
                return this.mTotal;
            }
        }
        CountingPrintWriter["__class"] = "com.vzome.core.exporters2d.SnapshotExporter.CountingPrintWriter";
        CountingPrintWriter["__interfaces"] = ["java.lang.Appendable","java.io.Closeable","java.lang.AutoCloseable","java.io.Flushable"];


    }

}
namespace java.beans {
    /**
     * Constructs a new <code>IndexedPropertyChangeEvent</code> object.
     * 
     * @param {*} source  The bean that fired the event.
     * @param {string} propertyName  The programmatic name of the property that
     * was changed.
     * @param {*} oldValue      The old value of the property.
     * @param {*} newValue      The new value of the property.
     * @param {number} index index of the property element that was changed.
     * @class
     * @extends java.beans.PropertyChangeEvent
     * @author Mark Davidson
     */
    export class IndexedPropertyChangeEvent extends java.beans.PropertyChangeEvent {
        static serialVersionUID: number = -320227448495806870;

        /*private*/ index: number;

        public constructor(source: any, propertyName: string, oldValue: any, newValue: any, index: number) {
            super(source, propertyName, oldValue, newValue);
            if (this.index === undefined) { this.index = 0; }
            this.index = index;
        }

        /**
         * Gets the index of the property that was changed.
         * 
         * @return {number} The index specifying the property element that was
         * changed.
         */
        public getIndex(): number {
            return this.index;
        }

        appendTo(sb: java.lang.StringBuilder) {
            sb.append("; index=").append(this.getIndex());
        }
    }
    IndexedPropertyChangeEvent["__class"] = "java.beans.IndexedPropertyChangeEvent";
    IndexedPropertyChangeEvent["__interfaces"] = ["java.io.Serializable"];


}
namespace java.beans {
    export class PropertyChangeSupport {
        /*private*/ map: PropertyChangeSupport.PropertyChangeListenerMap;

        public constructor(sourceBean: any) {
            this.map = new PropertyChangeSupport.PropertyChangeListenerMap();
            if (this.source === undefined) { this.source = null; }
            if (sourceBean == null){
                throw new java.lang.NullPointerException();
            }
            this.source = sourceBean;
        }

        public addPropertyChangeListener$java_beans_PropertyChangeListener(listener: java.beans.PropertyChangeListener) {
            if (listener == null){
                return;
            }
            if (listener != null && listener instanceof <any>java.beans.PropertyChangeListenerProxy){
                const proxy: java.beans.PropertyChangeListenerProxy = <java.beans.PropertyChangeListenerProxy><any>listener;
                this.addPropertyChangeListener$java_lang_String$java_beans_PropertyChangeListener(proxy.getPropertyName(), proxy.getListener());
            } else {
                this.map.add(null, listener);
            }
        }

        public removePropertyChangeListener$java_beans_PropertyChangeListener(listener: java.beans.PropertyChangeListener) {
            if (listener == null){
                return;
            }
            if (listener != null && listener instanceof <any>java.beans.PropertyChangeListenerProxy){
                const proxy: java.beans.PropertyChangeListenerProxy = <java.beans.PropertyChangeListenerProxy><any>listener;
                this.removePropertyChangeListener$java_lang_String$java_beans_PropertyChangeListener(proxy.getPropertyName(), proxy.getListener());
            } else {
                this.map.remove(null, listener);
            }
        }

        public getPropertyChangeListeners$(): java.beans.PropertyChangeListener[] {
            return this.map.getListeners$();
        }

        public addPropertyChangeListener$java_lang_String$java_beans_PropertyChangeListener(propertyName: string, listener: java.beans.PropertyChangeListener) {
            if (listener == null || propertyName == null){
                return;
            }
            listener = this.map.extract$java_beans_PropertyChangeListener(listener);
            if (listener != null){
                this.map.add(propertyName, listener);
            }
        }

        public addPropertyChangeListener(propertyName?: any, listener?: any) {
            if (((typeof propertyName === 'string') || propertyName === null) && ((listener != null && (listener.constructor != null && listener.constructor["__interfaces"] != null && listener.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || listener === null)) {
                return <any>this.addPropertyChangeListener$java_lang_String$java_beans_PropertyChangeListener(propertyName, listener);
            } else if (((propertyName != null && (propertyName.constructor != null && propertyName.constructor["__interfaces"] != null && propertyName.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || propertyName === null) && listener === undefined) {
                return <any>this.addPropertyChangeListener$java_beans_PropertyChangeListener(propertyName);
            } else throw new Error('invalid overload');
        }

        public removePropertyChangeListener$java_lang_String$java_beans_PropertyChangeListener(propertyName: string, listener: java.beans.PropertyChangeListener) {
            if (listener == null || propertyName == null){
                return;
            }
            listener = this.map.extract$java_beans_PropertyChangeListener(listener);
            if (listener != null){
                this.map.remove(propertyName, listener);
            }
        }

        public removePropertyChangeListener(propertyName?: any, listener?: any) {
            if (((typeof propertyName === 'string') || propertyName === null) && ((listener != null && (listener.constructor != null && listener.constructor["__interfaces"] != null && listener.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || listener === null)) {
                return <any>this.removePropertyChangeListener$java_lang_String$java_beans_PropertyChangeListener(propertyName, listener);
            } else if (((propertyName != null && (propertyName.constructor != null && propertyName.constructor["__interfaces"] != null && propertyName.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || propertyName === null) && listener === undefined) {
                return <any>this.removePropertyChangeListener$java_beans_PropertyChangeListener(propertyName);
            } else throw new Error('invalid overload');
        }

        public getPropertyChangeListeners$java_lang_String(propertyName: string): java.beans.PropertyChangeListener[] {
            return this.map.getListeners$java_lang_String(propertyName);
        }

        public getPropertyChangeListeners(propertyName?: any): java.beans.PropertyChangeListener[] {
            if (((typeof propertyName === 'string') || propertyName === null)) {
                return <any>this.getPropertyChangeListeners$java_lang_String(propertyName);
            } else if (propertyName === undefined) {
                return <any>this.getPropertyChangeListeners$();
            } else throw new Error('invalid overload');
        }

        public firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propertyName: string, oldValue: any, newValue: any) {
            if (oldValue == null || newValue == null || !/* equals */(<any>((o1: any, o2: any) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)(oldValue,newValue))){
                this.firePropertyChange$java_beans_PropertyChangeEvent(new java.beans.PropertyChangeEvent(this.source, propertyName, oldValue, newValue));
            }
        }

        public firePropertyChange$java_lang_String$int$int(propertyName: string, oldValue: number, newValue: number) {
            if (oldValue !== newValue){
                this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propertyName, javaemul.internal.IntegerHelper.valueOf(oldValue), javaemul.internal.IntegerHelper.valueOf(newValue));
            }
        }

        public firePropertyChange(propertyName?: any, oldValue?: any, newValue?: any) {
            if (((typeof propertyName === 'string') || propertyName === null) && ((typeof oldValue === 'number') || oldValue === null) && ((typeof newValue === 'number') || newValue === null)) {
                return <any>this.firePropertyChange$java_lang_String$int$int(propertyName, oldValue, newValue);
            } else if (((typeof propertyName === 'string') || propertyName === null) && ((typeof oldValue === 'boolean') || oldValue === null) && ((typeof newValue === 'boolean') || newValue === null)) {
                return <any>this.firePropertyChange$java_lang_String$boolean$boolean(propertyName, oldValue, newValue);
            } else if (((typeof propertyName === 'string') || propertyName === null) && ((oldValue != null) || oldValue === null) && ((newValue != null) || newValue === null)) {
                return <any>this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propertyName, oldValue, newValue);
            } else if (((propertyName != null && propertyName instanceof <any>java.beans.PropertyChangeEvent) || propertyName === null) && oldValue === undefined && newValue === undefined) {
                return <any>this.firePropertyChange$java_beans_PropertyChangeEvent(propertyName);
            } else throw new Error('invalid overload');
        }

        public firePropertyChange$java_lang_String$boolean$boolean(propertyName: string, oldValue: boolean, newValue: boolean) {
            if (oldValue !== newValue){
                this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propertyName, javaemul.internal.BooleanHelper.valueOf(oldValue), javaemul.internal.BooleanHelper.valueOf(newValue));
            }
        }

        public firePropertyChange$java_beans_PropertyChangeEvent(event: java.beans.PropertyChangeEvent) {
            const oldValue: any = event.getOldValue();
            const newValue: any = event.getNewValue();
            if (oldValue == null || newValue == null || !/* equals */(<any>((o1: any, o2: any) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)(oldValue,newValue))){
                const name: string = event.getPropertyName();
                const common: java.beans.PropertyChangeListener[] = this.map.get(null);
                const named: java.beans.PropertyChangeListener[] = (name != null) ? this.map.get(name) : null;
                PropertyChangeSupport.fire(common, event);
                PropertyChangeSupport.fire(named, event);
            }
        }

        static fire(listeners: java.beans.PropertyChangeListener[], event: java.beans.PropertyChangeEvent) {
            if (listeners != null){
                for(let index = 0; index < listeners.length; index++) {
                    let listener = listeners[index];
                    {
                        listener.propertyChange(event);
                    }
                }
            }
        }

        public fireIndexedPropertyChange$java_lang_String$int$java_lang_Object$java_lang_Object(propertyName: string, index: number, oldValue: any, newValue: any) {
            if (oldValue == null || newValue == null || !/* equals */(<any>((o1: any, o2: any) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)(oldValue,newValue))){
                this.firePropertyChange$java_beans_PropertyChangeEvent(new java.beans.IndexedPropertyChangeEvent(this.source, propertyName, oldValue, newValue, index));
            }
        }

        public fireIndexedPropertyChange$java_lang_String$int$int$int(propertyName: string, index: number, oldValue: number, newValue: number) {
            if (oldValue !== newValue){
                this.fireIndexedPropertyChange$java_lang_String$int$java_lang_Object$java_lang_Object(propertyName, index, javaemul.internal.IntegerHelper.valueOf(oldValue), javaemul.internal.IntegerHelper.valueOf(newValue));
            }
        }

        public fireIndexedPropertyChange(propertyName?: any, index?: any, oldValue?: any, newValue?: any) {
            if (((typeof propertyName === 'string') || propertyName === null) && ((typeof index === 'number') || index === null) && ((typeof oldValue === 'number') || oldValue === null) && ((typeof newValue === 'number') || newValue === null)) {
                return <any>this.fireIndexedPropertyChange$java_lang_String$int$int$int(propertyName, index, oldValue, newValue);
            } else if (((typeof propertyName === 'string') || propertyName === null) && ((typeof index === 'number') || index === null) && ((typeof oldValue === 'boolean') || oldValue === null) && ((typeof newValue === 'boolean') || newValue === null)) {
                return <any>this.fireIndexedPropertyChange$java_lang_String$int$boolean$boolean(propertyName, index, oldValue, newValue);
            } else if (((typeof propertyName === 'string') || propertyName === null) && ((typeof index === 'number') || index === null) && ((oldValue != null) || oldValue === null) && ((newValue != null) || newValue === null)) {
                return <any>this.fireIndexedPropertyChange$java_lang_String$int$java_lang_Object$java_lang_Object(propertyName, index, oldValue, newValue);
            } else throw new Error('invalid overload');
        }

        public fireIndexedPropertyChange$java_lang_String$int$boolean$boolean(propertyName: string, index: number, oldValue: boolean, newValue: boolean) {
            if (oldValue !== newValue){
                this.fireIndexedPropertyChange$java_lang_String$int$java_lang_Object$java_lang_Object(propertyName, index, javaemul.internal.BooleanHelper.valueOf(oldValue), javaemul.internal.BooleanHelper.valueOf(newValue));
            }
        }

        public hasListeners(propertyName: string): boolean {
            return this.map.hasListeners(propertyName);
        }

        /*private*/ source: any;

        static serialVersionUID: number = 6401253773779951803;
    }
    PropertyChangeSupport["__class"] = "java.beans.PropertyChangeSupport";


    export namespace PropertyChangeSupport {

        export class PropertyChangeListenerMap extends java.beans.ChangeListenerMap<java.beans.PropertyChangeListener> {
            static EMPTY: java.beans.PropertyChangeListener[]; public static EMPTY_$LI$(): java.beans.PropertyChangeListener[] { if (PropertyChangeListenerMap.EMPTY == null) { PropertyChangeListenerMap.EMPTY = []; }  return PropertyChangeListenerMap.EMPTY; }

            /**
             * 
             * @param {number} length
             * @return {java.beans.PropertyChangeListener[]}
             */
            newArray(length: number): java.beans.PropertyChangeListener[] {
                return (0 < length) ? (s => { let a=[]; while(s-->0) a.push(null); return a; })(length) : PropertyChangeListenerMap.EMPTY_$LI$();
            }

            public newProxy$java_lang_String$java_beans_PropertyChangeListener(name: string, listener: java.beans.PropertyChangeListener): java.beans.PropertyChangeListener {
                return new java.beans.PropertyChangeListenerProxy(name, listener);
            }

            /**
             * 
             * @param {string} name
             * @param {*} listener
             * @return {*}
             */
            public newProxy(name?: any, listener?: any): any {
                if (((typeof name === 'string') || name === null) && ((listener != null && (listener.constructor != null && listener.constructor["__interfaces"] != null && listener.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || listener === null)) {
                    return <any>this.newProxy$java_lang_String$java_beans_PropertyChangeListener(name, listener);
                } else if (((typeof name === 'string') || name === null) && ((listener != null) || listener === null)) {
                     throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); 
                } else throw new Error('invalid overload');
            }

            public extract$java_beans_PropertyChangeListener(listener: java.beans.PropertyChangeListener): java.beans.PropertyChangeListener {
                while((listener != null && listener instanceof <any>java.beans.PropertyChangeListenerProxy)) {{
                    listener = (<java.beans.PropertyChangeListenerProxy><any>listener).getListener();
                }};
                return listener;
            }

            public extract(listener?: any): any {
                if (((listener != null && (listener.constructor != null && listener.constructor["__interfaces"] != null && listener.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || listener === null)) {
                    return <any>this.extract$java_beans_PropertyChangeListener(listener);
                } else if (((listener != null) || listener === null)) {
                     throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); 
                } else throw new Error('invalid overload');
            }

            constructor() {
                super();
            }
        }
        PropertyChangeListenerMap["__class"] = "java.beans.PropertyChangeSupport.PropertyChangeListenerMap";

    }

}
namespace java.text {
    export class DecimalFormat extends java.text.NumberFormat {
        public applyPattern(pattern: string) {
        }
    }
    DecimalFormat["__class"] = "java.text.DecimalFormat";

}
namespace com.vzome.core.math {
    /**
     * Construct a new vector from its coordinate values.
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @class
     */
    export class RealVector {
        static __static_initialized: boolean = false;
        static __static_initialize() { if (!RealVector.__static_initialized) { RealVector.__static_initialized = true; RealVector.__static_initializer_0(); } }

        public static ORIGIN: RealVector; public static ORIGIN_$LI$(): RealVector { RealVector.__static_initialize(); if (RealVector.ORIGIN == null) { RealVector.ORIGIN = new RealVector(0.0, 0.0, 0.0); }  return RealVector.ORIGIN; }

        static FORMAT: java.text.NumberFormat; public static FORMAT_$LI$(): java.text.NumberFormat { RealVector.__static_initialize(); if (RealVector.FORMAT == null) { RealVector.FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US); }  return RealVector.FORMAT; }

        public static DIRECTION_0: RealVector; public static DIRECTION_0_$LI$(): RealVector { RealVector.__static_initialize(); if (RealVector.DIRECTION_0 == null) { RealVector.DIRECTION_0 = new RealVector(10.0, 0.1, -0.1); }  return RealVector.DIRECTION_0; }

        static  __static_initializer_0() {
            RealVector.FORMAT_$LI$().setMaximumFractionDigits(5);
            RealVector.FORMAT_$LI$().setMinimumFractionDigits(1);
        }

        public x: number;

        public y: number;

        public z: number;

        public constructor(x?: any, y?: any, z?: any) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null)) {
                let __args = arguments;
                if (this.x === undefined) { this.x = 0; } 
                if (this.y === undefined) { this.y = 0; } 
                if (this.z === undefined) { this.z = 0; } 
                this.x = (<any>Math).fround(x);
                this.y = (<any>Math).fround(y);
                this.z = (<any>Math).fround(z);
            } else if (((x != null && x instanceof <any>com.vzome.core.math.RealVector) || x === null) && y === undefined && z === undefined) {
                let __args = arguments;
                let that: any = __args[0];
                {
                    let __args = arguments;
                    let x: any = that.x;
                    let y: any = that.y;
                    let z: any = that.z;
                    if (this.x === undefined) { this.x = 0; } 
                    if (this.y === undefined) { this.y = 0; } 
                    if (this.z === undefined) { this.z = 0; } 
                    this.x = (<any>Math).fround(x);
                    this.y = (<any>Math).fround(y);
                    this.z = (<any>Math).fround(z);
                }
            } else if (x === undefined && y === undefined && z === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let x: any = 0.0;
                    let y: any = 0.0;
                    let z: any = 0.0;
                    if (this.x === undefined) { this.x = 0; } 
                    if (this.y === undefined) { this.y = 0; } 
                    if (this.z === undefined) { this.z = 0; } 
                    this.x = (<any>Math).fround(x);
                    this.y = (<any>Math).fround(y);
                    this.z = (<any>Math).fround(z);
                }
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {*}
         */
        public clone(): any {
            return new RealVector(this);
        }

        public isZero(): boolean {
            return this.x === 0 && this.y === 0 && this.z === 0;
        }

        /**
         * Return a string representing this vector as XML attribute values.
         * @return {string}
         */
        public toXmlAttributes(): string {
            return "x=\"" + RealVector.FORMAT_$LI$().format(this.x) + "\" y=\"" + RealVector.FORMAT_$LI$().format(this.y) + "\" z=\"" + RealVector.FORMAT_$LI$().format(this.z) + "\"";
        }

        public toString$java_text_NumberFormat(format: java.text.NumberFormat): string {
            return format.format(this.x) + "," + format.format(this.y) + "," + format.format(this.z);
        }

        /**
         * Return a string representing this vector in the form "x,y,z".
         * @param {java.text.NumberFormat} format
         * @return {string}
         */
        public toString(format?: any): string {
            if (((format != null && format instanceof <any>java.text.NumberFormat) || format === null)) {
                return <any>this.toString$java_text_NumberFormat(format);
            } else if (format === undefined) {
                return <any>this.toString$();
            } else throw new Error('invalid overload');
        }

        public toString$(): string {
            return RealVector.FORMAT_$LI$().format(this.x) + "," + RealVector.FORMAT_$LI$().format(this.y) + "," + RealVector.FORMAT_$LI$().format(this.z);
        }

        /**
         * Return a string representing this vector in the form "x y z".
         * @return {string}
         */
        public spacedString(): string {
            const result: string = RealVector.FORMAT_$LI$().format(this.x) + " " + RealVector.FORMAT_$LI$().format(this.y) + " " + RealVector.FORMAT_$LI$().format(this.z);
            return result;
        }

        /**
         * Return the sum of this vector plus the vector "other",
         * as a new Vector3D.
         * @param {com.vzome.core.math.RealVector} other
         * @return {com.vzome.core.math.RealVector}
         */
        public plus(other: RealVector): RealVector {
            return new RealVector((<any>Math).fround(this.x + other.x), (<any>Math).fround(this.y + other.y), (<any>Math).fround(this.z + other.z));
        }

        /**
         * Return the difference of this vector minus the vector "other",
         * as a new Vector3D.
         * @param {com.vzome.core.math.RealVector} other
         * @return {com.vzome.core.math.RealVector}
         */
        public minus(other: RealVector): RealVector {
            return new RealVector((<any>Math).fround(this.x - other.x), (<any>Math).fround(this.y - other.y), (<any>Math).fround(this.z - other.z));
        }

        public negate(): RealVector {
            return new RealVector(-this.x, -this.y, -this.z);
        }

        /**
         * Return a new vector equal to this vector scaled by the given factor.
         * @param {number} factor
         * @return {com.vzome.core.math.RealVector}
         */
        public scale(factor: number): RealVector {
            return new RealVector(this.x * factor, this.y * factor, this.z * factor);
        }

        /**
         * Return the scalar (dot) product with the other vector
         * @param {com.vzome.core.math.RealVector} other
         * @return {number}
         */
        public dot(other: RealVector): number {
            return (<any>Math).fround((<any>Math).fround((<any>Math).fround(this.x * other.x) + (<any>Math).fround(this.y * other.y)) + (<any>Math).fround(this.z * other.z));
        }

        public cross(that: RealVector): RealVector {
            return new RealVector((<any>Math).fround((<any>Math).fround(this.y * that.z) - (<any>Math).fround(this.z * that.y)), (<any>Math).fround((<any>Math).fround(this.z * that.x) - (<any>Math).fround(this.x * that.z)), (<any>Math).fround((<any>Math).fround(this.x * that.y) - (<any>Math).fround(this.y * that.x)));
        }

        /**
         * Return the length of this vector.
         * @return {number}
         */
        public length(): number {
            return Math.sqrt(this.dot(this));
        }

        public normalize(): RealVector {
            return this.scale(1.0 / this.length());
        }

        public write(buf: java.nio.FloatBuffer, offset: number) {
            buf.put(offset, this.x);
            buf.put(offset + 1, this.y);
            buf.put(offset + 2, this.z);
        }

        /**
         * 
         * @param {*} other
         * @return {boolean}
         */
        public equals(other: any): boolean {
            if (other == null){
                return false;
            }
            if (other === this){
                return true;
            }
            if (!(other != null && other instanceof <any>com.vzome.core.math.RealVector))return false;
            const v: RealVector = <RealVector>other;
            return this.x === v.x && this.y === v.y && this.z === v.z;
        }

        /**
         * 
         * @return {number}
         */
        public hashCode(): number {
            let hash: number = 3;
            hash = 41 * hash + (<number>(javaemul.internal.DoubleHelper.doubleToLongBits(this.x) ^ (javaemul.internal.DoubleHelper.doubleToLongBits(this.x) >>> 32))|0);
            hash = 41 * hash + (<number>(javaemul.internal.DoubleHelper.doubleToLongBits(this.y) ^ (javaemul.internal.DoubleHelper.doubleToLongBits(this.y) >>> 32))|0);
            hash = 41 * hash + (<number>(javaemul.internal.DoubleHelper.doubleToLongBits(this.z) ^ (javaemul.internal.DoubleHelper.doubleToLongBits(this.z) >>> 32))|0);
            return hash;
        }

        public addTo(addend: number[], sum: number[]) {
            sum[0] = ((<any>Math).fround(addend[0] + this.x));
            sum[1] = ((<any>Math).fround(addend[1] + this.y));
            sum[2] = ((<any>Math).fround(addend[2] + this.z));
        }

        public toArray(output: number[]) {
            output[0] = this.x;
            output[1] = this.y;
            output[2] = this.z;
        }
    }
    RealVector["__class"] = "com.vzome.core.math.RealVector";

}
namespace com.vzome.jsweet {
    export class JsPanel extends com.vzome.jsweet.JsManifestation implements com.vzome.core.model.Panel {
        public constructor(field: com.vzome.core.algebra.AlgebraicField, adapter: Object, coords: number[][][]) {
            super(field, adapter, coords);
        }

        /**
         * 
         * @return {com.vzome.core.construction.Construction}
         */
        public toConstruction(): com.vzome.core.construction.Construction {
            const projected: java.util.List<com.vzome.core.construction.Point> = <any>(new java.util.ArrayList<com.vzome.core.construction.Point>());
            for(let i: number = 0; i < this.vectors.length; i++) {{
                const pt: com.vzome.core.algebra.AlgebraicVector = (<com.vzome.jsweet.JsAlgebraicField><any>this.field).createVectorFromTDs(this.vectors[i]);
                projected.add(new com.vzome.core.construction.FreePoint(this.field.projectTo3d(pt, true)));
            };}
            return new com.vzome.core.construction.PolygonFromVertices(projected);
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getLocation(): com.vzome.core.algebra.AlgebraicVector {
            return null;
        }

        public getNormal$(): com.vzome.core.algebra.AlgebraicVector {
            return this.getZoneVector();
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getZoneVector(): com.vzome.core.algebra.AlgebraicVector {
            const v0: com.vzome.core.algebra.AlgebraicVector = (<com.vzome.jsweet.JsAlgebraicField><any>this.field).createVectorFromTDs(this.vectors[0]);
            const v1: com.vzome.core.algebra.AlgebraicVector = (<com.vzome.jsweet.JsAlgebraicField><any>this.field).createVectorFromTDs(this.vectors[1]);
            const v2: com.vzome.core.algebra.AlgebraicVector = (<com.vzome.jsweet.JsAlgebraicField><any>this.field).createVectorFromTDs(this.vectors[2]);
            return com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2);
        }

        /**
         * 
         * @return {*}
         */
        public iterator(): java.util.Iterator<com.vzome.core.algebra.AlgebraicVector> {
            return new JsPanel.JsPanel$0(this);
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} vector
         */
        public setZoneVector(vector: com.vzome.core.algebra.AlgebraicVector) {
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getFirstVertex(): com.vzome.core.algebra.AlgebraicVector {
            return (<com.vzome.jsweet.JsAlgebraicField><any>this.field).createVectorFromTDs(this.vectors[0]);
        }

        /**
         * 
         * @return {number}
         */
        public getVertexCount(): number {
            return this.vectors.length;
        }

        /**
         * 
         * @return {*}
         */
        public getQuadrea(): com.vzome.core.algebra.AlgebraicNumber {
            return this.field.one();
        }

        public getNormal$com_vzome_core_math_symmetry_Embedding(embedding: com.vzome.core.math.symmetry.Embedding): com.vzome.core.math.RealVector {
            throw new java.lang.RuntimeException("unimplemented");
        }

        /**
         * 
         * @param {*} embedding
         * @return {com.vzome.core.math.RealVector}
         */
        public getNormal(embedding?: any): any {
            if (((embedding != null && (embedding.constructor != null && embedding.constructor["__interfaces"] != null && embedding.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Embedding") >= 0)) || embedding === null)) {
                return <any>this.getNormal$com_vzome_core_math_symmetry_Embedding(embedding);
            } else if (embedding === undefined) {
                return <any>this.getNormal$();
            } else throw new Error('invalid overload');
        }
    }
    JsPanel["__class"] = "com.vzome.jsweet.JsPanel";
    JsPanel["__interfaces"] = ["com.vzome.core.model.GroupElement","com.vzome.core.model.Panel","com.vzome.core.model.Manifestation","java.lang.Iterable"];



    export namespace JsPanel {

        export class JsPanel$0 implements java.util.Iterator<com.vzome.core.algebra.AlgebraicVector> {
            public __parent: any;
            i: number;

            /**
             * 
             * @return {boolean}
             */
            public hasNext(): boolean {
                return this.i < this.__parent.vectors.length;
            }

            /**
             * 
             * @return {com.vzome.core.algebra.AlgebraicVector}
             */
            public next(): com.vzome.core.algebra.AlgebraicVector {
                return (<com.vzome.jsweet.JsAlgebraicField><any>this.__parent.field).createVectorFromTDs(this.__parent.vectors[this.i++]);
            }

            constructor(__parent: any) {
                this.__parent = __parent;
                this.i = 0;
            }
        }
        JsPanel$0["__interfaces"] = ["java.util.Iterator"];


    }

}
namespace com.vzome.jsweet {
    export class JsBall extends com.vzome.jsweet.JsManifestation implements com.vzome.core.model.Connector {
        public constructor(field: com.vzome.core.algebra.AlgebraicField, adapter: Object, coords: number[][][]) {
            super(field, adapter, coords);
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getLocation(): com.vzome.core.algebra.AlgebraicVector {
            return (<com.vzome.jsweet.JsAlgebraicField><any>this.field).createVectorFromTDs(this.vectors[0]);
        }

        /**
         * 
         * @return {com.vzome.core.construction.Construction}
         */
        public toConstruction(): com.vzome.core.construction.Construction {
            return new com.vzome.core.construction.FreePoint(this.getLocation());
        }

        /**
         * 
         * @param {*} other
         * @return {number}
         */
        public compareTo(other: com.vzome.core.model.Connector): number {
            if (this === other){
                return 0;
            }
            if (/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(other,this))){
                return 0;
            }
            return this.getLocation().compareTo(other.getLocation());
        }
    }
    JsBall["__class"] = "com.vzome.jsweet.JsBall";
    JsBall["__interfaces"] = ["com.vzome.core.model.GroupElement","com.vzome.core.model.Connector","java.lang.Comparable","com.vzome.core.model.Manifestation"];


}
namespace com.vzome.jsweet {
    export class JsStrut extends com.vzome.jsweet.JsManifestation implements com.vzome.core.model.Strut {
        public constructor(field: com.vzome.core.algebra.AlgebraicField, adapter: Object, coords: number[][][]) {
            super(field, adapter, coords);
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getLocation(): com.vzome.core.algebra.AlgebraicVector {
            return (<com.vzome.jsweet.JsAlgebraicField><any>this.field).createVectorFromTDs(this.vectors[0]);
        }

        /**
         * 
         * @return {com.vzome.core.construction.Construction}
         */
        public toConstruction(): com.vzome.core.construction.Construction {
            return new com.vzome.core.construction.SegmentJoiningPoints(new com.vzome.core.construction.FreePoint(this.getLocation()), new com.vzome.core.construction.FreePoint(this.getEnd()));
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getEnd(): com.vzome.core.algebra.AlgebraicVector {
            return (<com.vzome.jsweet.JsAlgebraicField><any>this.field).createVectorFromTDs(this.vectors[1]);
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getOffset(): com.vzome.core.algebra.AlgebraicVector {
            const start: com.vzome.core.algebra.AlgebraicVector = this.getLocation();
            const end: com.vzome.core.algebra.AlgebraicVector = this.getEnd();
            return end.minus(start);
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} vector
         */
        public setZoneVector(vector: com.vzome.core.algebra.AlgebraicVector) {
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getZoneVector(): com.vzome.core.algebra.AlgebraicVector {
            return this.getOffset();
        }

        /**
         * 
         * @param {*} other
         * @return {number}
         */
        public compareTo(other: com.vzome.core.model.Strut): number {
            if (this === other){
                return 0;
            }
            if (/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(other,this))){
                return 0;
            }
            const thisFirst: com.vzome.core.algebra.AlgebraicVector = this.getCanonicalLesserEnd();
            const thisLast: com.vzome.core.algebra.AlgebraicVector = this.getCanonicalGreaterEnd();
            const otherFirst: com.vzome.core.algebra.AlgebraicVector = other.getCanonicalLesserEnd();
            const otherLast: com.vzome.core.algebra.AlgebraicVector = other.getCanonicalGreaterEnd();
            const comparison: number = thisFirst.compareTo(otherFirst);
            return (comparison === 0) ? thisLast.compareTo(otherLast) : comparison;
        }

        public getCanonicalLesserEnd(): com.vzome.core.algebra.AlgebraicVector {
            const m_end1: com.vzome.core.algebra.AlgebraicVector = this.getLocation();
            const m_end2: com.vzome.core.algebra.AlgebraicVector = this.getEnd();
            return (m_end1.compareTo(m_end2) < 0) ? m_end1 : m_end2;
        }

        public getCanonicalGreaterEnd(): com.vzome.core.algebra.AlgebraicVector {
            const m_end1: com.vzome.core.algebra.AlgebraicVector = this.getLocation();
            const m_end2: com.vzome.core.algebra.AlgebraicVector = this.getEnd();
            return (m_end1.compareTo(m_end2) > 0) ? m_end1 : m_end2;
        }
    }
    JsStrut["__class"] = "com.vzome.jsweet.JsStrut";
    JsStrut["__interfaces"] = ["com.vzome.core.model.GroupElement","com.vzome.core.model.Strut","java.lang.Comparable","com.vzome.core.model.Manifestation"];


}
namespace com.vzome.core.kinds {
    export class OctahedralSymmetryPerspective extends com.vzome.core.kinds.AbstractSymmetryPerspective {
        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            super(new com.vzome.core.math.symmetry.OctahedralSymmetry(field));
            this.modelResourcePath = "org/vorthmann/zome/app/octahedral-vef.vZome";
            this.setDefaultGeometry(new com.vzome.core.viewing.OctahedralShapes("octahedral", "octahedra", this.symmetry));
        }

        /**
         * 
         * @return {com.vzome.core.math.symmetry.OctahedralSymmetry}
         */
        public getSymmetry(): com.vzome.core.math.symmetry.OctahedralSymmetry {
            return <com.vzome.core.math.symmetry.OctahedralSymmetry><any>this.symmetry;
        }

        /**
         * 
         * @param {com.vzome.api.Tool.Kind} kind
         * @param {com.vzome.core.editor.ToolsModel} tools
         * @return {*}
         */
        public createToolFactories(kind: com.vzome.api.Tool.Kind, tools: com.vzome.core.editor.ToolsModel): java.util.List<com.vzome.api.Tool.Factory> {
            const result: java.util.List<com.vzome.api.Tool.Factory> = <any>(new java.util.ArrayList<any>());
            switch((kind)) {
            case com.vzome.api.Tool.Kind.SYMMETRY:
                result.add(new com.vzome.core.tools.OctahedralToolFactory(tools, this.symmetry));
                result.add(new com.vzome.core.tools.TetrahedralToolFactory(tools, this.symmetry));
                result.add(new com.vzome.core.tools.InversionToolFactory(tools));
                result.add(new com.vzome.core.tools.LineReflectionToolFactory(tools));
                result.add(new com.vzome.core.tools.MirrorToolFactory(tools));
                result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry));
                break;
            case com.vzome.api.Tool.Kind.TRANSFORM:
                result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry));
                result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry));
                result.add(new com.vzome.core.tools.TranslationToolFactory(tools));
                result.add(new com.vzome.core.tools.ProjectionToolFactory(tools));
                result.add(new com.vzome.core.tools.PerspectiveProjectionToolFactory(tools));
                break;
            case com.vzome.api.Tool.Kind.LINEAR_MAP:
                result.add(new com.vzome.core.tools.LinearMapToolFactory(tools, this.symmetry, false));
                break;
            default:
                break;
            }
            return result;
        }

        /**
         * 
         * @param {com.vzome.api.Tool.Kind} kind
         * @param {com.vzome.core.editor.ToolsModel} tools
         * @return {*}
         */
        public predefineTools(kind: com.vzome.api.Tool.Kind, tools: com.vzome.core.editor.ToolsModel): java.util.List<com.vzome.api.Tool> {
            const result: java.util.List<com.vzome.api.Tool> = <any>(new java.util.ArrayList<any>());
            switch((kind)) {
            case com.vzome.api.Tool.Kind.SYMMETRY:
                result.add(new com.vzome.core.tools.OctahedralToolFactory(tools, this.symmetry).createPredefinedTool("octahedral around origin"));
                result.add(new com.vzome.core.tools.TetrahedralToolFactory(tools, this.symmetry).createPredefinedTool("tetrahedral around origin"));
                result.add(new com.vzome.core.tools.InversionToolFactory(tools).createPredefinedTool("reflection through origin"));
                result.add(new com.vzome.core.tools.MirrorToolFactory(tools).createPredefinedTool("reflection through XY plane"));
                result.add(new com.vzome.core.tools.MirrorToolFactory(tools).createPredefinedTool("reflection through X=Y green plane"));
                result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry).createPredefinedTool("symmetry around green through origin"));
                break;
            case com.vzome.api.Tool.Kind.TRANSFORM:
                result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale down"));
                result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale up"));
                result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry, true).createPredefinedTool("rotate around green through origin"));
                result.add(new com.vzome.core.tools.TranslationToolFactory(tools).createPredefinedTool("b1 move along +X"));
                break;
            default:
                break;
            }
            return result;
        }

        /**
         * 
         * @return {string}
         */
        public getModelResourcePath(): string {
            return this.modelResourcePath;
        }

        /*private*/ modelResourcePath: string;

        public setModelResourcePath(resourcePath: string) {
            this.modelResourcePath = resourcePath;
        }
    }
    OctahedralSymmetryPerspective["__class"] = "com.vzome.core.kinds.OctahedralSymmetryPerspective";
    OctahedralSymmetryPerspective["__interfaces"] = ["com.vzome.core.editor.SymmetryPerspective"];


}
namespace com.vzome.core.kinds {
    export class IcosahedralSymmetryPerspective extends com.vzome.core.kinds.AbstractSymmetryPerspective {
        /*private*/ qSymmH4: com.vzome.core.math.symmetry.QuaternionicSymmetry;

        /*private*/ qSymmH4_ROT: com.vzome.core.math.symmetry.QuaternionicSymmetry;

        /*private*/ qSymmT2: com.vzome.core.math.symmetry.QuaternionicSymmetry;

        /*private*/ cmdIcosasymm: com.vzome.core.commands.Command;

        /*private*/ cmdTetrasymm: com.vzome.core.commands.Command;

        /*private*/ cmdAxialsymm: com.vzome.core.commands.Command;

        /*private*/ cmdH4symmetry: com.vzome.core.commands.Command;

        /*private*/ cmdH4rotations: com.vzome.core.commands.Command;

        /*private*/ cmdIxTsymmetry: com.vzome.core.commands.Command;

        /*private*/ cmdTxTsymmetry: com.vzome.core.commands.Command;

        /*private*/ cmdVanOss600cell: com.vzome.core.commands.Command;

        public constructor(af?: any) {
            if (((af != null && (af.constructor != null && af.constructor["__interfaces"] != null && af.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || af === null)) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let symm: any = new com.vzome.core.math.symmetry.IcosahedralSymmetry(af);
                    super(symm);
                    if (this.qSymmH4 === undefined) { this.qSymmH4 = null; } 
                    if (this.qSymmH4_ROT === undefined) { this.qSymmH4_ROT = null; } 
                    if (this.qSymmT2 === undefined) { this.qSymmT2 = null; } 
                    if (this.cmdIcosasymm === undefined) { this.cmdIcosasymm = null; } 
                    if (this.cmdTetrasymm === undefined) { this.cmdTetrasymm = null; } 
                    if (this.cmdAxialsymm === undefined) { this.cmdAxialsymm = null; } 
                    if (this.cmdH4symmetry === undefined) { this.cmdH4symmetry = null; } 
                    if (this.cmdH4rotations === undefined) { this.cmdH4rotations = null; } 
                    if (this.cmdIxTsymmetry === undefined) { this.cmdIxTsymmetry = null; } 
                    if (this.cmdTxTsymmetry === undefined) { this.cmdTxTsymmetry = null; } 
                    if (this.cmdVanOss600cell === undefined) { this.cmdVanOss600cell = null; } 
                    const icosadefaultShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "default", "solid connectors", this.symmetry);
                    const printableShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "printable", "printable", this.symmetry, icosadefaultShapes);
                    const lifelikeShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "lifelike", "lifelike", this.symmetry, icosadefaultShapes);
                    const tinyShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "tiny", "tiny connectors", this.symmetry);
                    const tinyDodecs: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "dodecs", "small dodecahedra", "tiny dodecahedra", this.symmetry, tinyShapes);
                    const bigZome: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "bigzome", "Big Zome", this.symmetry, tinyShapes);
                    const noTwist: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "noTwist", "no-twist 121 zone", this.symmetry, true);
                    const vienne2: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "vienne2", "Vienne", this.symmetry, icosadefaultShapes);
                    const vienne3: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "vienne3", "Vienne lifelike", this.symmetry, vienne2);
                    const vienne: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "vienne", "Vienne 121 zone", this.symmetry, true);
                    const dimtoolShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "dimtool", "dimtool", this.symmetry, icosadefaultShapes);
                    this.setDefaultGeometry(printableShapes);
                    this.addShapes(icosadefaultShapes);
                    this.addShapes(lifelikeShapes);
                    this.addShapes(tinyShapes);
                    this.addShapes(tinyDodecs);
                    this.addShapes(bigZome);
                    this.addShapes(noTwist);
                    this.addShapes(vienne2);
                    this.addShapes(vienne3);
                    this.addShapes(vienne);
                    this.addShapes(dimtoolShapes);
                    const field: com.vzome.core.algebra.AlgebraicField = this.symmetry.getField();
                    this.qSymmH4 = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", field);
                    this.qSymmH4_ROT = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H4_ROT", "com/vzome/core/math/symmetry/H4roots-rotationalSubgroup.vef", field);
                    this.qSymmT2 = new com.vzome.core.math.symmetry.QuaternionicSymmetry("2T", "com/vzome/core/math/symmetry/binaryTetrahedralGroup.vef", field);
                    this.cmdIcosasymm = new com.vzome.core.commands.CommandSymmetry(this.symmetry);
                    this.cmdTetrasymm = new com.vzome.core.commands.CommandTetrahedralSymmetry(this.symmetry);
                    this.cmdAxialsymm = new com.vzome.core.commands.CommandAxialSymmetry(this.symmetry);
                    this.cmdH4symmetry = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmH4, this.qSymmH4);
                    this.cmdH4rotations = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmH4_ROT, this.qSymmH4_ROT);
                    this.cmdIxTsymmetry = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmH4, this.qSymmT2);
                    this.cmdTxTsymmetry = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmT2, this.qSymmT2);
                    this.cmdVanOss600cell = new com.vzome.core.commands.CommandVanOss600Cell();
                }
            } else if (((af != null && af instanceof <any>com.vzome.core.math.symmetry.IcosahedralSymmetry) || af === null)) {
                let __args = arguments;
                let symm: any = __args[0];
                super(symm);
                if (this.qSymmH4 === undefined) { this.qSymmH4 = null; } 
                if (this.qSymmH4_ROT === undefined) { this.qSymmH4_ROT = null; } 
                if (this.qSymmT2 === undefined) { this.qSymmT2 = null; } 
                if (this.cmdIcosasymm === undefined) { this.cmdIcosasymm = null; } 
                if (this.cmdTetrasymm === undefined) { this.cmdTetrasymm = null; } 
                if (this.cmdAxialsymm === undefined) { this.cmdAxialsymm = null; } 
                if (this.cmdH4symmetry === undefined) { this.cmdH4symmetry = null; } 
                if (this.cmdH4rotations === undefined) { this.cmdH4rotations = null; } 
                if (this.cmdIxTsymmetry === undefined) { this.cmdIxTsymmetry = null; } 
                if (this.cmdTxTsymmetry === undefined) { this.cmdTxTsymmetry = null; } 
                if (this.cmdVanOss600cell === undefined) { this.cmdVanOss600cell = null; } 
                const icosadefaultShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "default", "solid connectors", this.symmetry);
                const printableShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "printable", "printable", this.symmetry, icosadefaultShapes);
                const lifelikeShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "lifelike", "lifelike", this.symmetry, icosadefaultShapes);
                const tinyShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "tiny", "tiny connectors", this.symmetry);
                const tinyDodecs: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "dodecs", "small dodecahedra", "tiny dodecahedra", this.symmetry, tinyShapes);
                const bigZome: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "bigzome", "Big Zome", this.symmetry, tinyShapes);
                const noTwist: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "noTwist", "no-twist 121 zone", this.symmetry, true);
                const vienne2: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "vienne2", "Vienne", this.symmetry, icosadefaultShapes);
                const vienne3: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "vienne3", "Vienne lifelike", this.symmetry, vienne2);
                const vienne: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "vienne", "Vienne 121 zone", this.symmetry, true);
                const dimtoolShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "dimtool", "dimtool", this.symmetry, icosadefaultShapes);
                this.setDefaultGeometry(printableShapes);
                this.addShapes(icosadefaultShapes);
                this.addShapes(lifelikeShapes);
                this.addShapes(tinyShapes);
                this.addShapes(tinyDodecs);
                this.addShapes(bigZome);
                this.addShapes(noTwist);
                this.addShapes(vienne2);
                this.addShapes(vienne3);
                this.addShapes(vienne);
                this.addShapes(dimtoolShapes);
                const field: com.vzome.core.algebra.AlgebraicField = this.symmetry.getField();
                this.qSymmH4 = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", field);
                this.qSymmH4_ROT = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H4_ROT", "com/vzome/core/math/symmetry/H4roots-rotationalSubgroup.vef", field);
                this.qSymmT2 = new com.vzome.core.math.symmetry.QuaternionicSymmetry("2T", "com/vzome/core/math/symmetry/binaryTetrahedralGroup.vef", field);
                this.cmdIcosasymm = new com.vzome.core.commands.CommandSymmetry(this.symmetry);
                this.cmdTetrasymm = new com.vzome.core.commands.CommandTetrahedralSymmetry(this.symmetry);
                this.cmdAxialsymm = new com.vzome.core.commands.CommandAxialSymmetry(this.symmetry);
                this.cmdH4symmetry = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmH4, this.qSymmH4);
                this.cmdH4rotations = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmH4_ROT, this.qSymmH4_ROT);
                this.cmdIxTsymmetry = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmH4, this.qSymmT2);
                this.cmdTxTsymmetry = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmT2, this.qSymmT2);
                this.cmdVanOss600cell = new com.vzome.core.commands.CommandVanOss600Cell();
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {com.vzome.core.math.symmetry.IcosahedralSymmetry}
         */
        public getSymmetry(): com.vzome.core.math.symmetry.IcosahedralSymmetry {
            return <com.vzome.core.math.symmetry.IcosahedralSymmetry><any>this.symmetry;
        }

        /**
         * 
         * @param {com.vzome.api.Tool.Kind} kind
         * @param {com.vzome.core.editor.ToolsModel} tools
         * @return {*}
         */
        public createToolFactories(kind: com.vzome.api.Tool.Kind, tools: com.vzome.core.editor.ToolsModel): java.util.List<com.vzome.api.Tool.Factory> {
            const result: java.util.List<com.vzome.api.Tool.Factory> = <any>(new java.util.ArrayList<any>());
            const icosaSymm: com.vzome.core.math.symmetry.IcosahedralSymmetry = this.getSymmetry();
            switch((kind)) {
            case com.vzome.api.Tool.Kind.SYMMETRY:
                result.add(new com.vzome.core.tools.IcosahedralToolFactory(tools, icosaSymm));
                result.add(new com.vzome.core.tools.TetrahedralToolFactory(tools, icosaSymm));
                result.add(new com.vzome.core.tools.InversionToolFactory(tools));
                result.add(new com.vzome.core.tools.LineReflectionToolFactory(tools));
                result.add(new com.vzome.core.tools.MirrorToolFactory(tools));
                result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, icosaSymm));
                break;
            case com.vzome.api.Tool.Kind.TRANSFORM:
                result.add(new com.vzome.core.tools.ScalingToolFactory(tools, icosaSymm));
                result.add(new com.vzome.core.tools.RotationToolFactory(tools, icosaSymm));
                result.add(new com.vzome.core.tools.TranslationToolFactory(tools));
                result.add(new com.vzome.core.tools.ProjectionToolFactory(tools));
                result.add(new com.vzome.core.tools.PerspectiveProjectionToolFactory(tools));
                break;
            case com.vzome.api.Tool.Kind.LINEAR_MAP:
                result.add(new com.vzome.core.tools.AxialStretchTool.Factory(tools, icosaSymm, true, true, true));
                result.add(new com.vzome.core.tools.AxialStretchTool.Factory(tools, icosaSymm, true, false, true));
                result.add(new com.vzome.core.tools.AxialStretchTool.Factory(tools, icosaSymm, true, true, false));
                result.add(new com.vzome.core.tools.AxialStretchTool.Factory(tools, icosaSymm, true, false, false));
                result.add(new com.vzome.core.tools.AxialStretchTool.Factory(tools, icosaSymm, false, true, false));
                result.add(new com.vzome.core.tools.AxialStretchTool.Factory(tools, icosaSymm, false, false, false));
                result.add(new com.vzome.core.tools.LinearMapToolFactory(tools, icosaSymm, false));
                break;
            default:
                break;
            }
            return result;
        }

        /**
         * 
         * @param {com.vzome.api.Tool.Kind} kind
         * @param {com.vzome.core.editor.ToolsModel} tools
         * @return {*}
         */
        public predefineTools(kind: com.vzome.api.Tool.Kind, tools: com.vzome.core.editor.ToolsModel): java.util.List<com.vzome.api.Tool> {
            const result: java.util.List<com.vzome.api.Tool> = <any>(new java.util.ArrayList<any>());
            const icosaSymm: com.vzome.core.math.symmetry.IcosahedralSymmetry = this.getSymmetry();
            switch((kind)) {
            case com.vzome.api.Tool.Kind.SYMMETRY:
                result.add(new com.vzome.core.tools.IcosahedralToolFactory(tools, icosaSymm).createPredefinedTool("icosahedral around origin"));
                result.add(new com.vzome.core.tools.TetrahedralToolFactory(tools, icosaSymm).createPredefinedTool("tetrahedral around origin"));
                result.add(new com.vzome.core.tools.InversionToolFactory(tools).createPredefinedTool("reflection through origin"));
                result.add(new com.vzome.core.tools.MirrorToolFactory(tools).createPredefinedTool("reflection through XY plane"));
                result.add(new com.vzome.core.tools.MirrorToolFactory(tools).createPredefinedTool("reflection through X=Y green plane"));
                result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, icosaSymm).createPredefinedTool("symmetry around red through origin"));
                break;
            case com.vzome.api.Tool.Kind.TRANSFORM:
                result.add(new com.vzome.core.tools.ScalingToolFactory(tools, icosaSymm).createPredefinedTool("scale down"));
                result.add(new com.vzome.core.tools.ScalingToolFactory(tools, icosaSymm).createPredefinedTool("scale up"));
                result.add(new com.vzome.core.tools.RotationToolFactory(tools, icosaSymm, true).createPredefinedTool("rotate around red through origin"));
                result.add(new com.vzome.core.tools.TranslationToolFactory(tools).createPredefinedTool("b1 move along +X"));
                break;
            default:
                break;
            }
            return result;
        }

        /**
         * 
         * @param {string} action
         * @return {*}
         */
        public getLegacyCommand(action: string): com.vzome.core.commands.Command {
            switch((action)) {
            case "icosasymm":
                return this.cmdIcosasymm;
            case "tetrasymm":
                return this.cmdTetrasymm;
            case "axialsymm":
                return this.cmdAxialsymm;
            case "h4symmetry":
                return this.cmdH4symmetry;
            case "h4rotations":
                return this.cmdH4rotations;
            case "IxTsymmetry":
                return this.cmdIxTsymmetry;
            case "TxTsymmetry":
                return this.cmdTxTsymmetry;
            case "vanOss600cell":
                return this.cmdVanOss600cell;
            default:
                return super.getLegacyCommand(action);
            }
        }

        public getQuaternionSymmetry(name: string): com.vzome.core.math.symmetry.QuaternionicSymmetry {
            switch((name)) {
            case "H_4":
                return this.qSymmH4;
            case "H4_ROT":
                return this.qSymmH4_ROT;
            case "2T":
                return this.qSymmT2;
            default:
                return null;
            }
        }

        /**
         * 
         * @return {string}
         */
        public getModelResourcePath(): string {
            return "org/vorthmann/zome/app/icosahedral-vef.vZome";
        }
    }
    IcosahedralSymmetryPerspective["__class"] = "com.vzome.core.kinds.IcosahedralSymmetryPerspective";
    IcosahedralSymmetryPerspective["__interfaces"] = ["com.vzome.core.editor.SymmetryPerspective"];


}
namespace com.vzome.core.kinds {
    /**
     * Everything here is stateless, or at worst, a cache (like Shapes).
     * An instance of this can be shared by many DocumentModels.
     * This is why it does not have tool factories, though it does
     * dictate what tool factories will be present.
     * 
     * @author Scott Vorthmann
     * @param {*} field
     * @class
     * @extends com.vzome.core.kinds.DefaultFieldApplication
     */
    export class HeptagonFieldApplication extends com.vzome.core.kinds.DefaultFieldApplication {
        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            super(field);
            this.correctedAntiprismPerspective = new HeptagonFieldApplication.HeptagonalSymmetryPerspective(this, true);
            this.originalAntiprismPerspective = new HeptagonFieldApplication.HeptagonalSymmetryPerspective(this, false);
        }

        /**
         * 
         * @return {string}
         */
        public getLabel(): string {
            return "Heptagon";
        }

        /*private*/ correctedAntiprismPerspective: com.vzome.core.editor.SymmetryPerspective;

        /*private*/ originalAntiprismPerspective: com.vzome.core.editor.SymmetryPerspective;

        /**
         * 
         * @return {*}
         */
        public getSymmetryPerspectives(): java.util.Collection<com.vzome.core.editor.SymmetryPerspective> {
            return java.util.Arrays.asList<any>(this.correctedAntiprismPerspective, super.getDefaultSymmetryPerspective(), this.originalAntiprismPerspective);
        }

        /**
         * 
         * @return {*}
         */
        public getDefaultSymmetryPerspective(): com.vzome.core.editor.SymmetryPerspective {
            return this.correctedAntiprismPerspective;
        }

        /**
         * 
         * @param {string} symmName
         * @return {*}
         */
        public getSymmetryPerspective(symmName: string): com.vzome.core.editor.SymmetryPerspective {
            switch((symmName)) {
            case "heptagonal antiprism corrected":
                return this.correctedAntiprismPerspective;
            case "heptagonal antiprism":
                return this.originalAntiprismPerspective;
            default:
                return super.getSymmetryPerspective(symmName);
            }
        }
    }
    HeptagonFieldApplication["__class"] = "com.vzome.core.kinds.HeptagonFieldApplication";
    HeptagonFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D","com.vzome.core.editor.FieldApplication"];



    export namespace HeptagonFieldApplication {

        export class HeptagonalSymmetryPerspective extends com.vzome.core.kinds.AbstractSymmetryPerspective {
            public __parent: any;
            corrected: boolean;

            constructor(__parent: any, corrected: boolean) {
                super(new com.vzome.fields.heptagon.HeptagonalAntiprismSymmetry(__parent.getField(), "blue", corrected).createStandardOrbits("blue"));
                this.__parent = __parent;
                if (this.corrected === undefined) { this.corrected = false; }
                this.axialsymm = new com.vzome.core.commands.CommandAxialSymmetry(this.symmetry);
                this.corrected = corrected;
                const octahedralShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.OctahedralShapes("octahedral", "triangular antiprism", this.symmetry);
                const antiprismShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "heptagon/antiprism", "heptagonal antiprism", this.symmetry, octahedralShapes);
                this.setDefaultGeometry(antiprismShapes);
                this.addShapes(octahedralShapes);
            }

            /**
             * 
             * @return {string}
             */
            public getLabel(): string {
                return this.corrected ? "heptagonal antiprism" : null;
            }

            /**
             * 
             * @param {com.vzome.api.Tool.Kind} kind
             * @param {com.vzome.core.editor.ToolsModel} tools
             * @return {*}
             */
            public createToolFactories(kind: com.vzome.api.Tool.Kind, tools: com.vzome.core.editor.ToolsModel): java.util.List<com.vzome.api.Tool.Factory> {
                const result: java.util.List<com.vzome.api.Tool.Factory> = <any>(new java.util.ArrayList<any>());
                switch((kind)) {
                case com.vzome.api.Tool.Kind.SYMMETRY:
                    result.add(new com.vzome.core.tools.SymmetryToolFactory(tools, this.symmetry));
                    result.add(new com.vzome.core.tools.LineReflectionToolFactory(tools));
                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools));
                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry));
                    break;
                case com.vzome.api.Tool.Kind.TRANSFORM:
                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry));
                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry));
                    result.add(new com.vzome.core.tools.TranslationToolFactory(tools));
                    break;
                case com.vzome.api.Tool.Kind.LINEAR_MAP:
                    result.add(new com.vzome.core.tools.LinearMapToolFactory(tools, this.symmetry, false));
                    break;
                default:
                    break;
                }
                return result;
            }

            /**
             * 
             * @param {com.vzome.api.Tool.Kind} kind
             * @param {com.vzome.core.editor.ToolsModel} tools
             * @return {*}
             */
            public predefineTools(kind: com.vzome.api.Tool.Kind, tools: com.vzome.core.editor.ToolsModel): java.util.List<com.vzome.api.Tool> {
                const result: java.util.List<com.vzome.api.Tool> = <any>(new java.util.ArrayList<any>());
                switch((kind)) {
                case com.vzome.api.Tool.Kind.SYMMETRY:
                    result.add(new com.vzome.core.tools.SymmetryToolFactory(tools, this.symmetry).createPredefinedTool("heptagonal antiprism around origin"));
                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools).createPredefinedTool("reflection through XY plane"));
                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry).createPredefinedTool("symmetry around red through origin"));
                    break;
                case com.vzome.api.Tool.Kind.TRANSFORM:
                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale down"));
                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale up"));
                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry, true).createPredefinedTool("rotate around red through origin"));
                    result.add(new com.vzome.core.tools.TranslationToolFactory(tools).createPredefinedTool("b1 move along +X"));
                    break;
                default:
                    break;
                }
                return result;
            }

            axialsymm: com.vzome.core.commands.Command;

            /**
             * 
             * @param {string} action
             * @return {*}
             */
            public getLegacyCommand(action: string): com.vzome.core.commands.Command {
                switch((action)) {
                case "axialsymm":
                    return this.axialsymm;
                default:
                    return super.getLegacyCommand(action);
                }
            }

            /**
             * 
             * @return {string}
             */
            public getModelResourcePath(): string {
                return "org/vorthmann/zome/app/heptagonal antiprism.vZome";
            }
        }
        HeptagonalSymmetryPerspective["__class"] = "com.vzome.core.kinds.HeptagonFieldApplication.HeptagonalSymmetryPerspective";
        HeptagonalSymmetryPerspective["__interfaces"] = ["com.vzome.core.editor.SymmetryPerspective"];


    }

}
namespace com.vzome.core.kinds {
    /**
     * Everything here is stateless, or at worst, a cache (like Shapes).
     * An instance of this can be shared by many DocumentModels.
     * This is why it does not have tool factories, though it does
     * dictate what tool factories will be present.
     * 
     * @author David Hall
     * @param {com.vzome.core.algebra.PolygonField} field
     * @class
     * @extends com.vzome.core.kinds.DefaultFieldApplication
     */
    export class PolygonFieldApplication extends com.vzome.core.kinds.DefaultFieldApplication {
        public constructor(field: com.vzome.core.algebra.PolygonField) {
            super(field);
            this.symmetryPerspectives = <any>(new java.util.ArrayList<any>());
            if (this.icosahedralPerspective === undefined) { this.icosahedralPerspective = null; }
            if (this.H4 === undefined) { this.H4 = null; }
            this.h4Builder = null;
            this.symmetryPerspectives.add(new PolygonFieldApplication.AntiprismSymmetryPerspective(this));
            if (field.polygonSides() === 5){
                this.icosahedralPerspective = new com.vzome.core.kinds.IcosahedralSymmetryPerspective(this.getField());
                this.symmetryPerspectives.add(this.icosahedralPerspective);
                this.H4 = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", this.getField());
            } else {
                this.icosahedralPerspective = null;
                this.H4 = null;
            }
            this.symmetryPerspectives.add(super.getDefaultSymmetryPerspective());
        }

        /**
         * 
         * @return {com.vzome.core.algebra.PolygonField}
         */
        public getField(): com.vzome.core.algebra.PolygonField {
            return <com.vzome.core.algebra.PolygonField><any>super.getField();
        }

        symmetryPerspectives: java.util.ArrayList<com.vzome.core.editor.SymmetryPerspective>;

        /**
         * 
         * @return {*}
         */
        public getSymmetryPerspectives(): java.util.Collection<com.vzome.core.editor.SymmetryPerspective> {
            return this.symmetryPerspectives;
        }

        /*private*/ icosahedralPerspective: com.vzome.core.kinds.IcosahedralSymmetryPerspective;

        /**
         * 
         * @return {*}
         */
        public getDefaultSymmetryPerspective(): com.vzome.core.editor.SymmetryPerspective {
            return (this.icosahedralPerspective == null) ? this.symmetryPerspectives.get(0) : this.icosahedralPerspective;
        }

        /**
         * 
         * @param {string} symmName
         * @return {*}
         */
        public getSymmetryPerspective(symmName: string): com.vzome.core.editor.SymmetryPerspective {
            for(let index=this.symmetryPerspectives.iterator();index.hasNext();) {
                let sp = index.next();
                {
                    if (sp.getName() === symmName){
                        return sp;
                    }
                }
            }
            return super.getSymmetryPerspective(symmName);
        }

        /**
         * 
         * @param {*} toolFactories
         * @param {com.vzome.core.editor.ToolsModel} tools
         */
        public registerToolFactories(toolFactories: java.util.Map<string, com.vzome.api.Tool.Factory>, tools: com.vzome.core.editor.ToolsModel) {
            super.registerToolFactories(toolFactories, tools);
            if (this.icosahedralPerspective != null){
                const symm: com.vzome.core.math.symmetry.IcosahedralSymmetry = this.icosahedralPerspective.getSymmetry();
                toolFactories.put("AxialStretchTool", new com.vzome.core.tools.AxialStretchTool.Factory(tools, symm, false, false, false));
                toolFactories.put("SymmetryTool", new com.vzome.core.tools.IcosahedralToolFactory(tools, symm));
            }
        }

        /*private*/ H4: com.vzome.core.math.symmetry.QuaternionicSymmetry;

        /**
         * 
         * @param {string} name
         * @return {com.vzome.core.math.symmetry.QuaternionicSymmetry}
         */
        public getQuaternionSymmetry(name: string): com.vzome.core.math.symmetry.QuaternionicSymmetry {
            switch((name)) {
            case "H_4":
                return this.H4;
            default:
                return null;
            }
        }

        /*private*/ h4Builder: com.vzome.core.commands.CommandUniformH4Polytope;

        /**
         * 
         * @param {string} groupName
         * @param {number} index
         * @param {number} edgesToRender
         * @param {com.vzome.core.algebra.AlgebraicNumber[]} edgeScales
         * @param {*} listener
         */
        public constructPolytope(groupName: string, index: number, edgesToRender: number, edgeScales: com.vzome.core.algebra.AlgebraicNumber[], listener: com.vzome.core.math.symmetry.WythoffConstruction.Listener) {
            switch((groupName)) {
            case "H4":
                if (this.h4Builder == null){
                    const qsymm: com.vzome.core.math.symmetry.QuaternionicSymmetry = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", this.getField());
                    this.h4Builder = new com.vzome.core.commands.CommandUniformH4Polytope(this.getField(), qsymm, 0);
                }
                this.h4Builder.generate(index, edgesToRender, edgeScales, listener);
                break;
            default:
                super.constructPolytope(groupName, index, edgesToRender, edgeScales, listener);
                break;
            }
        }
    }
    PolygonFieldApplication["__class"] = "com.vzome.core.kinds.PolygonFieldApplication";
    PolygonFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D","com.vzome.core.editor.FieldApplication"];



    export namespace PolygonFieldApplication {

        export class AntiprismSymmetryPerspective extends com.vzome.core.kinds.AbstractSymmetryPerspective {
            public __parent: any;
            constructor(__parent: any) {
                super(new com.vzome.core.math.symmetry.AntiprismSymmetry(__parent.getField()).createStandardOrbits("blue"));
                this.__parent = __parent;
                this.axialsymm = new com.vzome.core.commands.CommandAxialSymmetry(this.symmetry);
                const thinAntiprismShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.AntiprismShapes("thin", "thin antiprism", this.getSymmetry());
                const antiprismShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.AntiprismShapes("antiprism", "antiprism", this.getSymmetry());
                const octahedralShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.OctahedralShapes("octahedral", "octahedral", this.symmetry);
                this.setDefaultGeometry(thinAntiprismShapes);
                this.addShapes(antiprismShapes);
                this.addShapes(octahedralShapes);
            }

            /**
             * 
             * @return {string}
             */
            public getLabel(): string {
                return "antiprism";
            }

            /**
             * 
             * @return {com.vzome.core.math.symmetry.AntiprismSymmetry}
             */
            public getSymmetry(): com.vzome.core.math.symmetry.AntiprismSymmetry {
                return <com.vzome.core.math.symmetry.AntiprismSymmetry><any>super.getSymmetry();
            }

            /**
             * 
             * @param {com.vzome.api.Tool.Kind} kind
             * @param {com.vzome.core.editor.ToolsModel} tools
             * @return {*}
             */
            public createToolFactories(kind: com.vzome.api.Tool.Kind, tools: com.vzome.core.editor.ToolsModel): java.util.List<com.vzome.api.Tool.Factory> {
                const isTrivial: boolean = this.symmetry.isTrivial();
                const result: java.util.List<com.vzome.api.Tool.Factory> = <any>(new java.util.ArrayList<any>());
                switch((kind)) {
                case com.vzome.api.Tool.Kind.SYMMETRY:
                    result.add(new com.vzome.core.tools.SymmetryToolFactory(tools, this.symmetry));
                    if (isTrivial){
                        result.add(new com.vzome.core.tools.InversionToolFactory(tools));
                    }
                    result.add(new com.vzome.core.tools.LineReflectionToolFactory(tools));
                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools));
                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry));
                    break;
                case com.vzome.api.Tool.Kind.TRANSFORM:
                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry));
                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry));
                    result.add(new com.vzome.core.tools.TranslationToolFactory(tools));
                    if (isTrivial){
                        result.add(new com.vzome.core.tools.ProjectionToolFactory(tools));
                    }
                    break;
                case com.vzome.api.Tool.Kind.LINEAR_MAP:
                    result.add(new com.vzome.core.tools.LinearMapToolFactory(tools, this.symmetry, false));
                    break;
                default:
                    break;
                }
                return result;
            }

            /**
             * 
             * @param {com.vzome.api.Tool.Kind} kind
             * @param {com.vzome.core.editor.ToolsModel} tools
             * @return {*}
             */
            public predefineTools(kind: com.vzome.api.Tool.Kind, tools: com.vzome.core.editor.ToolsModel): java.util.List<com.vzome.api.Tool> {
                const result: java.util.List<com.vzome.api.Tool> = <any>(new java.util.ArrayList<any>());
                switch((kind)) {
                case com.vzome.api.Tool.Kind.SYMMETRY:
                    result.add(new com.vzome.core.tools.SymmetryToolFactory(tools, this.symmetry).createPredefinedTool("polygonal antiprism around origin"));
                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools).createPredefinedTool("reflection through XY plane"));
                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry, true).createPredefinedTool("symmetry around red through origin"));
                    break;
                case com.vzome.api.Tool.Kind.TRANSFORM:
                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale down"));
                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale up"));
                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry, true).createPredefinedTool("rotate around red through origin"));
                    break;
                default:
                    break;
                }
                return result;
            }

            axialsymm: com.vzome.core.commands.Command;

            /**
             * 
             * @param {string} action
             * @return {*}
             */
            public getLegacyCommand(action: string): com.vzome.core.commands.Command {
                switch((action)) {
                case "axialsymm":
                    return this.axialsymm;
                default:
                    return super.getLegacyCommand(action);
                }
            }

            /**
             * 
             * @return {string}
             */
            public getModelResourcePath(): string {
                return "org/vorthmann/zome/app/antiprism-trackball-template.vZome";
            }
        }
        AntiprismSymmetryPerspective["__class"] = "com.vzome.core.kinds.PolygonFieldApplication.AntiprismSymmetryPerspective";
        AntiprismSymmetryPerspective["__interfaces"] = ["com.vzome.core.editor.SymmetryPerspective"];


    }

}
namespace com.vzome.core.kinds {
    export class SnubCubeFieldApplication extends com.vzome.core.kinds.DefaultFieldApplication {
        public constructor(field: com.vzome.core.algebra.SnubCubeField) {
            super(field);
            const symmPerspective: com.vzome.core.kinds.OctahedralSymmetryPerspective = <com.vzome.core.kinds.OctahedralSymmetryPerspective><any>super.getDefaultSymmetryPerspective();
            symmPerspective.setModelResourcePath("org/vorthmann/zome/app/snubCubeTrackball-vef.vZome");
            const symm: com.vzome.core.math.symmetry.AbstractSymmetry = symmPerspective.getSymmetry();
            const vSnubSquare: com.vzome.core.algebra.AlgebraicVector = field.createVector([[1, 1, 0, 1, 0, 1], [0, 1, 2, 1, -1, 1], [0, 1, 0, 1, 0, 1]]);
            const vSnubTriangle: com.vzome.core.algebra.AlgebraicVector = field.createVector([[1, 1, 0, 1, 0, 1], [1, 2, 1, 1, -1, 2], [1, 2, -1, 1, 1, 2]]);
            const vSnubDiagonal: com.vzome.core.algebra.AlgebraicVector = field.createVector([[1, 1, 0, 1, 0, 1], [0, 1, -1, 2, 1, 2], [0, 1, -1, 2, 1, 2]]);
            const vSnubFaceNormal: com.vzome.core.algebra.AlgebraicVector = field.createVector([[1, 1, 0, 1, 0, 1], [-2, 7, 2, 7, 1, 7], [-1, 7, -6, 7, 4, 7]]);
            const vSnubVertex: com.vzome.core.algebra.AlgebraicVector = field.createVector([[1, 1, 0, 1, 0, 1], [-1, 1, -1, 1, 1, 1], [0, 1, 2, 1, -1, 1]]);
            const vSnubSquareMidEdge: com.vzome.core.algebra.AlgebraicVector = field.createVector([[1, 1, 0, 1, 0, 1], [-1, 2, 1, 2, 0, 1], [-1, 2, -3, 2, 1, 1]]);
            const vSnubTriangleMidEdge: com.vzome.core.algebra.AlgebraicVector = field.createVector([[1, 1, 0, 1, 0, 1], [-1, 1, 1, 1, 0, 1], [-1, 1, -1, 1, 1, 1]]);
            const nSnubSquare: com.vzome.core.algebra.AlgebraicNumber = field.createAlgebraicNumber$int_A([-1, 1, 0]);
            const nSnubTriangle: com.vzome.core.algebra.AlgebraicNumber = field.createAlgebraicNumber$int_A([1, -2, 1]);
            const nSnubDiagonal: com.vzome.core.algebra.AlgebraicNumber = field.createAlgebraicNumber$int_A([0, 4, -2]);
            const nSnubFaceNormal: com.vzome.core.algebra.AlgebraicNumber = field.createAlgebraicNumber$int_A([2, 3, -2]);
            const nSnubVertex: com.vzome.core.algebra.AlgebraicNumber = field.one();
            const nSnubSquareMidEdge: com.vzome.core.algebra.AlgebraicNumber = field.one();
            const nSnubTriangleMidEdge: com.vzome.core.algebra.AlgebraicNumber = field.createAlgebraicNumber$int_A([0, -1, 1]).dividedBy(field.createRational$long(2));
            symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubSquare", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubSquare, false, false, nSnubSquare);
            symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubTriangle", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubTriangle, false, false, nSnubTriangle);
            symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubDiagonal", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubDiagonal, false, false, nSnubDiagonal);
            symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubFaceNormal", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubFaceNormal, true, false, nSnubFaceNormal);
            symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubVertex", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubVertex, true, false, nSnubVertex);
            symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubSquareMid", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubSquareMidEdge, false, false, nSnubSquareMidEdge);
            symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubTriangleMid", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubTriangleMidEdge, false, false, nSnubTriangleMidEdge);
            const defaultShapes: com.vzome.core.viewing.AbstractShapes = <com.vzome.core.viewing.AbstractShapes><any>symmPerspective.getDefaultGeometry();
            let resPath: string = "snubCube";
            const snubCubeRhShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, resPath, "snub cube right", null, symm, defaultShapes, false);
            const snubCubeLhShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, resPath, "snub cube left", null, symm, defaultShapes, true);
            resPath = "snubCube/dual";
            const snubDualRhShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, resPath, "snub cube dual right", null, symm, defaultShapes, false);
            const snubDualLhShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, resPath, "snub cube dual left", null, symm, defaultShapes, true);
            resPath = "snubCube/disdyakisDodec";
            const disdyakisDodec: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, resPath, "disdyakis dodec", null, symm, defaultShapes, false);
            symmPerspective.addShapes(disdyakisDodec);
            symmPerspective.addShapes(snubCubeRhShapes);
            symmPerspective.addShapes(snubCubeRhShapes);
            symmPerspective.addShapes(snubCubeLhShapes);
            symmPerspective.addShapes(snubDualRhShapes);
            symmPerspective.addShapes(snubDualLhShapes);
        }

        /**
         * 
         * @return {string}
         */
        public getLabel(): string {
            return "Snub Cube";
        }
    }
    SnubCubeFieldApplication["__class"] = "com.vzome.core.kinds.SnubCubeFieldApplication";
    SnubCubeFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D","com.vzome.core.editor.FieldApplication"];


}
namespace com.vzome.core.kinds {
    /**
     * Everything here is stateless, or at worst, a cache (like Shapes).
     * An instance of this can be shared by many DocumentModels.
     * This is why it does not have tool factories, though it does
     * dictate what tool factories will be present.
     * 
     * @author Scott Vorthmann
     * @param {*} field
     * @class
     * @extends com.vzome.core.kinds.DefaultFieldApplication
     */
    export class RootThreeFieldApplication extends com.vzome.core.kinds.DefaultFieldApplication {
        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            super(field);
            this.dodecagonalPerspective = new RootThreeFieldApplication.RootThreeFieldApplication$0(this, new com.vzome.core.math.symmetry.DodecagonalSymmetry(this.getField()));
            const octahedralPerspective: com.vzome.core.kinds.OctahedralSymmetryPerspective = <com.vzome.core.kinds.OctahedralSymmetryPerspective><any>super.getDefaultSymmetryPerspective();
            const symm: com.vzome.core.math.symmetry.AbstractSymmetry = octahedralPerspective.getSymmetry();
            symm.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean("red", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 1, 1, 2], [1, 2, 0, 1], [0, 1, 0, 1]], true);
            symm.createZoneOrbit$java_lang_String$int$int$int_A_A("brown", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 1, 0, 1], [1, 1, 0, 1], [2, 1, 0, 1]]);
            const defaultShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "rootThreeOctaSmall", "small octahedra", "small connectors", symm);
            octahedralPerspective.setDefaultGeometry(defaultShapes);
        }

        /**
         * 
         * @return {string}
         */
        public getLabel(): string {
            return "\u221a3";
        }

        /*private*/ dodecagonalPerspective: com.vzome.core.editor.SymmetryPerspective;

        /**
         * 
         * @return {*}
         */
        public getDefaultSymmetryPerspective(): com.vzome.core.editor.SymmetryPerspective {
            return this.dodecagonalPerspective;
        }

        /**
         * 
         * @return {*}
         */
        public getSymmetryPerspectives(): java.util.Collection<com.vzome.core.editor.SymmetryPerspective> {
            return java.util.Arrays.asList<any>(super.getDefaultSymmetryPerspective(), this.dodecagonalPerspective);
        }

        /**
         * 
         * @param {string} symmName
         * @return {*}
         */
        public getSymmetryPerspective(symmName: string): com.vzome.core.editor.SymmetryPerspective {
            switch((symmName)) {
            case "dodecagonal":
                return this.dodecagonalPerspective;
            default:
                return super.getSymmetryPerspective(symmName);
            }
        }
    }
    RootThreeFieldApplication["__class"] = "com.vzome.core.kinds.RootThreeFieldApplication";
    RootThreeFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D","com.vzome.core.editor.FieldApplication"];



    export namespace RootThreeFieldApplication {

        export class RootThreeFieldApplication$0 extends com.vzome.core.kinds.AbstractSymmetryPerspective {
            public __parent: any;
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "dodecagonal";
            }

            /**
             * 
             * @param {com.vzome.core.math.symmetry.Direction} orbit
             * @return {boolean}
             */
            public orbitIsBuildDefault(orbit: com.vzome.core.math.symmetry.Direction): boolean {
                switch((orbit.getName())) {
                case "blue":
                case "green":
                    return true;
                default:
                    return false;
                }
            }

            /**
             * 
             * @param {com.vzome.core.math.symmetry.Direction} orbit
             * @return {*}
             */
            public getOrbitUnitLength(orbit: com.vzome.core.math.symmetry.Direction): com.vzome.core.algebra.AlgebraicNumber {
                switch((orbit.getName())) {
                case "blue":
                case "green":
                    return this.__parent.getField()['createPower$int'](2);
                default:
                    return super.getOrbitUnitLength(orbit);
                }
            }

            /**
             * 
             * @param {com.vzome.api.Tool.Kind} kind
             * @param {com.vzome.core.editor.ToolsModel} tools
             * @return {*}
             */
            public createToolFactories(kind: com.vzome.api.Tool.Kind, tools: com.vzome.core.editor.ToolsModel): java.util.List<com.vzome.api.Tool.Factory> {
                const result: java.util.List<com.vzome.api.Tool.Factory> = <any>(new java.util.ArrayList<any>());
                switch((kind)) {
                case com.vzome.api.Tool.Kind.SYMMETRY:
                    result.add(new com.vzome.core.tools.SymmetryToolFactory(tools, this.symmetry));
                    result.add(new com.vzome.core.tools.InversionToolFactory(tools));
                    result.add(new com.vzome.core.tools.LineReflectionToolFactory(tools));
                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools));
                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry));
                    break;
                case com.vzome.api.Tool.Kind.TRANSFORM:
                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry));
                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry));
                    result.add(new com.vzome.core.tools.TranslationToolFactory(tools));
                    result.add(new com.vzome.core.tools.ProjectionToolFactory(tools));
                    break;
                case com.vzome.api.Tool.Kind.LINEAR_MAP:
                    result.add(new com.vzome.core.tools.LinearMapToolFactory(tools, this.symmetry, false));
                    break;
                default:
                    break;
                }
                return result;
            }

            /**
             * 
             * @param {com.vzome.api.Tool.Kind} kind
             * @param {com.vzome.core.editor.ToolsModel} tools
             * @return {*}
             */
            public predefineTools(kind: com.vzome.api.Tool.Kind, tools: com.vzome.core.editor.ToolsModel): java.util.List<com.vzome.api.Tool> {
                const result: java.util.List<com.vzome.api.Tool> = <any>(new java.util.ArrayList<any>());
                switch((kind)) {
                case com.vzome.api.Tool.Kind.SYMMETRY:
                    result.add(new com.vzome.core.tools.SymmetryToolFactory(tools, this.symmetry).createPredefinedTool("dodecagonal antiprism around origin"));
                    result.add(new com.vzome.core.tools.InversionToolFactory(tools).createPredefinedTool("reflection through origin"));
                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools).createPredefinedTool("reflection through XY plane"));
                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry).createPredefinedTool("symmetry around red through origin"));
                    break;
                case com.vzome.api.Tool.Kind.TRANSFORM:
                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale down"));
                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale up"));
                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry, true).createPredefinedTool("rotate around red through origin"));
                    result.add(new com.vzome.core.tools.TranslationToolFactory(tools).createPredefinedTool("b1 move along +X"));
                    break;
                default:
                    break;
                }
                return result;
            }

            dodecagonsymm: com.vzome.core.commands.Command;

            /**
             * 
             * @param {string} action
             * @return {*}
             */
            public getLegacyCommand(action: string): com.vzome.core.commands.Command {
                switch((action)) {
                case "dodecagonsymm":
                    return this.dodecagonsymm;
                default:
                    return super.getLegacyCommand(action);
                }
            }

            /**
             * 
             * @return {string}
             */
            public getModelResourcePath(): string {
                return "org/vorthmann/zome/app/12-gon-trackball-vef.vZome";
            }

            constructor(__parent: any, __arg0: any) {
                super(__arg0);
                this.__parent = __parent;
                (() => {
                    const defaultShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "dodecagon3d", "prisms", this.symmetry);
                    const hexagonShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.DodecagonalShapes("dodecagonal", "hexagons", "flat hexagons", this.symmetry);
                    this.setDefaultGeometry(defaultShapes);
                    this.addShapes(hexagonShapes);
                })();
                this.dodecagonsymm = new com.vzome.core.commands.CommandSymmetry(this.symmetry);
            }
        }
        RootThreeFieldApplication$0["__interfaces"] = ["com.vzome.core.editor.SymmetryPerspective"];


    }

}
namespace com.vzome.core.kinds {
    /**
     * Everything here is stateless, or at worst, a cache (like Shapes).
     * An instance of this can be shared by many DocumentModels.
     * This is why it does not have tool factories, though it does
     * dictate what tool factories will be present.
     * 
     * @author vorth
     * @param {*} field
     * @class
     * @extends com.vzome.core.kinds.DefaultFieldApplication
     */
    export class GoldenFieldApplication extends com.vzome.core.kinds.DefaultFieldApplication {
        /*private*/ icosahedralPerspective: com.vzome.core.kinds.IcosahedralSymmetryPerspective;

        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            super(field);
            if (this.icosahedralPerspective === undefined) { this.icosahedralPerspective = null; }
            this.h4Builder = null;
            this.cmdTauDivide = new com.vzome.core.commands.CommandTauDivision();
            this.icosahedralPerspective = new com.vzome.core.kinds.IcosahedralSymmetryPerspective(this.getField());
            const octahedralPerspective: com.vzome.core.kinds.OctahedralSymmetryPerspective = <com.vzome.core.kinds.OctahedralSymmetryPerspective><any>super.getDefaultSymmetryPerspective();
            const symm: com.vzome.core.math.symmetry.AbstractSymmetry = octahedralPerspective.getSymmetry();
            symm.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("yellow", 0, 4, [[0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]], true, false, this.getField()['createPower$int'](-1));
            symm.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("green", 1, 8, [[1, 1, 0, 1], [1, 1, 0, 1], [0, 1, 0, 1]], true, true, this.getField()['createRational$long'](2));
            symm.createZoneOrbit$java_lang_String$int$int$int_A_A("lavender", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[2, 1, -1, 1], [0, 1, 1, 1], [2, 1, -1, 1]]);
            symm.createZoneOrbit$java_lang_String$int$int$int_A_A("olive", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, 1, 1], [0, 1, 1, 1], [2, 1, -1, 1]]);
            symm.createZoneOrbit$java_lang_String$int$int$int_A_A("maroon", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[-1, 1, 1, 1], [3, 1, -1, 1], [1, 1, -1, 1]]);
            symm.createZoneOrbit$java_lang_String$int$int$int_A_A("brown", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[-1, 1, 1, 1], [-1, 1, 1, 1], [-2, 1, 2, 1]]);
            symm.createZoneOrbit$java_lang_String$int$int$int_A_A("red", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, 1, 1], [1, 1, 0, 1], [0, 1, 0, 1]]);
            symm.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("purple", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 1, 1, 1], [0, 1, 0, 1], [-1, 1, 0, 1]], false, false, this.getField()['createPower$int'](-1));
            symm.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("black", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 2, 0, 1], [0, 1, 1, 2], [-1, 2, 1, 2]], false, false, this.getField()['createRational$long'](2));
            symm.createZoneOrbit$java_lang_String$int$int$int_A_A("turquoise", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 1, 2, 1], [3, 1, 4, 1], [3, 1, 4, 1]]);
            const defaultShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "octahedral", "trapezoids", symm, null);
            octahedralPerspective.setDefaultGeometry(defaultShapes);
            octahedralPerspective.addShapes(new com.vzome.core.viewing.ExportedVEFShapes(null, "octahedralFast", "small octahedra", symm, null));
            octahedralPerspective.addShapes(new com.vzome.core.viewing.ExportedVEFShapes(null, "octahedralRealistic", "vZome logo", symm, defaultShapes));
        }

        /**
         * 
         * @return {string}
         */
        public getLabel(): string {
            return "Zome (Golden)";
        }

        /**
         * 
         * @return {*}
         */
        public getSymmetryPerspectives(): java.util.Collection<com.vzome.core.editor.SymmetryPerspective> {
            return java.util.Arrays.asList<any>(this.icosahedralPerspective, super.getDefaultSymmetryPerspective());
        }

        /**
         * 
         * @return {*}
         */
        public getDefaultSymmetryPerspective(): com.vzome.core.editor.SymmetryPerspective {
            return this.icosahedralPerspective;
        }

        /**
         * 
         * @param {string} symmName
         * @return {*}
         */
        public getSymmetryPerspective(symmName: string): com.vzome.core.editor.SymmetryPerspective {
            switch((symmName)) {
            case "icosahedral":
                return this.icosahedralPerspective;
            default:
                return super.getSymmetryPerspective(symmName);
            }
        }

        /**
         * 
         * @param {string} name
         * @return {com.vzome.core.math.symmetry.QuaternionicSymmetry}
         */
        public getQuaternionSymmetry(name: string): com.vzome.core.math.symmetry.QuaternionicSymmetry {
            return this.icosahedralPerspective.getQuaternionSymmetry(name);
        }

        /**
         * 
         * @param {*} toolFactories
         * @param {com.vzome.core.editor.ToolsModel} tools
         */
        public registerToolFactories(toolFactories: java.util.Map<string, com.vzome.api.Tool.Factory>, tools: com.vzome.core.editor.ToolsModel) {
            super.registerToolFactories(toolFactories, tools);
            const symm: com.vzome.core.math.symmetry.IcosahedralSymmetry = this.icosahedralPerspective.getSymmetry();
            toolFactories.put("AxialStretchTool", new com.vzome.core.tools.AxialStretchTool.Factory(tools, symm, false, false, false));
            toolFactories.put("SymmetryTool", new com.vzome.core.tools.IcosahedralToolFactory(tools, symm));
        }

        /*private*/ h4Builder: com.vzome.core.commands.CommandUniformH4Polytope;

        /**
         * 
         * @param {string} groupName
         * @param {number} index
         * @param {number} edgesToRender
         * @param {com.vzome.core.algebra.AlgebraicNumber[]} edgeScales
         * @param {*} listener
         */
        public constructPolytope(groupName: string, index: number, edgesToRender: number, edgeScales: com.vzome.core.algebra.AlgebraicNumber[], listener: com.vzome.core.math.symmetry.WythoffConstruction.Listener) {
            switch((groupName)) {
            case "H4":
                if (this.h4Builder == null){
                    const qsymm: com.vzome.core.math.symmetry.QuaternionicSymmetry = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", this.getField());
                    this.h4Builder = new com.vzome.core.commands.CommandUniformH4Polytope(this.getField(), qsymm, 0);
                }
                this.h4Builder.generate(index, edgesToRender, edgeScales, listener);
                break;
            default:
                super.constructPolytope(groupName, index, edgesToRender, edgeScales, listener);
                break;
            }
        }

        /*private*/ cmdTauDivide: com.vzome.core.commands.Command;

        /**
         * 
         * @param {string} action
         * @return {*}
         */
        public getLegacyCommand(action: string): com.vzome.core.commands.Command {
            switch((action)) {
            case "tauDivide":
                return this.cmdTauDivide;
            default:
                return super.getLegacyCommand(action);
            }
        }
    }
    GoldenFieldApplication["__class"] = "com.vzome.core.kinds.GoldenFieldApplication";
    GoldenFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D","com.vzome.core.editor.FieldApplication"];


}
namespace com.vzome.core.exporters {
    export class OffExporter extends com.vzome.core.exporters.GeometryExporter {
        static __static_initialized: boolean = false;
        static __static_initialize() { if (!OffExporter.__static_initialized) { OffExporter.__static_initialized = true; OffExporter.__static_initializer_0(); } }

        static FORMAT: java.text.NumberFormat; public static FORMAT_$LI$(): java.text.NumberFormat { OffExporter.__static_initialize(); if (OffExporter.FORMAT == null) { OffExporter.FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US); }  return OffExporter.FORMAT; }

        static  __static_initializer_0() {
            OffExporter.FORMAT_$LI$().setMinimumFractionDigits(16);
        }

        /**
         * 
         * @param {java.io.File} directory
         * @param {java.io.Writer} writer
         * @param {number} height
         * @param {number} width
         */
        public doExport(directory: java.io.File, writer: java.io.Writer, height: number, width: number) {
            let vertices: java.util.SortedSet<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.TreeSet<any>());
            let numStruts: number = 0;
            const arrayComparator: com.vzome.core.generic.ArrayComparator<com.vzome.core.algebra.AlgebraicVector> = <any>(new com.vzome.core.generic.ArrayComparator<any>());
            const panelVertices: java.util.SortedSet<com.vzome.core.algebra.AlgebraicVector[]> = <any>(new java.util.TreeSet<any>(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0, arg1) =>  (funcInst['compare'] ? funcInst['compare'] : funcInst) .call(funcInst, arg0, arg1)})(arrayComparator.getLengthFirstArrayComparator()))));
            for(let index=this.mModel.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    const man: com.vzome.core.model.Manifestation = rm.getManifestation();
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        const loc: com.vzome.core.algebra.AlgebraicVector = man.getLocation();
                        vertices.add(loc);
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        ++numStruts;
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                        const panel: com.vzome.core.model.Panel = <com.vzome.core.model.Panel><any>man;
                        const corners: java.util.ArrayList<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>(panel.getVertexCount()));
                        for(let index=panel.iterator();index.hasNext();) {
                            let vertex = index.next();
                            {
                                corners.add(vertex);
                            }
                        }
                        vertices.addAll(corners);
                        const cornerArray: com.vzome.core.algebra.AlgebraicVector[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(corners.size());
                        corners.toArray<any>(cornerArray);
                        panelVertices.add(cornerArray);
                    }
                }
            }
            const sortedVertexList: java.util.ArrayList<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>(vertices));
            vertices = null;
            this.output = new java.io.PrintWriter(writer);
            this.output.println$java_lang_Object("OFF");
            this.output.println$java_lang_Object("# numVertices numFaces numEdges (numEdges is ignored)");
            this.output.println$java_lang_Object(sortedVertexList.size() + " " + panelVertices.size() + " " + numStruts + "\n");
            this.output.println$java_lang_Object("# Vertices.  Each line is the XYZ coordinates of one vertex.");
            for(let index=sortedVertexList.iterator();index.hasNext();) {
                let vector = index.next();
                {
                    const dv: number[] = this.mModel.renderVectorDouble(vector);
                    this.output.print(OffExporter.FORMAT_$LI$().format(dv[0]) + " ");
                    this.output.print(OffExporter.FORMAT_$LI$().format(dv[1]) + " ");
                    this.output.print(OffExporter.FORMAT_$LI$().format(dv[2]) + "\n");
                }
            }
            this.output.println$();
            this.output.println$java_lang_Object("# Faces.  numCorners vertexIndex[0] ... vertexIndex[numCorners-1]");
            for(let index=panelVertices.iterator();index.hasNext();) {
                let corners = index.next();
                {
                    this.output.print(corners.length);
                    for(let index = 0; index < corners.length; index++) {
                        let corner = corners[index];
                        {
                            this.output.print(" " + sortedVertexList.indexOf(corner));
                        }
                    }
                    this.output.println$();
                }
            }
            this.output.flush();
        }

        /**
         * 
         * @return {string}
         */
        public getFileExtension(): string {
            return "off";
        }
    }
    OffExporter["__class"] = "com.vzome.core.exporters.OffExporter";

}
namespace com.vzome.core.exporters {
    export class OpenScadMeshExporter extends com.vzome.core.exporters.GeometryExporter {
        static __static_initialized: boolean = false;
        static __static_initialize() { if (!OpenScadMeshExporter.__static_initialized) { OpenScadMeshExporter.__static_initialized = true; OpenScadMeshExporter.__static_initializer_0(); } }

        static FORMAT: java.text.NumberFormat; public static FORMAT_$LI$(): java.text.NumberFormat { OpenScadMeshExporter.__static_initialize(); if (OpenScadMeshExporter.FORMAT == null) { OpenScadMeshExporter.FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US); }  return OpenScadMeshExporter.FORMAT; }

        static  __static_initializer_0() {
            OpenScadMeshExporter.FORMAT_$LI$().setMinimumFractionDigits(6);
            OpenScadMeshExporter.FORMAT_$LI$().setMaximumFractionDigits(6);
        }

        /**
         * 
         * @param {java.io.File} directory
         * @param {java.io.Writer} writer
         * @param {number} height
         * @param {number} width
         */
        public doExport(directory: java.io.File, writer: java.io.Writer, height: number, width: number) {
            let vertices: java.util.SortedSet<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.TreeSet<any>());
            for(let index=this.mModel.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    const man: com.vzome.core.model.Manifestation = rm.getManifestation();
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        const strut: com.vzome.core.model.Strut = <com.vzome.core.model.Strut><any>man;
                        let loc: com.vzome.core.algebra.AlgebraicVector = strut.getLocation();
                        vertices.add(loc);
                        loc = strut.getEnd();
                        vertices.add(loc);
                    }
                }
            }
            const sortedVertexList: java.util.ArrayList<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>(vertices));
            vertices = null;
            this.output = new java.io.PrintWriter(writer);
            const prelude: string = this.getBoilerplate("com/vzome/core/exporters/mesh-prelude.scad");
            this.output.print(prelude);
            this.output.println$java_lang_Object("vertices = [");
            for(let index=sortedVertexList.iterator();index.hasNext();) {
                let vector = index.next();
                {
                    const dv: number[] = this.mModel.renderVectorDouble(vector);
                    this.output.print("[ ");
                    this.output.print(OpenScadMeshExporter.FORMAT_$LI$().format(dv[0]) + ", ");
                    this.output.print(OpenScadMeshExporter.FORMAT_$LI$().format(dv[1]) + ", ");
                    this.output.println$java_lang_Object(OpenScadMeshExporter.FORMAT_$LI$().format(dv[2]) + " ],");
                }
            }
            this.output.println$java_lang_Object("];");
            this.output.println$();
            this.output.println$java_lang_Object("edges = [");
            for(let index=this.mModel.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    const man: com.vzome.core.model.Manifestation = rm.getManifestation();
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        const strut: com.vzome.core.model.Strut = <com.vzome.core.model.Strut><any>man;
                        this.output.println$java_lang_Object("[ " + sortedVertexList.indexOf(strut.getLocation()) + ", " + sortedVertexList.indexOf(strut.getEnd()) + " ],");
                    }
                }
            }
            this.output.println$java_lang_Object("];");
            const postlude: string = this.getBoilerplate("com/vzome/core/exporters/mesh-postlude.scad");
            this.output.print(postlude);
            this.output.flush();
        }

        /**
         * 
         * @return {string}
         */
        public getFileExtension(): string {
            return "scad";
        }
    }
    OpenScadMeshExporter["__class"] = "com.vzome.core.exporters.OpenScadMeshExporter";

}
namespace com.vzome.core.exporters {
    export class PythonBuild123dExporter extends com.vzome.core.exporters.GeometryExporter {
        static __static_initialized: boolean = false;
        static __static_initialize() { if (!PythonBuild123dExporter.__static_initialized) { PythonBuild123dExporter.__static_initialized = true; PythonBuild123dExporter.__static_initializer_0(); } }

        static FORMAT: java.text.NumberFormat; public static FORMAT_$LI$(): java.text.NumberFormat { PythonBuild123dExporter.__static_initialize(); if (PythonBuild123dExporter.FORMAT == null) { PythonBuild123dExporter.FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US); }  return PythonBuild123dExporter.FORMAT; }

        static  __static_initializer_0() {
            PythonBuild123dExporter.FORMAT_$LI$().setMinimumFractionDigits(6);
            PythonBuild123dExporter.FORMAT_$LI$().setMaximumFractionDigits(6);
        }

        /**
         * 
         * @param {java.io.File} directory
         * @param {java.io.Writer} writer
         * @param {number} height
         * @param {number} width
         */
        public doExport(directory: java.io.File, writer: java.io.Writer, height: number, width: number) {
            let vertices: java.util.SortedSet<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.TreeSet<any>());
            for(let index=this.mModel.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    const man: com.vzome.core.model.Manifestation = rm.getManifestation();
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        const strut: com.vzome.core.model.Strut = <com.vzome.core.model.Strut><any>man;
                        let loc: com.vzome.core.algebra.AlgebraicVector = strut.getLocation();
                        vertices.add(loc);
                        loc = strut.getEnd();
                        vertices.add(loc);
                    }
                }
            }
            const sortedVertexList: java.util.ArrayList<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>(vertices));
            vertices = null;
            this.output = new java.io.PrintWriter(writer);
            const prelude: string = this.getBoilerplate("com/vzome/core/exporters/mesh-prelude.py");
            this.output.print(prelude);
            this.output.println$java_lang_Object("vertices = [");
            for(let index=sortedVertexList.iterator();index.hasNext();) {
                let vector = index.next();
                {
                    const dv: number[] = this.mModel.renderVectorDouble(vector);
                    this.output.print("( ");
                    this.output.print(PythonBuild123dExporter.FORMAT_$LI$().format(dv[0]) + ", ");
                    this.output.print(PythonBuild123dExporter.FORMAT_$LI$().format(dv[1]) + ", ");
                    this.output.println$java_lang_Object(PythonBuild123dExporter.FORMAT_$LI$().format(dv[2]) + " ),");
                }
            }
            this.output.println$java_lang_Object("]");
            this.output.println$();
            this.output.println$java_lang_Object("edges = [");
            for(let index=this.mModel.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    const man: com.vzome.core.model.Manifestation = rm.getManifestation();
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        const strut: com.vzome.core.model.Strut = <com.vzome.core.model.Strut><any>man;
                        this.output.println$java_lang_Object("[ " + sortedVertexList.indexOf(strut.getLocation()) + ", " + sortedVertexList.indexOf(strut.getEnd()) + " ],");
                    }
                }
            }
            this.output.println$java_lang_Object("]");
            const postlude: string = this.getBoilerplate("com/vzome/core/exporters/mesh-postlude.py");
            this.output.print(postlude);
            this.output.flush();
        }

        /**
         * 
         * @return {string}
         */
        public getFileExtension(): string {
            return "py";
        }
    }
    PythonBuild123dExporter["__class"] = "com.vzome.core.exporters.PythonBuild123dExporter";

}
namespace com.vzome.core.exporters {
    export abstract class DocumentExporter extends com.vzome.core.exporters.GeometryExporter implements com.vzome.core.exporters.DocumentExporterIntf {
        mLights: com.vzome.core.viewing.Lights;

        mScene: com.vzome.core.viewing.CameraIntf;

        /**
         * Subclasses can override this if they need to export history, the lesson model, or the selection.
         * @param {*} doc
         * @param {java.io.File} file
         * @param {java.io.Writer} writer
         * @param {number} height
         * @param {number} width
         */
        public exportDocument(doc: com.vzome.core.exporters.DocumentIntf, file: java.io.File, writer: java.io.Writer, height: number, width: number) {
            this.mScene = doc.getCameraModel();
            this.mLights = doc.getSceneLighting();
            this.exportGeometry(doc.getRenderedModel(), file, writer, height, width);
            this.mScene = null;
            this.mLights = null;
        }

        constructor() {
            super();
            if (this.mLights === undefined) { this.mLights = null; }
            if (this.mScene === undefined) { this.mScene = null; }
        }
    }
    DocumentExporter["__class"] = "com.vzome.core.exporters.DocumentExporter";
    DocumentExporter["__interfaces"] = ["com.vzome.core.exporters.DocumentExporterIntf"];


}
namespace com.vzome.core.exporters {
    export class PdbExporter extends com.vzome.core.exporters.GeometryExporter {
        /**
         * 
         * @param {java.io.File} directory
         * @param {java.io.Writer} writer
         * @param {number} height
         * @param {number} width
         */
        public doExport(directory: java.io.File, writer: java.io.Writer, height: number, width: number) {
            const atoms: java.util.Map<com.vzome.core.algebra.AlgebraicVector, PdbExporter.Atom> = <any>(new java.util.HashMap<any, any>());
            const atomsList: java.util.List<PdbExporter.Atom> = <any>(new java.util.ArrayList<any>());
            let indices: number = 0;
            for(let index=this.mModel.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    const man: com.vzome.core.model.Manifestation = rm.getManifestation();
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        const startLoc: com.vzome.core.algebra.AlgebraicVector = (<com.vzome.core.model.Strut><any>man).getLocation();
                        const endLoc: com.vzome.core.algebra.AlgebraicVector = (<com.vzome.core.model.Strut><any>man).getEnd();
                        let startAtom: PdbExporter.Atom = atoms.get(startLoc);
                        if (startAtom == null){
                            startAtom = new PdbExporter.Atom(this, startLoc, ++indices);
                            atoms.put(startLoc, startAtom);
                            atomsList.add(startAtom);
                        }
                        let endAtom: PdbExporter.Atom = atoms.get(endLoc);
                        if (endAtom == null){
                            endAtom = new PdbExporter.Atom(this, endLoc, ++indices);
                            atoms.put(endLoc, endAtom);
                            atomsList.add(endAtom);
                        }
                        startAtom.neighbors.add(endAtom);
                        endAtom.neighbors.add(startAtom);
                    }
                }
            }
            const field: com.vzome.core.algebra.AlgebraicField = this.mModel.getField();
            const scale: com.vzome.core.algebra.AlgebraicNumber = field['createAlgebraicNumber$int$int$int$int'](4, 6, 1, 0);
            const scaleFactor: number = 5.0 / scale.evaluate();
            const locations: java.lang.StringBuilder = new java.lang.StringBuilder();
            const neighbors: java.lang.StringBuilder = new java.lang.StringBuilder();
            for(let index=atomsList.iterator();index.hasNext();) {
                let atom = index.next();
                {
                    const rv: com.vzome.core.math.RealVector = this.mModel.renderVector(atom.location);
                    console.info(atom.location.toString());
                    locations.append(javaemul.internal.StringHelper.format("HETATM%5d He   UNK  0001     %7.3f %7.3f %7.3f\n", atom.index, rv.x * scaleFactor, rv.y * scaleFactor, rv.z * scaleFactor));
                    neighbors.append(javaemul.internal.StringHelper.format("CONECT%5d", atom.index));
                    for(let index=atom.neighbors.iterator();index.hasNext();) {
                        let neighbor = index.next();
                        {
                            neighbors.append(javaemul.internal.StringHelper.format("%5d", neighbor.index));
                        }
                    }
                    neighbors.append("\n");
                }
            }
            this.output = new java.io.PrintWriter(writer);
            this.output.println$java_lang_Object("HEADER");
            this.output.println$java_lang_Object("REMARK vZome");
            this.output.print(locations);
            this.output.print(neighbors);
            this.output.println$java_lang_Object("END");
            this.output.flush();
        }

        /**
         * 
         * @return {string}
         */
        public getFileExtension(): string {
            return "pdb";
        }
    }
    PdbExporter["__class"] = "com.vzome.core.exporters.PdbExporter";


    export namespace PdbExporter {

        export class Atom {
            public __parent: any;
            public constructor(__parent: any, location: com.vzome.core.algebra.AlgebraicVector, i: number) {
                this.__parent = __parent;
                if (this.location === undefined) { this.location = null; }
                if (this.index === undefined) { this.index = 0; }
                this.neighbors = <any>(new java.util.HashSet<any>());
                this.location = location;
                this.index = i;
            }

            location: com.vzome.core.algebra.AlgebraicVector;

            index: number;

            neighbors: java.util.Set<PdbExporter.Atom>;
        }
        Atom["__class"] = "com.vzome.core.exporters.PdbExporter.Atom";

    }

}
namespace com.vzome.core.exporters {
    export class StlExporter extends com.vzome.core.exporters.GeometryExporter {
        static FORMAT: java.text.NumberFormat; public static FORMAT_$LI$(): java.text.NumberFormat { if (StlExporter.FORMAT == null) { StlExporter.FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US); }  return StlExporter.FORMAT; }

        /**
         * 
         * @param {java.io.File} directory
         * @param {java.io.Writer} writer
         * @param {number} height
         * @param {number} width
         */
        public doExport(directory: java.io.File, writer: java.io.Writer, height: number, width: number) {
            if (StlExporter.FORMAT_$LI$() != null && StlExporter.FORMAT_$LI$() instanceof <any>java.text.DecimalFormat){
                (<java.text.DecimalFormat>StlExporter.FORMAT_$LI$()).applyPattern("0.000000E00");
            }
            const mmScaling: number = this.mModel.getCmScaling() * 10.0;
            this.output = new java.io.PrintWriter(writer);
            this.output.println$java_lang_Object("solid vcg");
            for(let index=this.mModel.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    const man: com.vzome.core.model.Manifestation = rm.getManifestation();
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                        const panel: com.vzome.core.model.Panel = <com.vzome.core.model.Panel><any>man;
                        const norm: com.vzome.core.math.RealVector = this.mModel.renderVector(panel['getNormal$']()).normalize();
                        let v0: com.vzome.core.math.RealVector = null;
                        let v1: com.vzome.core.math.RealVector = null;
                        for(let index=panel.iterator();index.hasNext();) {
                            let vert = index.next();
                            {
                                let vertex: com.vzome.core.math.RealVector = this.mModel.renderVector(vert);
                                vertex = vertex.scale(mmScaling);
                                if (v0 == null)v0 = vertex; else if (v1 == null)v1 = vertex; else {
                                    this.output.print("  facet normal ");
                                    this.output.println$java_lang_Object(StlExporter.FORMAT_$LI$().format(norm.x) + " " + StlExporter.FORMAT_$LI$().format(norm.y) + " " + StlExporter.FORMAT_$LI$().format(norm.z));
                                    this.output.println$java_lang_Object("    outer loop");
                                    this.output.println$java_lang_Object("      vertex " + StlExporter.FORMAT_$LI$().format(v0.x) + " " + StlExporter.FORMAT_$LI$().format(v0.y) + " " + StlExporter.FORMAT_$LI$().format(v0.z));
                                    this.output.println$java_lang_Object("      vertex " + StlExporter.FORMAT_$LI$().format(v1.x) + " " + StlExporter.FORMAT_$LI$().format(v1.y) + " " + StlExporter.FORMAT_$LI$().format(v1.z));
                                    this.output.println$java_lang_Object("      vertex " + StlExporter.FORMAT_$LI$().format(vertex.x) + " " + StlExporter.FORMAT_$LI$().format(vertex.y) + " " + StlExporter.FORMAT_$LI$().format(vertex.z));
                                    this.output.println$java_lang_Object("    endloop");
                                    this.output.println$java_lang_Object("  endfacet");
                                    v1 = vertex;
                                }
                            }
                        }
                    }
                }
            }
            this.output.println$java_lang_Object("endsolid vcg");
            this.output.flush();
        }

        /**
         * 
         * @return {string}
         */
        public getFileExtension(): string {
            return "stl";
        }
    }
    StlExporter["__class"] = "com.vzome.core.exporters.StlExporter";

}
namespace com.vzome.core.exporters {
    export class VefExporter extends com.vzome.core.exporters.GeometryExporter {
        /**
         * 
         * @param {java.io.File} directory
         * @param {java.io.Writer} writer
         * @param {number} height
         * @param {number} width
         */
        public doExport(directory: java.io.File, writer: java.io.Writer, height: number, width: number) {
            const field: com.vzome.core.algebra.AlgebraicField = this.mModel.getField();
            const exporter: com.vzome.core.model.VefModelExporter = new com.vzome.core.model.VefModelExporter(writer, field);
            for(let index=this.mModel.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    const man: com.vzome.core.model.Manifestation = rm.getManifestation();
                    exporter.exportManifestation(man);
                }
            }
            exporter.finish();
        }

        /**
         * 
         * @return {string}
         */
        public getFileExtension(): string {
            return "vef";
        }
    }
    VefExporter["__class"] = "com.vzome.core.exporters.VefExporter";

}
namespace com.vzome.core.exporters {
    export class DxfExporter extends com.vzome.core.exporters.GeometryExporter {
        /**
         * 
         * @param {java.io.File} directory
         * @param {java.io.Writer} writer
         * @param {number} height
         * @param {number} width
         */
        public doExport(directory: java.io.File, writer: java.io.Writer, height: number, width: number) {
            this.output = new java.io.PrintWriter(writer);
            this.output.println$java_lang_Object("0");
            this.output.println$java_lang_Object("SECTION");
            this.output.println$java_lang_Object("2");
            this.output.println$java_lang_Object("ENTITIES");
            const format: java.text.NumberFormat = java.text.NumberFormat.getNumberInstance(java.util.Locale.US);
            format.setMaximumFractionDigits(6);
            const inchScaling: number = this.mModel.getCmScaling() / 2.54;
            for(let index=this.mModel.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    const man: com.vzome.core.model.Manifestation = rm.getManifestation();
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        this.output.println$java_lang_Object("0");
                        this.output.println$java_lang_Object("LINE");
                        this.output.println$java_lang_Object("8");
                        this.output.println$java_lang_Object("vZome");
                        const start: com.vzome.core.algebra.AlgebraicVector = (<com.vzome.core.model.Strut><any>man).getLocation();
                        const end: com.vzome.core.algebra.AlgebraicVector = (<com.vzome.core.model.Strut><any>man).getEnd();
                        let rv: com.vzome.core.math.RealVector = this.mModel.renderVector(start);
                        rv = rv.scale(inchScaling);
                        this.output.println$java_lang_Object("10");
                        this.output.println$java_lang_Object(format.format(rv.x));
                        this.output.println$java_lang_Object("20");
                        this.output.println$java_lang_Object(format.format(rv.y));
                        this.output.println$java_lang_Object("30");
                        this.output.println$java_lang_Object(format.format(rv.z));
                        rv = this.mModel.renderVector(end);
                        rv = rv.scale(inchScaling);
                        this.output.println$java_lang_Object("11");
                        this.output.println$java_lang_Object(format.format(rv.x));
                        this.output.println$java_lang_Object("21");
                        this.output.println$java_lang_Object(format.format(rv.y));
                        this.output.println$java_lang_Object("31");
                        this.output.println$java_lang_Object(format.format(rv.z));
                    }
                }
            }
            this.output.println$java_lang_Object("0");
            this.output.println$java_lang_Object("ENDSEC");
            this.output.println$java_lang_Object("0");
            this.output.println$java_lang_Object("EOF");
            this.output.flush();
        }

        /**
         * 
         * @return {string}
         */
        public getFileExtension(): string {
            return "dxf";
        }
    }
    DxfExporter["__class"] = "com.vzome.core.exporters.DxfExporter";

}
namespace com.vzome.core.exporters {
    export class SegExporter extends com.vzome.core.exporters.GeometryExporter {
        /**
         * 
         * @param {java.io.File} directory
         * @param {java.io.Writer} writer
         * @param {number} height
         * @param {number} width
         */
        public doExport(directory: java.io.File, writer: java.io.Writer, height: number, width: number) {
            this.field = this.mModel.getField();
            this.vertices = new java.lang.StringBuffer();
            this.struts = new java.lang.StringBuffer();
            if (this.format != null && this.format instanceof <any>java.text.DecimalFormat){
                (<java.text.DecimalFormat>this.format).applyPattern("0.0000");
            }
            for(let index=this.mModel.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    const man: com.vzome.core.model.Manifestation = rm.getManifestation();
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        const strut: com.vzome.core.model.Strut = <com.vzome.core.model.Strut><any>man;
                        this.struts.append("s ");
                        this.struts.append(this.getVertexIndex(strut.getLocation()));
                        this.struts.append(" ");
                        this.struts.append(this.getVertexIndex(strut.getEnd()));
                        this.struts.append("\n");
                    }
                }
            }
            writer.append(this.vertices.toString());
            writer.append(this.struts.toString());
            writer.close();
        }

        /**
         * 
         * @return {string}
         */
        public getFileExtension(): string {
            return "seg";
        }

        /*private*/ vertexData: java.util.Map<com.vzome.core.algebra.AlgebraicVector, number>;

        /*private*/ vertices: java.lang.StringBuffer;

        /*private*/ struts: java.lang.StringBuffer;

        field: com.vzome.core.algebra.AlgebraicField;

        /*private*/ format: java.text.NumberFormat;

        getVertexIndex(vertexVector: com.vzome.core.algebra.AlgebraicVector): number {
            let val: number = this.vertexData.get(vertexVector);
            if (val == null){
                const key: com.vzome.core.algebra.AlgebraicVector = vertexVector;
                const index: number = this.vertexData.size();
                val = index;
                this.vertexData.put(key, val);
                this.vertices.append("v ");
                const vertex: com.vzome.core.math.RealVector = this.mModel.renderVector(vertexVector);
                this.vertices.append(this.format.format(vertex.x) + " ");
                this.vertices.append(this.format.format(vertex.y) + " ");
                this.vertices.append(this.format.format(vertex.z) + " ");
                this.vertices.append("\n");
            }
            return val;
        }

        constructor() {
            super();
            this.vertexData = <any>(new java.util.HashMap<any, any>());
            if (this.vertices === undefined) { this.vertices = null; }
            if (this.struts === undefined) { this.struts = null; }
            if (this.field === undefined) { this.field = null; }
            this.format = java.text.NumberFormat.getNumberInstance(java.util.Locale.US);
        }
    }
    SegExporter["__class"] = "com.vzome.core.exporters.SegExporter";

}
namespace com.vzome.core.exporters {
    /**
     * @author vorth
     * @class
     * @extends com.vzome.core.exporters.GeometryExporter
     */
    export class VRMLExporter extends com.vzome.core.exporters.GeometryExporter {
        static PREAMBLE_FILE: string = "com/vzome/core/exporters/vrml/preamble.wrl";

        static SCALE: number = 0.35;

        /*private*/ exportColor(name: string, color: com.vzome.core.construction.Color) {
            this.output.println$java_lang_Object("PROTO " + name + " [] {");
            this.output.print("    Appearance { material Material { diffuseColor ");
            const rgb: number[] = color.getRGBColorComponents([0, 0, 0]);
            this.output.print(rgb[0] + " ");
            this.output.print(rgb[1] + " ");
            this.output.print(rgb[2]);
            this.output.println$java_lang_Object(" }}}");
        }

        /**
         * 
         * @param {java.io.File} directory
         * @param {java.io.Writer} writer
         * @param {number} height
         * @param {number} width
         */
        public doExport(directory: java.io.File, writer: java.io.Writer, height: number, width: number) {
            this.output = new java.io.PrintWriter(writer);
            this.output.println$java_lang_Object(this.getBoilerplate(VRMLExporter.PREAMBLE_FILE));
            this.output.println$();
            let field: com.vzome.core.algebra.AlgebraicField = null;
            const instances: java.lang.StringBuffer = new java.lang.StringBuffer();
            let numShapes: number = 0;
            const shapes: java.util.HashMap<com.vzome.core.math.Polyhedron, string> = <any>(new java.util.HashMap<any, any>());
            const colors: java.util.Map<com.vzome.core.construction.Color, string> = <any>(new java.util.HashMap<any, any>());
            for(let index=this.mModel.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    const shape: com.vzome.core.math.Polyhedron = rm.getShape();
                    if (field == null)field = shape.getField();
                    let shapeName: string = shapes.get(shape);
                    if (shapeName == null){
                        shapeName = "shape" + numShapes++;
                        shapes.put(shape, shapeName);
                        this.exportShape(shapeName, shape);
                    }
                    const transform: com.vzome.core.algebra.AlgebraicMatrix = rm.getOrientation();
                    const mx: com.vzome.core.math.RealVector = this.mModel.renderVector(transform.timesRow(field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X)));
                    const my: com.vzome.core.math.RealVector = this.mModel.renderVector(transform.timesRow(field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y)));
                    const mz: com.vzome.core.math.RealVector = this.mModel.renderVector(transform.timesRow(field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z)));
                    let x: number = ((<any>Math).fround(mz.y - my.z));
                    let y: number = ((<any>Math).fround(mx.z - mz.x));
                    let z: number = ((<any>Math).fround(my.x - mx.y));
                    const cos: number = ((<any>Math).fround((<any>Math).fround(mx.x + my.y) + mz.z) - 1.0) * 0.5;
                    const sin: number = 0.5 * Math.sqrt(x * x + y * y + z * z);
                    const angle: number = (<any>Math).fround(Math.atan2(sin, cos));
                    if (Math.abs(angle - Math.PI) < 1.0E-5){
                        if ((mx.x >= my.y) && (mx.x >= mz.z)){
                            x = Math.sqrt((<any>Math).fround((<any>Math).fround(mx.x - my.y) - mz.z) + 1.0) * 0.5;
                            y = mx.y / (2.0 * x);
                            z = mx.z / (2.0 * x);
                        } else if ((my.y >= mz.z) && (my.y >= mx.x)){
                            y = Math.sqrt((<any>Math).fround((<any>Math).fround(my.y - mx.x) - mz.z) + 1.0) * 0.5;
                            x = mx.y / (2.0 * y);
                            z = my.z / (2.0 * y);
                        } else {
                            z = Math.sqrt((<any>Math).fround((<any>Math).fround(mz.z - my.y) - mx.x) + 1.0) * 0.5;
                            x = mx.z / (2.0 * z);
                            y = my.z / (2.0 * z);
                        }
                    }
                    let color: com.vzome.core.construction.Color = rm.getColor();
                    if (color == null){
                        color = com.vzome.core.construction.Color.WHITE_$LI$();
                    }
                    let colorName: string = colors.get(color);
                    if (colorName == null){
                        colorName = "color_" + /* replace */color.toString().split(',').join('_');
                        colors.put(color, colorName);
                        this.exportColor(colorName, color);
                    }
                    instances.append("Transform { translation ");
                    instances.append(rm.getLocation().scale(VRMLExporter.SCALE).spacedString());
                    instances.append(" rotation " + x + " " + y + " " + z + " " + angle);
                    instances.append(" children[ Shape{ geometry " + shapeName + "{} appearance " + colorName + "{}}]}\n");
                }
            }
            this.output.println$java_lang_Object(instances.toString());
            this.output.flush();
            this.output.close();
        }

        /*private*/ exportShape(shapeName: string, poly: com.vzome.core.math.Polyhedron) {
            this.output.println$java_lang_Object("PROTO " + shapeName + " [] { IndexedFaceSet{ solid FALSE convex FALSE colorPerVertex FALSE");
            this.output.println$java_lang_Object("   coord Coordinate{ point [");
            for(let index=poly.getVertexList().iterator();index.hasNext();) {
                let gv = index.next();
                {
                    const v: com.vzome.core.math.RealVector = this.mModel.renderVector(gv);
                    this.output.println$java_lang_Object(v.scale(VRMLExporter.SCALE).spacedString() + ",");
                }
            }
            this.output.println$java_lang_Object("] } coordIndex [");
            for(let index=poly.getFaceSet().iterator();index.hasNext();) {
                let face = index.next();
                {
                    const arity: number = face.size();
                    for(let j: number = 0; j < arity; j++) {{
                        const index: number = face.get(j);
                        this.output.print(index + ", ");
                    };}
                    this.output.println$java_lang_Object("-1,");
                }
            }
            this.output.println$java_lang_Object("]}}");
            this.output.flush();
        }

        /**
         * 
         * @return {string}
         */
        public getFileExtension(): string {
            return "wrl";
        }
    }
    VRMLExporter["__class"] = "com.vzome.core.exporters.VRMLExporter";

}
namespace com.vzome.core.commands {
    export class ZomicVirtualMachine extends com.vzome.core.render.AbstractZomicEventHandler {
        /*private*/ mLocation: com.vzome.core.construction.Point;

        /*private*/ mEffects: com.vzome.core.construction.ConstructionChanges;

        public getLocation(): com.vzome.core.algebra.AlgebraicVector {
            return this.mLocation.getLocation();
        }

        /**
         * @return
         * @return {com.vzome.core.construction.Construction}
         */
        public getLastPoint(): com.vzome.core.construction.Construction {
            return this.mLocation;
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Axis} axis
         * @param {*} length
         */
        public step(axis: com.vzome.core.math.symmetry.Axis, length: com.vzome.core.algebra.AlgebraicNumber) {
            axis = this.mOrientation.permute(axis, this.mHandedNess);
            length = length['times$com_vzome_core_algebra_AlgebraicNumber'](this.mScale);
            const segment: com.vzome.core.construction.Segment = new com.vzome.core.construction.AnchoredSegment(axis, length, this.mLocation);
            const pt2: com.vzome.core.construction.Point = new com.vzome.core.construction.SegmentEndPoint(segment);
            if (this.mAction !== com.vzome.core.render.ZomicEventHandler.JUST_MOVE){
                this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](this.mLocation);
                this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](segment);
                this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](pt2);
            }
            this.mLocation = pt2;
        }

        public constructor(start: com.vzome.core.construction.Point, effects: com.vzome.core.construction.ConstructionChanges, symm: com.vzome.core.math.symmetry.Symmetry) {
            super(symm);
            if (this.mLocation === undefined) { this.mLocation = null; }
            if (this.mEffects === undefined) { this.mEffects = null; }
            this.mLocation = start;
            this.mEffects = effects;
        }

        /**
         * 
         * @return {com.vzome.core.render.AbstractZomicEventHandler}
         */
        copyLocation(): com.vzome.core.render.AbstractZomicEventHandler {
            return new ZomicVirtualMachine(this.mLocation, this.mEffects, this.mSymmetry);
        }

        /**
         * 
         * @param {com.vzome.core.render.AbstractZomicEventHandler} changed
         */
        restoreLocation(changed: com.vzome.core.render.AbstractZomicEventHandler) {
            this.mLocation = (<ZomicVirtualMachine>changed).mLocation;
        }
    }
    ZomicVirtualMachine["__class"] = "com.vzome.core.commands.ZomicVirtualMachine";
    ZomicVirtualMachine["__interfaces"] = ["com.vzome.core.render.ZomicEventHandler"];


}
namespace com.vzome.core.viewing {
    export class DodecagonalShapes extends com.vzome.core.viewing.AbstractShapes {
        public constructor(pkgName: string, name: string, alias: string, symm: com.vzome.core.math.symmetry.Symmetry) {
            super(pkgName, name, alias, symm);
            if (this.V0 === undefined) { this.V0 = null; }
            if (this.V1 === undefined) { this.V1 = null; }
            if (this.V2 === undefined) { this.V2 = null; }
            if (this.V3 === undefined) { this.V3 = null; }
            if (this.V4 === undefined) { this.V4 = null; }
            if (this.V5 === undefined) { this.V5 = null; }
            if (this.TWO === undefined) { this.TWO = null; }
            if (this.GREEN === undefined) { this.GREEN = null; }
            if (this.V6 === undefined) { this.V6 = null; }
            if (this.V7 === undefined) { this.V7 = null; }
            const field: com.vzome.core.algebra.AlgebraicField = symm.getField();
            this.V0 = field.createVector([[1, 1, 0, 1], [0, 1, 0, 1], [0, 1, 0, 1]]);
            this.V1 = field.createVector([[1, 2, 0, 1], [0, 1, 1, 2], [0, 1, 0, 1]]);
            this.V2 = field.createVector([[-1, 2, 0, 1], [0, 1, 1, 2], [0, 1, 0, 1]]);
            this.V3 = field.createVector([[-1, 1, 0, 1], [0, 1, 0, 1], [0, 1, 0, 1]]);
            this.V4 = field.createVector([[-1, 2, 0, 1], [0, 1, -1, 2], [0, 1, 0, 1]]);
            this.V5 = field.createVector([[1, 2, 0, 1], [0, 1, -1, 2], [0, 1, 0, 1]]);
            this.TWO = field.createVector([[2, 1, 0, 1], [0, 1, 0, 1], [0, 1, 0, 1]]);
            this.GREEN = field.createVector([[1, 1, 1, 2], [1, 2, 0, 1], [0, 1, 0, 1]]);
            this.V6 = field.createVector([[1, 1, 0, 1], [0, 1, 1, 3], [0, 1, 0, 1]]);
            this.V7 = field.createVector([[0, 1, 2, 3], [0, 1, 0, 1], [0, 1, 0, 1]]);
        }

        /*private*/ V0: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ V1: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ V2: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ V3: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ V4: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ V5: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ TWO: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ GREEN: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ V6: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ V7: com.vzome.core.algebra.AlgebraicVector;

        /**
         * 
         * @param {string} pkgName
         * @return {com.vzome.core.math.Polyhedron}
         */
        buildConnectorShape(pkgName: string): com.vzome.core.math.Polyhedron {
            const hex: com.vzome.core.math.Polyhedron = new com.vzome.core.math.Polyhedron(this.mSymmetry.getField());
            hex.addVertex(this.V0);
            hex.addVertex(this.V1);
            hex.addVertex(this.V2);
            hex.addVertex(this.V3);
            hex.addVertex(this.V4);
            hex.addVertex(this.V5);
            let face: com.vzome.core.math.Polyhedron.Face = hex.newFace();
            face.add(0);
            face.add(1);
            face.add(2);
            face.add(3);
            face.add(4);
            face.add(5);
            hex.addFace(face);
            face = hex.newFace();
            face.add(5);
            face.add(4);
            face.add(3);
            face.add(2);
            face.add(1);
            face.add(0);
            hex.addFace(face);
            return hex;
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Direction} dir
         * @return {*}
         */
        createStrutGeometry(dir: com.vzome.core.math.symmetry.Direction): com.vzome.core.parts.StrutGeometry {
            if (dir.getName() === ("blue"))return new DodecagonalShapes.BlueStrutGeometry(this); else if (dir.getName() === ("green"))return new DodecagonalShapes.GreenStrutGeometry(this); else return super.createStrutGeometry(dir);
        }
    }
    DodecagonalShapes["__class"] = "com.vzome.core.viewing.DodecagonalShapes";
    DodecagonalShapes["__interfaces"] = ["com.vzome.core.editor.api.Shapes"];



    export namespace DodecagonalShapes {

        export class BlueStrutGeometry implements com.vzome.core.parts.StrutGeometry {
            public __parent: any;
            /**
             * 
             * @param {*} length
             * @return {com.vzome.core.math.Polyhedron}
             */
            public getStrutPolyhedron(length: com.vzome.core.algebra.AlgebraicNumber): com.vzome.core.math.Polyhedron {
                const field: com.vzome.core.algebra.AlgebraicField = this.__parent.mSymmetry.getField();
                const hex: com.vzome.core.math.Polyhedron = new com.vzome.core.math.Polyhedron(field);
                const strut: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, 0).scale(length);
                const THIRD: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long$long'](1, 3);
                hex.addVertex(strut.plus(this.__parent.V5.scale(THIRD).minus(this.__parent.TWO)));
                hex.addVertex(strut.plus(this.__parent.V0.scale(THIRD).minus(this.__parent.TWO)));
                hex.addVertex(strut.plus(this.__parent.V1.scale(THIRD).minus(this.__parent.TWO)));
                hex.addVertex(this.__parent.V2.scale(THIRD).plus(this.__parent.TWO));
                hex.addVertex(this.__parent.V3.scale(THIRD).plus(this.__parent.TWO));
                hex.addVertex(this.__parent.V4.scale(THIRD).plus(this.__parent.TWO));
                let face: com.vzome.core.math.Polyhedron.Face = hex.newFace();
                face.add(0);
                face.add(1);
                face.add(2);
                face.add(3);
                face.add(4);
                face.add(5);
                hex.addFace(face);
                face = hex.newFace();
                face.add(5);
                face.add(4);
                face.add(3);
                face.add(2);
                face.add(1);
                face.add(0);
                hex.addFace(face);
                return hex;
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }
        BlueStrutGeometry["__class"] = "com.vzome.core.viewing.DodecagonalShapes.BlueStrutGeometry";
        BlueStrutGeometry["__interfaces"] = ["com.vzome.core.parts.StrutGeometry"];



        export class GreenStrutGeometry implements com.vzome.core.parts.StrutGeometry {
            public __parent: any;
            /**
             * 
             * @param {*} length
             * @return {com.vzome.core.math.Polyhedron}
             */
            public getStrutPolyhedron(length: com.vzome.core.algebra.AlgebraicNumber): com.vzome.core.math.Polyhedron {
                const field: com.vzome.core.algebra.AlgebraicField = this.__parent.mSymmetry.getField();
                const vector: com.vzome.core.algebra.AlgebraicVector = this.__parent.GREEN.scale(length);
                const hex: com.vzome.core.math.Polyhedron = new com.vzome.core.math.Polyhedron(field);
                hex.addVertex(vector.plus(this.__parent.GREEN.plus(this.__parent.V6)).negate());
                hex.addVertex(vector.plus(this.__parent.GREEN.negate()));
                hex.addVertex(vector.plus(this.__parent.GREEN.plus(this.__parent.V7).negate()));
                hex.addVertex(this.__parent.V6.plus(this.__parent.GREEN));
                hex.addVertex(this.__parent.GREEN);
                hex.addVertex(this.__parent.V7.plus(this.__parent.GREEN));
                let face: com.vzome.core.math.Polyhedron.Face = hex.newFace();
                face.add(0);
                face.add(1);
                face.add(2);
                face.add(3);
                face.add(4);
                face.add(5);
                hex.addFace(face);
                face = hex.newFace();
                face.add(5);
                face.add(4);
                face.add(3);
                face.add(2);
                face.add(1);
                face.add(0);
                hex.addFace(face);
                return hex;
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }
        GreenStrutGeometry["__class"] = "com.vzome.core.viewing.DodecagonalShapes.GreenStrutGeometry";
        GreenStrutGeometry["__interfaces"] = ["com.vzome.core.parts.StrutGeometry"];


    }

}
namespace com.vzome.core.viewing {
    /**
     * @author David Hall
     * @param {string} pkgName
     * @param {string} name
     * @param {com.vzome.core.math.symmetry.AntiprismSymmetry} symm
     * @class
     * @extends com.vzome.core.viewing.AbstractShapes
     */
    export class AntiprismShapes extends com.vzome.core.viewing.AbstractShapes {
        public constructor(pkgName: string, name: string, symm: com.vzome.core.math.symmetry.AntiprismSymmetry) {
            super(pkgName, name, null, symm);
        }

        /**
         * 
         * @return {com.vzome.core.math.symmetry.AntiprismSymmetry}
         */
        public getSymmetry(): com.vzome.core.math.symmetry.AntiprismSymmetry {
            return <com.vzome.core.math.symmetry.AntiprismSymmetry><any>super.getSymmetry();
        }

        /**
         * 
         * @param {string} pkgName
         * @return {com.vzome.core.math.Polyhedron}
         */
        buildConnectorShape(pkgName: string): com.vzome.core.math.Polyhedron {
            const symm: com.vzome.core.math.symmetry.AntiprismSymmetry = this.getSymmetry();
            const field: com.vzome.core.algebra.PolygonField = symm.getField();
            const nSides: number = field.polygonSides();
            const antiprism: com.vzome.core.math.Polyhedron = new com.vzome.core.math.Polyhedron(field);
            const topX: com.vzome.core.algebra.AlgebraicNumber = field.one();
            const topY: com.vzome.core.algebra.AlgebraicNumber = field.zero();
            const maxTerm: com.vzome.core.algebra.AlgebraicNumber = field.getUnitDiagonal(field.diagonalCount() - 1);
            const botX: com.vzome.core.algebra.AlgebraicNumber = field.getUnitDiagonal(field.diagonalCount() - 2).dividedBy(maxTerm);
            const botY: com.vzome.core.algebra.AlgebraicNumber = maxTerm.reciprocal();
            const halfHeight: com.vzome.core.algebra.AlgebraicNumber = (pkgName === "thin") ? field.getUnitDiagonal(field.diagonalCount() - 1).reciprocal() : field.one();
            const rotationMatrix: com.vzome.core.algebra.AlgebraicMatrix = symm.getRotationMatrix();
            let vTop: com.vzome.core.algebra.AlgebraicVector = new com.vzome.core.algebra.AlgebraicVector(topX, topY, halfHeight);
            let vBot: com.vzome.core.algebra.AlgebraicVector = new com.vzome.core.algebra.AlgebraicVector(botX, botY, halfHeight.negate());
            for(let i: number = 0; i < nSides; i++) {{
                antiprism.addVertex(vTop);
                antiprism.addVertex(vBot);
                vTop = rotationMatrix.timesColumn(vTop);
                vBot = rotationMatrix.timesColumn(vBot);
            };}
            const topFace: com.vzome.core.math.Polyhedron.Face = antiprism.newFace();
            const botFace: com.vzome.core.math.Polyhedron.Face = antiprism.newFace();
            for(let i: number = 0; i < nSides * 2; i += 2) {{
                topFace.add(i);
            };}
            for(let i: number = nSides * 2 - 1; i >= 0; i -= 2) {{
                botFace.add(i);
            };}
            antiprism.addFace(topFace);
            antiprism.addFace(botFace);
            const nVertices: number = nSides * 2;
            for(let i: number = 0; i < nSides * 2; i += 2) {{
                const face: com.vzome.core.math.Polyhedron.Face = antiprism.newFace();
                face.add(i);
                face.add((i + 1) % nVertices);
                face.add((i + 2) % nVertices);
                antiprism.addFace(face);
            };}
            for(let i: number = 1; i < nSides * 2; i += 2) {{
                const face: com.vzome.core.math.Polyhedron.Face = antiprism.newFace();
                face.add(i);
                face.add((i + 2) % nVertices);
                face.add((i + 1) % nVertices);
                antiprism.addFace(face);
            };}
            return antiprism;
        }
    }
    AntiprismShapes["__class"] = "com.vzome.core.viewing.AntiprismShapes";
    AntiprismShapes["__interfaces"] = ["com.vzome.core.editor.api.Shapes"];


}
namespace com.vzome.core.viewing {
    export class OctahedralShapes extends com.vzome.core.viewing.AbstractShapes {
        public constructor(pkgName: string, name: string, symm: com.vzome.core.math.symmetry.Symmetry) {
            super(pkgName, name, null, symm);
        }

        /**
         * 
         * @param {string} pkgName
         * @return {com.vzome.core.math.Polyhedron}
         */
        buildConnectorShape(pkgName: string): com.vzome.core.math.Polyhedron {
            const field: com.vzome.core.algebra.AlgebraicField = this.mSymmetry.getField();
            const cube: com.vzome.core.math.Polyhedron = new com.vzome.core.math.Polyhedron(field);
            let scale: com.vzome.core.algebra.AlgebraicNumber = field['createPower$int'](-2);
            scale = field['createRational$long'](2)['times$com_vzome_core_algebra_AlgebraicNumber'](scale);
            const x: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
            const y: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y);
            const z: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
            cube.addVertex(x.scale(scale));
            cube.addVertex(x.negate().scale(scale));
            cube.addVertex(y.scale(scale));
            cube.addVertex(y.negate().scale(scale));
            cube.addVertex(z.scale(scale));
            cube.addVertex(z.negate().scale(scale));
            let face: com.vzome.core.math.Polyhedron.Face = cube.newFace();
            face.add(0);
            face.add(2);
            face.add(4);
            cube.addFace(face);
            face = cube.newFace();
            face.add(0);
            face.add(5);
            face.add(2);
            cube.addFace(face);
            face = cube.newFace();
            face.add(0);
            face.add(3);
            face.add(5);
            cube.addFace(face);
            face = cube.newFace();
            face.add(0);
            face.add(4);
            face.add(3);
            cube.addFace(face);
            face = cube.newFace();
            face.add(1);
            face.add(4);
            face.add(2);
            cube.addFace(face);
            face = cube.newFace();
            face.add(1);
            face.add(2);
            face.add(5);
            cube.addFace(face);
            face = cube.newFace();
            face.add(1);
            face.add(5);
            face.add(3);
            cube.addFace(face);
            face = cube.newFace();
            face.add(1);
            face.add(3);
            face.add(4);
            cube.addFace(face);
            return cube;
        }
    }
    OctahedralShapes["__class"] = "com.vzome.core.viewing.OctahedralShapes";
    OctahedralShapes["__interfaces"] = ["com.vzome.core.editor.api.Shapes"];


}
namespace com.vzome.core.zomic {
    /**
     * Implements the Zomic execution model while visiting a program.
     * 
     * @author Scott Vorthmann 2003
     * @param {*} renderer
     * @param {*} symmetry
     * @class
     * @extends com.vzome.core.zomic.program.Visitor.Default
     */
    export class Interpreter extends com.vzome.core.zomic.program.Visitor.Default {
        mEvents: com.vzome.core.render.ZomicEventHandler;

        mSymmetry: com.vzome.core.math.symmetry.Symmetry;

        public constructor(renderer: com.vzome.core.render.ZomicEventHandler, symmetry: com.vzome.core.math.symmetry.Symmetry) {
            super();
            if (this.mEvents === undefined) { this.mEvents = null; }
            if (this.mSymmetry === undefined) { this.mSymmetry = null; }
            this.mEvents = renderer;
            this.mSymmetry = symmetry;
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Axis} axis
         * @param {*} length
         */
        public visitMove(axis: com.vzome.core.math.symmetry.Axis, length: com.vzome.core.algebra.AlgebraicNumber) {
            this.mEvents.step(axis, length);
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Axis} axis
         * @param {number} steps
         */
        public visitRotate(axis: com.vzome.core.math.symmetry.Axis, steps: number) {
            this.mEvents.rotate(axis, steps);
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Axis} blueAxis
         */
        public visitReflect(blueAxis: com.vzome.core.math.symmetry.Axis) {
            this.mEvents.reflect(blueAxis);
        }

        /**
         * 
         * @param {com.vzome.core.zomic.program.Symmetry} model
         * @param {com.vzome.core.zomic.program.Permute} permute
         */
        public visitSymmetry(model: com.vzome.core.zomic.program.Symmetry, permute: com.vzome.core.zomic.program.Permute) {
            if (permute != null){
                const repetitions: number = permute.getOrder();
                if (repetitions === 1)throw new java.lang.RuntimeException("no rotation symmetry around extended axes");
                for(let i: number = 0; i < repetitions; i++) {{
                    this.saveAndNest(model, com.vzome.core.render.ZomicEventHandler.ORIENTATION);
                    permute.accept(this);
                };}
            } else {
                for(let i: number = 0; i < this.mSymmetry.getChiralOrder(); i++) {{
                    const current: com.vzome.core.math.symmetry.Permutation = this.mSymmetry.getPermutation(i);
                    const saved: com.vzome.core.render.ZomicEventHandler = this.mEvents;
                    this.mEvents = this.mEvents.save(com.vzome.core.render.ZomicEventHandler.ALL);
                    this.mEvents.permute(current, com.vzome.core.math.symmetry.Symmetry.PLUS);
                    try {
                        this.visitNested(model);
                    } catch(e) {
                        throw new java.lang.RuntimeException("error in global symmetry");
                    }
                    saved.restore(this.mEvents, com.vzome.core.render.ZomicEventHandler.ALL);
                    this.mEvents = saved;
                };}
            }
        }

        /*private*/ saveAndNest(stmt: com.vzome.core.zomic.program.Nested, state: number) {
            const saved: com.vzome.core.render.ZomicEventHandler = this.mEvents;
            this.mEvents = this.mEvents.save(state);
            this.visitNested(stmt);
            saved.restore(this.mEvents, state);
            this.mEvents = saved;
        }

        /**
         * 
         * @param {com.vzome.core.zomic.program.Save} stmt
         * @param {number} state
         */
        public visitSave(stmt: com.vzome.core.zomic.program.Save, state: number) {
            this.saveAndNest(stmt, state);
        }

        /**
         * 
         * @param {*} size
         */
        public visitScale(size: com.vzome.core.algebra.AlgebraicNumber) {
            this.mEvents.scale(size);
        }

        /**
         * 
         * @param {boolean} build
         * @param {boolean} destroy
         */
        public visitBuild(build: boolean, destroy: boolean) {
            let action: number = com.vzome.core.render.ZomicEventHandler.JUST_MOVE;
            if (build)action |= com.vzome.core.render.ZomicEventHandler.BUILD;
            if (destroy)action |= com.vzome.core.render.ZomicEventHandler.DESTROY;
            this.mEvents.action(action);
        }
    }
    Interpreter["__class"] = "com.vzome.core.zomic.Interpreter";
    Interpreter["__interfaces"] = ["com.vzome.core.zomic.program.Visitor"];


}
namespace com.vzome.core.zomic.program {
    /**
     * Description here.
     * 
     * @author Scott Vorthmann 2003
     * @param {boolean} build
     * @param {boolean} destroy
     * @class
     * @extends com.vzome.core.zomic.program.ZomicStatement
     */
    export class Build extends com.vzome.core.zomic.program.ZomicStatement {
        /*private*/ m_build: boolean;

        /*private*/ m_destroy: boolean;

        public constructor(build: boolean, destroy: boolean) {
            super();
            if (this.m_build === undefined) { this.m_build = false; }
            if (this.m_destroy === undefined) { this.m_destroy = false; }
            this.m_build = build;
            this.m_destroy = destroy;
        }

        /**
         * 
         * @param {*} visitor
         */
        public accept(visitor: com.vzome.core.zomic.program.Visitor) {
            visitor.visitBuild(this.m_build, this.m_destroy);
        }

        public setBuild(value: boolean) {
            this.m_build = value;
        }

        public setDestroy(value: boolean) {
            this.m_destroy = value;
        }

        public justMoving(): boolean {
            return this.m_build === this.m_destroy;
        }
    }
    Build["__class"] = "com.vzome.core.zomic.program.Build";

}
namespace com.vzome.core.zomic.program {
    /**
     * @author vorth
     * @param {string} id
     * @class
     * @extends com.vzome.core.zomic.program.ZomicStatement
     */
    export class Label extends com.vzome.core.zomic.program.ZomicStatement {
        mLabel: string;

        public constructor(id: string) {
            super();
            if (this.mLabel === undefined) { this.mLabel = null; }
            this.mLabel = id;
        }

        /**
         * 
         * @param {*} visitor
         */
        public accept(visitor: com.vzome.core.zomic.program.Visitor) {
            visitor.visitLabel(this.mLabel);
        }
    }
    Label["__class"] = "com.vzome.core.zomic.program.Label";

}
namespace com.vzome.core.zomic.program {
    /**
     * @author vorth
     * @param {com.vzome.core.math.symmetry.Axis} axis
     * @class
     * @extends com.vzome.core.zomic.program.ZomicStatement
     */
    export abstract class Permute extends com.vzome.core.zomic.program.ZomicStatement {
        /*private*/ m_axis: com.vzome.core.math.symmetry.Axis;

        public constructor(axis: com.vzome.core.math.symmetry.Axis) {
            super();
            if (this.m_axis === undefined) { this.m_axis = null; }
            this.m_axis = axis;
        }

        public setAxis(axis: com.vzome.core.math.symmetry.Axis) {
            this.m_axis = axis;
        }

        public getOrder(): number {
            if (this.m_axis == null)return 2;
            return this.m_axis.getRotationPermutation().getOrder();
        }

        public getAxis(): com.vzome.core.math.symmetry.Axis {
            return this.m_axis;
        }
    }
    Permute["__class"] = "com.vzome.core.zomic.program.Permute";

}
namespace com.vzome.core.zomic.program {
    /**
     * @author vorth
     * @param {string} msg
     * @class
     * @extends com.vzome.core.zomic.program.ZomicStatement
     */
    export class Untranslatable extends com.vzome.core.zomic.program.ZomicStatement {
        message: string;

        public constructor(msg: string) {
            super();
            if (this.message === undefined) { this.message = null; }
            this.message = msg;
        }

        public setMessage(msg: string) {
            this.message = msg;
        }

        /**
         * 
         * @param {*} visitor
         */
        public accept(visitor: com.vzome.core.zomic.program.Visitor) {
            visitor.visitUntranslatable(this.message == null ? "" : this.message);
        }
    }
    Untranslatable["__class"] = "com.vzome.core.zomic.program.Untranslatable";

}
namespace com.vzome.core.zomic.program {
    export class Nested extends com.vzome.core.zomic.program.ZomicStatement {
        m_body: com.vzome.core.zomic.program.ZomicStatement;

        /**
         * 
         * @param {*} visitor
         */
        public accept(visitor: com.vzome.core.zomic.program.Visitor) {
            visitor.visitNested(this);
        }

        public setBody(body: com.vzome.core.zomic.program.ZomicStatement) {
            this.m_body = body;
        }

        public getBody(): com.vzome.core.zomic.program.ZomicStatement {
            return this.m_body;
        }

        constructor() {
            super();
            if (this.m_body === undefined) { this.m_body = null; }
        }
    }
    Nested["__class"] = "com.vzome.core.zomic.program.Nested";

}
namespace com.vzome.core.zomic.program {
    export class Move extends com.vzome.core.zomic.program.ZomicStatement {
        axis: com.vzome.core.math.symmetry.Axis;

        length: com.vzome.core.algebra.AlgebraicNumber;

        public constructor(axis: com.vzome.core.math.symmetry.Axis, len: com.vzome.core.algebra.AlgebraicNumber) {
            super();
            if (this.axis === undefined) { this.axis = null; }
            if (this.length === undefined) { this.length = null; }
            this.axis = axis;
            this.length = len;
        }

        /**
         * 
         * @param {*} visitor
         */
        public accept(visitor: com.vzome.core.zomic.program.Visitor) {
            visitor.visitMove(this.axis, this.length);
        }

        /**
         * @return
         * @return {*}
         */
        public getLength(): com.vzome.core.algebra.AlgebraicNumber {
            return this.length;
        }

        public getAxis(): com.vzome.core.math.symmetry.Axis {
            return this.axis;
        }

        /**
         * Needed only for Zomic XMLS2AST.  TODO: remove this by
         * rearranging the XML?
         * @param axis2
         * @param {*} len
         * @param {com.vzome.core.math.symmetry.Axis} axis
         */
        public reset(axis: com.vzome.core.math.symmetry.Axis, len: com.vzome.core.algebra.AlgebraicNumber) {
            this.axis = axis;
            this.length = len;
        }
    }
    Move["__class"] = "com.vzome.core.zomic.program.Move";

}
namespace com.vzome.core.zomic.program {
    export class Walk extends com.vzome.core.zomic.program.ZomicStatement implements java.lang.Iterable<com.vzome.core.zomic.program.ZomicStatement> {
        /*private*/ stmts: java.util.List<com.vzome.core.zomic.program.ZomicStatement>;

        /**
         * 
         * @param {*} visitor
         */
        public accept(visitor: com.vzome.core.zomic.program.Visitor) {
            visitor.visitWalk(this);
        }

        public addStatement(stmt: com.vzome.core.zomic.program.ZomicStatement) {
            this.stmts.add(stmt);
        }

        /**
         * 
         * @return {*}
         */
        public iterator(): java.util.Iterator<com.vzome.core.zomic.program.ZomicStatement> {
            return this.stmts.iterator();
        }

        public size(): number {
            return this.stmts.size();
        }

        constructor() {
            super();
            this.stmts = <any>(new java.util.ArrayList<any>());
        }
    }
    Walk["__class"] = "com.vzome.core.zomic.program.Walk";
    Walk["__interfaces"] = ["java.lang.Iterable"];


}
namespace com.vzome.core.zomic.program {
    export class Scale extends com.vzome.core.zomic.program.ZomicStatement {
        /*private*/ m_scale: com.vzome.core.algebra.AlgebraicNumber;

        public constructor(size: com.vzome.core.algebra.AlgebraicNumber) {
            super();
            if (this.m_scale === undefined) { this.m_scale = null; }
            this.m_scale = size;
        }

        /**
         * 
         * @param {*} visitor
         */
        public accept(visitor: com.vzome.core.zomic.program.Visitor) {
            visitor.visitScale(this.m_scale);
        }
    }
    Scale["__class"] = "com.vzome.core.zomic.program.Scale";

}
namespace com.vzome.core.zomic {
    export class GreenDirectionNaming extends com.vzome.core.math.symmetry.DirectionNaming {
        mMap: com.vzome.core.math.symmetry.Axis[];

        mRedNames: com.vzome.core.math.symmetry.DirectionNaming;

        mYellowNames: com.vzome.core.math.symmetry.DirectionNaming;

        constructor(dir: com.vzome.core.math.symmetry.Direction, reds: com.vzome.core.math.symmetry.DirectionNaming, yellows: com.vzome.core.math.symmetry.DirectionNaming) {
            super(dir, dir.getName());
            if (this.mMap === undefined) { this.mMap = null; }
            if (this.mRedNames === undefined) { this.mRedNames = null; }
            if (this.mYellowNames === undefined) { this.mYellowNames = null; }
            this.mRedNames = reds;
            this.mYellowNames = yellows;
            this.mMap = (s => { let a=[]; while(s-->0) a.push(null); return a; })(dir.getSymmetry().getChiralOrder());
            for(let i: number = 0; i < this.mMap.length; i++) {{
                let axis: com.vzome.core.math.symmetry.Axis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, i);
                const ry: string = this.getName$com_vzome_core_math_symmetry_Axis(axis);
                const sense: number = this.getSign(ry);
                const index: number = this.getInteger(ry);
                if (sense === com.vzome.core.math.symmetry.Symmetry.MINUS)axis = dir.getAxis$int$int(sense, i);
                this.mMap[index] = axis;
            };}
        }

        /**
         * 
         * @param {string} axisName
         * @return {com.vzome.core.math.symmetry.Axis}
         */
        public getAxis(axisName: string): com.vzome.core.math.symmetry.Axis {
            const sense: number = this.getSign(axisName);
            const ry: number = this.getInteger(axisName);
            let axis: com.vzome.core.math.symmetry.Axis = this.mMap[ry];
            if (sense === com.vzome.core.math.symmetry.Symmetry.MINUS)axis = this.getDirection().getAxis$int$int(sense, axis.getOrientation());
            return axis;
        }

        public getName$com_vzome_core_math_symmetry_Axis(axis: com.vzome.core.math.symmetry.Axis): string {
            const redNeighbor: com.vzome.core.math.symmetry.Axis = this.mRedNames.getDirection().getAxis$int$int(axis.getSense(), axis.getOrientation());
            const redName: string = this.mRedNames.getName$com_vzome_core_math_symmetry_Axis(redNeighbor);
            const yellowNeighbor: com.vzome.core.math.symmetry.Axis = this.mYellowNames.getDirection().getAxis$int$int(axis.getSense(), axis.getOrientation());
            const yellowName: string = this.mYellowNames.getName$com_vzome_core_math_symmetry_Axis(yellowNeighbor).substring(1);
            return redName + yellowName;
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Axis} axis
         * @return {string}
         */
        public getName(axis?: any): string {
            if (((axis != null && axis instanceof <any>com.vzome.core.math.symmetry.Axis) || axis === null)) {
                return <any>this.getName$com_vzome_core_math_symmetry_Axis(axis);
            } else if (axis === undefined) {
                return <any>this.getName$();
            } else throw new Error('invalid overload');
        }
    }
    GreenDirectionNaming["__class"] = "com.vzome.core.zomic.GreenDirectionNaming";

}
namespace com.vzome.core.zomic {
    export class BlackDirectionNaming extends com.vzome.core.math.symmetry.DirectionNaming {
        mMap: com.vzome.core.math.symmetry.Axis[][];

        mRedNames: com.vzome.core.math.symmetry.DirectionNaming;

        mYellowNames: com.vzome.core.math.symmetry.DirectionNaming;

        constructor(dir: com.vzome.core.math.symmetry.Direction, reds: com.vzome.core.math.symmetry.DirectionNaming, yellows: com.vzome.core.math.symmetry.DirectionNaming) {
            super(dir, dir.getName());
            if (this.mMap === undefined) { this.mMap = null; }
            if (this.mRedNames === undefined) { this.mRedNames = null; }
            if (this.mYellowNames === undefined) { this.mYellowNames = null; }
            this.mRedNames = reds;
            this.mYellowNames = yellows;
            this.mMap = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([2, dir.getSymmetry().getChiralOrder()]);
            for(let sense: number = com.vzome.core.math.symmetry.Symmetry.PLUS; sense <= com.vzome.core.math.symmetry.Symmetry.MINUS; sense++) {for(let i: number = 0; i < this.mMap[com.vzome.core.math.symmetry.Symmetry.PLUS].length; i++) {{
                const axis: com.vzome.core.math.symmetry.Axis = dir.getAxis$int$int(sense, i);
                const ry: string = this.getName$com_vzome_core_math_symmetry_Axis(axis);
                if (this.getSign(ry) === com.vzome.core.math.symmetry.Symmetry.MINUS)continue;
                const minused: boolean = /* endsWith */((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(ry, "-");
                const index: number = this.getInteger(ry);
                const sign: number = minused ? com.vzome.core.math.symmetry.Symmetry.MINUS : com.vzome.core.math.symmetry.Symmetry.PLUS;
                this.mMap[sign][index] = axis;
            };};}
        }

        /**
         * 
         * @param {string} axisName
         * @return {number}
         */
        getInteger(axisName: string): number {
            if (/* endsWith */((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(axisName, "-") || /* endsWith */((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(axisName, "+"))axisName = axisName.substring(0, axisName.length - 1);
            if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(axisName, "-") || /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(axisName, "+"))return javaemul.internal.IntegerHelper.parseInt(axisName.substring(1));
            return javaemul.internal.IntegerHelper.parseInt(axisName);
        }

        /**
         * 
         * @param {string} axisName
         * @return {com.vzome.core.math.symmetry.Axis}
         */
        public getAxis(axisName: string): com.vzome.core.math.symmetry.Axis {
            const minused: boolean = /* endsWith */((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(axisName, "-");
            const sense: number = this.getSign(axisName);
            const ry: number = this.getInteger(axisName);
            let axis: com.vzome.core.math.symmetry.Axis = this.mMap[minused ? com.vzome.core.math.symmetry.Symmetry.MINUS : com.vzome.core.math.symmetry.Symmetry.PLUS][ry];
            if (sense === com.vzome.core.math.symmetry.Symmetry.MINUS)axis = this.getDirection().getAxis$int$int((axis.getSense() + 1) % 2, axis.getOrientation());
            return axis;
        }

        public getName$com_vzome_core_math_symmetry_Axis(axis: com.vzome.core.math.symmetry.Axis): string {
            let orn: number = axis.getOrientation();
            const redNeighbor: com.vzome.core.math.symmetry.Axis = this.mRedNames.getDirection().getAxis$int$int(axis.getSense(), orn);
            const redName: string = this.mRedNames.getName$com_vzome_core_math_symmetry_Axis(redNeighbor);
            let rot: com.vzome.core.math.symmetry.Permutation = redNeighbor.getRotationPermutation();
            if (axis.getSense() === com.vzome.core.math.symmetry.Symmetry.MINUS)rot = rot.inverse();
            orn = rot.mapIndex(orn);
            const redSign: number = this.getSign(redName);
            const yellowNeighbor: com.vzome.core.math.symmetry.Axis = this.mYellowNames.getDirection().getAxis$int$int(redSign, orn);
            let yellowName: string = this.mYellowNames.getName$com_vzome_core_math_symmetry_Axis(yellowNeighbor).substring(1);
            if (axis.getSense() === redSign)yellowName += "-";
            return redName + yellowName;
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Axis} axis
         * @return {string}
         */
        public getName(axis?: any): string {
            if (((axis != null && axis instanceof <any>com.vzome.core.math.symmetry.Axis) || axis === null)) {
                return <any>this.getName$com_vzome_core_math_symmetry_Axis(axis);
            } else if (axis === undefined) {
                return <any>this.getName$();
            } else throw new Error('invalid overload');
        }
    }
    BlackDirectionNaming["__class"] = "com.vzome.core.zomic.BlackDirectionNaming";

}
namespace com.vzome.core.zomic {
    export class ZomodDirectionNaming extends com.vzome.core.math.symmetry.DirectionNaming {
        /*private*/ mMapping: number[];

        /*private*/ mBackMap: java.util.Map<com.vzome.core.math.symmetry.Axis, string>;

        constructor(dir: com.vzome.core.math.symmetry.Direction, mapping: number[]) {
            super(dir, dir.getName());
            if (this.mMapping === undefined) { this.mMapping = null; }
            this.mBackMap = <any>(new java.util.HashMap<any, any>());
            this.mMapping = mapping;
            for(let i: number = 0; i < this.mMapping.length; i++) {{
                let axis: com.vzome.core.math.symmetry.Axis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, this.mMapping[i]);
                this.mBackMap.put(axis, "+" + i);
                axis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.MINUS, this.mMapping[i]);
                this.mBackMap.put(axis, "-" + i);
            };}
        }

        /**
         * 
         * @param {string} axisName
         * @return {com.vzome.core.math.symmetry.Axis}
         */
        public getAxis(axisName: string): com.vzome.core.math.symmetry.Axis {
            const sense: number = this.getSign(axisName);
            const index: number = this.getInteger(axisName);
            return this.getDirection().getAxis$int$int(sense, this.mMapping[index]);
        }

        public getName$com_vzome_core_math_symmetry_Axis(axis: com.vzome.core.math.symmetry.Axis): string {
            return this.mBackMap.get(axis);
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Axis} axis
         * @return {string}
         */
        public getName(axis?: any): string {
            if (((axis != null && axis instanceof <any>com.vzome.core.math.symmetry.Axis) || axis === null)) {
                return <any>this.getName$com_vzome_core_math_symmetry_Axis(axis);
            } else if (axis === undefined) {
                return <any>this.getName$();
            } else throw new Error('invalid overload');
        }
    }
    ZomodDirectionNaming["__class"] = "com.vzome.core.zomic.ZomodDirectionNaming";

}
namespace com.vzome.core.math.symmetry {
    /**
     * @author Scott Vorthmann
     * @param {*} field
     * @class
     * @extends com.vzome.core.math.symmetry.AbstractSymmetry
     */
    export class IcosahedralSymmetry extends com.vzome.core.math.symmetry.AbstractSymmetry {
        /*private*/ INCIDENCES: number[][];

        public IDENTITY: com.vzome.core.math.symmetry.Permutation;

        /*private*/ preferredAxis: com.vzome.core.math.symmetry.Axis;

        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            super(60, field, "blue", null);
            this.INCIDENCES = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return 0; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([60, 3]);
            this.IDENTITY = new com.vzome.core.math.symmetry.Permutation(this, null);
            if (this.preferredAxis === undefined) { this.preferredAxis = null; }
            this.tetrahedralSubgroup = [null, null, null, null, null];
            this.blueTetrahedral = (s => { let a=[]; while(s-->0) a.push(0); return a; })(60);
            this.greenTetrahedral = (s => { let a=[]; while(s-->0) a.push(0); return a; })(60);
            this.yellowTetrahedral = (s => { let a=[]; while(s-->0) a.push(0); return a; })(60);
            for(let i: number = 0; i < this.INCIDENCES.length; i++) {{
                this.INCIDENCES[i][0] = this.getPermutation(i).mapIndex(30);
                this.INCIDENCES[i][1] = this.getPermutation(i).mapIndex(45);
                this.INCIDENCES[i][2] = this.getPermutation(i).mapIndex(42);
            };}
            this.tetrahedralSubgroup[0] = this.closure([1, 15]);
            this.tetrahedralSubgroup[1] = this.closure([11, 20]);
            this.tetrahedralSubgroup[2] = this.closure([27, 58]);
            this.tetrahedralSubgroup[3] = this.closure([17, 4]);
            this.tetrahedralSubgroup[4] = this.closure([55, 14]);
            const blueOrbit: com.vzome.core.math.symmetry.Direction = this.getDirection("blue");
            const yellowOrbit: com.vzome.core.math.symmetry.Direction = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("yellow", 0, 27, field.createVector([[1, 1, 1, 1], [0, 1, 0, 1], [-1, 1, 0, 1]]), true, false, this.mField['createPower$int'](-1));
            yellowOrbit.setScaleNames(["y0", "y1", "y2", "y3"]);
            yellowOrbit.iterator();
            for(let i: number = 0; i < 60; i++) {{
                const blueZone: com.vzome.core.math.symmetry.Axis = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, i);
                const yellowZone: com.vzome.core.math.symmetry.Axis = yellowOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, i);
                for(let j: number = 0; j < this.tetrahedralSubgroup.length; j++) {{
                    for(let k: number = 0; k < this.tetrahedralSubgroup[j].length; k++) {{
                        if (this.tetrahedralSubgroup[j][k] === blueZone.getRotation())this.blueTetrahedral[i] = j;
                        if (this.tetrahedralSubgroup[j][k] === yellowZone.getRotation())this.yellowTetrahedral[i] = j;
                    };}
                };}
            };}
            const greenSeeds: number[] = [6, 9, 12, 0, 3];
            for(let j: number = 0; j < this.tetrahedralSubgroup.length; j++) {{
                const seedAxis: number = greenSeeds[j];
                for(let k: number = 0; k < this.tetrahedralSubgroup[j].length; k++) {{
                    const mappedAxis: number = this.mOrientations[this.tetrahedralSubgroup[j][k]].mapIndex(seedAxis);
                    this.greenTetrahedral[mappedAxis] = j;
                };}
            };}
            const redOrbit: com.vzome.core.math.symmetry.Direction = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("red", 0, 3, this.mField.createVector([[0, 1, 1, 1], [1, 1, 0, 1], [0, 1, 0, 1]]), true);
            redOrbit.setScaleNames(["r0", "r1", "r2", "r3"]);
            this.preferredAxis = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 1);
        }

        /**
         * 
         * @param {number} orientation
         * @return {int[]}
         */
        public getIncidentOrientations(orientation: number): number[] {
            return this.INCIDENCES[orientation];
        }

        /**
         * Create a collection of blue-axis normals from a prototype,
         * by applying known rotations.
         * @param {com.vzome.core.math.symmetry.Direction} dir
         * @param {number} prototype
         * @param {number} rotated
         * @param {com.vzome.core.algebra.AlgebraicVector} xyz
         * @private
         */
        /*private*/ createBlueAxes(dir: com.vzome.core.math.symmetry.Direction, prototype: number, rotated: number, xyz: com.vzome.core.algebra.AlgebraicVector) {
            let orientation: number = 0;
            const reflect: boolean[] = [false, false, false];
            for(let i: number = 0; i < 3; i++) {{
                for(let k: number = 0; k < 2; k++) {{
                    for(let l: number = 0; l < 2; l++) {{
                        const unit: number = this.mOrientations[orientation].mapIndex(prototype);
                        if (!dir.zoneInitialized(com.vzome.core.math.symmetry.Symmetry.PLUS, unit)){
                            const rot: number = this.mOrientations[orientation].mapIndex(rotated);
                            const rotation: number = this.getMapping(unit, rot);
                            const norm: com.vzome.core.algebra.AlgebraicVector = this.mField.origin(3);
                            for(let m: number = 0; m < 3; m++) {{
                                const offset: number = ((m + 3 - i) % 3);
                                if (reflect[m]){
                                    norm.setComponent(m, xyz.getComponent(offset).negate());
                                } else {
                                    norm.setComponent(m, xyz.getComponent(offset));
                                }
                            };}
                            dir.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(unit, rotation, norm);
                            dir.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(rot, rotation, norm);
                        }
                        orientation = this.mOrientations[45].mapIndex(orientation);
                        reflect[0] = !reflect[0];
                        reflect[2] = !reflect[2];
                    };}
                    orientation = this.mOrientations[15].mapIndex(orientation);
                    reflect[1] = !reflect[1];
                    reflect[2] = !reflect[2];
                };}
                orientation = this.mOrientations[1].mapIndex(orientation);
            };}
        }

        /**
         * 
         * @return {string}
         */
        public getName(): string {
            return "icosahedral";
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector[]}
         */
        public getOrbitTriangle(): com.vzome.core.algebra.AlgebraicVector[] {
            const twice: com.vzome.core.algebra.AlgebraicNumber = this.mField['createRational$long'](2);
            const blueVertex: com.vzome.core.algebra.AlgebraicVector = this.getDirection("blue").getPrototype().scale(twice);
            const redVertex: com.vzome.core.algebra.AlgebraicVector = this.getDirection("red").getPrototype();
            const phiInv: com.vzome.core.algebra.AlgebraicNumber = this.mField.getGoldenRatio().reciprocal();
            const yellowVertex: com.vzome.core.algebra.AlgebraicVector = this.getDirection("yellow").getPrototype().scale(phiInv);
            return [blueVertex, redVertex, yellowVertex];
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.SpecialOrbit} which
         * @return {com.vzome.core.math.symmetry.Direction}
         */
        public getSpecialOrbit(which: com.vzome.core.math.symmetry.SpecialOrbit): com.vzome.core.math.symmetry.Direction {
            switch((which)) {
            case com.vzome.core.math.symmetry.SpecialOrbit.BLUE:
                return this.getDirection("blue");
            case com.vzome.core.math.symmetry.SpecialOrbit.RED:
                return this.getDirection("red");
            case com.vzome.core.math.symmetry.SpecialOrbit.YELLOW:
                return this.getDirection("yellow");
            default:
                return this.getDirection("black");
            }
        }

        /**
         * 
         * @param {string} frameColor
         */
        createFrameOrbit(frameColor: string) {
            const xAxis: com.vzome.core.algebra.AlgebraicVector = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
            const dir: com.vzome.core.math.symmetry.Direction = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(frameColor, 0, 15, xAxis, true, true, this.mField['createRational$long'](2));
            dir.setScaleNames(["b0", "b1", "b2", "b3"]);
            this.createBlueAxes(dir, 0, 15, xAxis);
            this.createBlueAxes(dir, 9, 13, this.mField.createVector([[1, 2, 0, 1], [0, 1, 1, 2], [-1, 2, 1, 2]]));
            this.createBlueAxes(dir, 6, 49, this.mField.createVector([[1, 2, 0, 1], [0, 1, 1, 2], [1, 2, -1, 2]]));
            for(let p: number = 0; p < this.mOrientations.length; p++) {{
                const x: number = this.mOrientations[p].mapIndex(0);
                const y: number = this.mOrientations[p].mapIndex(1);
                const z: number = this.mOrientations[p].mapIndex(2);
                this.mMatrices[p] = new com.vzome.core.algebra.AlgebraicMatrix(dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, x).normal(), dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, y).normal(), dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, z).normal());
                const axis: com.vzome.core.math.symmetry.Axis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, p);
                const norm: com.vzome.core.algebra.AlgebraicVector = this.mMatrices[p].timesColumn(xAxis);
                if (!norm.equals(axis.normal()))throw new java.lang.IllegalStateException("matrix wrong: " + p);
            };}
        }

        /**
         * 
         * @return {com.vzome.core.math.symmetry.Axis}
         */
        public getPreferredAxis(): com.vzome.core.math.symmetry.Axis {
            return this.preferredAxis;
        }

        /**
         * @see com.vzome.core.math.symmetry.AbstractSymmetry#createOtherOrbits()
         * 
         * @see com.vzome.core.algebra.AlgebraicField#createVector()
         * 
         * @see com.vzome.core.math.symmetry.AbstractSymmetry#createZoneOrbit(String, int, int, AlgebraicVector, boolean, boolean, AlgebraicNumber)
         */
        createOtherOrbits() {
            const dir: com.vzome.core.math.symmetry.Direction = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("green", 6, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[1, 1, 0, 1], [1, 1, 0, 1], [0, 1, 0, 1]]), true, true, this.mField['createRational$long'](2));
            dir.setScaleNames(["g0", "g1", "g2", "g3"]);
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("orange", 6, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[1, 1, 0, 1], [0, 1, 1, 1], [0, 1, 0, 1]]));
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("purple", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[1, 1, 1, 1], [1, 1, 0, 1], [0, 1, 0, 1]]), false, false, this.mField['createPower$int'](-1));
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("black", 3, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[0, 1, 1, 1], [1, 1, 0, 1], [1, 1, -1, 1]]));
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("lavender", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[2, 1, -1, 1], [0, 1, 1, 1], [2, 1, -1, 1]])).withCorrection();
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("olive", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[0, 1, 1, 1], [0, 1, 1, 1], [2, 1, -1, 1]])).withCorrection();
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("maroon", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-1, 1, 1, 1], [3, 1, -1, 1], [1, 1, -1, 1]])).withCorrection();
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("rose", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[2, 1, -1, 1], [-1, 1, 2, 1], [0, 1, 0, 1]])).withCorrection();
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("navy", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-1, 1, 2, 1], [1, 1, 1, 1], [0, 1, 0, 1]]), false, false, this.mField['createPower$int'](-1)).withCorrection();
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("turquoise", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[2, 1, 0, 1], [2, 1, -1, 1], [-3, 1, 2, 1]])).withCorrection();
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("coral", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-3, 1, 3, 1], [0, 1, 0, 1], [1, 1, 0, 1]])).withCorrection();
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("sulfur", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-3, 1, 3, 1], [2, 1, -1, 1], [0, 1, 0, 1]])).withCorrection();
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("sand", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-2, 1, 2, 1], [-2, 1, 2, 1], [2, 1, 0, 1]])).withCorrection();
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("apple", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[5, 1, -3, 1], [1, 1, 0, 1], [0, 1, 1, 1]])).withCorrection();
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("cinnamon", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[5, 1, -3, 1], [2, 1, -1, 1], [2, 1, 0, 1]])).withCorrection();
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("spruce", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-3, 1, 2, 1], [-3, 1, 2, 1], [5, 1, -2, 1]])).withCorrection();
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("brown", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-1, 1, 1, 1], [-1, 1, 1, 1], [-2, 1, 2, 1]])).withCorrection();
        }

        /**
         * 
         */
        createInitialPermutations() {
            const ORDER: number = 60;
            this.mOrientations[0] = this.IDENTITY;
            let map: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(ORDER);
            for(let i: number = 0; i < 15; i++) {{
                map[i] = i + 15;
                map[i + 15] = i;
                map[i + 30] = i + 45;
                map[i + 45] = i + 30;
            };}
            this.mOrientations[15] = new com.vzome.core.math.symmetry.Permutation(this, map);
            map = (s => { let a=[]; while(s-->0) a.push(0); return a; })(ORDER);
            const starts: number[][] = [[0, 1, 2], [15, 46, 32], [16, 47, 30], [17, 45, 31]];
            for(let index = 0; index < starts.length; index++) {
                let start = starts[index];
                {
                    for(let j: number = 0; j < start.length; j++) {{
                        for(let k: number = 0; k < 5; k++) {{
                            map[start[j] + k * 3] = start[(j + 1) % 3] + k * 3;
                        };}
                    };}
                }
            }
            this.mOrientations[1] = new com.vzome.core.math.symmetry.Permutation(this, map);
            map = (s => { let a=[]; while(s-->0) a.push(0); return a; })(ORDER);
            const cycles: number[][] = [[0, 3, 6, 9, 12], [30, 42, 39, 36, 33], [2, 21, 29, 55, 4], [5, 24, 17, 58, 7], [8, 27, 20, 46, 10], [11, 15, 23, 49, 13], [1, 14, 18, 26, 52], [16, 50, 57, 38, 40], [19, 53, 45, 41, 43], [22, 56, 48, 44, 31], [25, 59, 51, 32, 34], [28, 47, 54, 35, 37]];
            for(let index = 0; index < cycles.length; index++) {
                let cycle = cycles[index];
                {
                    for(let j: number = 0; j < cycle.length; j++) {{
                        map[cycle[j]] = cycle[(j + 1) % 5];
                    };}
                }
            }
            this.mOrientations[3] = new com.vzome.core.math.symmetry.Permutation(this, map);
        }

        /*private*/ tetrahedralSubgroup: number[][];

        /*private*/ blueTetrahedral: number[];

        /*private*/ greenTetrahedral: number[];

        /*private*/ yellowTetrahedral: number[];

        public subgroup$java_lang_String(name: string): number[] {
            if (com.vzome.core.math.symmetry.Symmetry.TETRAHEDRAL === name)return this.tetrahedralSubgroup[0];
            return null;
        }

        /**
         * 
         * @param {string} color
         * @return {com.vzome.core.math.symmetry.Direction}
         */
        public getDirection(color: string): com.vzome.core.math.symmetry.Direction {
            if ("spring" === color)color = "apple";
            if ("tan" === color)color = "sand";
            return super.getDirection(color);
        }

        public subgroup$java_lang_String$com_vzome_core_math_symmetry_Axis(name: string, zone: com.vzome.core.math.symmetry.Axis): number[] {
            return this.subgroup$java_lang_String$com_vzome_core_math_symmetry_Axis$boolean(name, zone, true);
        }

        public subgroup$java_lang_String$com_vzome_core_math_symmetry_Axis$boolean(name: string, zone: com.vzome.core.math.symmetry.Axis, allowYellow: boolean): number[] {
            const orientation: number = zone.getOrientation();
            const orbit: com.vzome.core.math.symmetry.Direction = zone.getDirection();
            const orbitName: string = orbit.getName();
            if (orbitName === ("blue")){
                const subgroup: number = this.blueTetrahedral[orientation];
                return this.tetrahedralSubgroup[subgroup];
            } else if (orbitName === ("green")){
                const subgroup: number = this.greenTetrahedral[orientation];
                return this.tetrahedralSubgroup[subgroup];
            } else if (allowYellow && (orbitName === ("yellow"))){
                const subgroup: number = this.yellowTetrahedral[orientation];
                return this.tetrahedralSubgroup[subgroup];
            }
            return null;
        }

        public subgroup(name?: any, zone?: any, allowYellow?: any): number[] {
            if (((typeof name === 'string') || name === null) && ((zone != null && zone instanceof <any>com.vzome.core.math.symmetry.Axis) || zone === null) && ((typeof allowYellow === 'boolean') || allowYellow === null)) {
                return <any>this.subgroup$java_lang_String$com_vzome_core_math_symmetry_Axis$boolean(name, zone, allowYellow);
            } else if (((typeof name === 'string') || name === null) && ((zone != null && zone instanceof <any>com.vzome.core.math.symmetry.Axis) || zone === null) && allowYellow === undefined) {
                return <any>this.subgroup$java_lang_String$com_vzome_core_math_symmetry_Axis(name, zone);
            } else if (((typeof name === 'string') || name === null) && zone === undefined && allowYellow === undefined) {
                return <any>this.subgroup$java_lang_String(name);
            } else throw new Error('invalid overload');
        }

        public blueTetrahedralFromGreen(greenIndex: number): number {
            const subgroup: number = this.greenTetrahedral[greenIndex];
            for(let i: number = 0; i < this.blueTetrahedral.length; i++) {{
                if (this.blueTetrahedral[i] === subgroup)return i;
            };}
            return 0;
        }

        public interpretScript(script: string, language: string, offset: com.vzome.core.construction.Point, symmetry: com.vzome.core.math.symmetry.Symmetry, effects: com.vzome.core.construction.ConstructionChanges) {
            this.mField.interpretScript(script, language, offset, symmetry, effects);
        }
    }
    IcosahedralSymmetry["__class"] = "com.vzome.core.math.symmetry.IcosahedralSymmetry";
    IcosahedralSymmetry["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry","com.vzome.core.math.symmetry.Embedding"];


}
namespace com.vzome.core.math.symmetry {
    /**
     * @author Scott Vorthmann
     * 
     * @param {*} field
     * @class
     * @extends com.vzome.core.math.symmetry.AbstractSymmetry
     */
    export class OctahedralSymmetry extends com.vzome.core.math.symmetry.AbstractSymmetry {
        static ORDER: number = 24;

        public IDENTITY: com.vzome.core.math.symmetry.Permutation;

        frameColor: string;

        public constructor(field?: any, frameColor?: any) {
            if (((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((typeof frameColor === 'string') || frameColor === null)) {
                let __args = arguments;
                super(OctahedralSymmetry.ORDER, field, frameColor, null);
                if (this.frameColor === undefined) { this.frameColor = null; } 
                if (this.tetrahedralSubgroup === undefined) { this.tetrahedralSubgroup = null; } 
                this.IDENTITY = new com.vzome.core.math.symmetry.Permutation(this, null);
                this.frameColor = frameColor;
                this.tetrahedralSubgroup = this.closure([0, 2, 4]);
            } else if (((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && frameColor === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let frameColor: any = "blue";
                    super(OctahedralSymmetry.ORDER, field, frameColor, null);
                    if (this.frameColor === undefined) { this.frameColor = null; } 
                    if (this.tetrahedralSubgroup === undefined) { this.tetrahedralSubgroup = null; } 
                    this.IDENTITY = new com.vzome.core.math.symmetry.Permutation(this, null);
                    this.frameColor = frameColor;
                    this.tetrahedralSubgroup = this.closure([0, 2, 4]);
                }
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.SpecialOrbit} which
         * @return {com.vzome.core.math.symmetry.Direction}
         */
        public getSpecialOrbit(which: com.vzome.core.math.symmetry.SpecialOrbit): com.vzome.core.math.symmetry.Direction {
            switch((which)) {
            case com.vzome.core.math.symmetry.SpecialOrbit.BLUE:
                return this.getDirection(this.frameColor);
            case com.vzome.core.math.symmetry.SpecialOrbit.RED:
                return this.getDirection("green");
            case com.vzome.core.math.symmetry.SpecialOrbit.YELLOW:
                return this.getDirection("yellow");
            default:
                return null;
            }
        }

        /**
         * 
         * @return {boolean}
         */
        public reverseOrbitTriangle(): boolean {
            return true;
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector[]}
         */
        public getOrbitTriangle(): com.vzome.core.algebra.AlgebraicVector[] {
            const greenVertex: com.vzome.core.algebra.AlgebraicVector = this.getDirection("green").getPrototype();
            const blueVertex: com.vzome.core.algebra.AlgebraicVector = this.getDirection("blue").getPrototype();
            const yellowVertex: com.vzome.core.algebra.AlgebraicVector = this.getDirection("yellow").getPrototype();
            return [greenVertex, blueVertex, yellowVertex];
        }

        /**
         * 
         */
        createInitialPermutations() {
            this.mOrientations[0] = this.IDENTITY;
            let map: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(OctahedralSymmetry.ORDER);
            for(let i: number = 0; i < 6; i++) {for(let j: number = 0; j < 4; j++) {map[i * 4 + j] = i * 4 + ((j + 1) % 4);};}
            this.mOrientations[1] = new com.vzome.core.math.symmetry.Permutation(this, map);
            map = (s => { let a=[]; while(s-->0) a.push(0); return a; })(OctahedralSymmetry.ORDER);
            let cycles: number[][] = [[0, 4, 8], [1, 11, 17], [2, 16, 22], [3, 21, 5], [6, 20, 14], [7, 13, 9], [10, 12, 18], [19, 15, 23]];
            for(let index = 0; index < cycles.length; index++) {
                let cycle = cycles[index];
                {
                    for(let j: number = 0; j < cycle.length; j++) {{
                        map[cycle[j]] = cycle[(j + 1) % 3];
                    };}
                }
            }
            this.mOrientations[4] = new com.vzome.core.math.symmetry.Permutation(this, map);
            map = (s => { let a=[]; while(s-->0) a.push(0); return a; })(OctahedralSymmetry.ORDER);
            cycles = [[0, 5], [1, 8], [4, 9], [15, 20], [12, 19], [16, 23], [2, 17], [13, 10], [21, 6], [22, 3], [7, 14], [11, 18]];
            for(let index = 0; index < cycles.length; index++) {
                let cycle = cycles[index];
                {
                    for(let j: number = 0; j < cycle.length; j++) {{
                        map[cycle[j]] = cycle[(j + 1) % 2];
                    };}
                }
            }
            this.mOrientations[5] = new com.vzome.core.math.symmetry.Permutation(this, map);
        }

        /**
         * 
         */
        createOtherOrbits() {
            const xAxis: com.vzome.core.algebra.AlgebraicVector = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
            const yAxis: com.vzome.core.algebra.AlgebraicVector = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y);
            const zAxis: com.vzome.core.algebra.AlgebraicVector = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
            const green: com.vzome.core.algebra.AlgebraicVector = xAxis.plus(yAxis);
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("green", 1, 8, green, true);
            const yellow: com.vzome.core.algebra.AlgebraicVector = green.plus(zAxis);
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("yellow", 0, 4, yellow, true);
        }

        /**
         * 
         * @param {string} frameColor
         */
        createFrameOrbit(frameColor: string) {
            const xAxis: com.vzome.core.algebra.AlgebraicVector = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
            const yAxis: com.vzome.core.algebra.AlgebraicVector = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y);
            const zAxis: com.vzome.core.algebra.AlgebraicVector = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
            let dir: com.vzome.core.math.symmetry.Direction;
            if (this.mField.doubleFrameVectors())dir = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(frameColor, 0, 1, xAxis, true, true, this.mField['createRational$long'](2)); else dir = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(frameColor, 0, 1, xAxis, true);
            this.createBasisAxes(dir, xAxis, 0);
            this.createBasisAxes(dir, xAxis.negate(), 12);
            this.createBasisAxes(dir, yAxis, 5);
            this.createBasisAxes(dir, yAxis.negate(), 7);
            this.createBasisAxes(dir, zAxis, 4);
            this.createBasisAxes(dir, zAxis.negate(), 6);
            for(let p: number = 0; p < OctahedralSymmetry.ORDER; p++) {{
                const x: number = this.mOrientations[p].mapIndex(0);
                const y: number = this.mOrientations[p].mapIndex(8);
                const z: number = this.mOrientations[p].mapIndex(4);
                this.mMatrices[p] = new com.vzome.core.algebra.AlgebraicMatrix(dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, x).normal(), dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, y).normal(), dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, z).normal());
                const axis: com.vzome.core.math.symmetry.Axis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, p);
                const norm: com.vzome.core.algebra.AlgebraicVector = this.mMatrices[p].timesColumn(xAxis);
                if (!norm.equals(axis.normal()))throw new java.lang.IllegalStateException("matrix wrong: " + p);
            };}
        }

        /*private*/ createBasisAxes(dir: com.vzome.core.math.symmetry.Direction, norm: com.vzome.core.algebra.AlgebraicVector, orientation: number) {
            for(let i: number = 0; i < 4; i++) {{
                const prototype: number = this.mOrientations[orientation].mapIndex(i);
                const rotatedPrototype: number = this.mOrientations[orientation].mapIndex((i + 1) % 4);
                const rotation: number = this.getMapping(prototype, rotatedPrototype);
                dir.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(prototype, rotation, norm);
            };}
        }

        /**
         * 
         * @return {string}
         */
        public getName(): string {
            return "octahedral";
        }

        /*private*/ tetrahedralSubgroup: number[];

        /**
         * 
         * @param {string} name
         * @return {int[]}
         */
        public subgroup(name: string): number[] {
            if (com.vzome.core.math.symmetry.Symmetry.TETRAHEDRAL === name)return this.tetrahedralSubgroup;
            return null;
        }
    }
    OctahedralSymmetry["__class"] = "com.vzome.core.math.symmetry.OctahedralSymmetry";
    OctahedralSymmetry["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry","com.vzome.core.math.symmetry.Embedding"];


}
namespace com.vzome.core.math.symmetry {
    /**
     * @author Scott Vorthmann
     * @param {*} field
     * @class
     * @extends com.vzome.core.math.symmetry.AbstractSymmetry
     */
    export class DodecagonalSymmetry extends com.vzome.core.math.symmetry.AbstractSymmetry {
        static ORDER: number = 12;

        public IDENTITY: com.vzome.core.math.symmetry.Permutation;

        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            super(DodecagonalSymmetry.ORDER, field, "blue", null);
            this.IDENTITY = new com.vzome.core.math.symmetry.Permutation(this, null);
        }

        /**
         * 
         */
        createInitialPermutations() {
            this.mOrientations[0] = this.IDENTITY;
            const map: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(DodecagonalSymmetry.ORDER);
            for(let i: number = 0; i < DodecagonalSymmetry.ORDER; i++) {map[i] = (i + 1) % DodecagonalSymmetry.ORDER;}
            this.mOrientations[1] = new com.vzome.core.math.symmetry.Permutation(this, map);
        }

        /**
         * 
         * @param {string} frameColor
         */
        createFrameOrbit(frameColor: string) {
            const xAxis: com.vzome.core.algebra.AlgebraicVector = this.mField.createVector([[1, 1, 0, 1], [0, 1, 0, 1], [0, 1, 0, 1]]);
            const dir: com.vzome.core.math.symmetry.Direction = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(frameColor, 0, 15, xAxis, true);
            dir.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, xAxis);
            dir.createAxis$int$int$int_A_A(1, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, 1, 2], [1, 2, 0, 1], [0, 1, 0, 1]]);
            dir.createAxis$int$int$int_A_A(2, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 2, 0, 1], [0, 1, 1, 2], [0, 1, 0, 1]]);
            dir.createAxis$int$int$int_A_A(3, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, 0, 1], [1, 1, 0, 1], [0, 1, 0, 1]]);
            dir.createAxis$int$int$int_A_A(4, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[-1, 2, 0, 1], [0, 1, 1, 2], [0, 1, 0, 1]]);
            dir.createAxis$int$int$int_A_A(5, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, -1, 2], [1, 2, 0, 1], [0, 1, 0, 1]]);
            dir.createAxis$int$int$int_A_A(6, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[-1, 1, 0, 1], [0, 1, 0, 1], [0, 1, 0, 1]]);
            dir.createAxis$int$int$int_A_A(7, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, -1, 2], [-1, 2, 0, 1], [0, 1, 0, 1]]);
            dir.createAxis$int$int$int_A_A(8, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[-1, 2, 0, 1], [0, 1, -1, 2], [0, 1, 0, 1]]);
            dir.createAxis$int$int$int_A_A(9, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, 0, 1], [-1, 1, 0, 1], [0, 1, 0, 1]]);
            dir.createAxis$int$int$int_A_A(10, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 2, 0, 1], [0, 1, -1, 2], [0, 1, 0, 1]]);
            dir.createAxis$int$int$int_A_A(11, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, 1, 2], [-1, 2, 0, 1], [0, 1, 0, 1]]);
            const zAxis: com.vzome.core.algebra.AlgebraicVector = this.mField.createVector([[0, 1, 0, 1], [0, 1, 0, 1], [1, 1, 0, 1]]);
            for(let p: number = 0; p < DodecagonalSymmetry.ORDER; p++) {{
                const x: number = this.mOrientations[p].mapIndex(0);
                const y: number = this.mOrientations[p].mapIndex(3);
                this.mMatrices[p] = new com.vzome.core.algebra.AlgebraicMatrix(dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, x).normal(), dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, y).normal(), zAxis);
                const axis: com.vzome.core.math.symmetry.Axis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, p);
                const norm: com.vzome.core.algebra.AlgebraicVector = this.mMatrices[p].timesColumn(xAxis);
                if (!norm.equals(axis.normal()))throw new java.lang.IllegalStateException("matrix wrong: " + p);
            };}
        }

        /**
         * 
         */
        createOtherOrbits() {
            this.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean("green", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 1, 1, 2], [1, 2, 0, 1], [0, 1, 0, 1]], true);
            this.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean("red", 0, 1, [[0, 1, 0, 1], [0, 1, 0, 1], [1, 1, 0, 1]], true);
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.SpecialOrbit} which
         * @return {com.vzome.core.math.symmetry.Direction}
         */
        public getSpecialOrbit(which: com.vzome.core.math.symmetry.SpecialOrbit): com.vzome.core.math.symmetry.Direction {
            switch((which)) {
            case com.vzome.core.math.symmetry.SpecialOrbit.BLUE:
                return this.getDirection("blue");
            case com.vzome.core.math.symmetry.SpecialOrbit.RED:
                return this.getDirection("red");
            case com.vzome.core.math.symmetry.SpecialOrbit.YELLOW:
                return this.getDirection("green");
            default:
                return null;
            }
        }

        /**
         * 
         * @return {com.vzome.core.math.symmetry.Axis}
         */
        public getPreferredAxis(): com.vzome.core.math.symmetry.Axis {
            return this.getDirection("red").getAxis$int$int(0, 0);
        }

        /**
         * 
         * @return {string}
         */
        public getName(): string {
            return "dodecagonal";
        }

        /**
         * 
         * @param {string} name
         * @return {int[]}
         */
        public subgroup(name: string): number[] {
            return null;
        }
    }
    DodecagonalSymmetry["__class"] = "com.vzome.core.math.symmetry.DodecagonalSymmetry";
    DodecagonalSymmetry["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry","com.vzome.core.math.symmetry.Embedding"];


}
namespace com.vzome.core.math.symmetry {
    /**
     * @author David Hall
     * This class is a generalized implementation initially based on the HeptagonalAntiprismSymmetry by Scott Vorthmann
     * @param {com.vzome.core.algebra.PolygonField} field
     * @class
     * @extends com.vzome.core.math.symmetry.AbstractSymmetry
     */
    export class AntiprismSymmetry extends com.vzome.core.math.symmetry.AbstractSymmetry {
        /*private*/ preferredAxis: com.vzome.core.math.symmetry.Axis;

        /*private*/ useShear: boolean;

        /*private*/ shearTransform: com.vzome.core.math.RealVector[];

        public constructor(field: com.vzome.core.algebra.PolygonField) {
            super(field.polygonSides() * 2, field, "blue", field.isEven() ? null : new com.vzome.core.algebra.AlgebraicMatrix(field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X), field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y), field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z).negate()));
            if (this.preferredAxis === undefined) { this.preferredAxis = null; }
            if (this.useShear === undefined) { this.useShear = false; }
            if (this.shearTransform === undefined) { this.shearTransform = null; }
            this.rotationMatrix = null;
            const nSides: number = field.polygonSides();
            let m10: number = 0;
            let m11: number = 1;
            this.useShear = field.isOdd();
            if (this.useShear){
                m10 = field.getUnitDiagonal(field.diagonalCount() - 1).reciprocal().evaluate() / 2.0;
                m11 = Math.cos(Math.PI / (2.0 * nSides));
            }
            this.shearTransform = [new com.vzome.core.math.RealVector(1, m10, 0), new com.vzome.core.math.RealVector(0, m11, 0), new com.vzome.core.math.RealVector(0, 0, 1)];
        }

        /**
         * 
         * @return {com.vzome.core.algebra.PolygonField}
         */
        public getField(): com.vzome.core.algebra.PolygonField {
            return <com.vzome.core.algebra.PolygonField><any>super.getField();
        }

        /**
         * Called by the super constructor.
         */
        createInitialPermutations() {
            const nSides: number = this.getField().polygonSides();
            this.mOrientations[0] = new com.vzome.core.math.symmetry.Permutation(this, null);
            const map1: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(nSides * 2);
            for(let i: number = 0; i < nSides; i++) {{
                map1[i] = (i + 1) % nSides;
                map1[i + nSides] = map1[i] + nSides;
            };}
            this.mOrientations[1] = new com.vzome.core.math.symmetry.Permutation(this, map1);
            const map2: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(map1.length);
            let n: number = nSides * 2;
            for(let i: number = 0; i < map2.length; i++) {{
                n--;
                map2[i] = map1[n];
            };}
            this.mOrientations[nSides] = new com.vzome.core.math.symmetry.Permutation(this, map2);
        }

        /**
         * 
         * @param {string} frameColor
         */
        createFrameOrbit(frameColor: string) {
            const field: com.vzome.core.algebra.PolygonField = this.getField();
            const nSides: number = field.polygonSides();
            const nDiags: number = field.diagonalCount();
            const rotationMatrix: com.vzome.core.algebra.AlgebraicMatrix = this.getRotationMatrix();
            let vX: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
            let vY: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y);
            let vZ: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
            for(let i: number = 0; i < nSides * 2; i++) {{
                if (i === nSides){
                    vY = vY.negate();
                    if (field.isOdd()){
                        vY = vY.setComponent(com.vzome.core.algebra.AlgebraicVector.X, field.getUnitDiagonal(nDiags - 1).reciprocal());
                    }
                    vZ = vZ.negate();
                }
                this.mMatrices[i] = new com.vzome.core.algebra.AlgebraicMatrix(vX, vY, vZ);
                vX = rotationMatrix.timesColumn(vX);
                vY = rotationMatrix.timesColumn(vY);
            };}
        }

        /*private*/ rotationMatrix: com.vzome.core.algebra.AlgebraicMatrix;

        public getRotationMatrix(): com.vzome.core.algebra.AlgebraicMatrix {
            if (this.rotationMatrix == null){
                const field: com.vzome.core.algebra.PolygonField = this.getField();
                const diagCount: number = field.diagonalCount();
                const p_x: com.vzome.core.algebra.AlgebraicNumber = field.getUnitDiagonal(diagCount - 3);
                const q_y: com.vzome.core.algebra.AlgebraicNumber = field.getUnitDiagonal(diagCount - (field.isEven() ? 3 : 2));
                const den: com.vzome.core.algebra.AlgebraicNumber = field.getUnitDiagonal(diagCount - 1);
                const num: com.vzome.core.algebra.AlgebraicNumber = field.getUnitDiagonal(1);
                const p: com.vzome.core.algebra.AlgebraicVector = field.origin(3).setComponent(com.vzome.core.algebra.AlgebraicVector.X, p_x.dividedBy(den)).setComponent(com.vzome.core.algebra.AlgebraicVector.Y, num.dividedBy(den));
                const q: com.vzome.core.algebra.AlgebraicVector = field.origin(3).setComponent(com.vzome.core.algebra.AlgebraicVector.X, num.dividedBy(den).negate()).setComponent(com.vzome.core.algebra.AlgebraicVector.Y, q_y.dividedBy(den));
                const zAxis: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
                this.rotationMatrix = new com.vzome.core.algebra.AlgebraicMatrix(p, q, zAxis);
            }
            return this.rotationMatrix;
        }

        /**
         * 
         */
        createOtherOrbits() {
        }

        public createStandardOrbits(frameColor: string): AntiprismSymmetry {
            const redOrbit: com.vzome.core.math.symmetry.Direction = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("red", 0, 1, this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z), true);
            this.preferredAxis = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 0);
            const blueFrameVector: com.vzome.core.algebra.AlgebraicVector = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
            const nSides: number = this.getField().polygonSides();
            const blueOrbit: com.vzome.core.math.symmetry.Direction = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(frameColor, 0, nSides, blueFrameVector, true);
            let greenVector: com.vzome.core.algebra.AlgebraicVector;
            if (this.getField().isOdd()){
                const blueRotatedVector: com.vzome.core.algebra.AlgebraicVector = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, ((nSides + 1) / 2|0)).normal();
                greenVector = blueFrameVector.minus(blueRotatedVector);
            } else {
                const blueRotatedVector: com.vzome.core.algebra.AlgebraicVector = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 1).normal();
                greenVector = blueFrameVector.plus(blueRotatedVector);
            }
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("green", 0, nSides, greenVector, false);
            const yellowVector: com.vzome.core.algebra.AlgebraicVector = greenVector.plus(redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 1).normal());
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("yellow", 0, nSides, yellowVector, false);
            return this;
        }

        /**
         * 
         * @return {com.vzome.core.math.symmetry.Axis}
         */
        public getPreferredAxis(): com.vzome.core.math.symmetry.Axis {
            return this.preferredAxis;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} v
         * @return {com.vzome.core.math.RealVector}
         */
        public embedInR3(v: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.math.RealVector {
            const rv: com.vzome.core.math.RealVector = super.embedInR3(v);
            if (this.useShear){
                const sums: number[] = [0, 0, 0];
                for(let i: number = 0; i < this.shearTransform.length; i++) {{
                    sums[i] += (<any>Math).fround(this.shearTransform[i].x * rv.x);
                    sums[i] += (<any>Math).fround(this.shearTransform[i].y * rv.y);
                    sums[i] += (<any>Math).fround(this.shearTransform[i].z * rv.z);
                };}
                return new com.vzome.core.math.RealVector(sums[0], sums[1], sums[2]);
            }
            return rv;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} v
         * @return {double[]}
         */
        public embedInR3Double(v: com.vzome.core.algebra.AlgebraicVector): number[] {
            const dv: number[] = super.embedInR3Double(v);
            if (this.useShear){
                const sums: number[] = [0, 0, 0];
                for(let i: number = 0; i < this.shearTransform.length; i++) {{
                    sums[i] += this.shearTransform[i].x * dv[0];
                    sums[i] += this.shearTransform[i].y * dv[1];
                    sums[i] += this.shearTransform[i].z * dv[2];
                };}
                return sums;
            }
            return dv;
        }

        /**
         * 
         * @return {boolean}
         */
        public isTrivial(): boolean {
            return !this.useShear;
        }

        /**
         * 
         * @return {string}
         */
        public getName(): string {
            return ("antiprism" + this.getField().polygonSides());
        }

        /**
         * 
         * @param {string} name
         * @return {int[]}
         */
        public subgroup(name: string): number[] {
            return null;
        }

        /**
         * These three vertices represent the corners of the canonical orbit triangle.
         * They must correspond to the three "special" orbits returned by getSpecialOrbit().
         * All other canonical direction prototype vectors
         * must intersect this plane at a unique point within the triangle.
         * 
         * OrbitDotLocator will use the three vectors to locate the dots in this order:
         * AlgebraicVector[] triangle = getOrbitTriangle();
         * triangle[0] .. // SpecialOrbit.BLUE   = orthoVertex
         * triangle[1] .. // SpecialOrbit.RED    = sideVertex
         * triangle[2] .. // SpecialOrbit.YELLOW = topVertex
         * 
         * These variable names and their position in the array
         * correspond to the positions where they will be shown in the orbit triangle
         * rather than any specific colors.
         * The SpecialOrbit names originally matched the color position in the icosa orbit triangle
         * but other symmetries don't necessarily have any such corellation.
         * 
         * top
         * @
         * | `\
         * |    `\
         * @-------`@
         * ortho     side
         * 
         * AntiprismTrackball also uses these 3 vertices to locate the trackball orbit triangle hints.
         * @return {com.vzome.core.algebra.AlgebraicVector[]}
         */
        public getOrbitTriangle(): com.vzome.core.algebra.AlgebraicVector[] {
            const field: com.vzome.core.algebra.PolygonField = this.getField();
            const diagCount: number = field.diagonalCount();
            const sideVertex: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
            const blueOrbit: com.vzome.core.math.symmetry.Direction = this.getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.BLUE);
            const topVertex: com.vzome.core.algebra.AlgebraicVector = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, diagCount).normal();
            const bottomVert: com.vzome.core.algebra.AlgebraicVector = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, diagCount + 1).normal();
            const orthoVertex: com.vzome.core.algebra.AlgebraicVector = com.vzome.core.algebra.AlgebraicVectors.getCentroid([topVertex, bottomVert]);
            return [orthoVertex, sideVertex, topVertex];
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.SpecialOrbit} which
         * @return {com.vzome.core.math.symmetry.Direction}
         */
        public getSpecialOrbit(which: com.vzome.core.math.symmetry.SpecialOrbit): com.vzome.core.math.symmetry.Direction {
            switch((which)) {
            case com.vzome.core.math.symmetry.SpecialOrbit.BLUE:
                return this.getDirection("blue");
            case com.vzome.core.math.symmetry.SpecialOrbit.RED:
                return this.getDirection("red");
            case com.vzome.core.math.symmetry.SpecialOrbit.YELLOW:
                return this.getDirection(this.getField().isEven() ? "green" : "blue");
            default:
                return null;
            }
        }
    }
    AntiprismSymmetry["__class"] = "com.vzome.core.math.symmetry.AntiprismSymmetry";
    AntiprismSymmetry["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry","com.vzome.core.math.symmetry.Embedding"];


}
namespace com.vzome.fields.heptagon {
    export class HeptagonalAntiprismSymmetry extends com.vzome.core.math.symmetry.AbstractSymmetry {
        /*private*/ sigmaX2: number;

        /*private*/ skewFactor: number;

        /*private*/ correctedOrbits: boolean;

        /*private*/ preferredAxis: com.vzome.core.math.symmetry.Axis;

        public constructor(field?: any, frameColor?: any, correctedOrbits?: any) {
            if (((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((typeof frameColor === 'string') || frameColor === null) && ((typeof correctedOrbits === 'boolean') || correctedOrbits === null)) {
                let __args = arguments;
                super(14, field, frameColor, correctedOrbits ? new com.vzome.core.algebra.AlgebraicMatrix(field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X), field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y), field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z).negate()) : null);
                if (this.sigmaX2 === undefined) { this.sigmaX2 = 0; } 
                if (this.skewFactor === undefined) { this.skewFactor = 0; } 
                if (this.correctedOrbits === undefined) { this.correctedOrbits = false; } 
                if (this.preferredAxis === undefined) { this.preferredAxis = null; } 
                this.sigmaX2 = field.getAffineScalar()['times$com_vzome_core_algebra_AlgebraicNumber'](field['createRational$long'](2)).evaluate();
                this.skewFactor = Math.sin((3.0 / 7.0) * Math.PI);
                this.correctedOrbits = correctedOrbits;
            } else if (((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((typeof frameColor === 'string') || frameColor === null) && correctedOrbits === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let correctedOrbits: any = false;
                    super(14, field, frameColor, correctedOrbits ? new com.vzome.core.algebra.AlgebraicMatrix(field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X), field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y), field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z).negate()) : null);
                    if (this.sigmaX2 === undefined) { this.sigmaX2 = 0; } 
                    if (this.skewFactor === undefined) { this.skewFactor = 0; } 
                    if (this.correctedOrbits === undefined) { this.correctedOrbits = false; } 
                    if (this.preferredAxis === undefined) { this.preferredAxis = null; } 
                    this.sigmaX2 = field.getAffineScalar()['times$com_vzome_core_algebra_AlgebraicNumber'](field['createRational$long'](2)).evaluate();
                    this.skewFactor = Math.sin((3.0 / 7.0) * Math.PI);
                    this.correctedOrbits = correctedOrbits;
                }
            } else throw new Error('invalid overload');
        }

        /**
         * Called by the super constructor.
         */
        createInitialPermutations() {
            this.mOrientations[0] = new com.vzome.core.math.symmetry.Permutation(this, null);
            let map: number[] = [1, 2, 3, 4, 5, 6, 0, 8, 9, 10, 11, 12, 13, 7];
            this.mOrientations[1] = new com.vzome.core.math.symmetry.Permutation(this, map);
            map = [7, 13, 12, 11, 10, 9, 8, 0, 6, 5, 4, 3, 2, 1];
            this.mOrientations[7] = new com.vzome.core.math.symmetry.Permutation(this, map);
        }

        /**
         * 
         * @param {string} frameColor
         */
        createFrameOrbit(frameColor: string) {
            const hf: com.vzome.core.algebra.AlgebraicField = this.mField;
            const one: com.vzome.core.algebra.AlgebraicNumber = hf.one();
            const s: com.vzome.core.algebra.AlgebraicNumber = hf.getAffineScalar().reciprocal();
            const R: com.vzome.core.algebra.AlgebraicNumber = hf['createPower$int'](1)['times$com_vzome_core_algebra_AlgebraicNumber'](s);
            const zAxis: com.vzome.core.algebra.AlgebraicVector = hf.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
            const zAxisNeg: com.vzome.core.algebra.AlgebraicVector = zAxis.negate();
            const axis0: com.vzome.core.algebra.AlgebraicVector = hf.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
            const axis1: com.vzome.core.algebra.AlgebraicVector = hf.origin(3).setComponent(com.vzome.core.algebra.AlgebraicVector.X, s).setComponent(com.vzome.core.algebra.AlgebraicVector.Y, R);
            const axis2: com.vzome.core.algebra.AlgebraicVector = hf.origin(3).setComponent(com.vzome.core.algebra.AlgebraicVector.X, s.negate()).setComponent(com.vzome.core.algebra.AlgebraicVector.Y, one);
            const axis3: com.vzome.core.algebra.AlgebraicVector = hf.origin(3).setComponent(com.vzome.core.algebra.AlgebraicVector.X, one.negate()).setComponent(com.vzome.core.algebra.AlgebraicVector.Y, s);
            const axis4: com.vzome.core.algebra.AlgebraicVector = hf.origin(3).setComponent(com.vzome.core.algebra.AlgebraicVector.X, R.negate()).setComponent(com.vzome.core.algebra.AlgebraicVector.Y, s.negate());
            const axis5: com.vzome.core.algebra.AlgebraicVector = hf.origin(3).setComponent(com.vzome.core.algebra.AlgebraicVector.Y, one.negate());
            const axis6: com.vzome.core.algebra.AlgebraicVector = hf.origin(3).setComponent(com.vzome.core.algebra.AlgebraicVector.X, R).setComponent(com.vzome.core.algebra.AlgebraicVector.Y, R.negate());
            this.mMatrices[0] = hf.identityMatrix(3);
            this.mMatrices[1] = new com.vzome.core.algebra.AlgebraicMatrix(axis1, axis6.negate(), zAxis);
            this.mMatrices[2] = new com.vzome.core.algebra.AlgebraicMatrix(axis2, axis0.negate(), zAxis);
            this.mMatrices[3] = new com.vzome.core.algebra.AlgebraicMatrix(axis3, axis1.negate(), zAxis);
            this.mMatrices[4] = new com.vzome.core.algebra.AlgebraicMatrix(axis4, axis2.negate(), zAxis);
            this.mMatrices[5] = new com.vzome.core.algebra.AlgebraicMatrix(axis5, axis3.negate(), zAxis);
            this.mMatrices[6] = new com.vzome.core.algebra.AlgebraicMatrix(axis6, axis4.negate(), zAxis);
            this.mMatrices[7] = new com.vzome.core.algebra.AlgebraicMatrix(axis0, axis2.negate(), zAxisNeg);
            this.mMatrices[8] = this.mMatrices[1].times(this.mMatrices[7]);
            this.mMatrices[9] = this.mMatrices[2].times(this.mMatrices[7]);
            this.mMatrices[10] = this.mMatrices[3].times(this.mMatrices[7]);
            this.mMatrices[11] = this.mMatrices[4].times(this.mMatrices[7]);
            this.mMatrices[12] = this.mMatrices[5].times(this.mMatrices[7]);
            this.mMatrices[13] = this.mMatrices[6].times(this.mMatrices[7]);
        }

        /**
         * 
         */
        createOtherOrbits() {
        }

        public createStandardOrbits(frameColor: string): HeptagonalAntiprismSymmetry {
            const redOrbit: com.vzome.core.math.symmetry.Direction = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("red", 0, 1, this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z), true);
            this.preferredAxis = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 0);
            const blueFrameVector: com.vzome.core.algebra.AlgebraicVector = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
            const blueOrbit: com.vzome.core.math.symmetry.Direction = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(frameColor, 0, 7, blueFrameVector, true);
            const blueRotatedVector: com.vzome.core.algebra.AlgebraicVector = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, ((7 + 1) / 2|0)).normal();
            const greenVector: com.vzome.core.algebra.AlgebraicVector = blueFrameVector.minus(blueRotatedVector);
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("green", 0, 7, greenVector);
            return this;
        }

        /**
         * 
         * @return {com.vzome.core.math.symmetry.Axis}
         */
        public getPreferredAxis(): com.vzome.core.math.symmetry.Axis {
            return this.preferredAxis;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} v
         * @return {com.vzome.core.math.RealVector}
         */
        public embedInR3(v: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.math.RealVector {
            const rv: com.vzome.core.math.RealVector = super.embedInR3(v);
            const x: number = rv.x + (rv.y / this.sigmaX2);
            const y: number = rv.y * this.skewFactor;
            return new com.vzome.core.math.RealVector(x, y, rv.z);
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} v
         * @return {double[]}
         */
        public embedInR3Double(v: com.vzome.core.algebra.AlgebraicVector): number[] {
            const dv: number[] = super.embedInR3Double(v);
            const x: number = dv[0] + (dv[1] / this.sigmaX2);
            const y: number = dv[1] * this.skewFactor;
            return [x, y, dv[2]];
        }

        /**
         * 
         * @return {boolean}
         */
        public isTrivial(): boolean {
            return false;
        }

        /**
         * 
         * @return {string}
         */
        public getName(): string {
            if (this.correctedOrbits)return "heptagonal antiprism corrected"; else return "heptagonal antiprism";
        }

        /**
         * 
         * @param {string} name
         * @return {int[]}
         */
        public subgroup(name: string): number[] {
            return null;
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector[]}
         */
        public getOrbitTriangle(): com.vzome.core.algebra.AlgebraicVector[] {
            const field: com.vzome.core.algebra.AlgebraicField = this.getField();
            const zero: com.vzome.core.algebra.AlgebraicNumber = field.zero();
            let x: com.vzome.core.algebra.AlgebraicNumber = field['createAlgebraicNumber$int_A']([0, -1, -1]).dividedBy(field['createAlgebraicNumber$int_A']([0, 0, 2]));
            const orthoVertex: com.vzome.core.algebra.AlgebraicVector = new com.vzome.core.algebra.AlgebraicVector(x, zero, zero);
            const sideVertex: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
            x = field['createRational$long'](-1);
            const y: com.vzome.core.algebra.AlgebraicNumber = field['createAlgebraicNumber$int_A']([0, -1, 1]);
            const topVertex: com.vzome.core.algebra.AlgebraicVector = new com.vzome.core.algebra.AlgebraicVector(x, y, zero);
            return [orthoVertex, sideVertex, topVertex];
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.SpecialOrbit} which
         * @return {com.vzome.core.math.symmetry.Direction}
         */
        public getSpecialOrbit(which: com.vzome.core.math.symmetry.SpecialOrbit): com.vzome.core.math.symmetry.Direction {
            switch((which)) {
            case com.vzome.core.math.symmetry.SpecialOrbit.BLUE:
                return this.getDirection("blue");
            case com.vzome.core.math.symmetry.SpecialOrbit.RED:
                return this.getDirection("red");
            case com.vzome.core.math.symmetry.SpecialOrbit.YELLOW:
                return this.getDirection("blue");
            default:
                return null;
            }
        }
    }
    HeptagonalAntiprismSymmetry["__class"] = "com.vzome.fields.heptagon.HeptagonalAntiprismSymmetry";
    HeptagonalAntiprismSymmetry["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry","com.vzome.core.math.symmetry.Embedding"];


}
namespace com.vzome.fields.sqrtphi {
    export class PentagonalAntiprismSymmetry extends com.vzome.core.math.symmetry.AbstractSymmetry {
        static FIVEFOLD_AXIS: number[][]; public static FIVEFOLD_AXIS_$LI$(): number[][] { if (PentagonalAntiprismSymmetry.FIVEFOLD_AXIS == null) { PentagonalAntiprismSymmetry.FIVEFOLD_AXIS = [[-3, 1, 0, 1, -5, 1, 0, 1], [3, 1, 0, 1, 5, 1, 0, 1], [0, 1, 1, 1, 0, 1, 2, 1]]; }  return PentagonalAntiprismSymmetry.FIVEFOLD_AXIS; }

        static TWOFOLD_AXIS: number[][]; public static TWOFOLD_AXIS_$LI$(): number[][] { if (PentagonalAntiprismSymmetry.TWOFOLD_AXIS == null) { PentagonalAntiprismSymmetry.TWOFOLD_AXIS = [[0, 1], [2, 1, 0, 1, 3, 1, 0, 1], [0, 1, -3, 1, 0, 1, -5, 1]]; }  return PentagonalAntiprismSymmetry.TWOFOLD_AXIS; }

        static NEXT_TWOFOLD_AXIS: number[][]; public static NEXT_TWOFOLD_AXIS_$LI$(): number[][] { if (PentagonalAntiprismSymmetry.NEXT_TWOFOLD_AXIS == null) { PentagonalAntiprismSymmetry.NEXT_TWOFOLD_AXIS = [[2, 1, 0, 1, 3, 1, 0, 1], [3, 1, 0, 1, 5, 1, 0, 1], [0, 1, -2, 1, 0, 1, -3, 1]]; }  return PentagonalAntiprismSymmetry.NEXT_TWOFOLD_AXIS; }

        static FIVEFOLD_ROTATION: number[][][]; public static FIVEFOLD_ROTATION_$LI$(): number[][][] { if (PentagonalAntiprismSymmetry.FIVEFOLD_ROTATION == null) { PentagonalAntiprismSymmetry.FIVEFOLD_ROTATION = [[[-1, 1, 0, 1, 1, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 1, 1, 0, 1, -1, 1]], [[1, 1, 0, 1, -1, 1, 0, 1], [-1, 1, 0, 1, 1, 1, 0, 1], [0, 1, -2, 1, 0, 1, 1, 1]], [[0, 1, 2, 1, 0, 1, -1, 1], [0, 1, -1, 1, 0, 1, 1, 1], [2, 1, 0, 1, -1, 1, 0, 1]]]; }  return PentagonalAntiprismSymmetry.FIVEFOLD_ROTATION; }

        static TWOFOLD_ROTATION: number[][][]; public static TWOFOLD_ROTATION_$LI$(): number[][][] { if (PentagonalAntiprismSymmetry.TWOFOLD_ROTATION == null) { PentagonalAntiprismSymmetry.TWOFOLD_ROTATION = [[[-1, 1, 0, 1, 0, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 1]], [[0, 1, 0, 1, 0, 1, 0, 1], [1, 1, 0, 1, -1, 1, 0, 1], [0, 1, 1, 1, 0, 1, -1, 1]], [[0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 1, 1, 0, 1, -1, 1], [-1, 1, 0, 1, 1, 1, 0, 1]]]; }  return PentagonalAntiprismSymmetry.TWOFOLD_ROTATION; }

        static PRINCIPAL_REFLECTION: number[][][]; public static PRINCIPAL_REFLECTION_$LI$(): number[][][] { if (PentagonalAntiprismSymmetry.PRINCIPAL_REFLECTION == null) { PentagonalAntiprismSymmetry.PRINCIPAL_REFLECTION = [[[7, 5, 0, 1, -4, 5, 0, 1], [-2, 5, 0, 1, 4, 5, 0, 1], [0, 1, -8, 5, 0, 1, 6, 5]], [[-2, 5, 0, 1, 4, 5, 0, 1], [7, 5, 0, 1, -4, 5, 0, 1], [0, 1, 8, 5, 0, 1, -6, 5]], [[0, 1, -8, 5, 0, 1, 6, 5], [0, 1, 8, 5, 0, 1, -6, 5], [-9, 5, 0, 1, 8, 5, 0, 1]]]; }  return PentagonalAntiprismSymmetry.PRINCIPAL_REFLECTION; }

        /*private*/ preferredAxis: com.vzome.core.math.symmetry.Axis;

        public constructor(field: com.vzome.core.algebra.AlgebraicField, frameColor: string) {
            super(10, field, frameColor, field.createMatrix(PentagonalAntiprismSymmetry.PRINCIPAL_REFLECTION_$LI$()));
            if (this.preferredAxis === undefined) { this.preferredAxis = null; }
        }

        /**
         * Called by the super constructor.
         */
        createInitialPermutations() {
            this.mOrientations[0] = new com.vzome.core.math.symmetry.Permutation(this, null);
            let map: number[] = [1, 2, 3, 4, 0, 6, 7, 8, 9, 5];
            this.mOrientations[1] = new com.vzome.core.math.symmetry.Permutation(this, map);
            map = [5, 9, 8, 7, 6, 0, 4, 3, 2, 1];
            this.mOrientations[5] = new com.vzome.core.math.symmetry.Permutation(this, map);
        }

        /**
         * 
         * @param {string} frameColor
         */
        createFrameOrbit(frameColor: string) {
            this.mMatrices[0] = this.mField.identityMatrix(3);
            this.mMatrices[1] = this.mField.createMatrix(PentagonalAntiprismSymmetry.FIVEFOLD_ROTATION_$LI$());
            this.mMatrices[2] = this.mMatrices[1].times(this.mMatrices[1]);
            this.mMatrices[3] = this.mMatrices[1].times(this.mMatrices[2]);
            this.mMatrices[4] = this.mMatrices[1].times(this.mMatrices[3]);
            this.mMatrices[5] = this.mField.createMatrix(PentagonalAntiprismSymmetry.TWOFOLD_ROTATION_$LI$());
            this.mMatrices[6] = this.mMatrices[1].times(this.mMatrices[5]);
            this.mMatrices[7] = this.mMatrices[2].times(this.mMatrices[5]);
            this.mMatrices[8] = this.mMatrices[3].times(this.mMatrices[5]);
            this.mMatrices[9] = this.mMatrices[4].times(this.mMatrices[5]);
        }

        /**
         * 
         */
        createOtherOrbits() {
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector[]}
         */
        public getOrbitTriangle(): com.vzome.core.algebra.AlgebraicVector[] {
            const redVertex: com.vzome.core.algebra.AlgebraicVector = this.mField.createVector(PentagonalAntiprismSymmetry.FIVEFOLD_AXIS_$LI$());
            const greenVertex: com.vzome.core.algebra.AlgebraicVector = this.mField.createVector(PentagonalAntiprismSymmetry.TWOFOLD_AXIS_$LI$());
            const orthoVertex: com.vzome.core.algebra.AlgebraicVector = this.mField.createVector(PentagonalAntiprismSymmetry.NEXT_TWOFOLD_AXIS_$LI$());
            return [greenVertex, redVertex, orthoVertex];
        }

        public createStandardOrbits(frameColor: string): PentagonalAntiprismSymmetry {
            const redVertex: com.vzome.core.algebra.AlgebraicVector = this.mField.createVector(PentagonalAntiprismSymmetry.FIVEFOLD_AXIS_$LI$());
            const greenVertex: com.vzome.core.algebra.AlgebraicVector = this.mField.createVector(PentagonalAntiprismSymmetry.TWOFOLD_AXIS_$LI$());
            let unitLength: com.vzome.core.algebra.AlgebraicNumber = this.mField['createPower$int'](-6);
            const redOrbit: com.vzome.core.math.symmetry.Direction = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("red", 0, 1, redVertex, true, false, unitLength);
            this.preferredAxis = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 0);
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("green", 0, 5, greenVertex, true, false, unitLength);
            unitLength = this.mField['createPower$int'](6);
            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("blue", 0, -1, this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X), true, false, unitLength);
            return this;
        }

        /**
         * 
         * @return {com.vzome.core.math.symmetry.Axis}
         */
        public getPreferredAxis(): com.vzome.core.math.symmetry.Axis {
            return this.preferredAxis;
        }

        /**
         * 
         * @return {string}
         */
        public getName(): string {
            return "pentagonal";
        }

        /**
         * 
         * @param {string} name
         * @return {int[]}
         */
        public subgroup(name: string): number[] {
            return null;
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.SpecialOrbit} which
         * @return {com.vzome.core.math.symmetry.Direction}
         */
        public getSpecialOrbit(which: com.vzome.core.math.symmetry.SpecialOrbit): com.vzome.core.math.symmetry.Direction {
            switch((which)) {
            case com.vzome.core.math.symmetry.SpecialOrbit.BLUE:
                return this.getDirection("blue");
            case com.vzome.core.math.symmetry.SpecialOrbit.RED:
                return this.getDirection("red");
            case com.vzome.core.math.symmetry.SpecialOrbit.YELLOW:
                return this.getDirection("green");
            default:
                return null;
            }
        }
    }
    PentagonalAntiprismSymmetry["__class"] = "com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry";
    PentagonalAntiprismSymmetry["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry","com.vzome.core.math.symmetry.Embedding"];


}
namespace com.vzome.core.math.symmetry {
    export class PlaneOrbitSet extends com.vzome.core.math.symmetry.OrbitSet {
        /*private*/ delegate: com.vzome.core.math.symmetry.OrbitSet;

        /*private*/ normal: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ __zones: java.util.Set<com.vzome.core.math.symmetry.Axis>;

        public constructor(delegate: com.vzome.core.math.symmetry.OrbitSet, normal: com.vzome.core.algebra.AlgebraicVector) {
            super(delegate.getSymmetry());
            if (this.delegate === undefined) { this.delegate = null; }
            if (this.normal === undefined) { this.normal = null; }
            this.__zones = <any>(new java.util.HashSet<any>());
            this.delegate = delegate;
            this.normal = normal;
            for(let index=delegate.getDirections().iterator();index.hasNext();) {
                let dir = index.next();
                {
                    for(let index=dir.iterator();index.hasNext();) {
                        let axis = index.next();
                        {
                            if (axis.normal().dot(this.normal).isZero())this.__zones.add(axis);
                        }
                    }
                }
            }
        }

        public zones(): java.util.Iterator<com.vzome.core.math.symmetry.Axis> {
            return this.__zones.iterator();
        }

        /**
         * 
         * @param {com.vzome.core.math.RealVector} vector
         * @return {com.vzome.core.math.symmetry.Axis}
         */
        public getAxis(vector: com.vzome.core.math.RealVector): com.vzome.core.math.symmetry.Axis {
            if (com.vzome.core.math.RealVector.ORIGIN_$LI$().equals(vector)){
                return null;
            }
            let maxCosine: number = -1.0;
            let closest: com.vzome.core.math.symmetry.Axis = null;
            for(let index=this.__zones.iterator();index.hasNext();) {
                let axis = index.next();
                {
                    const axisV: com.vzome.core.math.RealVector = axis.normal().toRealVector();
                    const cosine: number = vector.dot(axisV) / (vector.length() * axisV.length());
                    if (cosine > maxCosine){
                        maxCosine = cosine;
                        closest = axis;
                    }
                }
            }
            return closest;
        }

        /**
         * 
         * @param {string} name
         * @return {com.vzome.core.math.symmetry.Direction}
         */
        public getDirection(name: string): com.vzome.core.math.symmetry.Direction {
            return this.delegate.getDirection(name);
        }
    }
    PlaneOrbitSet["__class"] = "com.vzome.core.math.symmetry.PlaneOrbitSet";

}
namespace com.vzome.core.math.symmetry {
    export class F4Group extends com.vzome.core.math.symmetry.B4Group {
        ROOTS: com.vzome.core.algebra.AlgebraicVector[];

        /*private*/ WEIGHTS: com.vzome.core.algebra.AlgebraicVector[];

        public A: com.vzome.core.algebra.AlgebraicMatrix;

        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            super(field);
            this.ROOTS = [null, null, null, null];
            this.WEIGHTS = [null, null, null, null];
            if (this.A === undefined) { this.A = null; }
            const one: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long'](1);
            const two: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long'](2);
            const three: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long'](3);
            const four: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long'](4);
            const neg_one: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long'](-1);
            const neg_two: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long'](-2);
            this.ROOTS[0] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
            this.ROOTS[0].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, two);
            this.ROOTS[0].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, neg_two);
            this.ROOTS[1] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Y4);
            this.ROOTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, two);
            this.ROOTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, neg_two);
            this.ROOTS[2] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Z4);
            this.ROOTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, two);
            this.ROOTS[3] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.W4);
            this.ROOTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, neg_one);
            this.ROOTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, neg_one);
            this.ROOTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, neg_one);
            this.WEIGHTS[0] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
            this.WEIGHTS[0].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, two);
            this.WEIGHTS[0].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, two);
            this.WEIGHTS[1] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Y4);
            this.WEIGHTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, two);
            this.WEIGHTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, two);
            this.WEIGHTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, four);
            this.WEIGHTS[2] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, one);
            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, one);
            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, three);
            this.WEIGHTS[3] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.W4);
            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, two);
            if (field.scale4dRoots()){
                const scale: com.vzome.core.algebra.AlgebraicNumber = field['createPower$int'](1);
                this.ROOTS[2] = this.ROOTS[2].scale(scale);
                this.WEIGHTS[2] = this.WEIGHTS[2].scale(scale);
            }
            const half: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long$long'](1, 2);
            const neg_half: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long$long'](-1, 2);
            const col1: com.vzome.core.algebra.AlgebraicVector = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
            col1.setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
            col1.setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, half);
            col1.setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, half);
            col1.setComponent(com.vzome.core.algebra.AlgebraicVector.W4, neg_half);
            const col2: com.vzome.core.algebra.AlgebraicVector = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
            col2.setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
            col2.setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, half);
            col2.setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, neg_half);
            col2.setComponent(com.vzome.core.algebra.AlgebraicVector.W4, half);
            const col3: com.vzome.core.algebra.AlgebraicVector = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
            col3.setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
            col3.setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, neg_half);
            col3.setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, half);
            col3.setComponent(com.vzome.core.algebra.AlgebraicVector.W4, half);
            const col4: com.vzome.core.algebra.AlgebraicVector = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
            col4.setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
            col4.setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, neg_half);
            col4.setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, neg_half);
            col4.setComponent(com.vzome.core.algebra.AlgebraicVector.W4, neg_half);
            this.A = new com.vzome.core.algebra.AlgebraicMatrix(col1, col2, col3, col4);
        }

        /**
         * 
         * @return {number}
         */
        public getOrder(): number {
            return 3 * super.getOrder();
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} model
         * @param {number} element
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public groupAction(model: com.vzome.core.algebra.AlgebraicVector, element: number): com.vzome.core.algebra.AlgebraicVector {
            const b4Order: number = super.getOrder();
            const aPower: number = (element / b4Order|0);
            const b4Element: number = element % b4Order;
            switch((aPower)) {
            case 0:
                return super.groupAction(model, b4Element);
            case 1:
                return super.groupAction(this.A.timesColumn(model), b4Element);
            case 2:
                return super.groupAction(this.A.timesColumn(this.A.timesColumn(model)), b4Element);
            default:
                break;
            }
            return null;
        }

        /**
         * 
         * @param {number} i
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getWeight(i: number): com.vzome.core.algebra.AlgebraicVector {
            return this.WEIGHTS[i];
        }

        /**
         * 
         * @param {number} i
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getSimpleRoot(i: number): com.vzome.core.algebra.AlgebraicVector {
            return this.ROOTS[i];
        }
    }
    F4Group["__class"] = "com.vzome.core.math.symmetry.F4Group";
    F4Group["__interfaces"] = ["com.vzome.core.math.symmetry.CoxeterGroup"];


}
namespace com.vzome.core.viewing {
    /**
     * @author vorth
     * @param {java.io.File} prefsFolder
     * @param {string} pkgName
     * @param {string} name
     * @param {string} alias
     * @param {*} symm
     * @param {com.vzome.core.viewing.AbstractShapes} fallback
     * @param {boolean} isSnub
     * @class
     * @extends com.vzome.core.viewing.AbstractShapes
     */
    export class ExportedVEFShapes extends com.vzome.core.viewing.AbstractShapes {
        static LOGGER: java.util.logging.Logger; public static LOGGER_$LI$(): java.util.logging.Logger { if (ExportedVEFShapes.LOGGER == null) { ExportedVEFShapes.LOGGER = java.util.logging.Logger.getLogger("com.vzome.core.viewing.shapes"); }  return ExportedVEFShapes.LOGGER; }

        public static MODEL_PREFIX: string = "com/vzome/core/parts/";

        static NODE_MODEL: string = "connector";

        /*private*/ fallback: com.vzome.core.viewing.AbstractShapes;

        /*private*/ colors: java.util.Properties;

        /*private*/ isSnub: boolean;

        public static injectShapeVEF(key: string, vef: string) {
        }

        public constructor(prefsFolder?: any, pkgName?: any, name?: any, alias?: any, symm?: any, fallback?: any, isSnub?: any) {
            if (((prefsFolder != null && prefsFolder instanceof <any>java.io.File) || prefsFolder === null) && ((typeof pkgName === 'string') || pkgName === null) && ((typeof name === 'string') || name === null) && ((typeof alias === 'string') || alias === null) && ((symm != null && (symm.constructor != null && symm.constructor["__interfaces"] != null && symm.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symm === null) && ((fallback != null && fallback instanceof <any>com.vzome.core.viewing.AbstractShapes) || fallback === null) && ((typeof isSnub === 'boolean') || isSnub === null)) {
                let __args = arguments;
                super(pkgName, name, alias, symm);
                if (this.fallback === undefined) { this.fallback = null; } 
                if (this.isSnub === undefined) { this.isSnub = false; } 
                this.colors = new java.util.Properties();
                this.fallback = fallback;
                this.isSnub = isSnub;
                const colorProps: string = ExportedVEFShapes.MODEL_PREFIX + pkgName + "/colors.properties";
                const resource: string = com.vzome.xml.ResourceLoader.loadStringResource(colorProps);
                if (resource != null)try {
                    const inputStream: java.io.InputStream = new java.io.ByteArrayInputStream(/* getBytes */(resource).split('').map(s => s.charCodeAt(0)));
                    this.colors.load(inputStream);
                } catch(ioe) {
                    if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(java.util.logging.Level.FINE))ExportedVEFShapes.LOGGER_$LI$().fine("problem with shape color properties: " + colorProps);
                }
            } else if (((prefsFolder != null && prefsFolder instanceof <any>java.io.File) || prefsFolder === null) && ((typeof pkgName === 'string') || pkgName === null) && ((typeof name === 'string') || name === null) && ((typeof alias === 'string') || alias === null) && ((symm != null && (symm.constructor != null && symm.constructor["__interfaces"] != null && symm.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symm === null) && ((fallback != null && fallback instanceof <any>com.vzome.core.viewing.AbstractShapes) || fallback === null) && isSnub === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let isSnub: any = false;
                    super(pkgName, name, alias, symm);
                    if (this.fallback === undefined) { this.fallback = null; } 
                    if (this.isSnub === undefined) { this.isSnub = false; } 
                    this.colors = new java.util.Properties();
                    this.fallback = fallback;
                    this.isSnub = isSnub;
                    const colorProps: string = ExportedVEFShapes.MODEL_PREFIX + pkgName + "/colors.properties";
                    const resource: string = com.vzome.xml.ResourceLoader.loadStringResource(colorProps);
                    if (resource != null)try {
                        const inputStream: java.io.InputStream = new java.io.ByteArrayInputStream(/* getBytes */(resource).split('').map(s => s.charCodeAt(0)));
                        this.colors.load(inputStream);
                    } catch(ioe) {
                        if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(java.util.logging.Level.FINE))ExportedVEFShapes.LOGGER_$LI$().fine("problem with shape color properties: " + colorProps);
                    }
                }
            } else if (((prefsFolder != null && prefsFolder instanceof <any>java.io.File) || prefsFolder === null) && ((typeof pkgName === 'string') || pkgName === null) && ((typeof name === 'string') || name === null) && ((typeof alias === 'string') || alias === null) && ((symm != null && (symm.constructor != null && symm.constructor["__interfaces"] != null && symm.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symm === null) && fallback === undefined && isSnub === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let fallback: any = new com.vzome.core.viewing.OctahedralShapes(__args[1], __args[2], __args[4]);
                    {
                        let __args = arguments;
                        let isSnub: any = false;
                        super(pkgName, name, alias, symm);
                        if (this.fallback === undefined) { this.fallback = null; } 
                        if (this.isSnub === undefined) { this.isSnub = false; } 
                        this.colors = new java.util.Properties();
                        this.fallback = fallback;
                        this.isSnub = isSnub;
                        const colorProps: string = ExportedVEFShapes.MODEL_PREFIX + pkgName + "/colors.properties";
                        const resource: string = com.vzome.xml.ResourceLoader.loadStringResource(colorProps);
                        if (resource != null)try {
                            const inputStream: java.io.InputStream = new java.io.ByteArrayInputStream(/* getBytes */(resource).split('').map(s => s.charCodeAt(0)));
                            this.colors.load(inputStream);
                        } catch(ioe) {
                            if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(java.util.logging.Level.FINE))ExportedVEFShapes.LOGGER_$LI$().fine("problem with shape color properties: " + colorProps);
                        }
                    }
                }
            } else if (((prefsFolder != null && prefsFolder instanceof <any>java.io.File) || prefsFolder === null) && ((typeof pkgName === 'string') || pkgName === null) && ((typeof name === 'string') || name === null) && ((alias != null && (alias.constructor != null && alias.constructor["__interfaces"] != null && alias.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || alias === null) && ((symm != null && symm instanceof <any>com.vzome.core.viewing.AbstractShapes) || symm === null) && fallback === undefined && isSnub === undefined) {
                let __args = arguments;
                let symm: any = __args[3];
                let fallback: any = __args[4];
                {
                    let __args = arguments;
                    let alias: any = null;
                    {
                        let __args = arguments;
                        let isSnub: any = false;
                        super(pkgName, name, alias, symm);
                        if (this.fallback === undefined) { this.fallback = null; } 
                        if (this.isSnub === undefined) { this.isSnub = false; } 
                        this.colors = new java.util.Properties();
                        this.fallback = fallback;
                        this.isSnub = isSnub;
                        const colorProps: string = ExportedVEFShapes.MODEL_PREFIX + pkgName + "/colors.properties";
                        const resource: string = com.vzome.xml.ResourceLoader.loadStringResource(colorProps);
                        if (resource != null)try {
                            const inputStream: java.io.InputStream = new java.io.ByteArrayInputStream(/* getBytes */(resource).split('').map(s => s.charCodeAt(0)));
                            this.colors.load(inputStream);
                        } catch(ioe) {
                            if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(java.util.logging.Level.FINE))ExportedVEFShapes.LOGGER_$LI$().fine("problem with shape color properties: " + colorProps);
                        }
                    }
                }
            } else if (((prefsFolder != null && prefsFolder instanceof <any>java.io.File) || prefsFolder === null) && ((typeof pkgName === 'string') || pkgName === null) && ((typeof name === 'string') || name === null) && ((alias != null && (alias.constructor != null && alias.constructor["__interfaces"] != null && alias.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || alias === null) && ((typeof symm === 'boolean') || symm === null) && fallback === undefined && isSnub === undefined) {
                let __args = arguments;
                let symm: any = __args[3];
                let useZomic: any = __args[4];
                {
                    let __args = arguments;
                    let alias: any = null;
                    let fallback: any = new com.vzome.core.viewing.OctahedralShapes(__args[1], __args[2], __args[4]);
                    {
                        let __args = arguments;
                        let isSnub: any = false;
                        super(pkgName, name, alias, symm);
                        if (this.fallback === undefined) { this.fallback = null; } 
                        if (this.isSnub === undefined) { this.isSnub = false; } 
                        this.colors = new java.util.Properties();
                        this.fallback = fallback;
                        this.isSnub = isSnub;
                        const colorProps: string = ExportedVEFShapes.MODEL_PREFIX + pkgName + "/colors.properties";
                        const resource: string = com.vzome.xml.ResourceLoader.loadStringResource(colorProps);
                        if (resource != null)try {
                            const inputStream: java.io.InputStream = new java.io.ByteArrayInputStream(/* getBytes */(resource).split('').map(s => s.charCodeAt(0)));
                            this.colors.load(inputStream);
                        } catch(ioe) {
                            if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(java.util.logging.Level.FINE))ExportedVEFShapes.LOGGER_$LI$().fine("problem with shape color properties: " + colorProps);
                        }
                    }
                }
            } else if (((prefsFolder != null && prefsFolder instanceof <any>java.io.File) || prefsFolder === null) && ((typeof pkgName === 'string') || pkgName === null) && ((typeof name === 'string') || name === null) && ((alias != null && (alias.constructor != null && alias.constructor["__interfaces"] != null && alias.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || alias === null) && symm === undefined && fallback === undefined && isSnub === undefined) {
                let __args = arguments;
                let symm: any = __args[3];
                {
                    let __args = arguments;
                    let alias: any = null;
                    {
                        let __args = arguments;
                        let fallback: any = new com.vzome.core.viewing.OctahedralShapes(__args[1], __args[2], __args[4]);
                        {
                            let __args = arguments;
                            let isSnub: any = false;
                            super(pkgName, name, alias, symm);
                            if (this.fallback === undefined) { this.fallback = null; } 
                            if (this.isSnub === undefined) { this.isSnub = false; } 
                            this.colors = new java.util.Properties();
                            this.fallback = fallback;
                            this.isSnub = isSnub;
                            const colorProps: string = ExportedVEFShapes.MODEL_PREFIX + pkgName + "/colors.properties";
                            const resource: string = com.vzome.xml.ResourceLoader.loadStringResource(colorProps);
                            if (resource != null)try {
                                const inputStream: java.io.InputStream = new java.io.ByteArrayInputStream(/* getBytes */(resource).split('').map(s => s.charCodeAt(0)));
                                this.colors.load(inputStream);
                            } catch(ioe) {
                                if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(java.util.logging.Level.FINE))ExportedVEFShapes.LOGGER_$LI$().fine("problem with shape color properties: " + colorProps);
                            }
                        }
                    }
                }
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {string} pkgName
         * @return {com.vzome.core.math.Polyhedron}
         */
        buildConnectorShape(pkgName: string): com.vzome.core.math.Polyhedron {
            const vefData: string = this.loadVefData(ExportedVEFShapes.NODE_MODEL);
            if (vefData != null){
                const parser: ExportedVEFShapes.VefToShape = new ExportedVEFShapes.VefToShape(this);
                parser.invertSnubBall = this.isSnub;
                parser.parseVEF(vefData, this.mSymmetry.getField());
                return parser.getConnectorPolyhedron();
            }
            const logLevel: java.util.logging.Level = java.util.logging.Level.FINE;
            if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(logLevel)){
                ExportedVEFShapes.LOGGER_$LI$().log(logLevel, this.toString() + " has no VEF data for " + ExportedVEFShapes.NODE_MODEL + " at " + pkgName);
            }
            if (this.fallback != null){
                if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(logLevel)){
                    ExportedVEFShapes.LOGGER_$LI$().log(logLevel, "\t" + ExportedVEFShapes.NODE_MODEL + " --> fallback to " + this.fallback.toString());
                }
                return this.fallback.buildConnectorShape(pkgName);
            }
            throw new java.lang.IllegalStateException("missing connector shape: " + pkgName);
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Direction} dir
         * @return {*}
         */
        createStrutGeometry(dir: com.vzome.core.math.symmetry.Direction): com.vzome.core.parts.StrutGeometry {
            if (!dir.isAutomatic()){
                const defaultGeometry: com.vzome.core.parts.StrutGeometry = new com.vzome.core.parts.FastDefaultStrutGeometry(dir);
                let shortGeometry: com.vzome.core.parts.StrutGeometry = defaultGeometry;
                let vefData: string = this.loadVefData(dir.getName() + "-short");
                if (vefData != null){
                    const parser: ExportedVEFShapes.VefToShape = new ExportedVEFShapes.VefToShape(this);
                    parser.parseVEF(vefData, this.mSymmetry.getField());
                    shortGeometry = parser.getStrutGeometry(dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 0).normal());
                    (<com.vzome.core.viewing.ExportedVEFStrutGeometry><any>shortGeometry).setShortGeometry(defaultGeometry);
                }
                vefData = this.loadVefData(dir.getName());
                if (vefData != null){
                    const parser: ExportedVEFShapes.VefToShape = new ExportedVEFShapes.VefToShape(this);
                    parser.parseVEF(vefData, this.mSymmetry.getField());
                    const geometry: com.vzome.core.viewing.ExportedVEFStrutGeometry = parser.getStrutGeometry(dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 0).normal());
                    geometry.setShortGeometry(shortGeometry);
                    return geometry;
                }
                const logLevel: java.util.logging.Level = java.util.logging.Level.FINER;
                if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(logLevel)){
                    ExportedVEFShapes.LOGGER_$LI$().log(logLevel, this.toString() + " has no VEF data for strut: " + dir.getName());
                }
                if (this.fallback != null){
                    if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(logLevel)){
                        ExportedVEFShapes.LOGGER_$LI$().log(logLevel, "\t" + dir.getName() + " strut --> fallback to " + this.fallback.toString());
                    }
                    return this.fallback.createStrutGeometry(dir);
                }
            }
            return super.createStrutGeometry(dir);
        }

        loadVefData(name: string): string {
            const script: string = this.mPkgName + "/" + name + ".vef";
            return com.vzome.xml.ResourceLoader.loadStringResource(ExportedVEFShapes.MODEL_PREFIX + script);
        }

        /**
         * 
         * @return {boolean}
         */
        public hasColors(): boolean {
            return !this.colors.isEmpty();
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Direction} dir
         * @return {com.vzome.core.construction.Color}
         */
        public getColor(dir: com.vzome.core.math.symmetry.Direction): com.vzome.core.construction.Color {
            if (this.colors.isEmpty())return null;
            const dirName: string = (dir == null) ? ExportedVEFShapes.NODE_MODEL : dir.getName();
            const colorString: string = this.colors.getProperty(dirName);
            if (colorString == null)return null;
            return com.vzome.core.render.Colors.parseColor(colorString);
        }
    }
    ExportedVEFShapes["__class"] = "com.vzome.core.viewing.ExportedVEFShapes";
    ExportedVEFShapes["__interfaces"] = ["com.vzome.core.editor.api.Shapes"];



    export namespace ExportedVEFShapes {

        export class VefToShape extends com.vzome.core.math.VefParser {
            public __parent: any;
            tipVertexIndices: java.util.Set<number>;

            midpointVertexIndices: java.util.Set<number>;

            tipVertex: com.vzome.core.algebra.AlgebraicVector;

            vertices: java.util.List<com.vzome.core.algebra.AlgebraicVector>;

            faces: java.util.List<java.util.List<number>>;

            invertSnubBall: boolean;

            public getStrutGeometry(prototype: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.viewing.ExportedVEFStrutGeometry {
                const tipAxis: com.vzome.core.math.symmetry.Axis = this.__parent.mSymmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](this.tipVertex);
                const midpoint: com.vzome.core.algebra.AlgebraicVector = this.tipVertex.scale(this.__parent.mSymmetry.getField()['createRational$long$long'](1, 2));
                const orientation: number = this.__parent.mSymmetry.inverse(tipAxis.getOrientation());
                const adjustment: com.vzome.core.algebra.AlgebraicMatrix = this.__parent.mSymmetry.getMatrix(orientation);
                const newVertices: java.util.List<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>());
                for(let i: number = 0; i < this.vertices.size(); i++) {{
                    let originalVertex: com.vzome.core.algebra.AlgebraicVector = this.vertices.get(i);
                    if (this.tipVertexIndices.contains(i))originalVertex = originalVertex.minus(this.tipVertex); else if (this.midpointVertexIndices.contains(i))originalVertex = originalVertex.minus(midpoint);
                    const adjustedVertex: com.vzome.core.algebra.AlgebraicVector = adjustment.timesColumn(originalVertex);
                    newVertices.add(adjustedVertex);
                };}
                return new com.vzome.core.viewing.ExportedVEFStrutGeometry(newVertices, this.faces, prototype, this.tipVertexIndices, this.midpointVertexIndices, this.__parent.mSymmetry.getField());
            }

            public getConnectorPolyhedron(): com.vzome.core.math.Polyhedron {
                const result: com.vzome.core.math.Polyhedron = new com.vzome.core.math.Polyhedron(this.__parent.mSymmetry.getField());
                for(let index=this.vertices.iterator();index.hasNext();) {
                    let vertex = index.next();
                    {
                        result.addVertex(vertex);
                    }
                }
                for(let index=this.faces.iterator();index.hasNext();) {
                    let prototypeFace = index.next();
                    {
                        const face: com.vzome.core.math.Polyhedron.Face = result.newFace();
                        face.addAll(prototypeFace);
                        result.addFace(face);
                    }
                }
                return result;
            }

            /**
             * 
             * @param {number} index
             * @param {int[]} verts
             */
            addFace(index: number, verts: number[]) {
                const face: java.util.List<number> = <any>(new java.util.ArrayList<any>());
                for(let i: number = 0; i < verts.length; i++) {{
                    const n: number = this.invertSnubBall ? verts.length - 1 - i : i;
                    const j: number = verts[n];
                    face.add(j);
                };}
                this.faces.add(face);
            }

            /**
             * 
             * @param {number} index
             * @param {com.vzome.core.algebra.AlgebraicVector} location
             */
            addVertex(index: number, location: com.vzome.core.algebra.AlgebraicVector) {
                let vertex: com.vzome.core.algebra.AlgebraicVector = this.__parent.mSymmetry.getField().projectTo3d(location, this.wFirst());
                if (this.invertSnubBall){
                    vertex = vertex.negate();
                }
                this.vertices.add(vertex);
            }

            /**
             * 
             * @param {number} index
             * @param {number} vertex
             */
            addBall(index: number, vertex: number) {
                this.tipVertexIndices.add(vertex);
            }

            /**
             * 
             * @param {java.util.StringTokenizer} tokens
             */
            endFile(tokens: java.util.StringTokenizer) {
                if (!tokens.hasMoreTokens())return;
                let token: string = tokens.nextToken();
                if (!("tip" === token))throw new java.lang.IllegalStateException("VEF format error: token after face list (\"" + token + "\" should be \"tip\"");
                try {
                    token = tokens.nextToken();
                } catch(e1) {
                    throw new java.lang.IllegalStateException("VEF format error: no tokens after \"tip\"");
                }
                let tipIndex: number;
                try {
                    tipIndex = javaemul.internal.IntegerHelper.parseInt(token);
                } catch(e) {
                    throw new java.lang.RuntimeException("VEF format error: strut tip vertex index (\"" + token + "\") must be an integer", e);
                }
                this.tipVertex = this.vertices.get(tipIndex);
                if (!tokens.hasMoreTokens())return;
                token = tokens.nextToken();
                if (!("middle" === token))throw new java.lang.IllegalStateException("VEF format error: token after tip vertex (\"" + token + "\" should be \"middle\"");
                while((tokens.hasMoreTokens())) {{
                    token = tokens.nextToken();
                    let vertexIndex: number;
                    try {
                        vertexIndex = javaemul.internal.IntegerHelper.parseInt(token);
                    } catch(e) {
                        throw new java.lang.RuntimeException("VEF format error: middle vertex index (\"" + token + "\") must be an integer", e);
                    }
                    this.midpointVertexIndices.add(vertexIndex);
                }};
            }

            /**
             * 
             * @param {number} numVertices
             */
            startBalls(numVertices: number) {
            }

            /**
             * 
             * @param {number} numEdges
             */
            startEdges(numEdges: number) {
            }

            /**
             * 
             * @param {number} index
             * @param {number} v1
             * @param {number} v2
             */
            addEdge(index: number, v1: number, v2: number) {
            }

            /**
             * 
             * @param {number} numFaces
             */
            startFaces(numFaces: number) {
            }

            /**
             * 
             * @param {number} numVertices
             */
            startVertices(numVertices: number) {
            }

            constructor(__parent: any) {
                super();
                this.__parent = __parent;
                this.tipVertexIndices = <any>(new java.util.HashSet<any>());
                this.midpointVertexIndices = <any>(new java.util.HashSet<any>());
                if (this.tipVertex === undefined) { this.tipVertex = null; }
                this.vertices = <any>(new java.util.ArrayList<any>());
                this.faces = <any>(new java.util.ArrayList<any>());
                this.invertSnubBall = false;
            }
        }
        VefToShape["__class"] = "com.vzome.core.viewing.ExportedVEFShapes.VefToShape";

    }

}
namespace com.vzome.core.math.symmetry {
    /**
     * @author Scott Vorthmann
     * @param {string} name
     * @param {string} rootsResource
     * @param {*} field
     * @class
     */
    export class QuaternionicSymmetry {
        /*private*/ mRoots: com.vzome.core.algebra.Quaternion[];

        /*private*/ mName: string;

        public constructor(name: string, rootsResource: string, field: com.vzome.core.algebra.AlgebraicField) {
            if (this.mRoots === undefined) { this.mRoots = null; }
            if (this.mName === undefined) { this.mName = null; }
            this.mName = name;
            const vefData: string = com.vzome.xml.ResourceLoader.loadStringResource(rootsResource);
            const parser: QuaternionicSymmetry.RootParser = new QuaternionicSymmetry.RootParser(field);
            parser.parseVEF(vefData, field);
            this.mRoots = parser.getQuaternions();
        }

        public getRoots(): com.vzome.core.algebra.Quaternion[] {
            return this.mRoots;
        }

        public getName(): string {
            return this.mName;
        }
    }
    QuaternionicSymmetry["__class"] = "com.vzome.core.math.symmetry.QuaternionicSymmetry";


    export namespace QuaternionicSymmetry {

        export class RootParser extends com.vzome.core.math.VefParser {
            mRoots: com.vzome.core.algebra.Quaternion[];

            __com_vzome_core_math_symmetry_QuaternionicSymmetry_RootParser_field: com.vzome.core.algebra.AlgebraicField;

            constructor(field: com.vzome.core.algebra.AlgebraicField) {
                super();
                if (this.mRoots === undefined) { this.mRoots = null; }
                if (this.__com_vzome_core_math_symmetry_QuaternionicSymmetry_RootParser_field === undefined) { this.__com_vzome_core_math_symmetry_QuaternionicSymmetry_RootParser_field = null; }
                if (this.HALF === undefined) { this.HALF = null; }
                this.__com_vzome_core_math_symmetry_QuaternionicSymmetry_RootParser_field = field;
                this.HALF = field['createRational$long$long'](1, 2);
            }

            /**
             * 
             * @param {number} numVertices
             */
            startVertices(numVertices: number) {
                this.mRoots = (s => { let a=[]; while(s-->0) a.push(null); return a; })(numVertices);
            }

            public getQuaternions(): com.vzome.core.algebra.Quaternion[] {
                return this.mRoots;
            }

            HALF: com.vzome.core.algebra.AlgebraicNumber;

            /**
             * 
             * @param {number} index
             * @param {com.vzome.core.algebra.AlgebraicVector} location
             */
            addVertex(index: number, location: com.vzome.core.algebra.AlgebraicVector) {
                this.mRoots[index] = new com.vzome.core.algebra.Quaternion(this.__com_vzome_core_math_symmetry_QuaternionicSymmetry_RootParser_field, location.scale(this.HALF));
            }

            /**
             * 
             * @param {number} numEdges
             */
            startEdges(numEdges: number) {
            }

            /**
             * 
             * @param {number} index
             * @param {number} v1
             * @param {number} v2
             */
            addEdge(index: number, v1: number, v2: number) {
            }

            /**
             * 
             * @param {number} numFaces
             */
            startFaces(numFaces: number) {
            }

            /**
             * 
             * @param {number} index
             * @param {int[]} verts
             */
            addFace(index: number, verts: number[]) {
            }

            /**
             * 
             * @param {number} index
             * @param {number} vertex
             */
            addBall(index: number, vertex: number) {
            }

            /**
             * 
             * @param {number} numVertices
             */
            startBalls(numVertices: number) {
            }

            /**
             * 
             * @param {java.util.StringTokenizer} tokens
             */
            endFile(tokens: java.util.StringTokenizer) {
            }
        }
        RootParser["__class"] = "com.vzome.core.math.symmetry.QuaternionicSymmetry.RootParser";

    }

}
namespace com.vzome.core.math {
    export class VefToPolyhedron extends com.vzome.core.math.VefParser {
        polyhedron: com.vzome.core.math.Polyhedron;

        public static importPolyhedron(field: com.vzome.core.algebra.AlgebraicField, vef: string): com.vzome.core.math.Polyhedron {
            const result: com.vzome.core.math.Polyhedron = new com.vzome.core.math.Polyhedron(field);
            const parser: VefToPolyhedron = new VefToPolyhedron(result);
            parser.parseVEF(vef, field);
            return result;
        }

        public constructor(polyhedron: com.vzome.core.math.Polyhedron) {
            super();
            if (this.polyhedron === undefined) { this.polyhedron = null; }
            this.polyhedron = polyhedron;
        }

        /**
         * 
         * @param {number} index
         * @param {com.vzome.core.algebra.AlgebraicVector} location
         */
        addVertex(index: number, location: com.vzome.core.algebra.AlgebraicVector) {
            this.polyhedron.addVertex(this.getField().projectTo3d(location, true));
        }

        /**
         * 
         * @param {number} index
         * @param {int[]} verts
         */
        addFace(index: number, verts: number[]) {
            const face: com.vzome.core.math.Polyhedron.Face = this.polyhedron.newFace();
            for(let index1 = 0; index1 < verts.length; index1++) {
                let i = verts[index1];
                face.add(i)
            }
            this.polyhedron.addFace(face);
        }

        /**
         * 
         * @param {number} numVertices
         */
        startVertices(numVertices: number) {
        }

        /**
         * 
         * @param {number} numFaces
         */
        startFaces(numFaces: number) {
        }

        /**
         * 
         * @param {number} numEdges
         */
        startEdges(numEdges: number) {
        }

        /**
         * 
         * @param {number} index
         * @param {number} v1
         * @param {number} v2
         */
        addEdge(index: number, v1: number, v2: number) {
        }

        /**
         * 
         * @param {number} numVertices
         */
        startBalls(numVertices: number) {
        }

        /**
         * 
         * @param {number} index
         * @param {number} vertex
         */
        addBall(index: number, vertex: number) {
        }
    }
    VefToPolyhedron["__class"] = "com.vzome.core.math.VefToPolyhedron";

}
namespace com.vzome.core.construction {
    export class VefToModel extends com.vzome.core.math.VefParser {
        offset: com.vzome.core.algebra.AlgebraicVector;

        scale: com.vzome.core.algebra.AlgebraicNumber;

        __com_vzome_core_construction_VefToModel_field: com.vzome.core.algebra.AlgebraicField;

        mProjection: com.vzome.core.math.Projection;

        mVertices: com.vzome.core.construction.Point[];

        mEffects: com.vzome.core.construction.ConstructionChanges;

        noBallsSection: boolean;

        static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (VefToModel.logger == null) { VefToModel.logger = java.util.logging.Logger.getLogger("com.vzome.core.construction.VefToModel"); }  return VefToModel.logger; }

        public constructor(projection: com.vzome.core.math.Projection, effects: com.vzome.core.construction.ConstructionChanges, scale: com.vzome.core.algebra.AlgebraicNumber, offset: com.vzome.core.algebra.AlgebraicVector) {
            super();
            if (this.offset === undefined) { this.offset = null; }
            if (this.scale === undefined) { this.scale = null; }
            if (this.__com_vzome_core_construction_VefToModel_field === undefined) { this.__com_vzome_core_construction_VefToModel_field = null; }
            if (this.mProjection === undefined) { this.mProjection = null; }
            if (this.mVertices === undefined) { this.mVertices = null; }
            if (this.mEffects === undefined) { this.mEffects = null; }
            this.noBallsSection = true;
            this.mEffects = effects;
            this.__com_vzome_core_construction_VefToModel_field = scale.getField();
            this.scale = scale;
            this.offset = offset;
            this.mProjection = projection == null ? new com.vzome.core.math.Projection.Default(this.__com_vzome_core_construction_VefToModel_field) : projection;
            if (projection != null && VefToModel.logger_$LI$().isLoggable(java.util.logging.Level.FINEST)){
                VefToModel.logger_$LI$().finest("projection = " + projection.getProjectionName());
            }
        }

        /**
         * 
         * @param {number} numVertices
         */
        startVertices(numVertices: number) {
            this.mVertices = (s => { let a=[]; while(s-->0) a.push(null); return a; })(numVertices);
        }

        /**
         * 
         * @param {number} index
         * @param {com.vzome.core.algebra.AlgebraicVector} location
         */
        addVertex(index: number, location: com.vzome.core.algebra.AlgebraicVector) {
            VefToModel.logger_$LI$().finest("addVertex location = " + location.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT));
            if (this.scale != null){
                location = location.scale(this.scale);
                VefToModel.logger_$LI$().finest("scaled = " + location.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT));
            }
            if (this.wFirst() && location.dimension() === 3){
                location = location.inflateTo4d$();
            }
            location = this.mProjection.projectImage(location, this.wFirst());
            VefToModel.logger_$LI$().finest("projected = " + location.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT));
            if (this.offset != null){
                location = location.plus(this.offset);
                VefToModel.logger_$LI$().finest("translated = " + location.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT));
            }
            this.mVertices[index] = new com.vzome.core.construction.FreePoint(location);
            this.mVertices[index].setIndex(index);
        }

        /**
         * 
         * @param {number} numEdges
         */
        startEdges(numEdges: number) {
        }

        /**
         * 
         * @param {number} index
         * @param {number} v1
         * @param {number} v2
         */
        addEdge(index: number, v1: number, v2: number) {
            const p1: com.vzome.core.construction.Point = this.mVertices[v1];
            const p2: com.vzome.core.construction.Point = this.mVertices[v2];
            if (p1 == null || p2 == null)return;
            const seg: com.vzome.core.construction.Segment = new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
            seg.setIndex(index);
            this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](seg);
        }

        /**
         * 
         * @param {number} numFaces
         */
        startFaces(numFaces: number) {
        }

        /**
         * 
         * @param {number} index
         * @param {int[]} verts
         */
        addFace(index: number, verts: number[]) {
            const points: com.vzome.core.construction.Point[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(verts.length);
            for(let i: number = 0; i < verts.length; i++) {points[i] = this.mVertices[verts[i]];}
            const panel: com.vzome.core.construction.Polygon = new com.vzome.core.construction.PolygonFromVertices(points);
            panel.setIndex(index);
            this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](panel);
        }

        /**
         * 
         * @param {number} index
         * @param {number} vertex
         */
        addBall(index: number, vertex: number) {
            this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](this.mVertices[vertex]);
        }

        /**
         * 
         * @param {number} numVertices
         */
        startBalls(numVertices: number) {
            this.noBallsSection = false;
        }

        /**
         * 
         * @param {java.util.StringTokenizer} tokens
         */
        endFile(tokens: java.util.StringTokenizer) {
            if (this.noBallsSection){
                for(let index = 0; index < this.mVertices.length; index++) {
                    let vertex = this.mVertices[index];
                    {
                        this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](vertex);
                    }
                }
            }
        }
    }
    VefToModel["__class"] = "com.vzome.core.construction.VefToModel";

}
namespace com.vzome.core.model {
    /**
     * Create a panel from a list of AlgebraicVectors
     * 
     * @param {*} vertices
     * @class
     * @extends com.vzome.core.model.ManifestationImpl
     */
    export class PanelImpl extends com.vzome.core.model.ManifestationImpl implements com.vzome.core.model.Panel {
        /*private*/ mVertices: java.util.List<com.vzome.core.algebra.AlgebraicVector>;

        /*private*/ zoneVector: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ label: string;

        public constructor(vertices: java.util.List<com.vzome.core.algebra.AlgebraicVector>) {
            super();
            if (this.mVertices === undefined) { this.mVertices = null; }
            if (this.zoneVector === undefined) { this.zoneVector = null; }
            if (this.label === undefined) { this.label = null; }
            this.mVertices = <any>(new java.util.ArrayList<any>(vertices));
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getZoneVector(): com.vzome.core.algebra.AlgebraicVector {
            if (this.zoneVector != null)return this.zoneVector; else return this.getNormal$();
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} vector
         */
        public setZoneVector(vector: com.vzome.core.algebra.AlgebraicVector) {
            this.zoneVector = vector;
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getLocation(): com.vzome.core.algebra.AlgebraicVector {
            return null;
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getFirstVertex(): com.vzome.core.algebra.AlgebraicVector {
            return this.mVertices.get(0);
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getCentroid(): com.vzome.core.algebra.AlgebraicVector {
            return com.vzome.core.algebra.AlgebraicVectors.calculateCentroid(this.mVertices);
        }

        /**
         * 
         * @return {com.vzome.core.construction.Construction}
         */
        public toConstruction(): com.vzome.core.construction.Construction {
            const first: com.vzome.core.construction.Construction = this.getFirstConstruction();
            if (first != null && first.is3d())return first;
            const field: com.vzome.core.algebra.AlgebraicField = this.mVertices.get(0).getField();
            const projected: java.util.List<com.vzome.core.construction.Point> = <any>(this.mVertices.stream().map<any>(((field) => {
                return (pt) => new com.vzome.core.construction.FreePoint(field.projectTo3d(pt, true))
            })(field)).collect<any, any>(java.util.stream.Collectors.toList<any>()));
            return new com.vzome.core.construction.PolygonFromVertices(projected);
        }

        /**
         * 
         * @return {*}
         */
        public iterator(): java.util.Iterator<com.vzome.core.algebra.AlgebraicVector> {
            return this.mVertices.iterator();
        }

        /**
         * 
         * @return {number}
         */
        public getVertexCount(): number {
            return this.mVertices.size();
        }

        /**
         * 
         * @return {number}
         */
        public hashCode(): number {
            const len: number = this.mVertices.size();
            if (len === 0)return 0;
            let val: number = /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})((this.mVertices.get(0))));
            for(let i: number = 1; i < len; i++) {val ^= /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})((this.mVertices.get(i))));}
            return val;
        }

        /**
         * 
         * @param {*} other
         * @return {boolean}
         */
        public equals(other: any): boolean {
            if (other == null)return false;
            if (other === this)return true;
            if (!(other != null && other instanceof <any>com.vzome.core.model.PanelImpl))return false;
            const panel: PanelImpl = <PanelImpl>other;
            const size: number = this.mVertices.size();
            if (size !== panel.mVertices.size())return false;
            const found: boolean[] = (s => { let a=[]; while(s-->0) a.push(false); return a; })(size);
            for(let i: number = 0; i < size; i++) {{
                let found_i: boolean = false;
                for(let j: number = 0; j < size; j++) {{
                    if (found[j])continue;
                    if (this.mVertices.get(j).equals(panel.mVertices.get(i))){
                        found[j] = true;
                        found_i = true;
                        break;
                    }
                };}
                if (!found_i)return false;
            };}
            for(let j: number = 0; j < size; j++) {if (!found[j])return false;;}
            return true;
        }

        public getNormal$(): com.vzome.core.algebra.AlgebraicVector {
            const v0: com.vzome.core.algebra.AlgebraicVector = this.mVertices.get(0);
            const v1: com.vzome.core.algebra.AlgebraicVector = this.mVertices.get(1);
            const v2: com.vzome.core.algebra.AlgebraicVector = this.mVertices.get(2);
            return com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2);
        }

        public getNormal$com_vzome_core_math_symmetry_Embedding(embedding: com.vzome.core.math.symmetry.Embedding): com.vzome.core.math.RealVector {
            const v0: com.vzome.core.algebra.AlgebraicVector = this.mVertices.get(0);
            const v1: com.vzome.core.algebra.AlgebraicVector = this.mVertices.get(1);
            const v2: com.vzome.core.algebra.AlgebraicVector = this.mVertices.get(2);
            const rv1: com.vzome.core.math.RealVector = embedding.embedInR3(v1.minus(v0));
            const rv2: com.vzome.core.math.RealVector = embedding.embedInR3(v2.minus(v0));
            return rv1.cross(rv2);
        }

        /**
         * 
         * @param {*} embedding
         * @return {com.vzome.core.math.RealVector}
         */
        public getNormal(embedding?: any): any {
            if (((embedding != null && (embedding.constructor != null && embedding.constructor["__interfaces"] != null && embedding.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Embedding") >= 0)) || embedding === null)) {
                return <any>this.getNormal$com_vzome_core_math_symmetry_Embedding(embedding);
            } else if (embedding === undefined) {
                return <any>this.getNormal$();
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {string}
         */
        public toString(): string {
            const buf: java.lang.StringBuilder = new java.lang.StringBuilder("panel: ");
            let delim: string = "";
            for(let index=this.mVertices.iterator();index.hasNext();) {
                let vertex = index.next();
                {
                    buf.append(delim).append(vertex.toString());
                    delim = ", ";
                }
            }
            return buf.toString();
        }

        /**
         * 
         * @param {string} label
         */
        public setLabel(label: string) {
            this.label = label;
        }

        /**
         * 
         * @return {string}
         */
        public getLabel(): string {
            return this.label;
        }

        /**
         * 
         * @return {*}
         */
        public getQuadrea(): com.vzome.core.algebra.AlgebraicNumber {
            const field: com.vzome.core.algebra.AlgebraicField = this.mVertices.get(0).getField();
            return field.one();
        }
    }
    PanelImpl["__class"] = "com.vzome.core.model.PanelImpl";
    PanelImpl["__interfaces"] = ["com.vzome.core.model.HasRenderedObject","com.vzome.core.model.GroupElement","com.vzome.core.model.Panel","com.vzome.core.model.Manifestation","java.lang.Iterable"];


}
namespace com.vzome.core.model {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.algebra.AlgebraicVector} end1
     * @param {com.vzome.core.algebra.AlgebraicVector} end2
     * @class
     * @extends com.vzome.core.model.ManifestationImpl
     */
    export class StrutImpl extends com.vzome.core.model.ManifestationImpl implements com.vzome.core.model.Strut {
        /*private*/ m_end1: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ m_end2: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ zoneVector: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ label: string;

        public constructor(end1: com.vzome.core.algebra.AlgebraicVector, end2: com.vzome.core.algebra.AlgebraicVector) {
            super();
            if (this.m_end1 === undefined) { this.m_end1 = null; }
            if (this.m_end2 === undefined) { this.m_end2 = null; }
            if (this.zoneVector === undefined) { this.zoneVector = null; }
            if (this.label === undefined) { this.label = null; }
            this.m_end1 = end1;
            this.m_end2 = end2;
        }

        public getZoneVector(): com.vzome.core.algebra.AlgebraicVector {
            if (this.zoneVector != null)return this.zoneVector; else return this.getOffset();
        }

        public setZoneVector(vector: com.vzome.core.algebra.AlgebraicVector) {
            this.zoneVector = vector;
        }

        /**
         * 
         * @return {number}
         */
        public hashCode(): number {
            const result: number = /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})(this.m_end1)) ^ /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})(this.m_end2));
            return result;
        }

        /**
         * 
         * @param {*} obj
         * @return {boolean}
         */
        public equals(obj: any): boolean {
            if (obj == null)return false;
            if (obj === this)return true;
            if (!(obj != null && obj instanceof <any>com.vzome.core.model.StrutImpl))return false;
            const other: StrutImpl = <StrutImpl>obj;
            const otherStart: com.vzome.core.algebra.AlgebraicVector = other.m_end1;
            const otherEnd: com.vzome.core.algebra.AlgebraicVector = other.m_end2;
            if (otherStart.equals(this.m_end1))return otherEnd.equals(this.m_end2); else if (otherEnd.equals(this.m_end1))return otherStart.equals(this.m_end2); else return false;
        }

        /**
         * 
         * @param {*} other
         * @return {number}
         */
        public compareTo(other: com.vzome.core.model.Strut): number {
            if (this === other){
                return 0;
            }
            if (/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(other,this))){
                return 0;
            }
            const thisFirst: com.vzome.core.algebra.AlgebraicVector = this.getCanonicalLesserEnd();
            const thisLast: com.vzome.core.algebra.AlgebraicVector = this.getCanonicalGreaterEnd();
            const otherFirst: com.vzome.core.algebra.AlgebraicVector = other.getCanonicalLesserEnd();
            const otherLast: com.vzome.core.algebra.AlgebraicVector = other.getCanonicalGreaterEnd();
            const comparison: number = thisFirst.compareTo(otherFirst);
            return (comparison === 0) ? thisLast.compareTo(otherLast) : comparison;
        }

        public getCanonicalLesserEnd(): com.vzome.core.algebra.AlgebraicVector {
            return (this.m_end1.compareTo(this.m_end2) < 0) ? this.m_end1 : this.m_end2;
        }

        public getCanonicalGreaterEnd(): com.vzome.core.algebra.AlgebraicVector {
            return (this.m_end1.compareTo(this.m_end2) > 0) ? this.m_end1 : this.m_end2;
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getLocation(): com.vzome.core.algebra.AlgebraicVector {
            return this.m_end1;
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getCentroid(): com.vzome.core.algebra.AlgebraicVector {
            return com.vzome.core.algebra.AlgebraicVectors.getCentroid([this.m_end1, this.m_end2]);
        }

        /**
         * 
         * @return {com.vzome.core.construction.Construction}
         */
        public toConstruction(): com.vzome.core.construction.Construction {
            const first: com.vzome.core.construction.Construction = this.getFirstConstruction();
            if (first != null && first.is3d())return first;
            const field: com.vzome.core.algebra.AlgebraicField = this.m_end1.getField();
            const pt1: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(field.projectTo3d(this.m_end1, true));
            const pt2: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(field.projectTo3d(this.m_end2, true));
            return new com.vzome.core.construction.SegmentJoiningPoints(pt1, pt2);
        }

        public getEnd(): com.vzome.core.algebra.AlgebraicVector {
            return this.m_end2;
        }

        public getOffset(): com.vzome.core.algebra.AlgebraicVector {
            return this.m_end2.minus(this.m_end1);
        }

        /**
         * 
         * @return {string}
         */
        public toString(): string {
            return "strut from " + this.m_end1.toString() + " to " + this.m_end2.toString();
        }

        /**
         * 
         * @param {string} label
         */
        public setLabel(label: string) {
            this.label = label;
        }

        /**
         * 
         * @return {string}
         */
        public getLabel(): string {
            return this.label;
        }
    }
    StrutImpl["__class"] = "com.vzome.core.model.StrutImpl";
    StrutImpl["__interfaces"] = ["com.vzome.core.model.HasRenderedObject","com.vzome.core.model.GroupElement","com.vzome.core.model.Strut","java.lang.Comparable","com.vzome.core.model.Manifestation"];


}
namespace com.vzome.core.model {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.algebra.AlgebraicVector} loc
     * @class
     * @extends com.vzome.core.model.ManifestationImpl
     */
    export class ConnectorImpl extends com.vzome.core.model.ManifestationImpl implements com.vzome.core.model.Connector {
        public constructor(loc: com.vzome.core.algebra.AlgebraicVector) {
            super();
            if (this.m_center === undefined) { this.m_center = null; }
            if (this.label === undefined) { this.label = null; }
            this.m_center = loc;
        }

        /*private*/ m_center: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ label: string;

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getLocation(): com.vzome.core.algebra.AlgebraicVector {
            return this.m_center;
        }

        /**
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public getCentroid(): com.vzome.core.algebra.AlgebraicVector {
            return this.m_center;
        }

        /**
         * 
         * @return {com.vzome.core.construction.Construction}
         */
        public toConstruction(): com.vzome.core.construction.Construction {
            const first: com.vzome.core.construction.Construction = this.getFirstConstruction();
            if (first != null && first.is3d())return first;
            const field: com.vzome.core.algebra.AlgebraicField = this.m_center.getField();
            return new com.vzome.core.construction.FreePoint(field.projectTo3d(this.m_center, true));
        }

        /**
         * 
         * @return {number}
         */
        public hashCode(): number {
            return /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})(this.m_center));
        }

        /**
         * 
         * @param {*} other
         * @return {boolean}
         */
        public equals(other: any): boolean {
            if (other == null)return false;
            if (other === this)return true;
            if (!(other != null && other instanceof <any>com.vzome.core.model.ConnectorImpl))return false;
            const conn: ConnectorImpl = <ConnectorImpl>other;
            return this.getLocation().equals(conn.getLocation());
        }

        /**
         * 
         * @param {*} other
         * @return {number}
         */
        public compareTo(other: com.vzome.core.model.Connector): number {
            if (this === other){
                return 0;
            }
            if (/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(other,this))){
                return 0;
            }
            return this.getLocation().compareTo(other.getLocation());
        }

        /**
         * 
         * @return {string}
         */
        public toString(): string {
            return "connector at " + this.m_center.toString();
        }

        /**
         * 
         * @param {string} label
         */
        public setLabel(label: string) {
            this.label = label;
        }

        /**
         * 
         * @return {string}
         */
        public getLabel(): string {
            return this.label;
        }
    }
    ConnectorImpl["__class"] = "com.vzome.core.model.ConnectorImpl";
    ConnectorImpl["__interfaces"] = ["com.vzome.core.model.HasRenderedObject","com.vzome.core.model.GroupElement","com.vzome.core.model.Connector","java.lang.Comparable","com.vzome.core.model.Manifestation"];


}
namespace com.vzome.core.construction {
    export abstract class Polygon extends com.vzome.core.construction.Construction {
        /**
         * 
         * @return {string}
         */
        public toString(): string {
            return "polygon " + java.util.Arrays.toString(this.mVertices);
        }

        /*private*/ mVertices: com.vzome.core.algebra.AlgebraicVector[];

        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            super(field);
            if (this.mVertices === undefined) { this.mVertices = null; }
            this.STRING_COMPARATOR = (s1, s2) => /* compareTo */s1.localeCompare(s2);
        }

        /*private*/ STRING_COMPARATOR: java.util.Comparator<string>;

        public getSignature(): string {
            const strArray: string[] = java.util.Arrays.stream<any>(this.mVertices).map<any>((av) => av.projectTo3d(true).toString()).toArray<any>((arg0) => { return new Array<string>(arg0) });
            java.util.Arrays.sort<any>(strArray, 0, strArray.length, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0, arg1) =>  (funcInst['compare'] ? funcInst['compare'] : funcInst) .call(funcInst, arg0, arg1)})(this.STRING_COMPARATOR)));
            return java.util.Arrays.toString(strArray);
        }

        setStateVariable(vertices: com.vzome.core.algebra.AlgebraicVector[], impossible: boolean): boolean {
            if (impossible){
                if (this.isImpossible())return false;
                this.setImpossible(true);
                return true;
            }
            this.mVertices = vertices;
            this.setImpossible(false);
            return true;
        }

        public getXml$org_w3c_dom_Document(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const result: org.w3c.dom.Element = doc.createElement("polygon");
            this.getXml$org_w3c_dom_Element$java_lang_String(result, "vertex");
            return result;
        }

        public getXml$org_w3c_dom_Element$java_lang_String(result: org.w3c.dom.Element, vertexChildName: string) {
            for(let index = 0; index < this.mVertices.length; index++) {
                let vertex = this.mVertices[index];
                {
                    const child: org.w3c.dom.Element = result.getOwnerDocument().createElement(vertexChildName);
                    com.vzome.xml.DomUtils.addAttribute(child, "at", vertex.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                    result.appendChild(child);
                }
            }
        }

        public getXml(result?: any, vertexChildName?: any) {
            if (((result != null && (result.constructor != null && result.constructor["__interfaces"] != null && result.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || result === null) && ((typeof vertexChildName === 'string') || vertexChildName === null)) {
                return <any>this.getXml$org_w3c_dom_Element$java_lang_String(result, vertexChildName);
            } else if (((result != null && (result.constructor != null && result.constructor["__interfaces"] != null && result.constructor["__interfaces"].indexOf("org.w3c.dom.Document") >= 0)) || result === null) && vertexChildName === undefined) {
                return <any>this.getXml$org_w3c_dom_Document(result);
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {boolean}
         */
        public is3d(): boolean {
            for(let index = 0; index < this.mVertices.length; index++) {
                let algebraicVector = this.mVertices[index];
                {
                    if (algebraicVector.dimension() !== 3)return false;
                }
            }
            return true;
        }

        public getVertexCount(): number {
            return this.mVertices.length;
        }

        public getVertex(i: number): com.vzome.core.algebra.AlgebraicVector {
            return this.mVertices[i];
        }

        public getNormal(): com.vzome.core.algebra.AlgebraicVector {
            return com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(this.mVertices[0], this.mVertices[1], this.mVertices[2]);
        }

        public getCentroid(): com.vzome.core.algebra.AlgebraicVector {
            return com.vzome.core.algebra.AlgebraicVectors.getCentroid(this.mVertices);
        }

        public getVertices(): com.vzome.core.algebra.AlgebraicVector[] {
            return java.util.Arrays.copyOf<any>(this.mVertices, this.mVertices.length);
        }
    }
    Polygon["__class"] = "com.vzome.core.construction.Polygon";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @extends com.vzome.core.construction.Construction
     * @class
     */
    export abstract class Transformation extends com.vzome.core.construction.Construction {
        /**
         * 
         * @return {boolean}
         */
        public is3d(): boolean {
            return true;
        }

        /*private*/ mTransform: com.vzome.core.algebra.AlgebraicMatrix;

        mOffset: com.vzome.core.algebra.AlgebraicVector;

        constructor(field: com.vzome.core.algebra.AlgebraicField) {
            super(field);
            if (this.mTransform === undefined) { this.mTransform = null; }
            if (this.mOffset === undefined) { this.mOffset = null; }
        }

        /**
         * 
         * @param {*} that
         * @return {boolean}
         */
        public equals(that: any): boolean {
            if (this === that){
                return true;
            }
            if (that == null){
                return false;
            }
            if (!(that != null && that instanceof <any>com.vzome.core.construction.Transformation)){
                return false;
            }
            const other: Transformation = <Transformation>that;
            if (this.mOffset == null){
                if (other.mOffset != null){
                    return false;
                }
            } else if (!this.mOffset.equals(other.mOffset)){
                return false;
            }
            if (this.mTransform == null){
                if (other.mTransform != null){
                    return false;
                }
            } else if (!this.mTransform.equals(other.mTransform)){
                return false;
            }
            return true;
        }

        setStateVariables(transform: com.vzome.core.algebra.AlgebraicMatrix, offset: com.vzome.core.algebra.AlgebraicVector, impossible: boolean): boolean {
            if (impossible){
                if (this.isImpossible())return false;
                this.setImpossible(true);
                return true;
            }
            if (transform != null && transform.equals(this.mTransform) && offset.equals(this.mOffset) && !this.isImpossible())return false;
            this.mTransform = transform;
            this.mOffset = offset;
            this.setImpossible(false);
            return true;
        }

        public transform$com_vzome_core_algebra_AlgebraicVector(arg: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            arg = arg.minus(this.mOffset);
            arg = this.mTransform.timesColumn(arg);
            arg = arg.plus(this.mOffset);
            return arg;
        }

        public transform(arg?: any): any {
            if (((arg != null && arg instanceof <any>com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                return <any>this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
            } else if (((arg != null && arg instanceof <any>com.vzome.core.construction.Construction) || arg === null)) {
                return <any>this.transform$com_vzome_core_construction_Construction(arg);
            } else throw new Error('invalid overload');
        }

        public transform$com_vzome_core_construction_Construction(c: com.vzome.core.construction.Construction): com.vzome.core.construction.Construction {
            if (c != null && c instanceof <any>com.vzome.core.construction.Point){
                return new com.vzome.core.construction.TransformedPoint(this, <com.vzome.core.construction.Point>c);
            } else if (c != null && c instanceof <any>com.vzome.core.construction.Segment){
                return new com.vzome.core.construction.TransformedSegment(this, <com.vzome.core.construction.Segment>c);
            } else if (c != null && c instanceof <any>com.vzome.core.construction.Polygon){
                return new com.vzome.core.construction.TransformedPolygon(this, <com.vzome.core.construction.Polygon>c);
            } else {
                return null;
            }
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const result: org.w3c.dom.Element = doc.createElement("transformation");
            return result;
        }
    }
    Transformation["__class"] = "com.vzome.core.construction.Transformation";


    export namespace Transformation {

        export class Identity extends com.vzome.core.construction.Transformation {
            public transform$int_A(arg: number[]): number[] {
                return arg;
            }

            public transform(arg?: any): any {
                if (((arg != null && arg instanceof <any>Array && (arg.length == 0 || arg[0] == null ||(typeof arg[0] === 'number'))) || arg === null)) {
                    return <any>this.transform$int_A(arg);
                } else if (((arg != null && arg instanceof <any>com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                    return super.transform(arg);
                } else if (((arg != null && arg instanceof <any>com.vzome.core.construction.Construction) || arg === null)) {
                    return <any>this.transform$com_vzome_core_construction_Construction(arg);
                } else throw new Error('invalid overload');
            }

            public constructor(field: com.vzome.core.algebra.AlgebraicField) {
                super(field);
            }

            public attach() {
            }

            public detach() {
            }

            /**
             * 
             * @return {boolean}
             */
            mapParamsToState(): boolean {
                return true;
            }
        }
        Identity["__class"] = "com.vzome.core.construction.Transformation.Identity";

    }

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @extends com.vzome.core.construction.Construction
     * @class
     */
    export abstract class Segment extends com.vzome.core.construction.Construction {
        /*private*/ mStart: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ mOffset: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ mEnd: com.vzome.core.algebra.AlgebraicVector;

        constructor(field: com.vzome.core.algebra.AlgebraicField) {
            super(field);
            if (this.mStart === undefined) { this.mStart = null; }
            if (this.mOffset === undefined) { this.mOffset = null; }
            if (this.mEnd === undefined) { this.mEnd = null; }
        }

        public getSignature(): string {
            const start: string = this.mStart.projectTo3d(true).toString();
            const end: string = this.getEnd().projectTo3d(true).toString();
            if (/* compareTo */start.localeCompare(end) <= 0)return start + "," + end; else return end + "," + start;
        }

        /**
         * 
         * @return {boolean}
         */
        public is3d(): boolean {
            return this.mStart.dimension() === 3 && this.mOffset.dimension() === 3;
        }

        setStateVariables(start: com.vzome.core.algebra.AlgebraicVector, offset: com.vzome.core.algebra.AlgebraicVector, impossible: boolean): boolean {
            if (impossible){
                if (this.isImpossible())return false;
                this.setImpossible(true);
                return true;
            }
            if (offset.equals(this.mOffset) && !this.isImpossible() && start.equals(this.mStart))return false;
            this.mOffset = offset;
            this.mStart = start;
            this.mEnd = null;
            this.setImpossible(false);
            return true;
        }

        public getStart(): com.vzome.core.algebra.AlgebraicVector {
            return this.mStart;
        }

        public getEnd(): com.vzome.core.algebra.AlgebraicVector {
            if (this.mEnd == null)this.mEnd = this.mStart.plus(this.mOffset);
            return this.mEnd;
        }

        public getOffset(): com.vzome.core.algebra.AlgebraicVector {
            return this.mOffset;
        }

        public getCentroid(): com.vzome.core.algebra.AlgebraicVector {
            return com.vzome.core.algebra.AlgebraicVectors.getCentroid([this.mStart, this.mEnd]);
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const result: org.w3c.dom.Element = doc.createElement("segment");
            result.setAttribute("start", this.mStart.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
            result.setAttribute("end", this.getEnd().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
            return result;
        }

        /**
         * 
         * @return {string}
         */
        public toString(): string {
            return "segment from " + this.mStart + " to " + this.getEnd();
        }
    }
    Segment["__class"] = "com.vzome.core.construction.Segment";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @extends com.vzome.core.construction.Construction
     * @class
     */
    export abstract class Point extends com.vzome.core.construction.Construction {
        /*private*/ mLocation: com.vzome.core.algebra.AlgebraicVector;

        constructor(field: com.vzome.core.algebra.AlgebraicField) {
            super(field);
            if (this.mLocation === undefined) { this.mLocation = null; }
        }

        public getSignature(): string {
            return this.mLocation.projectTo3d(true).toString();
        }

        /**
         * 
         * @return {boolean}
         */
        public is3d(): boolean {
            return this.mLocation.dimension() === 3;
        }

        setStateVariable(loc: com.vzome.core.algebra.AlgebraicVector, impossible: boolean): boolean {
            if (impossible){
                if (this.isImpossible())return false;
                this.setImpossible(true);
                return true;
            }
            if (loc.equals(this.mLocation) && !this.isImpossible())return false;
            this.mLocation = loc;
            this.setImpossible(false);
            return true;
        }

        public getLocation(): com.vzome.core.algebra.AlgebraicVector {
            return this.mLocation;
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const result: org.w3c.dom.Element = doc.createElement("point");
            result.setAttribute("at", this.getLocation().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
            return result;
        }

        /**
         * 
         * @return {string}
         */
        public toString(): string {
            return "point at " + this.mLocation;
        }
    }
    Point["__class"] = "com.vzome.core.construction.Point";

}
namespace com.vzome.core.construction {
    export class Marker extends com.vzome.core.construction.Construction {
        /*private*/ mTarget: com.vzome.core.construction.Construction;

        public constructor(target: com.vzome.core.construction.Construction) {
            super(target.field);
            if (this.mTarget === undefined) { this.mTarget = null; }
            this.mTarget = target;
        }

        public getTarget(): com.vzome.core.construction.Construction {
            return this.mTarget;
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            return false;
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const result: org.w3c.dom.Element = doc.createElement("marker");
            return result;
        }

        /**
         * 
         * @return {boolean}
         */
        public is3d(): boolean {
            return this.mTarget.is3d();
        }
    }
    Marker["__class"] = "com.vzome.core.construction.Marker";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @extends com.vzome.core.construction.Construction
     * @class
     */
    export abstract class Plane extends com.vzome.core.construction.Construction {
        /*private*/ mBase: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ mNormal: com.vzome.core.algebra.AlgebraicVector;

        constructor(field: com.vzome.core.algebra.AlgebraicField) {
            super(field);
            if (this.mBase === undefined) { this.mBase = null; }
            if (this.mNormal === undefined) { this.mNormal = null; }
        }

        /**
         * 
         * @return {boolean}
         */
        public is3d(): boolean {
            return true;
        }

        setStateVariables(base: com.vzome.core.algebra.AlgebraicVector, normal: com.vzome.core.algebra.AlgebraicVector, impossible: boolean): boolean {
            if (impossible){
                if (this.isImpossible())return false;
                this.setImpossible(true);
                return true;
            }
            if (normal.equals(this.mNormal) && !this.isImpossible() && base.equals(this.mBase))return false;
            normal = normal.projectTo3d(true);
            this.mNormal = normal;
            this.mBase = base.projectTo3d(true);
            this.setImpossible(false);
            return true;
        }

        public getBase(): com.vzome.core.algebra.AlgebraicVector {
            return this.mBase;
        }

        public getNormal(): com.vzome.core.algebra.AlgebraicVector {
            return this.mNormal;
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const result: org.w3c.dom.Element = doc.createElement("plane");
            return result;
        }

        public getHomogeneous(): com.vzome.core.algebra.Trivector3dHomogeneous {
            return null;
        }
    }
    Plane["__class"] = "com.vzome.core.construction.Plane";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @extends com.vzome.core.construction.Construction
     * @class
     */
    export abstract class Line extends com.vzome.core.construction.Construction {
        /*private*/ mDirection: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ mStart: com.vzome.core.algebra.AlgebraicVector;

        constructor(field: com.vzome.core.algebra.AlgebraicField) {
            super(field);
            if (this.mDirection === undefined) { this.mDirection = null; }
            if (this.mStart === undefined) { this.mStart = null; }
        }

        /**
         * 
         * @return {boolean}
         */
        public is3d(): boolean {
            return true;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} start
         * @param {com.vzome.core.algebra.AlgebraicVector} norm need not be normalized yet
         * @return
         * @param {boolean} impossible
         * @return {boolean}
         */
        setStateVariables(start: com.vzome.core.algebra.AlgebraicVector, norm: com.vzome.core.algebra.AlgebraicVector, impossible: boolean): boolean {
            if (impossible){
                if (this.isImpossible())return false;
                this.setImpossible(true);
                return true;
            }
            if (norm.equals(this.mDirection) && start.equals(this.mStart) && !this.isImpossible())return false;
            this.mDirection = norm;
            this.mStart = start;
            this.setImpossible(false);
            return true;
        }

        public getStart(): com.vzome.core.algebra.AlgebraicVector {
            return this.mStart;
        }

        /**
         * @return {com.vzome.core.algebra.AlgebraicVector} a "unit" vector... always normalized
         */
        public getDirection(): com.vzome.core.algebra.AlgebraicVector {
            return this.mDirection;
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const result: org.w3c.dom.Element = doc.createElement("line");
            return result;
        }

        public getHomogeneous(): com.vzome.core.algebra.Bivector3dHomogeneous {
            const v1: com.vzome.core.algebra.Vector3dHomogeneous = new com.vzome.core.algebra.Vector3dHomogeneous(this.mStart, this.getField());
            const v2: com.vzome.core.algebra.Vector3dHomogeneous = new com.vzome.core.algebra.Vector3dHomogeneous(this.mStart.plus(this.mDirection), this.getField());
            return v1.outer(v2);
        }
    }
    Line["__class"] = "com.vzome.core.construction.Line";

}
namespace com.vzome.core.editor.api {
    /**
     * @author David Hall
     * @class
     */
    export class Manifestations {
        public static visibleManifestations$java_lang_Iterable(manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>): Manifestations.ManifestationIterator {
            return new Manifestations.ManifestationIterator((man) => { return Manifestations.Filters.isVisible(man) }, manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(null)));
        }

        public static visibleManifestations$java_util_function_Predicate$java_lang_Iterable(preTest: (p1: com.vzome.core.model.Manifestation) => boolean, manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>): Manifestations.ManifestationIterator {
            return new Manifestations.ManifestationIterator(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(preTest)), manifestations, (man) => { return Manifestations.Filters.isVisible(man) });
        }

        public static visibleManifestations(preTest?: any, manifestations?: any): Manifestations.ManifestationIterator {
            if (((typeof preTest === 'function' && (<any>preTest).length === 1) || preTest === null) && ((manifestations != null && (manifestations.constructor != null && manifestations.constructor["__interfaces"] != null && manifestations.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || manifestations === null)) {
                return <any>com.vzome.core.editor.api.Manifestations.visibleManifestations$java_util_function_Predicate$java_lang_Iterable(preTest, manifestations);
            } else if (((preTest != null && (preTest.constructor != null && preTest.constructor["__interfaces"] != null && preTest.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preTest === null) && ((typeof manifestations === 'function' && (<any>manifestations).length === 1) || manifestations === null)) {
                return <any>com.vzome.core.editor.api.Manifestations.visibleManifestations$java_lang_Iterable$java_util_function_Predicate(preTest, manifestations);
            } else if (((preTest != null && (preTest.constructor != null && preTest.constructor["__interfaces"] != null && preTest.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preTest === null) && manifestations === undefined) {
                return <any>com.vzome.core.editor.api.Manifestations.visibleManifestations$java_lang_Iterable(preTest);
            } else throw new Error('invalid overload');
        }

        public static visibleManifestations$java_lang_Iterable$java_util_function_Predicate(manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>, postTest: (p1: com.vzome.core.model.Manifestation) => boolean): Manifestations.ManifestationIterator {
            return new Manifestations.ManifestationIterator((man) => { return Manifestations.Filters.isVisible(man) }, manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postTest)));
        }

        public static getConnectors$java_lang_Iterable(manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>): Manifestations.ConnectorIterator {
            return new Manifestations.ConnectorIterator(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(null)), manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(null)));
        }

        public static getConnectors$java_lang_Iterable$java_util_function_Predicate(manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>, postFilter: (p1: com.vzome.core.model.Connector) => boolean): Manifestations.ConnectorIterator {
            return new Manifestations.ConnectorIterator(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(null)), manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postFilter)));
        }

        public static getConnectors$java_util_function_Predicate$java_lang_Iterable$java_util_function_Predicate(preFilter: (p1: com.vzome.core.model.Manifestation) => boolean, manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>, postFilter: (p1: com.vzome.core.model.Connector) => boolean): Manifestations.ConnectorIterator {
            return new Manifestations.ConnectorIterator(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(preFilter)), manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postFilter)));
        }

        public static getConnectors(preFilter?: any, manifestations?: any, postFilter?: any): Manifestations.ConnectorIterator {
            if (((typeof preFilter === 'function' && (<any>preFilter).length === 1) || preFilter === null) && ((manifestations != null && (manifestations.constructor != null && manifestations.constructor["__interfaces"] != null && manifestations.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || manifestations === null) && ((typeof postFilter === 'function' && (<any>postFilter).length === 1) || postFilter === null)) {
                return <any>com.vzome.core.editor.api.Manifestations.getConnectors$java_util_function_Predicate$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations, postFilter);
            } else if (((preFilter != null && (preFilter.constructor != null && preFilter.constructor["__interfaces"] != null && preFilter.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preFilter === null) && ((typeof manifestations === 'function' && (<any>manifestations).length === 1) || manifestations === null) && postFilter === undefined) {
                return <any>com.vzome.core.editor.api.Manifestations.getConnectors$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations);
            } else if (((preFilter != null && (preFilter.constructor != null && preFilter.constructor["__interfaces"] != null && preFilter.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preFilter === null) && manifestations === undefined && postFilter === undefined) {
                return <any>com.vzome.core.editor.api.Manifestations.getConnectors$java_lang_Iterable(preFilter);
            } else throw new Error('invalid overload');
        }

        public static getVisibleConnectors(manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>, postFilter: (p1: com.vzome.core.model.Connector) => boolean = null): Manifestations.ConnectorIterator {
            return new Manifestations.ConnectorIterator((man) => { return Manifestations.Filters.isVisible(man) }, manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postFilter)));
        }

        public static getHiddenConnectors(manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>, postFilter: (p1: com.vzome.core.model.Connector) => boolean = null): Manifestations.ConnectorIterator {
            return new Manifestations.ConnectorIterator((man) => { return Manifestations.Filters.isHidden(man) }, manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postFilter)));
        }

        public static getStruts$java_lang_Iterable(manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>): Manifestations.StrutIterator {
            return new Manifestations.StrutIterator(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(null)), manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(null)));
        }

        public static getStruts$java_lang_Iterable$java_util_function_Predicate(manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>, postFilter: (p1: com.vzome.core.model.Strut) => boolean): Manifestations.StrutIterator {
            return new Manifestations.StrutIterator(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(null)), manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postFilter)));
        }

        public static getStruts$java_util_function_Predicate$java_lang_Iterable$java_util_function_Predicate(preFilter: (p1: com.vzome.core.model.Manifestation) => boolean, manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>, postFilter: (p1: com.vzome.core.model.Strut) => boolean): Manifestations.StrutIterator {
            return new Manifestations.StrutIterator(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(preFilter)), manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postFilter)));
        }

        public static getStruts(preFilter?: any, manifestations?: any, postFilter?: any): Manifestations.StrutIterator {
            if (((typeof preFilter === 'function' && (<any>preFilter).length === 1) || preFilter === null) && ((manifestations != null && (manifestations.constructor != null && manifestations.constructor["__interfaces"] != null && manifestations.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || manifestations === null) && ((typeof postFilter === 'function' && (<any>postFilter).length === 1) || postFilter === null)) {
                return <any>com.vzome.core.editor.api.Manifestations.getStruts$java_util_function_Predicate$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations, postFilter);
            } else if (((preFilter != null && (preFilter.constructor != null && preFilter.constructor["__interfaces"] != null && preFilter.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preFilter === null) && ((typeof manifestations === 'function' && (<any>manifestations).length === 1) || manifestations === null) && postFilter === undefined) {
                return <any>com.vzome.core.editor.api.Manifestations.getStruts$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations);
            } else if (((preFilter != null && (preFilter.constructor != null && preFilter.constructor["__interfaces"] != null && preFilter.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preFilter === null) && manifestations === undefined && postFilter === undefined) {
                return <any>com.vzome.core.editor.api.Manifestations.getStruts$java_lang_Iterable(preFilter);
            } else throw new Error('invalid overload');
        }

        public static getVisibleStruts(manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>, postFilter: (p1: com.vzome.core.model.Strut) => boolean = null): Manifestations.StrutIterator {
            return new Manifestations.StrutIterator((man) => { return Manifestations.Filters.isVisible(man) }, manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postFilter)));
        }

        public static getHiddenStruts(manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>, postFilter: (p1: com.vzome.core.model.Strut) => boolean = null): Manifestations.StrutIterator {
            return new Manifestations.StrutIterator((man) => { return Manifestations.Filters.isHidden(man) }, manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postFilter)));
        }

        public static getPanels$java_lang_Iterable(manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>): Manifestations.PanelIterator {
            return new Manifestations.PanelIterator(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(null)), manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(null)));
        }

        public static getPanels$java_lang_Iterable$java_util_function_Predicate(manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>, postFilter: (p1: com.vzome.core.model.Panel) => boolean): Manifestations.PanelIterator {
            return new Manifestations.PanelIterator(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(null)), manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postFilter)));
        }

        public static getPanels$java_util_function_Predicate$java_lang_Iterable$java_util_function_Predicate(preFilter: (p1: com.vzome.core.model.Manifestation) => boolean, manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>, postFilter: (p1: com.vzome.core.model.Panel) => boolean): Manifestations.PanelIterator {
            return new Manifestations.PanelIterator(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(preFilter)), manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postFilter)));
        }

        public static getPanels(preFilter?: any, manifestations?: any, postFilter?: any): Manifestations.PanelIterator {
            if (((typeof preFilter === 'function' && (<any>preFilter).length === 1) || preFilter === null) && ((manifestations != null && (manifestations.constructor != null && manifestations.constructor["__interfaces"] != null && manifestations.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || manifestations === null) && ((typeof postFilter === 'function' && (<any>postFilter).length === 1) || postFilter === null)) {
                return <any>com.vzome.core.editor.api.Manifestations.getPanels$java_util_function_Predicate$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations, postFilter);
            } else if (((preFilter != null && (preFilter.constructor != null && preFilter.constructor["__interfaces"] != null && preFilter.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preFilter === null) && ((typeof manifestations === 'function' && (<any>manifestations).length === 1) || manifestations === null) && postFilter === undefined) {
                return <any>com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations);
            } else if (((preFilter != null && (preFilter.constructor != null && preFilter.constructor["__interfaces"] != null && preFilter.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preFilter === null) && manifestations === undefined && postFilter === undefined) {
                return <any>com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable(preFilter);
            } else throw new Error('invalid overload');
        }

        public static getVisiblePanels(manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>, postFilter: (p1: com.vzome.core.model.Panel) => boolean = null): Manifestations.PanelIterator {
            return new Manifestations.PanelIterator((man) => { return Manifestations.Filters.isVisible(man) }, manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postFilter)));
        }

        public static getHiddenPanels(manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>, postFilter: (p1: com.vzome.core.model.Panel) => boolean = null): Manifestations.PanelIterator {
            return new Manifestations.PanelIterator((man) => { return Manifestations.Filters.isHidden(man) }, manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postFilter)));
        }

        /**
         * 
         * @param {*} manifestations
         * @param {*} output
         * @return {com.vzome.core.algebra.AlgebraicVector} last selected Connector location, or last selected Strut location, or last vertex of last selected Panel
         */
        public static sortVertices(manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>, output: java.util.SortedSet<com.vzome.core.algebra.AlgebraicVector>): com.vzome.core.algebra.AlgebraicVector {
            let lastBall: com.vzome.core.algebra.AlgebraicVector = null;
            let lastVertex: com.vzome.core.algebra.AlgebraicVector = null;
            for(let index=manifestations.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        lastBall = man.getLocation();
                        output.add(lastBall);
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        lastVertex = man.getLocation();
                        output.add(lastVertex);
                        output.add((<com.vzome.core.model.Strut><any>man).getEnd());
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                        for(let index=(<com.vzome.core.model.Panel><any>man).iterator();index.hasNext();) {
                            let vertex = index.next();
                            {
                                lastVertex = vertex;
                                output.add(vertex);
                            }
                        }
                    }
                }
            }
            return (lastBall != null) ? lastBall : lastVertex;
        }
    }
    Manifestations["__class"] = "com.vzome.core.editor.api.Manifestations";


    export namespace Manifestations {

        export class ManifestationIterator extends com.vzome.core.generic.FilteredIterator<com.vzome.core.model.Manifestation, com.vzome.core.model.Manifestation> {
            public constructor(preTest: (p1: com.vzome.core.model.Manifestation) => boolean, manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>, postTest: (p1: com.vzome.core.model.Manifestation) => boolean) {
                super(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(preTest)), manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postTest)));
            }

            public apply$com_vzome_core_model_Manifestation(element: com.vzome.core.model.Manifestation): com.vzome.core.model.Manifestation {
                return element;
            }

            /**
             * 
             * @param {*} element
             * @return {*}
             */
            public apply(element?: any): any {
                if (((element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                    return <any>this.apply$com_vzome_core_model_Manifestation(element);
                } else if (((element != null) || element === null)) {
                     throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); 
                } else throw new Error('invalid overload');
            }
        }
        ManifestationIterator["__class"] = "com.vzome.core.editor.api.Manifestations.ManifestationIterator";
        ManifestationIterator["__interfaces"] = ["java.util.Iterator","java.lang.Iterable"];



        export class ConnectorIterator extends com.vzome.core.generic.FilteredIterator<com.vzome.core.model.Manifestation, com.vzome.core.model.Connector> {
            public preFilter$com_vzome_core_model_Manifestation(element: com.vzome.core.model.Manifestation): boolean {
                return (element != null && (element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))) ? super.preFilter(element) : false;
            }

            /**
             * 
             * @param {*} element
             * @return {boolean}
             */
            public preFilter(element?: any): boolean {
                if (((element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                    return <any>this.preFilter$com_vzome_core_model_Manifestation(element);
                } else if (((element != null) || element === null)) {
                    return super.preFilter(element);
                } else throw new Error('invalid overload');
            }

            public apply$com_vzome_core_model_Manifestation(element: com.vzome.core.model.Manifestation): com.vzome.core.model.Connector {
                return <com.vzome.core.model.Connector><any>element;
            }

            /**
             * 
             * @param {*} element
             * @return {*}
             */
            public apply(element?: any): any {
                if (((element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                    return <any>this.apply$com_vzome_core_model_Manifestation(element);
                } else if (((element != null) || element === null)) {
                     throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); 
                } else throw new Error('invalid overload');
            }

            constructor(preFilter: (p1: com.vzome.core.model.Manifestation) => boolean, manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>, postFilter: (p1: com.vzome.core.model.Connector) => boolean) {
                super(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(preFilter)), manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postFilter)));
            }
        }
        ConnectorIterator["__class"] = "com.vzome.core.editor.api.Manifestations.ConnectorIterator";
        ConnectorIterator["__interfaces"] = ["java.util.Iterator","java.lang.Iterable"];



        export class StrutIterator extends com.vzome.core.generic.FilteredIterator<com.vzome.core.model.Manifestation, com.vzome.core.model.Strut> {
            public preFilter$com_vzome_core_model_Manifestation(element: com.vzome.core.model.Manifestation): boolean {
                return (element != null && (element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))) ? super.preFilter(element) : false;
            }

            /**
             * 
             * @param {*} element
             * @return {boolean}
             */
            public preFilter(element?: any): boolean {
                if (((element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                    return <any>this.preFilter$com_vzome_core_model_Manifestation(element);
                } else if (((element != null) || element === null)) {
                    return super.preFilter(element);
                } else throw new Error('invalid overload');
            }

            public apply$com_vzome_core_model_Manifestation(element: com.vzome.core.model.Manifestation): com.vzome.core.model.Strut {
                return <com.vzome.core.model.Strut><any>element;
            }

            /**
             * 
             * @param {*} element
             * @return {*}
             */
            public apply(element?: any): any {
                if (((element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                    return <any>this.apply$com_vzome_core_model_Manifestation(element);
                } else if (((element != null) || element === null)) {
                     throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); 
                } else throw new Error('invalid overload');
            }

            constructor(preFilter: (p1: com.vzome.core.model.Manifestation) => boolean, manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>, postFilter: (p1: com.vzome.core.model.Strut) => boolean) {
                super(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(preFilter)), manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postFilter)));
            }
        }
        StrutIterator["__class"] = "com.vzome.core.editor.api.Manifestations.StrutIterator";
        StrutIterator["__interfaces"] = ["java.util.Iterator","java.lang.Iterable"];



        export class PanelIterator extends com.vzome.core.generic.FilteredIterator<com.vzome.core.model.Manifestation, com.vzome.core.model.Panel> {
            public preFilter$com_vzome_core_model_Manifestation(element: com.vzome.core.model.Manifestation): boolean {
                return (element != null && (element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0))) ? super.preFilter(element) : false;
            }

            /**
             * 
             * @param {*} element
             * @return {boolean}
             */
            public preFilter(element?: any): boolean {
                if (((element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                    return <any>this.preFilter$com_vzome_core_model_Manifestation(element);
                } else if (((element != null) || element === null)) {
                    return super.preFilter(element);
                } else throw new Error('invalid overload');
            }

            public apply$com_vzome_core_model_Manifestation(element: com.vzome.core.model.Manifestation): com.vzome.core.model.Panel {
                return <com.vzome.core.model.Panel><any>element;
            }

            /**
             * 
             * @param {*} element
             * @return {*}
             */
            public apply(element?: any): any {
                if (((element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                    return <any>this.apply$com_vzome_core_model_Manifestation(element);
                } else if (((element != null) || element === null)) {
                     throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); 
                } else throw new Error('invalid overload');
            }

            constructor(preFilter: (p1: com.vzome.core.model.Manifestation) => boolean, manifestations: java.lang.Iterable<com.vzome.core.model.Manifestation>, postFilter: (p1: com.vzome.core.model.Panel) => boolean) {
                super(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(preFilter)), manifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postFilter)));
            }
        }
        PanelIterator["__class"] = "com.vzome.core.editor.api.Manifestations.PanelIterator";
        PanelIterator["__interfaces"] = ["java.util.Iterator","java.lang.Iterable"];



        export class Filters {
            constructor() {
            }

            public static isRendered(man: com.vzome.core.model.Manifestation): boolean {
                return man.isRendered();
            }

            public static isVisible(man: com.vzome.core.model.Manifestation): boolean {
                return !man.isHidden();
            }

            public static isHidden(man: com.vzome.core.model.Manifestation): boolean {
                return man.isHidden();
            }

            public static is(man: com.vzome.core.model.Manifestation): boolean {
                return true;
            }
        }
        Filters["__class"] = "com.vzome.core.editor.api.Manifestations.Filters";

    }

}
namespace com.vzome.core.commands {
    export class XmlSymmetryFormat extends com.vzome.core.commands.XmlSaveFormat {
        static __static_initialized: boolean = false;
        static __static_initialize() { if (!XmlSymmetryFormat.__static_initialized) { XmlSymmetryFormat.__static_initialized = true; XmlSymmetryFormat.__static_initializer_0(); } }

        /*private*/ symmetries: com.vzome.core.math.symmetry.OrbitSet.Field;

        static __com_vzome_core_commands_XmlSymmetryFormat_logger: java.util.logging.Logger; public static __com_vzome_core_commands_XmlSymmetryFormat_logger_$LI$(): java.util.logging.Logger { XmlSymmetryFormat.__static_initialize(); if (XmlSymmetryFormat.__com_vzome_core_commands_XmlSymmetryFormat_logger == null) { XmlSymmetryFormat.__com_vzome_core_commands_XmlSymmetryFormat_logger = java.util.logging.Logger.getLogger("com.vzome.core.commands.XmlSaveFormat"); }  return XmlSymmetryFormat.__com_vzome_core_commands_XmlSymmetryFormat_logger; }

        static  __static_initializer_0() {
            new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/2.0/", [com.vzome.core.commands.XmlSaveFormat.PROJECT_4D, com.vzome.core.commands.XmlSaveFormat.SELECTION_NOT_SAVED]);
            new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/2.0.1/", [com.vzome.core.commands.XmlSaveFormat.PROJECT_4D, com.vzome.core.commands.XmlSaveFormat.SELECTION_NOT_SAVED]);
            new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/2.0.2/", [com.vzome.core.commands.XmlSaveFormat.SELECTION_NOT_SAVED]);
            new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/2.0.3/", [com.vzome.core.commands.XmlSaveFormat.SELECTION_NOT_SAVED]);
            new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/2.1.0/", [com.vzome.core.commands.XmlSaveFormat.SELECTION_NOT_SAVED, com.vzome.core.commands.XmlSaveFormat.FORMAT_2_1_0]);
            new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/3.0.0/", [com.vzome.core.commands.XmlSaveFormat.GROUPING_IN_SELECTION]);
            new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/4.0.0/", [com.vzome.core.commands.XmlSaveFormat.RATIONAL_VECTORS, com.vzome.core.commands.XmlSaveFormat.GROUPING_IN_SELECTION]);
            new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/5.0.0/", [com.vzome.core.commands.XmlSaveFormat.RATIONAL_VECTORS, com.vzome.core.commands.XmlSaveFormat.COMPACTED_COMMAND_EDITS]);
            new XmlSymmetryFormat(com.vzome.core.commands.XmlSaveFormat.CURRENT_FORMAT, [com.vzome.core.commands.XmlSaveFormat.RATIONAL_VECTORS, com.vzome.core.commands.XmlSaveFormat.COMPACTED_COMMAND_EDITS, com.vzome.core.commands.XmlSaveFormat.MULTIPLE_DESIGNS]);
        }

        public static getFormat(namespace: string): XmlSymmetryFormat {
            return <XmlSymmetryFormat>com.vzome.core.commands.XmlSaveFormat.FORMATS_$LI$().get(namespace);
        }

        public initialize$com_vzome_core_algebra_AlgebraicField$com_vzome_core_math_symmetry_OrbitSet_Field$int$java_lang_String$java_util_Properties(field: com.vzome.core.algebra.AlgebraicField, symms: com.vzome.core.math.symmetry.OrbitSet.Field, scale: number, writerVersion: string, props: java.util.Properties) {
            super.initialize(field, scale, writerVersion, props);
            this.symmetries = symms;
        }

        public initialize(field?: any, symms?: any, scale?: any, writerVersion?: any, props?: any) {
            if (((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((symms != null && (symms.constructor != null && symms.constructor["__interfaces"] != null && symms.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.OrbitSet.Field") >= 0)) || symms === null) && ((typeof scale === 'number') || scale === null) && ((typeof writerVersion === 'string') || writerVersion === null) && ((props != null && props instanceof <any>java.util.Properties) || props === null)) {
                return <any>this.initialize$com_vzome_core_algebra_AlgebraicField$com_vzome_core_math_symmetry_OrbitSet_Field$int$java_lang_String$java_util_Properties(field, symms, scale, writerVersion, props);
            } else if (((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((typeof symms === 'number') || symms === null) && ((typeof scale === 'string') || scale === null) && ((writerVersion != null && writerVersion instanceof <any>java.util.Properties) || writerVersion === null) && props === undefined) {
                super.initialize(field, symms, scale, writerVersion);
            } else throw new Error('invalid overload');
        }

        public constructor(version: string, capabilities: string[]) {
            super(version, capabilities);
            if (this.symmetries === undefined) { this.symmetries = null; }
        }

        public parseAlgebraicObject(valName: string, val: org.w3c.dom.Element): any {
            if (valName === ("Symmetry")){
                const name: string = val.getAttribute("name");
                return this.parseSymmetry(name);
            } else if (valName === ("QuaternionicSymmetry")){
                const name: string = val.getAttribute("name");
                return this.getQuaternionicSymmetry(name);
            } else if (valName === ("Axis"))return this.parseAxis(val, "symm", "dir", "index", "sense"); else {
                return super.parseAlgebraicObject(valName, val);
            }
        }

        getQuaternionicSymmetry(name: string): com.vzome.core.math.symmetry.QuaternionicSymmetry {
            return this.symmetries.getQuaternionSet(name);
        }

        public parseSymmetry(sname: string): com.vzome.core.math.symmetry.Symmetry {
            const group: com.vzome.core.math.symmetry.OrbitSet = this.symmetries.getGroup(sname);
            const symm: com.vzome.core.math.symmetry.Symmetry = group.getSymmetry();
            if (symm == null){
                XmlSymmetryFormat.__com_vzome_core_commands_XmlSymmetryFormat_logger_$LI$().severe("UNSUPPORTED symmetry: " + sname);
                throw new java.lang.IllegalStateException("no symmetry with name=" + sname);
            } else return symm;
        }

        public static serializeAxis(xml: org.w3c.dom.Element, symmAttr: string, dirAttr: string, indexAttr: string, senseAttr: string, axis: com.vzome.core.math.symmetry.Axis) {
            let str: string = axis.getDirection().getSymmetry().getName();
            if (!("icosahedral" === str))com.vzome.xml.DomUtils.addAttribute(xml, symmAttr, str);
            str = axis.getDirection().getName();
            if (!("blue" === str))com.vzome.xml.DomUtils.addAttribute(xml, dirAttr, str);
            com.vzome.xml.DomUtils.addAttribute(xml, indexAttr, /* toString */(''+(axis.getOrientation())));
            if (axis.getSense() !== com.vzome.core.math.symmetry.Symmetry.PLUS)com.vzome.xml.DomUtils.addAttribute(xml, "sense", "minus");
            if (!axis.isOutbound())com.vzome.xml.DomUtils.addAttribute(xml, "outbound", "false");
        }

        public parseAxis(xml: org.w3c.dom.Element, symmAttr: string, dirAttr: string, indexAttr: string, senseAttr: string): com.vzome.core.math.symmetry.Axis {
            let sname: string = xml.getAttribute(symmAttr);
            if (sname == null || /* isEmpty */(sname.length === 0))sname = "icosahedral";
            const group: com.vzome.core.math.symmetry.OrbitSet = this.symmetries.getGroup(sname);
            let aname: string = xml.getAttribute(dirAttr);
            if (aname == null || /* isEmpty */(aname.length === 0))aname = "blue"; else if (aname === ("tan"))aname = "sand"; else if (aname === ("spring"))aname = "apple";
            const iname: string = xml.getAttribute(indexAttr);
            const index: number = javaemul.internal.IntegerHelper.parseInt(iname);
            let sense: number = com.vzome.core.math.symmetry.Symmetry.PLUS;
            if ("minus" === xml.getAttribute(senseAttr)){
                sense = com.vzome.core.math.symmetry.Symmetry.MINUS;
            }
            let outbound: boolean = true;
            const outs: string = xml.getAttribute("outbound");
            if (outs != null && (outs === ("false")))outbound = false;
            const dir: com.vzome.core.math.symmetry.Direction = group.getDirection(aname);
            if (dir == null){
                const msg: string = "Unsupported direction \'" + aname + "\' in " + sname + " symmetry";
                XmlSymmetryFormat.__com_vzome_core_commands_XmlSymmetryFormat_logger_$LI$().severe(msg);
                throw new java.lang.IllegalStateException(msg);
            }
            return dir.getAxis$int$int$boolean(sense, index, outbound);
        }
    }
    XmlSymmetryFormat["__class"] = "com.vzome.core.commands.XmlSymmetryFormat";

}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @class
     * @extends com.vzome.core.commands.AbstractCommand
     */
    export class CommandFreePoint extends com.vzome.core.commands.AbstractCommand {
        static PARAMS: any[][]; public static PARAMS_$LI$(): any[][] { if (CommandFreePoint.PARAMS == null) { CommandFreePoint.PARAMS = []; }  return CommandFreePoint.PARAMS; }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getParameterSignature(): any[][] {
            return CommandFreePoint.PARAMS_$LI$();
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return null;
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attributes: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const result: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            const loc: com.vzome.core.algebra.AlgebraicVector = <com.vzome.core.algebra.AlgebraicVector>attributes.get("where");
            const pt2: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(loc);
            effects['constructionAdded$com_vzome_core_construction_Construction'](pt2);
            result.addConstruction(pt2);
            return result;
        }

        constructor() {
            super();
        }
    }
    CommandFreePoint["__class"] = "com.vzome.core.commands.CommandFreePoint";
    CommandFreePoint["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @class
     * @extends com.vzome.core.commands.AbstractCommand
     */
    export class CommandHide extends com.vzome.core.commands.AbstractCommand {
        static PARAM_SIGNATURE: any[][]; public static PARAM_SIGNATURE_$LI$(): any[][] { if (CommandHide.PARAM_SIGNATURE == null) { CommandHide.PARAM_SIGNATURE = [[com.vzome.core.commands.Command.GENERIC_PARAM_NAME, com.vzome.core.construction.Construction]]; }  return CommandHide.PARAM_SIGNATURE; }

        static ATTR_SIGNATURE: any[][]; public static ATTR_SIGNATURE_$LI$(): any[][] { if (CommandHide.ATTR_SIGNATURE == null) { CommandHide.ATTR_SIGNATURE = []; }  return CommandHide.ATTR_SIGNATURE; }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getParameterSignature(): any[][] {
            return CommandHide.PARAM_SIGNATURE_$LI$();
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return CommandHide.ATTR_SIGNATURE_$LI$();
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attributes: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            throw new Command.Failure("CommandHide apply attempted");
        }

        constructor() {
            super();
        }
    }
    CommandHide["__class"] = "com.vzome.core.commands.CommandHide";
    CommandHide["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.commands {
    export class CommandSetColor extends com.vzome.core.commands.AbstractCommand {
        public static MANIFESTATION_ATTR: string = "manifestation.context";

        public static COLOR_ATTR: string = "color";

        static PARAM_SIGNATURE: any[][]; public static PARAM_SIGNATURE_$LI$(): any[][] { if (CommandSetColor.PARAM_SIGNATURE == null) { CommandSetColor.PARAM_SIGNATURE = []; }  return CommandSetColor.PARAM_SIGNATURE; }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getParameterSignature(): any[][] {
            return CommandSetColor.PARAM_SIGNATURE_$LI$();
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return null;
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attributes: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            return parameters;
        }

        constructor() {
            super();
        }
    }
    CommandSetColor["__class"] = "com.vzome.core.commands.CommandSetColor";
    CommandSetColor["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @class
     * @extends com.vzome.core.commands.AbstractCommand
     */
    export class CommandLoad extends com.vzome.core.commands.AbstractCommand {
        public static XML_ATTR: string = "xml";

        static PARAM_SIGNATURE: any[][]; public static PARAM_SIGNATURE_$LI$(): any[][] { if (CommandLoad.PARAM_SIGNATURE == null) { CommandLoad.PARAM_SIGNATURE = []; }  return CommandLoad.PARAM_SIGNATURE; }

        static ATTR_SIGNATURE: any[][]; public static ATTR_SIGNATURE_$LI$(): any[][] { if (CommandLoad.ATTR_SIGNATURE == null) { CommandLoad.ATTR_SIGNATURE = [[CommandLoad.XML_ATTR, "org.w3c.dom.Element"]]; }  return CommandLoad.ATTR_SIGNATURE; }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getParameterSignature(): any[][] {
            return CommandLoad.PARAM_SIGNATURE_$LI$();
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return CommandLoad.ATTR_SIGNATURE_$LI$();
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attributes: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const result: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            return result;
        }

        constructor() {
            super();
        }
    }
    CommandLoad["__class"] = "com.vzome.core.commands.CommandLoad";
    CommandLoad["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.edits {
    export class GroupSelection extends com.vzome.core.editor.api.UndoableEdit {
        mSelection: com.vzome.core.editor.api.Selection;

        /*private*/ mGrouping: boolean;

        /*private*/ recursiveGroups: boolean;

        /*private*/ unnecessary: boolean;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super();
            if (this.mSelection === undefined) { this.mSelection = null; }
            this.mGrouping = false;
            this.recursiveGroups = true;
            this.unnecessary = false;
            this.mSelection = editor.getSelection();
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
            const mode: string = <string>props.get("mode");
            this.mGrouping = (mode == null) || /* isEmpty */(mode.length === 0) || (mode === ("group"));
            this.unnecessary = this.mGrouping === this.mSelection.isSelectionAGroup();
        }

        /**
         * 
         * @return {boolean}
         */
        public isNoOp(): boolean {
            return this.unnecessary;
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const elem: org.w3c.dom.Element = doc.createElement("GroupSelection");
            if (!this.mGrouping)com.vzome.xml.DomUtils.addAttribute(elem, "grouping", "false");
            return elem;
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getDetailXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            return this.getXml(doc);
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         * @param {*} context
         */
        public loadAndPerform(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat, context: com.vzome.core.editor.api.Context) {
            const grouping: string = xml.getAttribute("grouping");
            this.mGrouping = (grouping == null) || /* isEmpty */(grouping.length === 0) || (grouping === ("true"));
            this.recursiveGroups = format.groupingRecursive();
            context.performAndRecord(this);
        }

        /**
         * 
         * @return {boolean}
         */
        public isDestructive(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isVisible(): boolean {
            return true;
        }

        /**
         * 
         */
        public redo() {
            if (this.mGrouping)if (this.recursiveGroups)this.mSelection.gatherGroup(); else this.mSelection.gatherGroup211(); else if (this.recursiveGroups)this.mSelection.scatterGroup(); else this.mSelection.scatterGroup211();
        }

        /**
         * 
         */
        public undo() {
            if (!this.mGrouping)if (this.recursiveGroups)this.mSelection.gatherGroup(); else this.mSelection.gatherGroup211(); else if (this.recursiveGroups)this.mSelection.scatterGroup(); else this.mSelection.scatterGroup211();
        }

        /**
         * 
         */
        public perform() {
            if (this.unnecessary)return;
            this.redo();
        }

        /**
         * 
         * @return {boolean}
         */
        public isSticky(): boolean {
            return false;
        }
    }
    GroupSelection["__class"] = "com.vzome.core.edits.GroupSelection";

}
namespace com.vzome.core.edits {
    /**
     * Used by CommandEdit.
     * @param {*} editor
     * @param m
     * @param {com.vzome.core.construction.Point} newCenter
     * @class
     * @extends com.vzome.core.editor.api.UndoableEdit
     */
    export class SymmetryCenterChange extends com.vzome.core.editor.api.UndoableEdit {
        /*private*/ mOldCenter: com.vzome.core.construction.Point;

        /*private*/ mNewCenter: com.vzome.core.construction.Point;

        /*private*/ editor: com.vzome.core.editor.api.ImplicitSymmetryParameters;

        public constructor(editor?: any, newCenter?: any) {
            if (((editor != null && (editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.ImplicitSymmetryParameters") >= 0)) || editor === null) && ((newCenter != null && newCenter instanceof <any>com.vzome.core.construction.Point) || newCenter === null)) {
                let __args = arguments;
                super();
                if (this.mOldCenter === undefined) { this.mOldCenter = null; } 
                if (this.mNewCenter === undefined) { this.mNewCenter = null; } 
                if (this.editor === undefined) { this.editor = null; } 
                this.mOldCenter = editor.getCenterPoint();
                this.mNewCenter = newCenter;
                this.editor = editor;
            } else if (((editor != null && (editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.ImplicitSymmetryParameters") >= 0)) || editor === null) && newCenter === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let newCenter: any = null;
                    super();
                    if (this.mOldCenter === undefined) { this.mOldCenter = null; } 
                    if (this.mNewCenter === undefined) { this.mNewCenter = null; } 
                    if (this.editor === undefined) { this.editor = null; } 
                    this.mOldCenter = editor.getCenterPoint();
                    this.mNewCenter = newCenter;
                    this.editor = editor;
                }
            } else throw new Error('invalid overload');
        }

        public configure(props: java.util.Map<string, any>) {
            const man: com.vzome.core.model.Manifestation = <com.vzome.core.model.Manifestation><any>props.get("picked");
            if (man != null)this.mNewCenter = <com.vzome.core.construction.Point>man.getFirstConstruction();
        }

        /**
         * 
         * @return {boolean}
         */
        public isNoOp(): boolean {
            return this.mNewCenter == null || this.mNewCenter.getLocation().equals(this.mOldCenter.getLocation());
        }

        /**
         * 
         * @return {boolean}
         */
        public isVisible(): boolean {
            return false;
        }

        /**
         * 
         */
        public redo() {
            if (this.isNoOp())return;
            this.editor.setCenterPoint(this.mNewCenter);
        }

        /**
         * 
         */
        public undo() {
            if (this.isNoOp())return;
            this.editor.setCenterPoint(this.mOldCenter);
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const result: org.w3c.dom.Element = doc.createElement("SymmetryCenterChange");
            com.vzome.core.commands.XmlSaveFormat.serializePoint(result, "new", this.mNewCenter);
            return result;
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getDetailXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            return this.getXml(doc);
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         * @param {*} context
         */
        public loadAndPerform(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat, context: com.vzome.core.editor.api.Context) {
            if (format.rationalVectors()){
                this.mNewCenter = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "new");
            } else {
                const attrs: com.vzome.core.commands.AttributeMap = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                const center: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>attrs.get("new");
                this.mNewCenter = new com.vzome.core.construction.FreePoint(center.getLocation().projectTo3d(true));
            }
            context.performAndRecord(this);
        }

        /**
         * 
         */
        public perform() {
            if (this.mNewCenter == null){
                this.mNewCenter = <com.vzome.core.construction.Point>this.editor.getSelectedConstruction(com.vzome.core.construction.Point);
                if (this.mNewCenter == null)throw new com.vzome.core.commands.Command.Failure("Selection is not a single ball.");
            }
            this.redo();
        }

        /**
         * 
         * @return {boolean}
         */
        public isDestructive(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isSticky(): boolean {
            return false;
        }
    }
    SymmetryCenterChange["__class"] = "com.vzome.core.edits.SymmetryCenterChange";

}
namespace com.vzome.core.edits {
    /**
     * Used by CommandEdit.
     * @param {*} editor
     * @param m
     * @param {com.vzome.core.construction.Segment} newAxis
     * @class
     * @extends com.vzome.core.editor.api.UndoableEdit
     */
    export class SymmetryAxisChange extends com.vzome.core.editor.api.UndoableEdit {
        /*private*/ mOldAxis: com.vzome.core.construction.Segment;

        /*private*/ mNewAxis: com.vzome.core.construction.Segment;

        /*private*/ mEditor: com.vzome.core.editor.api.ImplicitSymmetryParameters;

        public constructor(editor?: any, newAxis?: any) {
            if (((editor != null && (editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.ImplicitSymmetryParameters") >= 0)) || editor === null) && ((newAxis != null && newAxis instanceof <any>com.vzome.core.construction.Segment) || newAxis === null)) {
                let __args = arguments;
                super();
                if (this.mOldAxis === undefined) { this.mOldAxis = null; } 
                if (this.mNewAxis === undefined) { this.mNewAxis = null; } 
                if (this.mEditor === undefined) { this.mEditor = null; } 
                this.mOldAxis = editor.getSymmetrySegment();
                this.mNewAxis = newAxis;
                this.mEditor = editor;
            } else if (((editor != null && (editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.ImplicitSymmetryParameters") >= 0)) || editor === null) && newAxis === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let newAxis: any = null;
                    super();
                    if (this.mOldAxis === undefined) { this.mOldAxis = null; } 
                    if (this.mNewAxis === undefined) { this.mNewAxis = null; } 
                    if (this.mEditor === undefined) { this.mEditor = null; } 
                    this.mOldAxis = editor.getSymmetrySegment();
                    this.mNewAxis = newAxis;
                    this.mEditor = editor;
                }
            } else throw new Error('invalid overload');
        }

        public configure(props: java.util.Map<string, any>) {
            const man: com.vzome.core.model.Manifestation = <com.vzome.core.model.Manifestation><any>props.get("picked");
            if (man != null)this.mNewAxis = <com.vzome.core.construction.Segment>man.getFirstConstruction();
        }

        /**
         * 
         * @return {boolean}
         */
        public isVisible(): boolean {
            return false;
        }

        /**
         * 
         * @return {boolean}
         */
        public isNoOp(): boolean {
            return this.mNewAxis == null || (this.mOldAxis != null && this.mNewAxis.getStart().equals(this.mOldAxis.getStart()) && this.mNewAxis.getEnd().equals(this.mOldAxis.getEnd()));
        }

        /**
         * 
         */
        public redo() {
            if (this.isNoOp())return;
            this.mEditor.setSymmetrySegment(this.mNewAxis);
        }

        /**
         * 
         */
        public undo() {
            if (this.isNoOp())return;
            this.mEditor.setSymmetrySegment(this.mOldAxis);
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const result: org.w3c.dom.Element = doc.createElement("SymmetryAxisChange");
            com.vzome.core.commands.XmlSaveFormat.serializeSegment(result, "start", "end", this.mNewAxis);
            return result;
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getDetailXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            return this.getXml(doc);
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         * @param {*} context
         */
        public loadAndPerform(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat, context: com.vzome.core.editor.api.Context) {
            if (format.rationalVectors()){
                this.mNewAxis = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "start", "end");
            } else {
                const attrs: com.vzome.core.commands.AttributeMap = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                this.mNewAxis = <com.vzome.core.construction.Segment>attrs.get("new");
            }
            context.performAndRecord(this);
        }

        /**
         * 
         */
        public perform() {
            if (this.mNewAxis == null){
                this.mNewAxis = <com.vzome.core.construction.Segment>this.mEditor.getSelectedConstruction(com.vzome.core.construction.Segment);
                if (this.mNewAxis == null)throw new com.vzome.core.commands.Command.Failure("Selection is not a single strut.");
            }
            this.redo();
        }

        /**
         * 
         * @return {boolean}
         */
        public isDestructive(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isSticky(): boolean {
            return false;
        }
    }
    SymmetryAxisChange["__class"] = "com.vzome.core.edits.SymmetryAxisChange";

}
namespace com.vzome.core.editor {
    /**
     * Just a marker in the history.
     * @author Scott Vorthmann
     * @param {*} editor
     * @class
     * @extends com.vzome.core.editor.api.UndoableEdit
     */
    export class EndBlock extends com.vzome.core.editor.api.UndoableEdit {
        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super();
        }

        /**
         * 
         * @return {boolean}
         */
        public isNoOp(): boolean {
            return false;
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            return doc.createElement("EndBlock");
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getDetailXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            return this.getXml(doc);
        }

        /**
         * 
         * @return {boolean}
         */
        public isVisible(): boolean {
            return false;
        }

        /**
         * 
         * @return {boolean}
         */
        public isDestructive(): boolean {
            return false;
        }

        /**
         * 
         */
        public redo() {
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         * @param {*} context
         */
        public loadAndPerform(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat, context: com.vzome.core.editor.api.Context) {
            context.performAndRecord(this);
        }

        /**
         * 
         */
        public undo() {
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
        }

        /**
         * 
         */
        public perform() {
        }

        /**
         * 
         * @return {boolean}
         */
        public isSticky(): boolean {
            return false;
        }
    }
    EndBlock["__class"] = "com.vzome.core.editor.EndBlock";

}
namespace com.vzome.core.editor {
    export class EditHistory implements java.lang.Iterable<com.vzome.core.editor.api.UndoableEdit> {
        /*private*/ mEdits: java.util.List<com.vzome.core.editor.api.UndoableEdit>;

        /*private*/ mEditNumber: number;

        /*private*/ breakpointHit: boolean;

        static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (EditHistory.logger == null) { EditHistory.logger = java.util.logging.Logger.getLogger("com.vzome.core.EditHistory"); }  return EditHistory.logger; }

        static breakpointLogger: java.util.logging.Logger; public static breakpointLogger_$LI$(): java.util.logging.Logger { if (EditHistory.breakpointLogger == null) { EditHistory.breakpointLogger = java.util.logging.Logger.getLogger("com.vzome.core.editor.Breakpoint"); }  return EditHistory.breakpointLogger; }

        public listener: EditHistory.Listener;

        public setListener(listener: EditHistory.Listener) {
            this.listener = listener;
        }

        /*private*/ serializer: EditHistory.XmlSerializer;

        public setSerializer(serializer: EditHistory.XmlSerializer) {
            this.serializer = serializer;
        }

        public addEdit(edit: com.vzome.core.editor.api.UndoableEdit, context: com.vzome.core.editor.api.Context) {
            if (!edit.isDestructive()){
                this.mEdits.add(this.mEditNumber, edit);
                ++this.mEditNumber;
                return;
            }
            if (this.mEditNumber < this.mEdits.size()){
                let makeBranch: boolean = false;
                let lastStickyEdit: number = this.mEditNumber - 1;
                let deadEditIndex: number = this.mEditNumber;
                for(const deadEdits: java.util.Iterator<com.vzome.core.editor.api.UndoableEdit> = this.mEdits.listIterator(this.mEditNumber); deadEdits.hasNext(); ) {{
                    const dead: com.vzome.core.editor.api.UndoableEdit = deadEdits.next();
                    if (dead.isSticky()){
                        makeBranch = true;
                        lastStickyEdit = deadEditIndex;
                    }
                    ++deadEditIndex;
                };}
                const branch: com.vzome.core.editor.Branch = makeBranch ? new com.vzome.core.editor.Branch(context) : null;
                deadEditIndex = this.mEditNumber;
                for(const deadEdits: java.util.Iterator<com.vzome.core.editor.api.UndoableEdit> = this.mEdits.listIterator(this.mEditNumber); deadEdits.hasNext(); ) {{
                    const removed: com.vzome.core.editor.api.UndoableEdit = deadEdits.next();
                    deadEdits.remove();
                    if (deadEditIndex <= lastStickyEdit){
                        branch.addEdit(removed);
                    }
                    ++deadEditIndex;
                };}
                if (makeBranch){
                    this.mEdits.add(branch);
                    ++this.mEditNumber;
                }
            }
            this.mEdits.add(edit);
            ++this.mEditNumber;
        }

        public undoAll(): com.vzome.core.editor.api.UndoableEdit {
            let last: com.vzome.core.editor.api.UndoableEdit = null;
            do {{
                const edit: com.vzome.core.editor.api.UndoableEdit = this.undo$();
                if (edit == null)break;
                last = edit;
            }} while((true));
            this.listener.publishChanges();
            return last;
        }

        public undoToManifestation(man: com.vzome.core.model.Manifestation): com.vzome.core.editor.api.UndoableEdit {
            let edit: com.vzome.core.editor.api.UndoableEdit = null;
            do {{
                edit = this.undo$();
                if (edit == null)break;
                if ((edit != null && edit instanceof <any>com.vzome.core.editor.api.ChangeManifestations) && (<com.vzome.core.editor.api.ChangeManifestations>edit).showsManifestation(man)){
                    break;
                }
            }} while((true));
            this.listener.publishChanges();
            return edit;
        }

        public redoToBreakpoint(): com.vzome.core.editor.api.UndoableEdit {
            let edit: com.vzome.core.editor.api.UndoableEdit = this.redo$();
            if (edit == null)return edit;
            do {{
                if (this.atBreakpoint())break;
                edit = this.redo$();
                if (edit == null)break;
            }} while((true));
            this.listener.publishChanges();
            return edit;
        }

        atBreakpoint(): boolean {
            if (this.mEditNumber === this.mEdits.size())return false;
            const edit: com.vzome.core.editor.api.UndoableEdit = this.mEdits.get(this.mEditNumber);
            return edit.hasBreakpoint();
        }

        public setBreakpoints(lineNumbers: number[]) {
            java.util.Arrays.sort(lineNumbers);
            let index: number = 0;
            let lineNumber: number = lineNumbers[index];
            for(let index1=this.mEdits.iterator();index1.hasNext();) {
                let edit = index1.next();
                {
                    const startLine: number = edit.getLineNumber();
                    if (startLine !== 0 && startLine >= lineNumber){
                        edit.setBreakpoint(true);
                        ++index;
                        if (index < lineNumbers.length)lineNumber = lineNumbers[index]; else lineNumber = javaemul.internal.IntegerHelper.MAX_VALUE;
                    } else {
                        edit.setBreakpoint(false);
                    }
                }
            }
        }

        public getBreakpoints(): java.util.List<number> {
            const result: java.util.List<number> = <any>(new java.util.ArrayList<any>());
            for(let index=this.mEdits.iterator();index.hasNext();) {
                let edit = index.next();
                {
                    if (edit.hasBreakpoint())result.add(edit.getLineNumber());
                }
            }
            return result;
        }

        public redoAll(breakpoint: number): com.vzome.core.editor.api.UndoableEdit {
            let last: com.vzome.core.editor.api.UndoableEdit = null;
            this.breakpointHit = false;
            do {{
                const edit: com.vzome.core.editor.api.UndoableEdit = this.redo$();
                if (edit == null)break;
                last = edit;
                if (this.breakpointHit){
                    this.breakpointHit = false;
                    break;
                }
            }} while((breakpoint === -1 || this.mEditNumber < breakpoint));
            this.listener.publishChanges();
            return last;
        }

        public goToEdit(editNum: number) {
            if (editNum === -1)editNum = this.mEdits.size();
            if (editNum === this.mEditNumber)return;
            while((this.mEditNumber < editNum)) {{
                if (this.mEditNumber === this.mEdits.size())break;
                const undoable: com.vzome.core.editor.api.UndoableEdit = this.mEdits.get(this.mEditNumber++);
                undoable.redo();
            }};
            while((this.mEditNumber > editNum)) {{
                if (this.mEditNumber === 0)break;
                const undoable: com.vzome.core.editor.api.UndoableEdit = this.mEdits.get(--this.mEditNumber);
                undoable.undo();
            }};
            this.listener.publishChanges();
        }

        public undo$(): com.vzome.core.editor.api.UndoableEdit {
            return this.undo$boolean(true);
        }

        public undo$boolean(useBlocks: boolean): com.vzome.core.editor.api.UndoableEdit {
            if (this.mEditNumber === 0)return null;
            const undoable: com.vzome.core.editor.api.UndoableEdit = this.mEdits.get(--this.mEditNumber);
            if (useBlocks && (undoable != null && undoable instanceof <any>com.vzome.core.editor.EndBlock))return this.undoBlock();
            undoable.undo();
            EditHistory.logger_$LI$().fine("undo: " + undoable.toString());
            if (undoable != null && undoable instanceof <any>com.vzome.core.editor.BeginBlock)return undoable;
            if (!undoable.isVisible())return this.undo$();
            this.listener.publishChanges();
            return undoable;
        }

        public undo(useBlocks?: any): com.vzome.core.editor.api.UndoableEdit {
            if (((typeof useBlocks === 'boolean') || useBlocks === null)) {
                return <any>this.undo$boolean(useBlocks);
            } else if (useBlocks === undefined) {
                return <any>this.undo$();
            } else throw new Error('invalid overload');
        }

        undoBlock(): com.vzome.core.editor.api.UndoableEdit {
            let undone: com.vzome.core.editor.api.UndoableEdit;
            do {{
                undone = this.undo$();
            }} while((!(undone != null && undone instanceof <any>com.vzome.core.editor.BeginBlock)));
            return undone;
        }

        public getNextLineNumber(): number {
            if (this.mEdits.isEmpty())return 3;
            let editNumber: number = this.mEditNumber;
            if (editNumber >= this.mEdits.size())editNumber = this.mEdits.size() - 1;
            const undoable: com.vzome.core.editor.api.UndoableEdit = this.mEdits.get(editNumber);
            if (undoable != null && undoable instanceof <any>com.vzome.core.editor.EditHistory.DeferredEdit)return (<EditHistory.DeferredEdit>undoable).getLineNumber(); else return 0;
        }

        public redo$(): com.vzome.core.editor.api.UndoableEdit {
            return this.redo$boolean(true);
        }

        public redo$boolean(useBlocks: boolean): com.vzome.core.editor.api.UndoableEdit {
            if (this.mEditNumber === this.mEdits.size())return null;
            const undoable: com.vzome.core.editor.api.UndoableEdit = this.mEdits.get(this.mEditNumber++);
            if (useBlocks && (undoable != null && undoable instanceof <any>com.vzome.core.editor.BeginBlock))return this.redoBlock();
            try {
                if (EditHistory.logger_$LI$().isLoggable(java.util.logging.Level.FINE))EditHistory.logger_$LI$().fine("redo: " + undoable.toString());
                undoable.redo();
            } catch(e) {
                if (EditHistory.logger_$LI$().isLoggable(java.util.logging.Level.WARNING))EditHistory.logger_$LI$().warning("edit number that failed is " + (this.mEditNumber - 1));
                throw e;
            }
            if (undoable != null && undoable instanceof <any>com.vzome.core.editor.EndBlock)return undoable;
            if (!undoable.isVisible())return this.redo$();
            this.listener.publishChanges();
            return undoable;
        }

        public redo(useBlocks?: any): com.vzome.core.editor.api.UndoableEdit {
            if (((typeof useBlocks === 'boolean') || useBlocks === null)) {
                return <any>this.redo$boolean(useBlocks);
            } else if (useBlocks === undefined) {
                return <any>this.redo$();
            } else throw new Error('invalid overload');
        }

        redoBlock(): com.vzome.core.editor.api.UndoableEdit {
            let lastSuccessfulRedo: string = "none";
            const startingEditNumber: number = this.mEditNumber;
            let redone: com.vzome.core.editor.api.UndoableEdit;
            do {{
                redone = this.redo$();
                if (redone == null){
                    throw new java.lang.IllegalStateException("All " + this.mEditNumber + " edits have been redone without reaching an EndBlock. Starting edit number was " + startingEditNumber + ". Last successful redo was " + lastSuccessfulRedo + ". ");
                }
                lastSuccessfulRedo = /* getSimpleName */(c => typeof c === 'string' ? (<any>c).substring((<any>c).lastIndexOf('.')+1) : c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.')+1) : c["name"].substring(c["name"].lastIndexOf('.')+1))((<any>redone.constructor));
                if (EditHistory.logger_$LI$().isLoggable(java.util.logging.Level.FINE)){
                    const msg: string = "redoBlock is redoing edits from " + startingEditNumber + ". Current edit number is " + this.mEditNumber + ". Last redone was " + lastSuccessfulRedo;
                    EditHistory.logger_$LI$().fine(msg);
                }
            }} while((!(redone != null && redone instanceof <any>com.vzome.core.editor.EndBlock)));
            return redone;
        }

        public getDetailXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const result: org.w3c.dom.Element = doc.createElement("EditHistoryDetails");
            com.vzome.xml.DomUtils.addAttribute(result, "editNumber", /* toString */(''+(this.mEditNumber)));
            let edits: number = 0;
            let lastStickyEdit: number = -1;
            for(let index=this.iterator();index.hasNext();) {
                let undoable = index.next();
                {
                    const edit: org.w3c.dom.Element = undoable.getDetailXml(doc);
                    ++edits;
                    com.vzome.xml.DomUtils.addAttribute(edit, "editNumber", /* toString */(''+(edits)));
                    if (EditHistory.logger_$LI$().isLoggable(java.util.logging.Level.FINEST))EditHistory.logger_$LI$().finest("side-effect: " + this.serializer.serialize(edit));
                    result.appendChild(edit);
                    if (undoable.isSticky())lastStickyEdit = edits;
                }
            }
            result.setAttribute("lastStickyEdit", /* toString */(''+(lastStickyEdit)));
            return result;
        }

        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const result: org.w3c.dom.Element = doc.createElement("EditHistory");
            com.vzome.xml.DomUtils.addAttribute(result, "editNumber", /* toString */(''+(this.mEditNumber)));
            return result;
        }

        public mergeSelectionChanges() {
            let cursor: number = this.mEditNumber;
            if (cursor === 0)return;
            --cursor;
            const above: com.vzome.core.editor.api.UndoableEdit = this.mEdits.get(cursor);
            if (above != null && above instanceof <any>com.vzome.core.editor.api.ChangeManifestations)return;
            if (!(above != null && above instanceof <any>com.vzome.core.editor.api.ChangeSelection))return;
            if (cursor === 0)return;
            --cursor;
            const below: com.vzome.core.editor.api.UndoableEdit = this.mEdits.get(cursor);
            if (below != null && below instanceof <any>com.vzome.core.editor.api.ChangeManifestations)return;
            if (below != null && below instanceof <any>com.vzome.core.editor.api.ChangeSelection){
                let bracket: com.vzome.core.editor.api.UndoableEdit = new com.vzome.core.editor.BeginBlock(null);
                this.mEdits.add(cursor, bracket);
                bracket = new com.vzome.core.editor.EndBlock(null);
                this.mEdits.add(bracket);
                this.mEditNumber += 2;
            } else if (below != null && below instanceof <any>com.vzome.core.editor.EndBlock){
                let scan: number = cursor - 1;
                const done: boolean = false;
                while((!done)) {{
                    const next: com.vzome.core.editor.api.UndoableEdit = this.mEdits.get(scan);
                    if (next != null && next instanceof <any>com.vzome.core.editor.api.ChangeManifestations)return;
                    if (next != null && next instanceof <any>com.vzome.core.editor.api.ChangeSelection)--scan; else if (next != null && next instanceof <any>com.vzome.core.editor.BeginBlock){
                        this.mEdits.remove(above);
                        this.mEdits.add(cursor, above);
                        return;
                    } else return;
                }};
            }
        }

        public replaceEdit(oldEdit: com.vzome.core.editor.api.UndoableEdit, newEdit: com.vzome.core.editor.api.UndoableEdit) {
            this.mEdits.set(this.mEdits.indexOf(oldEdit), newEdit);
        }

        /**
         * This is used during DeferredEdit .redo(), possibly to migrate one UndoableEdit into several.
         * It must maintain the invariant that the next UndoableEdit is the next DeferredEdit to redo.
         * @param {com.vzome.core.editor.api.UndoableEdit} edit
         */
        public insert(edit: com.vzome.core.editor.api.UndoableEdit) {
            this.mEdits.add(this.mEditNumber++, edit);
        }

        /**
         * Redo to greater of lastStickyEdit and lastDoneEdit, undo back to lastDoneEdit.
         * If there are explicitSnapshots, this is a migration of an old Article, using edit
         * numbers, and we have to redo as far as the last one, inserting snapshots as we go.
         * Note that lastStickyEdit and explicitSnapshots are mutually exclusive, after and before
         * migration, respectively.
         * 
         * @param {number} lastDoneEdit
         * @param {number} lastStickyEdit
         * @param {com.vzome.core.editor.api.UndoableEdit[]} explicitSnapshots
         * @throws Failure
         */
        public synchronize(lastDoneEdit: number, lastStickyEdit: number, explicitSnapshots: com.vzome.core.editor.api.UndoableEdit[]) {
            let redoThreshold: number = Math.max(lastDoneEdit, lastStickyEdit);
            if (explicitSnapshots != null)redoThreshold = Math.max(redoThreshold, explicitSnapshots.length - 1);
            this.mEditNumber = 0;
            let targetEdit: number = 0;
            const toRedo: java.util.List<com.vzome.core.editor.api.UndoableEdit> = <any>(new java.util.ArrayList<any>());
            for(let i: number = 0; i < redoThreshold; i++) {if (i < this.mEdits.size())toRedo.add(this.mEdits.get(i)); else break;;}
            for(let oldIndex: number = 0; oldIndex < toRedo.size(); oldIndex++) {{
                const edit: EditHistory.DeferredEdit = <EditHistory.DeferredEdit>toRedo.get(oldIndex);
                try {
                    if (explicitSnapshots != null && explicitSnapshots.length > oldIndex && explicitSnapshots[oldIndex] != null){
                        const snapshot: com.vzome.core.editor.api.UndoableEdit = explicitSnapshots[oldIndex];
                        this.mEdits.add(this.mEditNumber, snapshot);
                        if (this.mEditNumber <= lastDoneEdit)++lastDoneEdit;
                        ++this.mEditNumber;
                        snapshot.perform();
                    }
                    ++this.mEditNumber;
                    edit.redo();
                    if (oldIndex + 1 === lastDoneEdit)targetEdit = this.mEditNumber;
                } catch(e) {
                    if (EditHistory.logger_$LI$().isLoggable(java.util.logging.Level.WARNING))EditHistory.logger_$LI$().warning("edit number that failed is " + (this.mEditNumber - 1));
                    const t: Error = (<Error>null);
                    if (t != null && t instanceof <any>com.vzome.core.commands.Command.Failure)throw <com.vzome.core.commands.Command.Failure>t; else throw e;
                }
            };}
            if (explicitSnapshots != null && explicitSnapshots.length > redoThreshold && explicitSnapshots[redoThreshold] != null){
                const snapshot: com.vzome.core.editor.api.UndoableEdit = explicitSnapshots[redoThreshold];
                this.mEdits.add(this.mEditNumber, snapshot);
                ++this.mEditNumber;
                snapshot.perform();
            }
            this.goToEdit(targetEdit);
        }

        public loadEdit(format: com.vzome.core.commands.XmlSaveFormat, editElem: org.w3c.dom.Element, context: com.vzome.core.editor.api.Context) {
            const edit: EditHistory.DeferredEdit = new EditHistory.DeferredEdit(this, format, editElem, context);
            this.addEdit(edit, context);
        }

        /**
         * 
         * @return {*}
         */
        public iterator(): java.util.Iterator<com.vzome.core.editor.api.UndoableEdit> {
            return this.mEdits.iterator();
        }

        public getEditNumber(): number {
            return this.mEditNumber;
        }

        constructor() {
            this.mEdits = <any>(new java.util.ArrayList<any>());
            this.mEditNumber = 0;
            this.breakpointHit = false;
            if (this.listener === undefined) { this.listener = null; }
            if (this.serializer === undefined) { this.serializer = null; }
        }
    }
    EditHistory["__class"] = "com.vzome.core.editor.EditHistory";
    EditHistory["__interfaces"] = ["java.lang.Iterable"];



    export namespace EditHistory {

        export interface Listener {
            showCommand(xml: org.w3c.dom.Element, editNumber: number);

            publishChanges();
        }

        export interface XmlSerializer {
            serialize(xmlElement: org.w3c.dom.Element): string;
        }

        export class Breakpoint extends com.vzome.core.editor.api.UndoableEdit {
            public __parent: any;
            /**
             * 
             * @param {*} doc
             * @return {*}
             */
            public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
                return doc.createElement("Breakpoint");
            }

            /**
             * 
             * @return {boolean}
             */
            public isNoOp(): boolean {
                return false;
            }

            /**
             * 
             * @return {boolean}
             */
            public isVisible(): boolean {
                return true;
            }

            /**
             * 
             * @param {*} xml
             * @param {com.vzome.core.commands.XmlSaveFormat} format
             * @param {*} context
             */
            public loadAndPerform(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat, context: com.vzome.core.editor.api.Context) {
                context.performAndRecord(this);
            }

            /**
             * 
             */
            public perform() {
                com.vzome.core.editor.EditHistory.breakpointLogger_$LI$().info("hit a Breakpoint at " + this.__parent.mEditNumber);
                this.__parent.breakpointHit = true;
            }

            /**
             * 
             */
            public redo() {
                this.perform();
            }

            /**
             * 
             */
            public undo() {
            }

            /**
             * 
             * @param {*} props
             */
            public configure(props: java.util.Map<string, any>) {
            }

            /**
             * 
             * @return {boolean}
             */
            public isSticky(): boolean {
                return false;
            }

            /**
             * 
             * @return {boolean}
             */
            public isDestructive(): boolean {
                return false;
            }

            /**
             * 
             * @param {*} doc
             * @return {*}
             */
            public getDetailXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
                return this.getXml(doc);
            }

            constructor(__parent: any) {
                super();
                this.__parent = __parent;
            }
        }
        Breakpoint["__class"] = "com.vzome.core.editor.EditHistory.Breakpoint";


        export class DeferredEdit extends com.vzome.core.editor.api.UndoableEdit {
            public __parent: any;
            format: com.vzome.core.commands.XmlSaveFormat;

            xml: org.w3c.dom.Element;

            context: com.vzome.core.editor.api.Context;

            isBreakpoint: boolean;

            public constructor(__parent: any, format: com.vzome.core.commands.XmlSaveFormat, editElem: org.w3c.dom.Element, context: com.vzome.core.editor.api.Context) {
                super();
                this.__parent = __parent;
                if (this.format === undefined) { this.format = null; }
                if (this.xml === undefined) { this.xml = null; }
                if (this.context === undefined) { this.context = null; }
                this.isBreakpoint = false;
                this.format = format;
                this.xml = editElem;
                this.context = context;
            }

            /**
             * 
             * @param {boolean} value
             */
            public setBreakpoint(value: boolean) {
                this.isBreakpoint = value;
            }

            /**
             * 
             * @return {boolean}
             */
            public hasBreakpoint(): boolean {
                return this.isBreakpoint;
            }

            /**
             * 
             * @return {boolean}
             */
            public isNoOp(): boolean {
                return false;
            }

            /**
             * 
             * @return {number}
             */
            public getLineNumber(): number {
                const locationData: com.vzome.xml.LocationData = <com.vzome.xml.LocationData>this.xml.getUserData(com.vzome.xml.LocationData.LOCATION_DATA_KEY);
                if (locationData != null)return locationData.getStartLine(); else return 0;
            }

            /**
             * 
             * @param {*} doc
             * @return {*}
             */
            public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
                return (/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(doc,this.xml.getOwnerDocument()))) ? this.xml : <org.w3c.dom.Element><any>doc.importNode(this.xml, true);
            }

            /**
             * 
             * @return {boolean}
             */
            public isVisible(): boolean {
                return true;
            }

            /**
             * 
             * @return {boolean}
             */
            public isDestructive(): boolean {
                return true;
            }

            /**
             * 
             */
            public redo() {
                const num: number = this.getLineNumber();
                this.__parent.mEdits.remove(--this.__parent.mEditNumber);
                if (com.vzome.core.editor.EditHistory.logger_$LI$().isLoggable(java.util.logging.Level.FINE))com.vzome.core.editor.EditHistory.logger_$LI$().fine("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% " + num + ": " + this.__parent.serializer.serialize(this.xml));
                let realized: com.vzome.core.editor.api.UndoableEdit = null;
                const cmdName: string = this.xml.getLocalName();
                if (cmdName === ("Breakpoint")){
                    realized = new EditHistory.Breakpoint(this.__parent);
                } else realized = this.context.createEdit(this.xml);
                realized.setLineNumber(num);
                try {
                    this.__parent.listener.showCommand(this.xml, num);
                    realized.loadAndPerform(this.xml, this.format, new DeferredEdit.DeferredEdit$0(this));
                } catch(e) {
                    com.vzome.core.editor.EditHistory.logger_$LI$().warning("failure during initial edit replay:\n" + this.__parent.serializer.serialize(this.xml));
                    throw e;
                }
            }

            /**
             * 
             * @param {*} xml
             * @param {com.vzome.core.commands.XmlSaveFormat} format
             * @param {*} context
             */
            public loadAndPerform(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat, context: com.vzome.core.editor.api.Context) {
                throw new java.lang.IllegalStateException("should never be called");
            }

            /**
             * 
             */
            public undo() {
            }

            /**
             * 
             * @param {*} props
             */
            public configure(props: java.util.Map<string, any>) {
            }

            /**
             * 
             */
            public perform() {
            }

            /**
             * 
             * @return {boolean}
             */
            public isSticky(): boolean {
                return false;
            }

            /**
             * 
             * @param {*} doc
             * @return {*}
             */
            public getDetailXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
                return doc.createElement("deferredEdit");
            }
        }
        DeferredEdit["__class"] = "com.vzome.core.editor.EditHistory.DeferredEdit";


        export namespace DeferredEdit {

            export class DeferredEdit$0 implements com.vzome.core.editor.api.Context {
                public __parent: any;
                /**
                 * 
                 * @param {com.vzome.core.editor.api.UndoableEdit} edit
                 */
                public performAndRecord(edit: com.vzome.core.editor.api.UndoableEdit) {
                    try {
                        edit.perform();
                        if (edit.isNoOp())return;
                        if (com.vzome.core.editor.EditHistory.logger_$LI$().isLoggable(java.util.logging.Level.FINEST)){
                            const details: org.w3c.dom.Element = edit.getDetailXml(this.__parent.xml.getOwnerDocument());
                            com.vzome.core.editor.EditHistory.logger_$LI$().finest("side-effect: " + this.__parent.__parent.serializer.serialize(details));
                        }
                    } catch(e) {
                        throw new java.lang.RuntimeException(e);
                    }
                    this.__parent.__parent.insert(edit);
                }

                /**
                 * 
                 * @param {*} xml
                 * @return {com.vzome.core.editor.api.UndoableEdit}
                 */
                public createEdit(xml: org.w3c.dom.Element): com.vzome.core.editor.api.UndoableEdit {
                    const edit: com.vzome.core.editor.api.UndoableEdit = this.__parent.context.createEdit(xml);
                    edit.setLineNumber(this.__parent.getLineNumber());
                    return edit;
                }

                /**
                 * 
                 * @param {string} cmdName
                 * @return {*}
                 */
                public createLegacyCommand(cmdName: string): com.vzome.core.commands.Command {
                    return this.__parent.context.createLegacyCommand(cmdName);
                }

                /**
                 * 
                 * @param {string} action
                 * @param {*} props
                 * @return {boolean}
                 */
                public doEdit(action: string, props: java.util.Map<string, any>): boolean {
                    return false;
                }

                constructor(__parent: any) {
                    this.__parent = __parent;
                }
            }
            DeferredEdit$0["__interfaces"] = ["com.vzome.core.editor.api.Context"];


        }

    }

}
namespace com.vzome.core.editor {
    export class Snapshot extends com.vzome.core.editor.api.UndoableEdit {
        /**
         * 
         * @return {boolean}
         */
        public isNoOp(): boolean {
            return false;
        }

        /*private*/ id: number;

        /*private*/ recorder: Snapshot.Recorder;

        /**
         * 
         */
        public perform() {
            this.recorder.recordSnapshot(this.id);
        }

        public constructor(id: number, controller: Snapshot.Recorder) {
            super();
            if (this.id === undefined) { this.id = 0; }
            if (this.recorder === undefined) { this.recorder = null; }
            this.id = id;
            this.recorder = controller;
        }

        /**
         * 
         */
        public undo() {
        }

        /**
         * 
         */
        public redo() {
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
            const idProp: number = <number>props.get("id");
            if (idProp != null)this.id = /* intValue */(idProp|0);
        }

        /**
         * 
         * @return {boolean}
         */
        public isVisible(): boolean {
            return false;
        }

        /**
         * 
         * @return {boolean}
         */
        public isDestructive(): boolean {
            return false;
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const xml: org.w3c.dom.Element = doc.createElement("Snapshot");
            com.vzome.xml.DomUtils.addAttribute(xml, "id", /* toString */(''+(this.id)));
            return xml;
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getDetailXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            return this.getXml(doc);
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         * @param {*} context
         */
        public loadAndPerform(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat, context: com.vzome.core.editor.api.Context) {
            this.id = javaemul.internal.IntegerHelper.parseInt(xml.getAttribute("id"));
            context.performAndRecord(this);
        }

        /**
         * 
         * @return {boolean}
         */
        public isSticky(): boolean {
            return true;
        }
    }
    Snapshot["__class"] = "com.vzome.core.editor.Snapshot";


    export namespace Snapshot {

        export interface Recorder {
            recordSnapshot(id: number);

            actOnSnapshot(id: number, action: Snapshot.SnapshotAction);
        }

        export interface SnapshotAction {
            actOnSnapshot(snapshot: com.vzome.core.render.RenderedModel);
        }
    }

}
namespace com.vzome.core.editor {
    export class Branch extends com.vzome.core.editor.api.UndoableEdit {
        /*private*/ context: com.vzome.core.editor.api.Context;

        public constructor(context: com.vzome.core.editor.api.Context) {
            super();
            if (this.context === undefined) { this.context = null; }
            this.edits = <any>(new java.util.ArrayList<any>());
            if (this.format === undefined) { this.format = null; }
            if (this.xml === undefined) { this.xml = null; }
            this.context = context;
        }

        /**
         * 
         * @return {boolean}
         */
        public isNoOp(): boolean {
            return false;
        }

        /*private*/ edits: java.util.List<com.vzome.core.editor.api.UndoableEdit>;

        /*private*/ format: com.vzome.core.commands.XmlSaveFormat;

        /*private*/ xml: org.w3c.dom.Element;

        public addEdit(edit: com.vzome.core.editor.api.UndoableEdit) {
            this.edits.add(edit);
        }

        /**
         * 
         * @return {boolean}
         */
        public isDestructive(): boolean {
            return false;
        }

        /**
         * 
         */
        public perform() {
            const toUndo: java.util.Stack<com.vzome.core.editor.api.UndoableEdit> = <any>(new java.util.Stack<any>());
            const nodes: org.w3c.dom.NodeList = this.xml.getChildNodes();
            for(let i: number = 0; i < nodes.getLength(); i++) {{
                const kid: org.w3c.dom.Node = nodes.item(i);
                if (kid != null && (kid.constructor != null && kid.constructor["__interfaces"] != null && kid.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)){
                    const editElem: org.w3c.dom.Element = <org.w3c.dom.Element><any>kid;
                    const edit: com.vzome.core.editor.api.UndoableEdit = this.context.createEdit(editElem);
                    this.addEdit(edit);
                    edit.loadAndPerform(editElem, this.format, new Branch.Branch$0(this, toUndo));
                }
            };}
            while((!toUndo.isEmpty())) {{
                const edit: com.vzome.core.editor.api.UndoableEdit = toUndo.pop();
                edit.undo();
            }};
        }

        /**
         * 
         */
        public undo() {
        }

        /**
         * 
         */
        public redo() {
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
        }

        /**
         * 
         * @return {boolean}
         */
        public isVisible(): boolean {
            return false;
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const branch: org.w3c.dom.Element = doc.createElement("Branch");
            for(let index=this.edits.iterator();index.hasNext();) {
                let edit = index.next();
                {
                    branch.appendChild(edit.getXml(doc));
                }
            }
            return branch;
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getDetailXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const branch: org.w3c.dom.Element = doc.createElement("Branch");
            for(let index=this.edits.iterator();index.hasNext();) {
                let edit = index.next();
                {
                    branch.appendChild(edit.getDetailXml(doc));
                }
            }
            return branch;
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         * @param {*} context
         */
        public loadAndPerform(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat, context: com.vzome.core.editor.api.Context) {
            this.xml = xml;
            this.format = format;
            context.performAndRecord(this);
        }

        /**
         * 
         * @return {boolean}
         */
        public isSticky(): boolean {
            return true;
        }
    }
    Branch["__class"] = "com.vzome.core.editor.Branch";


    export namespace Branch {

        export class Branch$0 implements com.vzome.core.editor.api.Context {
            public __parent: any;
            /**
             * 
             * @param {com.vzome.core.editor.api.UndoableEdit} edit
             */
            public performAndRecord(edit: com.vzome.core.editor.api.UndoableEdit) {
                try {
                    edit.perform();
                } catch(e) {
                    throw new java.lang.RuntimeException(e);
                }
                this.toUndo.push(edit);
            }

            /**
             * 
             * @param {*} xml
             * @return {com.vzome.core.editor.api.UndoableEdit}
             */
            public createEdit(xml: org.w3c.dom.Element): com.vzome.core.editor.api.UndoableEdit {
                return this.__parent.context.createEdit(xml);
            }

            /**
             * 
             * @param {string} cmdName
             * @return {*}
             */
            public createLegacyCommand(cmdName: string): com.vzome.core.commands.Command {
                return this.__parent.context.createLegacyCommand(cmdName);
            }

            /**
             * 
             * @param {string} action
             * @param {*} props
             * @return {boolean}
             */
            public doEdit(action: string, props: java.util.Map<string, any>): boolean {
                return false;
            }

            constructor(__parent: any, private toUndo: any) {
                this.__parent = __parent;
            }
        }
        Branch$0["__interfaces"] = ["com.vzome.core.editor.api.Context"];


    }

}
namespace com.vzome.core.editor {
    /**
     * Just a marker in the history.
     * @author Scott Vorthmann
     * @param {*} editor
     * @class
     * @extends com.vzome.core.editor.api.UndoableEdit
     */
    export class BeginBlock extends com.vzome.core.editor.api.UndoableEdit {
        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super();
        }

        /**
         * 
         * @return {boolean}
         */
        public isNoOp(): boolean {
            return false;
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            return doc.createElement("BeginBlock");
        }

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getDetailXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            return this.getXml(doc);
        }

        /**
         * 
         * @return {boolean}
         */
        public isVisible(): boolean {
            return false;
        }

        /**
         * 
         * @return {boolean}
         */
        public isDestructive(): boolean {
            return false;
        }

        /**
         * 
         */
        public redo() {
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         * @param {*} context
         */
        public loadAndPerform(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat, context: com.vzome.core.editor.api.Context) {
            context.performAndRecord(this);
        }

        /**
         * 
         */
        public undo() {
        }

        /**
         * 
         */
        public perform() {
        }

        /**
         * 
         * @return {boolean}
         */
        public isSticky(): boolean {
            return false;
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
        }
    }
    BeginBlock["__class"] = "com.vzome.core.editor.BeginBlock";

}
namespace com.vzome.core.editor.api {
    export abstract class SideEffects extends com.vzome.core.editor.api.UndoableEdit {
        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getDetailXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const result: org.w3c.dom.Element = this.getXml(doc);
            const effects: org.w3c.dom.Element = doc.createElement("effects");
            for(let index=this.mItems.iterator();index.hasNext();) {
                let se = index.next();
                {
                    if (se != null){
                        const effect: org.w3c.dom.Element = se.getXml(doc);
                        if (effect != null){
                            effects.appendChild(effect);
                        }
                    }
                }
            }
            result.appendChild(effects);
            return result;
        }

        /**
         * 
         * @return {boolean}
         */
        public isSticky(): boolean {
            return false;
        }

        /*private*/ mItems: java.util.List<com.vzome.core.editor.api.SideEffect>;

        /**
         * This lets us use this pattern:
         * plan plan plan plan
         * redo
         * plan plan plan
         * redo
         * 
         * ... so we can sync the state with a redo
         * 
         */
        /*private*/ redone: number;

        static BUG_ACCOMMODATION_LOGGER: java.util.logging.Logger; public static BUG_ACCOMMODATION_LOGGER_$LI$(): java.util.logging.Logger { if (SideEffects.BUG_ACCOMMODATION_LOGGER == null) { SideEffects.BUG_ACCOMMODATION_LOGGER = java.util.logging.Logger.getLogger("com.vzome.core.bug.accommodations"); }  return SideEffects.BUG_ACCOMMODATION_LOGGER; }

        public static logBugAccommodation(accommodation: string) {
            if (SideEffects.BUG_ACCOMMODATION_LOGGER_$LI$().isLoggable(java.util.logging.Level.WARNING))SideEffects.BUG_ACCOMMODATION_LOGGER_$LI$().warning("ACCOMMODATION: " + accommodation);
        }

        /**
         * 
         * @return {boolean}
         */
        public isVisible(): boolean {
            return true;
        }

        /**
         * 
         * @return {boolean}
         */
        public isDestructive(): boolean {
            return true;
        }

        plan(se: com.vzome.core.editor.api.SideEffect) {
            this.mItems.add(se);
        }

        /**
         * 
         */
        public perform() {
            this.redo();
        }

        fail(message: string) {
            this.undo();
            throw new com.vzome.core.commands.Command.Failure(message);
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
        }

        /**
         * 
         * @return {boolean}
         */
        public isNoOp(): boolean {
            return this.mItems.size() === 0;
        }

        /**
         * 
         */
        public redo() {
            for(let i: number = this.redone; i < this.mItems.size(); i++) {{
                const se: com.vzome.core.editor.api.SideEffect = this.mItems.get(i);
                if (se != null)se.redo();
            };}
            this.redone = this.mItems.size();
        }

        /**
         * 
         */
        public undo() {
            for(let i: number = this.mItems.size(); i > 0; i--) {{
                const se: com.vzome.core.editor.api.SideEffect = this.mItems.get(i - 1);
                if (se != null)se.undo();
            };}
            this.redone = 0;
        }

        getEffects(): java.util.Iterator<com.vzome.core.editor.api.SideEffect> {
            return this.mItems.iterator();
        }

        constructor() {
            super();
            this.mItems = <any>(new java.util.ArrayList<any>());
            this.redone = 0;
        }
    }
    SideEffects["__class"] = "com.vzome.core.editor.api.SideEffects";

}
namespace com.vzome.core.tools {
    export class LinearMapToolFactory extends com.vzome.core.editor.AbstractToolFactory {
        /*private*/ originalScaling: boolean;

        public constructor(tools: com.vzome.core.editor.ToolsModel, symmetry: com.vzome.core.math.symmetry.Symmetry, originalScaling: boolean) {
            super(tools, symmetry, com.vzome.core.tools.LinearMapTool.CATEGORY, com.vzome.core.tools.LinearMapTool.LABEL, com.vzome.core.tools.LinearMapTool.TOOLTIP);
            if (this.originalScaling === undefined) { this.originalScaling = false; }
            this.originalScaling = originalScaling;
        }

        /**
         * 
         * @param {number} total
         * @param {number} balls
         * @param {number} struts
         * @param {number} panels
         * @return {boolean}
         */
        countsAreValid(total: number, balls: number, struts: number, panels: number): boolean {
            return (total === 7 && balls === 1 && struts === 6) || (total === 4 && balls === 1 && struts === 3);
        }

        /**
         * 
         * @param {string} id
         * @return {com.vzome.core.editor.Tool}
         */
        public createToolInternal(id: string): com.vzome.core.editor.Tool {
            return new com.vzome.core.tools.LinearMapTool(id, this.getToolsModel(), this.originalScaling);
        }

        /**
         * 
         * @return {com.vzome.core.editor.Tool}
         */
        public createTool(): com.vzome.core.editor.Tool {
            const result: com.vzome.core.editor.Tool = super.createTool();
            result.setCopyColors(false);
            return result;
        }

        /**
         * 
         * @param {*} selection
         * @return {boolean}
         */
        bindParameters(selection: com.vzome.core.editor.api.Selection): boolean {
            let index: number = 0;
            const segments: com.vzome.core.construction.Segment[] = [null, null, null, null, null, null];
            for(let index1=selection.iterator();index1.hasNext();) {
                let man = index1.next();
                {
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))segments[index++] = <com.vzome.core.construction.Segment>man.getFirstConstruction();
                }
            }
            let c1: com.vzome.core.algebra.AlgebraicVector = com.vzome.core.construction.ChangeOfBasis.findCommonVertex(segments[0], segments[1]);
            let c2: com.vzome.core.algebra.AlgebraicVector = com.vzome.core.construction.ChangeOfBasis.findCommonVertex(segments[2], segments[1]);
            if (c1 == null || c2 == null || !c1.equals(c2))return false;
            if (index === 3)return true;
            c1 = com.vzome.core.construction.ChangeOfBasis.findCommonVertex(segments[3], segments[4]);
            c2 = com.vzome.core.construction.ChangeOfBasis.findCommonVertex(segments[5], segments[4]);
            if (c1 == null || c2 == null || !c1.equals(c2))return false;
            return true;
        }
    }
    LinearMapToolFactory["__class"] = "com.vzome.core.tools.LinearMapToolFactory";
    LinearMapToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


}
namespace com.vzome.core.tools {
    export class TranslationToolFactory extends com.vzome.core.editor.AbstractToolFactory {
        public constructor(tools: com.vzome.core.editor.ToolsModel) {
            super(tools, null, com.vzome.core.tools.TranslationTool.ID, com.vzome.core.tools.TranslationTool.LABEL, com.vzome.core.tools.TranslationTool.TOOLTIP);
        }

        /**
         * 
         * @param {number} total
         * @param {number} balls
         * @param {number} struts
         * @param {number} panels
         * @return {boolean}
         */
        countsAreValid(total: number, balls: number, struts: number, panels: number): boolean {
            return (total === 2 && balls === 2);
        }

        /**
         * 
         * @param {string} id
         * @return {com.vzome.core.editor.Tool}
         */
        public createToolInternal(id: string): com.vzome.core.editor.Tool {
            return new com.vzome.core.tools.TranslationTool(id, this.getToolsModel());
        }

        /**
         * 
         * @param {*} selection
         * @return {boolean}
         */
        bindParameters(selection: com.vzome.core.editor.api.Selection): boolean {
            return true;
        }
    }
    TranslationToolFactory["__class"] = "com.vzome.core.tools.TranslationToolFactory";
    TranslationToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


}
namespace com.vzome.core.tools {
    export class OctahedralToolFactory extends com.vzome.core.editor.AbstractToolFactory {
        static ID: string = "octahedral";

        static LABEL: string = "Create an octahedral symmetry tool";

        static TOOLTIP2: string = "<p>Each tool produces up to 23 copies of the input<br>selection, using the rotation symmetries of a<br>cube or octahedron.  To create a tool, select a<br>ball that defines the center of symmetry.<br><br>Combine with a point reflection tool to achieve<br>all 48 symmetries of the octahedron, including<br>reflections.<br></p>";

        public constructor(tools: com.vzome.core.editor.ToolsModel, symmetry: com.vzome.core.math.symmetry.Symmetry, id: string = OctahedralToolFactory.ID, label: string = OctahedralToolFactory.LABEL, tooltip: string = OctahedralToolFactory.TOOLTIP2) {
            super(tools, symmetry, id, label, tooltip);
        }

        /**
         * 
         * @param {number} total
         * @param {number} balls
         * @param {number} struts
         * @param {number} panels
         * @return {boolean}
         */
        countsAreValid(total: number, balls: number, struts: number, panels: number): boolean {
            return (total === 1 && balls === 1) || (total === 2 && balls === 1 && struts === 1);
        }

        /**
         * 
         * @param {string} id
         * @return {com.vzome.core.editor.Tool}
         */
        public createToolInternal(id: string): com.vzome.core.editor.Tool {
            return new com.vzome.core.tools.SymmetryTool(id, this.getSymmetry(), this.getToolsModel());
        }

        /**
         * 
         * @param {*} selection
         * @return {boolean}
         */
        bindParameters(selection: com.vzome.core.editor.api.Selection): boolean {
            const symmetry: com.vzome.core.math.symmetry.Symmetry = this.getSymmetry();
            const total: number = this.getSelection().size();
            if (symmetry != null && symmetry instanceof <any>com.vzome.core.math.symmetry.IcosahedralSymmetry){
                if (total !== 2)return false;
                for(let index=selection.iterator();index.hasNext();) {
                    let man = index.next();
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        const zone: com.vzome.core.math.symmetry.Axis = symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector']((<com.vzome.core.model.Strut><any>man).getOffset());
                        if (zone == null)return false;
                        switch((zone.getDirection().getName())) {
                        case "blue":
                        case "green":
                            return true;
                        default:
                            return false;
                        }
                    }
                }
                return false;
            } else {
                return total === 1;
            }
        }
    }
    OctahedralToolFactory["__class"] = "com.vzome.core.tools.OctahedralToolFactory";
    OctahedralToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


}
namespace com.vzome.core.tools {
    export class PlaneSelectionToolFactory extends com.vzome.core.editor.AbstractToolFactory {
        public constructor(tools: com.vzome.core.editor.ToolsModel) {
            super(tools, null, "plane", "", "");
        }

        /**
         * 
         * @param {number} total
         * @param {number} balls
         * @param {number} struts
         * @param {number} panels
         * @return {boolean}
         */
        countsAreValid(total: number, balls: number, struts: number, panels: number): boolean {
            return (total === 3 && balls === 3);
        }

        /**
         * 
         * @param {string} id
         * @return {com.vzome.core.editor.Tool}
         */
        public createToolInternal(id: string): com.vzome.core.editor.Tool {
            return new com.vzome.core.tools.PlaneSelectionTool(id, this.getToolsModel());
        }

        /**
         * 
         * @param {*} selection
         * @return {boolean}
         */
        bindParameters(selection: com.vzome.core.editor.api.Selection): boolean {
            return true;
        }
    }
    PlaneSelectionToolFactory["__class"] = "com.vzome.core.tools.PlaneSelectionToolFactory";
    PlaneSelectionToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


}
namespace com.vzome.core.tools {
    export class InversionToolFactory extends com.vzome.core.editor.AbstractToolFactory {
        public constructor(tools: com.vzome.core.editor.ToolsModel) {
            super(tools, null, com.vzome.core.tools.InversionTool.ID, com.vzome.core.tools.InversionTool.LABEL, com.vzome.core.tools.InversionTool.TOOLTIP);
        }

        /**
         * 
         * @param {number} total
         * @param {number} balls
         * @param {number} struts
         * @param {number} panels
         * @return {boolean}
         */
        countsAreValid(total: number, balls: number, struts: number, panels: number): boolean {
            return (total === 1 && balls === 1);
        }

        /**
         * 
         * @param {string} id
         * @return {com.vzome.core.editor.Tool}
         */
        public createToolInternal(id: string): com.vzome.core.editor.Tool {
            return new com.vzome.core.tools.InversionTool(id, this.getToolsModel());
        }

        /**
         * 
         * @return {com.vzome.core.editor.Tool}
         */
        public createTool(): com.vzome.core.editor.Tool {
            const result: com.vzome.core.editor.Tool = super.createTool();
            result.setCopyColors(false);
            return result;
        }

        /**
         * 
         * @param {*} selection
         * @return {boolean}
         */
        bindParameters(selection: com.vzome.core.editor.api.Selection): boolean {
            return true;
        }
    }
    InversionToolFactory["__class"] = "com.vzome.core.tools.InversionToolFactory";
    InversionToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


}
namespace com.vzome.core.tools {
    export class BookmarkToolFactory extends com.vzome.core.editor.AbstractToolFactory {
        public constructor(tools: com.vzome.core.editor.ToolsModel) {
            super(tools, null, com.vzome.core.tools.BookmarkTool.ID, com.vzome.core.tools.BookmarkTool.LABEL, com.vzome.core.tools.BookmarkTool.TOOLTIP);
        }

        /**
         * 
         * @param {number} total
         * @param {number} balls
         * @param {number} struts
         * @param {number} panels
         * @return {boolean}
         */
        countsAreValid(total: number, balls: number, struts: number, panels: number): boolean {
            return (total > 0);
        }

        /**
         * 
         * @param {string} id
         * @return {com.vzome.core.editor.Tool}
         */
        public createToolInternal(id: string): com.vzome.core.editor.Tool {
            return new com.vzome.core.tools.BookmarkTool(id, this.getToolsModel());
        }

        /**
         * 
         * @param {*} selection
         * @return {boolean}
         */
        bindParameters(selection: com.vzome.core.editor.api.Selection): boolean {
            return true;
        }
    }
    BookmarkToolFactory["__class"] = "com.vzome.core.tools.BookmarkToolFactory";
    BookmarkToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


}
namespace com.vzome.core.tools {
    export class RotationToolFactory extends com.vzome.core.editor.AbstractToolFactory {
        static ID: string = "rotation";

        static LABEL: string = "Create a rotation tool";

        static TOOLTIP: string = "<p>Each tool rotates the selected objects around an axis<br>of symmetry.  To create a tool, select a strut that<br>defines that axis.  You can also define the direction<br>and center independently, by selecting a ball for the<br>center and a strut for the axis.  Note: not all struts<br>correspond to rotational symmetries!<br><br>The direction of rotation depends on the strut<br>orientation, which is hard to discover, but easy to<br>control, by dragging out a new strut.<br><br>By default, the input selection will be moved to the new,<br>rotated orientation.  After creating a tool, you can<br>right-click to configure the tool to create a copy, instead.<br></p>";

        /*private*/ noStrut: boolean;

        public constructor(tools?: any, symmetry?: any, id?: any, label?: any, tooltip?: any) {
            if (((tools != null && tools instanceof <any>com.vzome.core.editor.ToolsModel) || tools === null) && ((symmetry != null && (symmetry.constructor != null && symmetry.constructor["__interfaces"] != null && symmetry.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symmetry === null) && ((typeof id === 'string') || id === null) && ((typeof label === 'string') || label === null) && ((typeof tooltip === 'string') || tooltip === null)) {
                let __args = arguments;
                super(tools, symmetry, id, label, tooltip);
                if (this.noStrut === undefined) { this.noStrut = false; } 
            } else if (((tools != null && tools instanceof <any>com.vzome.core.editor.ToolsModel) || tools === null) && ((symmetry != null && (symmetry.constructor != null && symmetry.constructor["__interfaces"] != null && symmetry.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symmetry === null) && ((typeof id === 'boolean') || id === null) && label === undefined && tooltip === undefined) {
                let __args = arguments;
                let useSymmetryName: any = __args[2];
                {
                    let __args = arguments;
                    let id: any = (useSymmetryName ? __args[1].getName() + ' ' : "") + RotationToolFactory.ID;
                    let label: any = RotationToolFactory.LABEL;
                    let tooltip: any = RotationToolFactory.TOOLTIP;
                    super(tools, symmetry, id, label, tooltip);
                    if (this.noStrut === undefined) { this.noStrut = false; } 
                }
            } else if (((tools != null && tools instanceof <any>com.vzome.core.editor.ToolsModel) || tools === null) && ((symmetry != null && (symmetry.constructor != null && symmetry.constructor["__interfaces"] != null && symmetry.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symmetry === null) && id === undefined && label === undefined && tooltip === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let useSymmetryName: any = false;
                    {
                        let __args = arguments;
                        let id: any = (useSymmetryName ? __args[1].getName() + ' ' : "") + RotationToolFactory.ID;
                        let label: any = RotationToolFactory.LABEL;
                        let tooltip: any = RotationToolFactory.TOOLTIP;
                        super(tools, symmetry, id, label, tooltip);
                        if (this.noStrut === undefined) { this.noStrut = false; } 
                    }
                }
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {number} total
         * @param {number} balls
         * @param {number} struts
         * @param {number} panels
         * @return {boolean}
         */
        countsAreValid(total: number, balls: number, struts: number, panels: number): boolean {
            if (total === 1 && balls === 1){
                this.noStrut = true;
                return true;
            } else if ((total === 1 && struts === 1) || (total === 2 && balls === 1 && struts === 1)){
                this.noStrut = false;
                return true;
            }
            return false;
        }

        /**
         * 
         * @param {string} id
         * @return {com.vzome.core.editor.Tool}
         */
        public createToolInternal(id: string): com.vzome.core.editor.Tool {
            return new com.vzome.core.tools.RotationTool(id, this.getSymmetry(), this.getToolsModel(), false);
        }

        /**
         * 
         * @param {*} selection
         * @return {boolean}
         */
        bindParameters(selection: com.vzome.core.editor.api.Selection): boolean {
            const symmetry: com.vzome.core.math.symmetry.Symmetry = this.getSymmetry();
            for(let index=selection.iterator();index.hasNext();) {
                let man = index.next();
                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                    const axisStrut: com.vzome.core.model.Strut = <com.vzome.core.model.Strut><any>man;
                    let vector: com.vzome.core.algebra.AlgebraicVector = axisStrut.getOffset();
                    vector = symmetry.getField().projectTo3d(vector, true);
                    const axis: com.vzome.core.math.symmetry.Axis = symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](vector);
                    if (axis == null)return false;
                    const perm: com.vzome.core.math.symmetry.Permutation = axis.getRotationPermutation();
                    if (perm == null)return false;
                } else if (this.noStrut){
                    const axis: com.vzome.core.math.symmetry.Axis = symmetry.getPreferredAxis();
                    if (axis == null)return false;
                }
            }
            return true;
        }
    }
    RotationToolFactory["__class"] = "com.vzome.core.tools.RotationToolFactory";
    RotationToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


}
namespace com.vzome.core.tools {
    export class MirrorToolFactory extends com.vzome.core.editor.AbstractToolFactory {
        public constructor(tools: com.vzome.core.editor.ToolsModel) {
            super(tools, null, com.vzome.core.tools.MirrorTool.ID, com.vzome.core.tools.MirrorTool.LABEL, com.vzome.core.tools.MirrorTool.TOOLTIP);
        }

        /**
         * 
         * @param {number} total
         * @param {number} balls
         * @param {number} struts
         * @param {number} panels
         * @return {boolean}
         */
        countsAreValid(total: number, balls: number, struts: number, panels: number): boolean {
            return (total === 2 && balls === 1 && struts === 1) || (total === 1 && panels === 1);
        }

        /**
         * 
         * @param {string} id
         * @return {com.vzome.core.editor.Tool}
         */
        public createToolInternal(id: string): com.vzome.core.editor.Tool {
            return new com.vzome.core.tools.MirrorTool(id, this.getToolsModel());
        }

        /**
         * 
         * @return {com.vzome.core.editor.Tool}
         */
        public createTool(): com.vzome.core.editor.Tool {
            const result: com.vzome.core.editor.Tool = super.createTool();
            result.setCopyColors(false);
            return result;
        }

        /**
         * 
         * @param {*} selection
         * @return {boolean}
         */
        bindParameters(selection: com.vzome.core.editor.api.Selection): boolean {
            return true;
        }
    }
    MirrorToolFactory["__class"] = "com.vzome.core.tools.MirrorToolFactory";
    MirrorToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


}
namespace com.vzome.core.tools {
    export class ProjectionToolFactory extends com.vzome.core.editor.AbstractToolFactory {
        public constructor(tools: com.vzome.core.editor.ToolsModel) {
            super(tools, null, com.vzome.core.tools.ProjectionTool.ID, com.vzome.core.tools.ProjectionTool.LABEL, com.vzome.core.tools.ProjectionTool.TOOLTIP);
        }

        /**
         * 
         * @param {number} total
         * @param {number} balls
         * @param {number} struts
         * @param {number} panels
         * @return {boolean}
         */
        countsAreValid(total: number, balls: number, struts: number, panels: number): boolean {
            return (total === 2 && panels === 1 && struts === 1) || (total === 1 && panels === 1) || (total === 2 && balls === 1 && struts === 1);
        }

        /**
         * 
         * @param {string} id
         * @return {com.vzome.core.editor.Tool}
         */
        public createToolInternal(id: string): com.vzome.core.editor.Tool {
            return new com.vzome.core.tools.ProjectionTool(id, this.getToolsModel());
        }

        /**
         * 
         * @return {com.vzome.core.editor.Tool}
         */
        public createTool(): com.vzome.core.editor.Tool {
            const result: com.vzome.core.editor.Tool = super.createTool();
            result.setCopyColors(false);
            return result;
        }

        /**
         * 
         * @param {*} selection
         * @return {boolean}
         */
        bindParameters(selection: com.vzome.core.editor.api.Selection): boolean {
            return true;
        }
    }
    ProjectionToolFactory["__class"] = "com.vzome.core.tools.ProjectionToolFactory";
    ProjectionToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


}
namespace com.vzome.core.tools {
    export class SymmetryToolFactory extends com.vzome.core.editor.AbstractToolFactory {
        public constructor(tools: com.vzome.core.editor.ToolsModel, symmetry: com.vzome.core.math.symmetry.Symmetry) {
            super(tools, symmetry, com.vzome.core.tools.SymmetryTool.ID, com.vzome.core.tools.SymmetryTool.LABEL, com.vzome.core.tools.SymmetryTool.TOOLTIP);
        }

        /**
         * 
         * @param {number} total
         * @param {number} balls
         * @param {number} struts
         * @param {number} panels
         * @return {boolean}
         */
        countsAreValid(total: number, balls: number, struts: number, panels: number): boolean {
            return (total === 1 && balls === 1);
        }

        /**
         * 
         * @param {string} id
         * @return {com.vzome.core.editor.Tool}
         */
        public createToolInternal(id: string): com.vzome.core.editor.Tool {
            return new com.vzome.core.tools.SymmetryTool(id, this.getSymmetry(), this.getToolsModel());
        }

        /**
         * 
         * @param {*} selection
         * @return {boolean}
         */
        bindParameters(selection: com.vzome.core.editor.api.Selection): boolean {
            return selection.size() === 1 && (selection.iterator().next() != null && (selection.iterator().next().constructor != null && selection.iterator().next().constructor["__interfaces"] != null && selection.iterator().next().constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0));
        }
    }
    SymmetryToolFactory["__class"] = "com.vzome.core.tools.SymmetryToolFactory";
    SymmetryToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


}
namespace com.vzome.core.tools {
    export class IcosahedralToolFactory extends com.vzome.core.editor.AbstractToolFactory {
        static ID: string = "icosahedral";

        static LABEL: string = "Create an icosahedral symmetry tool";

        static TOOLTIP: string = "<p>Each tool produces up to 59 copies of the input<br>selection, using the rotation symmetries of an<br>icosahedron.  To create a tool, select a single<br>ball that defines the center of symmetry.<br><br>Combine with a point reflection tool to achieve<br>all 120 symmetries of the icosahedron, including<br>reflections.<br></p>";

        public constructor(tools: com.vzome.core.editor.ToolsModel, symmetry: com.vzome.core.math.symmetry.IcosahedralSymmetry) {
            super(tools, symmetry, IcosahedralToolFactory.ID, IcosahedralToolFactory.LABEL, IcosahedralToolFactory.TOOLTIP);
        }

        /**
         * 
         * @param {number} total
         * @param {number} balls
         * @param {number} struts
         * @param {number} panels
         * @return {boolean}
         */
        countsAreValid(total: number, balls: number, struts: number, panels: number): boolean {
            return (total === 1 && balls === 1);
        }

        /**
         * 
         * @param {string} id
         * @return {com.vzome.core.editor.Tool}
         */
        public createToolInternal(id: string): com.vzome.core.editor.Tool {
            return new com.vzome.core.tools.SymmetryTool(id, this.getSymmetry(), this.getToolsModel());
        }

        /**
         * 
         * @param {*} selection
         * @return {boolean}
         */
        bindParameters(selection: com.vzome.core.editor.api.Selection): boolean {
            return selection.size() === 1 && (selection.iterator().next() != null && (selection.iterator().next().constructor != null && selection.iterator().next().constructor["__interfaces"] != null && selection.iterator().next().constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0));
        }
    }
    IcosahedralToolFactory["__class"] = "com.vzome.core.tools.IcosahedralToolFactory";
    IcosahedralToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


}
namespace com.vzome.core.tools {
    export class PerspectiveProjectionToolFactory extends com.vzome.core.editor.AbstractToolFactory {
        public constructor(tools: com.vzome.core.editor.ToolsModel) {
            super(tools, null, com.vzome.core.tools.PerspectiveProjectionTool.ID, com.vzome.core.tools.PerspectiveProjectionTool.LABEL, com.vzome.core.tools.PerspectiveProjectionTool.TOOLTIP);
        }

        /**
         * 
         * @param {number} total
         * @param {number} balls
         * @param {number} struts
         * @param {number} panels
         * @return {boolean}
         */
        countsAreValid(total: number, balls: number, struts: number, panels: number): boolean {
            return (total === 2 && panels === 1 && balls === 1);
        }

        /**
         * 
         * @param {string} id
         * @return {com.vzome.core.editor.Tool}
         */
        public createToolInternal(id: string): com.vzome.core.editor.Tool {
            return new com.vzome.core.tools.PerspectiveProjectionTool(id, this.getToolsModel());
        }

        /**
         * 
         * @return {com.vzome.core.editor.Tool}
         */
        public createTool(): com.vzome.core.editor.Tool {
            const result: com.vzome.core.editor.Tool = super.createTool();
            result.setCopyColors(false);
            return result;
        }

        /**
         * 
         * @param {*} selection
         * @return {boolean}
         */
        bindParameters(selection: com.vzome.core.editor.api.Selection): boolean {
            return true;
        }
    }
    PerspectiveProjectionToolFactory["__class"] = "com.vzome.core.tools.PerspectiveProjectionToolFactory";
    PerspectiveProjectionToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


}
namespace com.vzome.core.tools {
    export class LineReflectionToolFactory extends com.vzome.core.editor.AbstractToolFactory {
        static ID: string = "line reflection";

        static LABEL: string = "Create a line reflection tool";

        static TOOLTIP: string = "<p>Each tool duplicates the selection by reflecting<br>each object in a line.  To create a tool,<br>define the mirror line by selecting a strut.<br></p>";

        public constructor(tools: com.vzome.core.editor.ToolsModel) {
            super(tools, null, LineReflectionToolFactory.ID, LineReflectionToolFactory.LABEL, LineReflectionToolFactory.TOOLTIP);
        }

        /**
         * 
         * @param {string} id
         * @return {com.vzome.core.editor.Tool}
         */
        public createToolInternal(id: string): com.vzome.core.editor.Tool {
            return new com.vzome.core.tools.LineReflectionTool(id, this.getToolsModel());
        }

        /**
         * 
         * @param {number} total
         * @param {number} balls
         * @param {number} struts
         * @param {number} panels
         * @return {boolean}
         */
        countsAreValid(total: number, balls: number, struts: number, panels: number): boolean {
            return (total === 1 && struts === 1);
        }

        /**
         * 
         * @param {*} selection
         * @return {boolean}
         */
        bindParameters(selection: com.vzome.core.editor.api.Selection): boolean {
            return true;
        }
    }
    LineReflectionToolFactory["__class"] = "com.vzome.core.tools.LineReflectionToolFactory";
    LineReflectionToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


}
namespace com.vzome.core.tools {
    export class ModuleToolFactory extends com.vzome.core.editor.AbstractToolFactory {
        public constructor(tools: com.vzome.core.editor.ToolsModel) {
            super(tools, null, com.vzome.core.tools.ModuleTool.ID, com.vzome.core.tools.ModuleTool.LABEL, com.vzome.core.tools.ModuleTool.TOOLTIP);
        }

        /**
         * 
         * @param {number} total
         * @param {number} balls
         * @param {number} struts
         * @param {number} panels
         * @return {boolean}
         */
        countsAreValid(total: number, balls: number, struts: number, panels: number): boolean {
            return (total > 0);
        }

        /**
         * 
         * @param {string} id
         * @return {com.vzome.core.editor.Tool}
         */
        public createToolInternal(id: string): com.vzome.core.editor.Tool {
            return new com.vzome.core.tools.ModuleTool(id, this.getToolsModel());
        }

        /**
         * 
         * @param {*} selection
         * @return {boolean}
         */
        bindParameters(selection: com.vzome.core.editor.api.Selection): boolean {
            return true;
        }
    }
    ModuleToolFactory["__class"] = "com.vzome.core.tools.ModuleToolFactory";
    ModuleToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


}
namespace com.vzome.core.tools {
    export class ScalingToolFactory extends com.vzome.core.editor.AbstractToolFactory {
        public constructor(tools: com.vzome.core.editor.ToolsModel, symmetry: com.vzome.core.math.symmetry.Symmetry) {
            super(tools, symmetry, com.vzome.core.tools.ScalingTool.ID, com.vzome.core.tools.ScalingTool.LABEL, com.vzome.core.tools.ScalingTool.TOOLTIP);
        }

        /**
         * 
         * @param {number} total
         * @param {number} balls
         * @param {number} struts
         * @param {number} panels
         * @return {boolean}
         */
        countsAreValid(total: number, balls: number, struts: number, panels: number): boolean {
            return (total === 3 && balls === 1 && struts === 2);
        }

        /**
         * 
         * @param {string} id
         * @return {com.vzome.core.editor.Tool}
         */
        public createToolInternal(id: string): com.vzome.core.editor.Tool {
            const tool: com.vzome.core.tools.ScalingTool = new com.vzome.core.tools.ScalingTool(id, this.getSymmetry(), this.getToolsModel());
            let scalePower: number = 0;
            switch((id)) {
            case "scaling.builtin/scale up":
                scalePower = 1;
                break;
            case "scaling.builtin/scale down":
                scalePower = -1;
                break;
            default:
                return tool;
            }
            const field: com.vzome.core.algebra.AlgebraicField = this.getToolsModel().getEditorModel().getRealizedModel().getField();
            tool.setScaleFactor(field['createPower$int'](scalePower));
            return tool;
        }

        /**
         * 
         * @param {*} selection
         * @return {boolean}
         */
        bindParameters(selection: com.vzome.core.editor.api.Selection): boolean {
            const symmetry: com.vzome.core.math.symmetry.Symmetry = this.getSymmetry();
            let offset1: com.vzome.core.algebra.AlgebraicVector = null;
            let offset2: com.vzome.core.algebra.AlgebraicVector = null;
            for(let index=selection.iterator();index.hasNext();) {
                let man = index.next();
                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                    const strut: com.vzome.core.model.Strut = <com.vzome.core.model.Strut><any>man;
                    if (offset1 == null)offset1 = strut.getOffset(); else offset2 = strut.getOffset();
                }
            }
            const zone1: com.vzome.core.math.symmetry.Axis = symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](offset1);
            const zone2: com.vzome.core.math.symmetry.Axis = symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](offset2);
            if (zone1 == null || zone2 == null)return false;
            const orbit1: com.vzome.core.math.symmetry.Direction = zone1.getDirection();
            const orbit2: com.vzome.core.math.symmetry.Direction = zone2.getDirection();
            if (orbit1 !== orbit2)return false;
            if (orbit1.isAutomatic())return false;
            const l1: com.vzome.core.algebra.AlgebraicNumber = zone1.getLength(offset1);
            const l2: com.vzome.core.algebra.AlgebraicNumber = zone2.getLength(offset2);
            if (/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(l1,l2)))return false;
            return true;
        }
    }
    ScalingToolFactory["__class"] = "com.vzome.core.tools.ScalingToolFactory";
    ScalingToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


}
namespace com.vzome.core.exporters {
    export class MathTableExporter extends com.vzome.core.exporters.GeometryExporter {
        static X: number; public static X_$LI$(): number { if (MathTableExporter.X == null) { MathTableExporter.X = com.vzome.core.algebra.AlgebraicVector.X; }  return MathTableExporter.X; }

        static Y: number; public static Y_$LI$(): number { if (MathTableExporter.Y == null) { MathTableExporter.Y = com.vzome.core.algebra.AlgebraicVector.Y; }  return MathTableExporter.Y; }

        /**
         * 
         * @param {java.io.File} file
         * @param {java.io.Writer} writer
         * @param {number} height
         * @param {number} width
         */
        public doExport(file: java.io.File, writer: java.io.Writer, height: number, width: number) {
            const field: com.vzome.core.algebra.AlgebraicField = this.mModel.getField();
            const buf: java.lang.StringBuilder = new java.lang.StringBuilder();
            buf.append("{\n");
            MathTableExporter.writeFieldData(field, buf);
            MathTableExporter.writeUnitTermsOrDiagonals(field, buf);
            MathTableExporter.writeMultiplicationTable(field, buf);
            MathTableExporter.writeDivisionTable(field, buf);
            MathTableExporter.writeExponentsTable(field, buf);
            if (field != null && field instanceof <any>com.vzome.core.algebra.PolygonField){
                MathTableExporter.writeNamedNumbers(<com.vzome.core.algebra.PolygonField><any>field, buf);
                MathTableExporter.writeEmbedding(<com.vzome.core.algebra.PolygonField><any>field, buf);
                MathTableExporter.writeTrigTable(<com.vzome.core.algebra.PolygonField><any>field, buf);
            }
            buf.setLength(buf.length() - 2);
            buf.append("\n}\n");
            this.output = new java.io.PrintWriter(writer);
            this.output.println$java_lang_Object(/* replace */buf.toString().split("\'").join("\""));
            this.output.flush();
        }

        /*private*/ static getUnitTermOrDiagonal(field: com.vzome.core.algebra.AlgebraicField, i: number): com.vzome.core.algebra.AlgebraicNumber {
            return (field != null && field instanceof <any>com.vzome.core.algebra.PolygonField) ? (<com.vzome.core.algebra.PolygonField><any>field).getUnitDiagonal(i) : field.getUnitTerm(i);
        }

        /*private*/ static getFieldOrderOrDiagonalCount(field: com.vzome.core.algebra.AlgebraicField): number {
            return (field != null && field instanceof <any>com.vzome.core.algebra.PolygonField) ? (<com.vzome.core.algebra.PolygonField><any>field).diagonalCount() : field.getOrder();
        }

        /*private*/ static writeFieldData(field: com.vzome.core.algebra.AlgebraicField, buf: java.lang.StringBuilder) {
            buf.append(" \'field\': { ").append("\'name\': \'").append(field.getName()).append("\', ").append("\'order\': ").append(field.getOrder());
            if (field != null && field instanceof <any>com.vzome.core.algebra.PolygonField){
                const pfield: com.vzome.core.algebra.PolygonField = <com.vzome.core.algebra.PolygonField><any>field;
                buf.append(", \'parity\': \'").append(pfield.isOdd() ? "odd" : "even").append("\', ").append("\'diagonalCount\': ").append(pfield.diagonalCount()).append(", ").append("\'polygonSides\': ").append(pfield.polygonSides());
            }
            buf.append(" },\n");
        }

        /*private*/ static writeEmbedding(field: com.vzome.core.algebra.PolygonField, buf: java.lang.StringBuilder) {
            const symm: com.vzome.core.math.symmetry.AntiprismSymmetry = new com.vzome.core.math.symmetry.AntiprismSymmetry(field);
            const embeddingRows: number[] = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            for(let i: number = 0; i < 3; i++) {{
                const column: com.vzome.core.math.RealVector = symm.embedInR3(field.basisVector(3, i));
                embeddingRows[0 + i] = column.x;
                embeddingRows[4 + i] = column.y;
                embeddingRows[8 + i] = column.z;
            };}
            buf.append(" \'embedding\': [ ");
            let delim: string = "";
            for(let index = 0; index < embeddingRows.length; index++) {
                let f = embeddingRows[index];
                {
                    buf.append(delim).append(f);
                    delim = ", ";
                }
            }
            buf.append(" ],\n");
        }

        /*private*/ static writeUnitTermsOrDiagonals(field: com.vzome.core.algebra.AlgebraicField, buf: java.lang.StringBuilder) {
            const limit: number = MathTableExporter.getFieldOrderOrDiagonalCount(field);
            buf.append(" \'unitTerms\': [ ");
            let delim: string = "\n";
            for(let i: number = 0; i < limit; i++) {{
                const number: com.vzome.core.algebra.AlgebraicNumber = MathTableExporter.getUnitTermOrDiagonal(field, i);
                const name: string = (i === 0) ? "1" : field['getIrrational$int'](i);
                buf.append(delim);
                delim = ",\n";
                buf.append("  { \'name\': \'").append(name).append("\'");
                buf.append(", \'value\': ").append(MathTableExporter.formatAN(number));
                buf.append(" }");
            };}
            buf.append("\n ],\n");
        }

        public static OPTIONAL_NAMED_VALUES: string[]; public static OPTIONAL_NAMED_VALUES_$LI$(): string[] { if (MathTableExporter.OPTIONAL_NAMED_VALUES == null) { MathTableExporter.OPTIONAL_NAMED_VALUES = ["phi", "rho", "sigma", "alpha", "beta", "gamma", "delta", "epsilon", "theta", "kappa", "lambda", "mu", "\u221a2", "\u221a3", "\u221a5", "\u221a6", "\u221a7", "\u221a8", "\u221a10"]; }  return MathTableExporter.OPTIONAL_NAMED_VALUES; }

        /*private*/ static writeNamedNumbers(field: com.vzome.core.algebra.PolygonField, buf: java.lang.StringBuilder) {
            buf.append(" \'namedNumbers\': [");
            let delim: string = "\n";
            for(let index = 0; index < MathTableExporter.OPTIONAL_NAMED_VALUES_$LI$().length; index++) {
                let name = MathTableExporter.OPTIONAL_NAMED_VALUES_$LI$()[index];
                {
                    const number: com.vzome.core.algebra.AlgebraicNumber = field.getNumberByName(name);
                    if (number != null){
                        buf.append(delim);
                        delim = ",\n";
                        buf.append("  { \'name\': \'").append(name).append("\', ");
                        buf.append("\'value\': ").append(MathTableExporter.formatAN(number)).append(", ");
                        switch((name)) {
                        case "phi":
                            MathTableExporter.writeDiagonalRatio(field, 5, buf);
                            break;
                        case "rho":
                            MathTableExporter.writeDiagonalRatio(field, 7, buf);
                            break;
                        case "sigma":
                            MathTableExporter.writeDiagonalRatio(field, 7, buf, 3);
                            break;
                        case "\u221a2":
                            MathTableExporter.writeDiagonalRatio(field, 4, buf);
                            break;
                        case "\u221a3":
                            MathTableExporter.writeDiagonalRatio(field, 6, buf);
                            break;
                        default:
                            break;
                        }
                        buf.append("\'reciprocal\': ").append(MathTableExporter.formatAN(number.reciprocal()));
                        buf.append(" }");
                    }
                }
            }
            buf.append("\n ],\n");
        }

        /*private*/ static writeTrigTable(field: com.vzome.core.algebra.PolygonField, buf: java.lang.StringBuilder) {
            const rotationMatrix: com.vzome.core.algebra.AlgebraicMatrix = (new com.vzome.core.math.symmetry.AntiprismSymmetry(field)).getRotationMatrix();
            const vX: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, MathTableExporter.X_$LI$());
            const v1: com.vzome.core.algebra.AlgebraicVector = rotationMatrix.timesColumn(vX);
            let bisector: com.vzome.core.algebra.AlgebraicVector = vX.plus(v1).scale(field.getUnitTerm(1).reciprocal());
            let v: com.vzome.core.algebra.AlgebraicVector = vX;
            const nSides: number = field.polygonSides();
            buf.append(" \'trig\': [\n");
            for(let i: number = 0; i < nSides; i++) {{
                MathTableExporter.writeTrigEntry(i, nSides, v, bisector, buf);
                buf.append(i === nSides - 1 ? "\n" : ",\n");
                v = rotationMatrix.timesColumn(v);
                bisector = rotationMatrix.timesColumn(bisector);
            };}
            buf.append(" ],\n");
        }

        /*private*/ static writeMultiplicationTable(field: com.vzome.core.algebra.AlgebraicField, buf: java.lang.StringBuilder) {
            MathTableExporter.writeTable(field, buf, "multiplication", (n1, n2) => n1['times$com_vzome_core_algebra_AlgebraicNumber'](n2));
        }

        /*private*/ static writeDivisionTable(field: com.vzome.core.algebra.AlgebraicField, buf: java.lang.StringBuilder) {
            MathTableExporter.writeTable(field, buf, "division", (n1, n2) => n1.dividedBy(n2));
        }

        /*private*/ static writeTable(field: com.vzome.core.algebra.AlgebraicField, buf: java.lang.StringBuilder, tableName: string, op: (p1: com.vzome.core.algebra.AlgebraicNumber, p2: com.vzome.core.algebra.AlgebraicNumber) => com.vzome.core.algebra.AlgebraicNumber) {
            const operandFactory: (p1: number) => com.vzome.core.algebra.AlgebraicNumber = (field != null && field instanceof <any>com.vzome.core.algebra.PolygonField) ? (instance$PolygonField,n) => { return instance$PolygonField.getUnitDiagonal(n) } : (n) => { return field.getUnitTerm(n) };
            const limit: number = (field != null && field instanceof <any>com.vzome.core.algebra.PolygonField) ? (<com.vzome.core.algebra.PolygonField><any>field).diagonalCount() : field.getOrder();
            buf.append(" \'").append(tableName).append("\': [\n");
            let delim1: string = "";
            for(let i: number = 0; i < limit; i++) {{
                const n1: com.vzome.core.algebra.AlgebraicNumber = (target => (typeof target === 'function') ? target(i) : (<any>target).apply(i))(operandFactory);
                buf.append(delim1).append("  [ ");
                delim1 = ",\n";
                let delim2: string = "";
                for(let j: number = 0; j < limit; j++) {{
                    const n2: com.vzome.core.algebra.AlgebraicNumber = (target => (typeof target === 'function') ? target(j) : (<any>target).apply(j))(operandFactory);
                    const result: com.vzome.core.algebra.AlgebraicNumber = (target => (typeof target === 'function') ? target(n1, n2) : (<any>target).apply(n1, n2))(op);
                    buf.append(delim2);
                    delim2 = ", ";
                    buf.append(MathTableExporter.formatAN(result));
                };}
                buf.append(" ]");
            };}
            buf.append("\n ],\n");
        }

        /*private*/ static writeExponentsTable(field: com.vzome.core.algebra.AlgebraicField, buf: java.lang.StringBuilder) {
            const limit: number = MathTableExporter.getFieldOrderOrDiagonalCount(field);
            const range: number = 6;
            buf.append(" \'exponents\': [\n");
            let delim1: string = "";
            for(let i: number = 1; i < limit; i++) {{
                buf.append(delim1).append("  {");
                delim1 = ",\n";
                const name: string = field['getIrrational$int'](i);
                buf.append(" \'base\': \'").append(name).append("\'");
                {
                    buf.append(",\n    \'positivePowers\': [ ");
                    let delim2: string = "";
                    const base: com.vzome.core.algebra.AlgebraicNumber = MathTableExporter.getUnitTermOrDiagonal(field, i);
                    let result: com.vzome.core.algebra.AlgebraicNumber = base;
                    for(let power: number = 1; power <= range; power++) {{
                        buf.append(delim2);
                        delim2 = ", ";
                        buf.append(MathTableExporter.formatAN(result));
                        result = result['times$com_vzome_core_algebra_AlgebraicNumber'](base);
                    };}
                    buf.append(" ]");
                };
                {
                    buf.append(",\n    \'negativePowers\': [ ");
                    let delim2: string = "";
                    const base: com.vzome.core.algebra.AlgebraicNumber = MathTableExporter.getUnitTermOrDiagonal(field, i).reciprocal();
                    let result: com.vzome.core.algebra.AlgebraicNumber = base;
                    for(let power: number = 1; power <= range; power++) {{
                        buf.append(delim2);
                        delim2 = ", ";
                        buf.append(MathTableExporter.formatAN(result));
                        result = result['times$com_vzome_core_algebra_AlgebraicNumber'](base);
                    };}
                    buf.append(" ]");
                };
                buf.append("\n  }");
            };}
            buf.append("\n ],\n");
        }

        public static writeDiagonalRatio(field: com.vzome.core.algebra.PolygonField, divisor: number, buf: java.lang.StringBuilder, step: number = 2) {
            if (field.polygonSides() % divisor === 0){
                const n: number = (field.polygonSides() / divisor|0);
                const denominator: com.vzome.core.algebra.AlgebraicNumber = field.getUnitDiagonal(n - 1);
                const numerator: com.vzome.core.algebra.AlgebraicNumber = field.getUnitDiagonal((step * n) - 1);
                buf.append("\'numerator\': ").append(MathTableExporter.formatAN(numerator)).append(", ");
                buf.append("\'denominator\': ").append(MathTableExporter.formatAN(denominator)).append(", ");
            } else {
                throw new java.lang.IllegalStateException("shouldn\'t ever get here");
            }
        }

        /*private*/ static writeTrigEntry(i: number, nSides: number, vStep: com.vzome.core.algebra.AlgebraicVector, bisector: com.vzome.core.algebra.AlgebraicVector, buf: java.lang.StringBuilder) {
            const delim1: string = "\', ";
            const delim2: string = ", ";
            const infinite: string = "{ \'alg\': \'\u221e\', \'dec\': \'\u221e\', \'tdf\': \'\u221e\' }";
            let v: com.vzome.core.algebra.AlgebraicVector = vStep;
            for(let n: number = 0; n < 2; n++) {{
                const k: number = (i * 2) + n;
                const degrees: number = k * 180.0 / nSides;
                const sin: com.vzome.core.algebra.AlgebraicNumber = v.getComponent(MathTableExporter.Y_$LI$());
                const cos: com.vzome.core.algebra.AlgebraicNumber = v.getComponent(MathTableExporter.X_$LI$());
                buf.append("  { ");
                buf.append("\'rot\': \'").append(k).append("/").append(nSides * 2).append(delim1);
                buf.append("\'rad\': \'").append(k).append("\u03c0/").append(nSides).append(delim1);
                buf.append("\'deg\': ").append(degrees).append(delim2);
                buf.append("\'sin\': ").append(MathTableExporter.formatAN(sin)).append(delim2);
                buf.append("\'cos\': ").append(MathTableExporter.formatAN(cos)).append(delim2);
                buf.append("\'tan\': ").append(cos.isZero() ? infinite : MathTableExporter.formatAN(sin.dividedBy(cos))).append(delim2);
                buf.append("\'csc\': ").append(sin.isZero() ? infinite : MathTableExporter.formatAN(sin.reciprocal())).append(delim2);
                buf.append("\'sec\': ").append(cos.isZero() ? infinite : MathTableExporter.formatAN(cos.reciprocal())).append(delim2);
                buf.append("\'cot\': ").append(sin.isZero() ? infinite : MathTableExporter.formatAN(cos.dividedBy(sin)));
                buf.append(" }");
                if (n === 0){
                    buf.append(",\n");
                }
                v = bisector;
            };}
        }

        /*private*/ static formatAN(n: com.vzome.core.algebra.AlgebraicNumber): string {
            const buf: java.lang.StringBuilder = new java.lang.StringBuilder();
            buf.append("{ \'alg\': \'").append(n).append("\', \'dec\': ").append(n.evaluate()).append(", \'tdf\': [");
            let delim: string = "";
            {
                let array = n.toTrailingDivisor();
                for(let index = 0; index < array.length; index++) {
                    let term = array[index];
                    {
                        buf.append(delim);
                        delim = ", ";
                        buf.append(term);
                    }
                }
            }
            buf.append("] }");
            return buf.toString();
        }

        /**
         * 
         * @return {string}
         */
        public getFileExtension(): string {
            return "math.json";
        }

        /**
         * 
         * @return {string}
         */
        public getContentType(): string {
            return "application/json";
        }
    }
    MathTableExporter["__class"] = "com.vzome.core.exporters.MathTableExporter";

}
namespace com.vzome.core.algebra {
    export class SnubDodecField extends com.vzome.core.algebra.AbstractAlgebraicField {
        public static FIELD_NAME: string = "snubDodec";

        /**
         * 
         * @return {double[]} the coefficients of this AlgebraicField class.
         * This can be used to determine when two fields have compatible coefficients
         * without having to generate an instance of the class.
         */
        public static getFieldCoefficients(): number[] {
            return [1.0, SnubDodecField.PHI_VALUE_$LI$(), SnubDodecField.XI_VALUE, SnubDodecField.PHI_VALUE_$LI$() * SnubDodecField.XI_VALUE, SnubDodecField.XI_VALUE * SnubDodecField.XI_VALUE, SnubDodecField.PHI_VALUE_$LI$() * SnubDodecField.XI_VALUE * SnubDodecField.XI_VALUE];
        }

        /**
         * 
         * @return {double[]}
         */
        public getCoefficients(): number[] {
            return SnubDodecField.getFieldCoefficients();
        }

        public constructor(factory: com.vzome.core.algebra.AlgebraicNumberFactory) {
            super(SnubDodecField.FIELD_NAME, 6, factory);
        }

        public static PHI_VALUE: number; public static PHI_VALUE_$LI$(): number { if (SnubDodecField.PHI_VALUE == null) { SnubDodecField.PHI_VALUE = (1.0 + Math.sqrt(5.0)) / 2.0; }  return SnubDodecField.PHI_VALUE; }

        public static XI_VALUE: number = 1.7155614996973678;

        static A: number = 0;

        static B: number = 1;

        static C: number = 2;

        static D: number = 3;

        static E: number = 4;

        static F: number = 5;

        /**
         * 
         * @param {com.vzome.core.algebra.BigRational[]} a
         * @param {com.vzome.core.algebra.BigRational[]} b
         * @return {com.vzome.core.algebra.BigRational[]}
         */
        public multiply(a: com.vzome.core.algebra.BigRational[], b: com.vzome.core.algebra.BigRational[]): com.vzome.core.algebra.BigRational[] {
            const result: com.vzome.core.algebra.BigRational[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.getOrder());
            let factor: com.vzome.core.algebra.BigRational = a[SnubDodecField.A].times(b[SnubDodecField.A]);
            factor = factor.plus(a[SnubDodecField.B].times(b[SnubDodecField.B]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.C]));
            factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.D]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.D]));
            factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.E]));
            factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.F]));
            result[SnubDodecField.A] = factor;
            factor = a[SnubDodecField.B].times(b[SnubDodecField.A]);
            factor = factor.plus(a[SnubDodecField.A].times(b[SnubDodecField.B]));
            factor = factor.plus(a[SnubDodecField.B].times(b[SnubDodecField.B]));
            factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.C]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.C]));
            factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.D]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.D]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.D]));
            factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.E]));
            factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.E]));
            factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.F]));
            result[SnubDodecField.B] = factor;
            factor = a[SnubDodecField.C].times(b[SnubDodecField.A]);
            factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.B]));
            factor = factor.plus(a[SnubDodecField.A].times(b[SnubDodecField.C]));
            factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.C]));
            factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.C]));
            factor = factor.plus(a[SnubDodecField.B].times(b[SnubDodecField.D]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.D]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.D]));
            factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.E]));
            factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.E]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.E]));
            factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.F]));
            result[SnubDodecField.C] = factor;
            factor = a[SnubDodecField.D].times(b[SnubDodecField.A]);
            factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.B]));
            factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.B]));
            factor = factor.plus(a[SnubDodecField.B].times(b[SnubDodecField.C]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.C]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.C]));
            factor = factor.plus(a[SnubDodecField.A].times(b[SnubDodecField.D]));
            factor = factor.plus(a[SnubDodecField.B].times(b[SnubDodecField.D]));
            factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.D]));
            factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.D]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.D]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.D]));
            factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.E]));
            factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.E]));
            factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.E]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.E]));
            factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.F]));
            result[SnubDodecField.D] = factor;
            factor = a[SnubDodecField.E].times(b[SnubDodecField.A]);
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.B]));
            factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.C]));
            factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.D]));
            factor = factor.plus(a[SnubDodecField.A].times(b[SnubDodecField.E]));
            factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.E]));
            factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.E]));
            factor = factor.plus(a[SnubDodecField.B].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.F]));
            result[SnubDodecField.E] = factor;
            factor = a[SnubDodecField.F].times(b[SnubDodecField.A]);
            factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.B]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.B]));
            factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.C]));
            factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.D]));
            factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.D]));
            factor = factor.plus(a[SnubDodecField.B].times(b[SnubDodecField.E]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.E]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.E]));
            factor = factor.plus(a[SnubDodecField.A].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.B].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.F]));
            factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.F]));
            result[SnubDodecField.F] = factor;
            return result;
        }

        /**
         * 
         * @return {number}
         */
        public getNumMultipliers(): number {
            return 2;
        }

        /**
         * scalar for an affine pentagon
         * @return {*}
         */
        public getAffineScalar(): com.vzome.core.algebra.AlgebraicNumber {
            return this.getUnitTerm(1);
        }

        /**
         * 
         * @return {*}
         */
        public getGoldenRatio(): com.vzome.core.algebra.AlgebraicNumber {
            return this.getUnitTerm(1);
        }

        static IRRATIONAL_LABELS: string[][]; public static IRRATIONAL_LABELS_$LI$(): string[][] { if (SnubDodecField.IRRATIONAL_LABELS == null) { SnubDodecField.IRRATIONAL_LABELS = [[" ", " "], ["\u03c6", "phi"], ["\u03be", "xi"], ["\u03c6\u03be", "phi*xi"], ["\u03be\u00b2", "xi^2"], ["\u03c6\u03be\u00b2", "phi*xi^2"]]; }  return SnubDodecField.IRRATIONAL_LABELS; }

        public getIrrational$int$int(i: number, format: number): string {
            return SnubDodecField.IRRATIONAL_LABELS_$LI$()[i][format];
        }

        /**
         * 
         * @param {number} i
         * @param {number} format
         * @return {string}
         */
        public getIrrational(i?: any, format?: any): string {
            if (((typeof i === 'number') || i === null) && ((typeof format === 'number') || format === null)) {
                return <any>this.getIrrational$int$int(i, format);
            } else if (((typeof i === 'number') || i === null) && format === undefined) {
                return <any>this.getIrrational$int(i);
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {com.vzome.core.algebra.BigRational[]} factors
         * @return {number}
         */
        evaluateNumber(factors: com.vzome.core.algebra.BigRational[]): number {
            let result: number = 0.0;
            result += factors[SnubDodecField.A].evaluate();
            result += SnubDodecField.PHI_VALUE_$LI$() * factors[SnubDodecField.B].evaluate();
            result += SnubDodecField.XI_VALUE * factors[SnubDodecField.C].evaluate();
            result += SnubDodecField.PHI_VALUE_$LI$() * SnubDodecField.XI_VALUE * factors[SnubDodecField.D].evaluate();
            result += SnubDodecField.XI_VALUE * SnubDodecField.XI_VALUE * factors[SnubDodecField.E].evaluate();
            result += SnubDodecField.XI_VALUE * SnubDodecField.XI_VALUE * SnubDodecField.PHI_VALUE_$LI$() * factors[SnubDodecField.F].evaluate();
            return result;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.BigRational[]} factors
         * @param {number} whichIrrational
         * @return {com.vzome.core.algebra.BigRational[]}
         */
        scaleBy(factors: com.vzome.core.algebra.BigRational[], whichIrrational: number): com.vzome.core.algebra.BigRational[] {
            switch((whichIrrational)) {
            case 0 /* A */:
                return factors;
            case 1 /* B */:
                return [factors[SnubDodecField.B], factors[SnubDodecField.A].plus(factors[SnubDodecField.B]), factors[SnubDodecField.D], factors[SnubDodecField.C].plus(factors[SnubDodecField.D]), factors[SnubDodecField.F], factors[SnubDodecField.E].plus(factors[SnubDodecField.F])];
            case 2 /* C */:
                return [factors[SnubDodecField.F], factors[SnubDodecField.E].plus(factors[SnubDodecField.F]), factors[SnubDodecField.A].plus(factors[SnubDodecField.E]).plus(factors[SnubDodecField.E]), factors[SnubDodecField.B].plus(factors[SnubDodecField.F]).plus(factors[SnubDodecField.F]), factors[SnubDodecField.C], factors[SnubDodecField.D]];
            case 3 /* D */:
                return this.scaleBy(this.scaleBy(factors, SnubDodecField.B), SnubDodecField.C);
            case 4 /* E */:
                return this.scaleBy(this.scaleBy(factors, SnubDodecField.C), SnubDodecField.C);
            case 5 /* F */:
                return this.scaleBy(this.scaleBy(factors, SnubDodecField.D), SnubDodecField.C);
            default:
                throw new java.lang.IllegalArgumentException(whichIrrational + " is not a valid irrational in this field");
            }
        }
    }
    SnubDodecField["__class"] = "com.vzome.core.algebra.SnubDodecField";
    SnubDodecField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];


}
namespace com.vzome.core.algebra {
    /**
     * @author David Hall
     * @param {string} name
     * @param {number} order
     * @param {*} factory
     * @class
     * @extends com.vzome.core.algebra.AbstractAlgebraicField
     */
    export abstract class ParameterizedField extends com.vzome.core.algebra.AbstractAlgebraicField {
        coefficients: number[];

        multiplicationTensor: number[][][];

        irrationalLabels: string[][];

        public constructor(name: string, order: number, factory: com.vzome.core.algebra.AlgebraicNumberFactory) {
            super(name, order, factory);
            if (this.coefficients === undefined) { this.coefficients = null; }
            if (this.multiplicationTensor === undefined) { this.multiplicationTensor = null; }
            if (this.irrationalLabels === undefined) { this.irrationalLabels = null; }
            this.normalizer = (field,factors) => { return ParameterizedField.doNothing(field,factors) };
            this.coefficients = (s => { let a=[]; while(s-->0) a.push(0); return a; })(order);
            this.multiplicationTensor = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return 0; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([order, order, order]);
            this.irrationalLabels = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([order, 2]);
            this.irrationalLabels[0] = [" ", " "];
        }

        /**
         * doNothing is the default normalizer method.
         * @param {com.vzome.core.algebra.BigRational[]} factors
         * @param {*} field
         */
        static doNothing(field: com.vzome.core.algebra.AlgebraicField, factors: com.vzome.core.algebra.BigRational[]) {
        }

        /**
         * Subclasses may need different normalization methods based on their parameters.
         * For example, SqrtField(2) doesn't need normalization, but SqrtField(4) does since 4 is a perfect square
         * By assigning an appropriate normalizer method once in the c'tor,
         * the method can avoid the repeated overhead of checking isPerfectSquare() within the normalizer method itself.
         */
        normalizer: (p1: com.vzome.core.algebra.AlgebraicField, p2: com.vzome.core.algebra.BigRational[]) => void;

        /**
         * 
         * @param {com.vzome.core.algebra.BigRational[]} factors
         */
        normalize(factors: com.vzome.core.algebra.BigRational[]) {
            (target => (typeof target === 'function') ? target(this, factors) : (<any>target).accept(this, factors))(this.normalizer);
        }

        initialize() {
            this.initializeNormalizer();
            this.initializeMultiplicationTensor();
            this.initializeCoefficients();
            this.initializeLabels();
        }

        initializeNormalizer() {
            this.normalizer = (field,factors) => { return ParameterizedField.doNothing(field,factors) };
        }

        abstract initializeMultiplicationTensor();

        abstract initializeCoefficients();

        abstract initializeLabels();

        /**
         * 
         * @param {com.vzome.core.algebra.BigRational[]} v1
         * @param {com.vzome.core.algebra.BigRational[]} v2
         * @return {com.vzome.core.algebra.BigRational[]}
         */
        multiply(v1: com.vzome.core.algebra.BigRational[], v2: com.vzome.core.algebra.BigRational[]): com.vzome.core.algebra.BigRational[] {
            const order: number = this.getOrder();
            const result: com.vzome.core.algebra.BigRational[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(order);
            for(let i: number = 0; i < order; i++) {{
                result[i] = this.numberFactory.zero();
                for(let j: number = 0; j < order; j++) {{
                    for(let k: number = 0; k < order; k++) {{
                        const multiplier: number = this.multiplicationTensor[i][j][k];
                        if (multiplier !== 0){
                            let product: com.vzome.core.algebra.BigRational = v1[j].times(v2[k]);
                            if (multiplier !== 1){
                                product = product.timesInt(multiplier);
                            }
                            result[i] = result[i].plus(product);
                        }
                    };}
                };}
            };}
            return result;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.BigRational[]} factors
         * @param {number} whichIrrational
         * @return {com.vzome.core.algebra.BigRational[]}
         */
        scaleBy(factors: com.vzome.core.algebra.BigRational[], whichIrrational: number): com.vzome.core.algebra.BigRational[] {
            if (whichIrrational === 0){
                return factors;
            }
            const order: number = this.getOrder();
            const result: com.vzome.core.algebra.BigRational[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(order);
            for(let i: number = 0; i < order; i++) {{
                result[i] = this.numberFactory.zero();
                for(let j: number = 0; j < order; j++) {{
                    const multiplier: number = this.multiplicationTensor[i][j][whichIrrational];
                    if (multiplier !== 0){
                        if (multiplier === 1){
                            result[i] = result[i].plus(factors[j]);
                        } else {
                            result[i] = result[i].plus(factors[j].timesInt(multiplier));
                        }
                    }
                };}
            };}
            this.normalize(result);
            return result;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.BigRational[]} factors
         * @return {number}
         */
        evaluateNumber(factors: com.vzome.core.algebra.BigRational[]): number {
            let result: number = 0.0;
            const order: number = this.getOrder();
            for(let i: number = 0; i < order; i++) {{
                result += factors[i].evaluate() * this.coefficients[i];
            };}
            return result;
        }

        public getIrrational$int$int(i: number, format: number): string {
            return this.irrationalLabels[i][format];
        }

        /**
         * 
         * @param {number} i
         * @param {number} format
         * @return {string}
         */
        public getIrrational(i?: any, format?: any): string {
            if (((typeof i === 'number') || i === null) && ((typeof format === 'number') || format === null)) {
                return <any>this.getIrrational$int$int(i, format);
            } else if (((typeof i === 'number') || i === null) && format === undefined) {
                return <any>this.getIrrational$int(i);
            } else throw new Error('invalid overload');
        }

        public getCoefficient(i: number): number {
            return this.coefficients[i];
        }
    }
    ParameterizedField["__class"] = "com.vzome.core.algebra.ParameterizedField";
    ParameterizedField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];


}
namespace com.vzome.core.model {
    export class VefModelExporter extends com.vzome.core.algebra.VefVectorExporter implements com.vzome.core.model.Exporter {
        public constructor(writer: java.io.Writer, field: com.vzome.core.algebra.AlgebraicField, scale: com.vzome.core.algebra.AlgebraicNumber = null, withOffset: boolean = false) {
            super(writer, field, scale, withOffset);
        }

        /**
         * 
         * @param {*} man
         */
        public exportManifestation(man: com.vzome.core.model.Manifestation) {
            if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                this.exportPoint(man.getLocation());
            } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                const strut: com.vzome.core.model.Strut = <com.vzome.core.model.Strut><any>man;
                this.exportSegment(strut.getLocation(), strut.getEnd());
            } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                const panel: com.vzome.core.model.Panel = <com.vzome.core.model.Panel><any>man;
                const corners: java.util.ArrayList<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>(panel.getVertexCount()));
                for(let index=panel.iterator();index.hasNext();) {
                    let vertex = index.next();
                    {
                        corners.add(vertex);
                    }
                }
                this.exportPolygon(corners);
            }
        }

        /**
         * This is used only for vZome part geometry export
         * @param {*} man
         */
        public exportSelectedManifestation(man: com.vzome.core.model.Manifestation) {
            if (man == null){
                this.output.println$();
                this.output.flush();
            } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                if (this.strTip != null){
                    this.output.print(this.strTip);
                    this.strTip = null;
                }
                const loc: com.vzome.core.algebra.AlgebraicVector = man.getLocation();
                this.output.println$java_lang_Object(" " + this.sortedVertexList.indexOf(loc));
            } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                if (this.strMiddle != null){
                    this.output.println$java_lang_Object(this.strMiddle);
                    this.strMiddle = null;
                }
                const panel: com.vzome.core.model.Panel = <com.vzome.core.model.Panel><any>man;
                for(let index=panel.iterator();index.hasNext();) {
                    let corner = index.next();
                    {
                        this.output.print(this.sortedVertexList.indexOf(corner) + " ");
                    }
                }
                this.output.println$();
            }
        }

        /**
         * 
         */
        public finish() {
            super.finishExport();
        }
    }
    VefModelExporter["__class"] = "com.vzome.core.model.VefModelExporter";
    VefModelExporter["__interfaces"] = ["com.vzome.core.model.Exporter"];


}
namespace com.vzome.desktop.controller {
    export class PolytopesController extends com.vzome.desktop.controller.DefaultController {
        /*private*/ model: com.vzome.core.editor.api.ImplicitSymmetryParameters;

        /*private*/ context: com.vzome.core.editor.api.Context;

        /*private*/ group: string;

        /*private*/ groups: string[];

        /*private*/ generateEdge: boolean[];

        /*private*/ renderEdge: boolean[];

        /*private*/ edgeScales: com.vzome.core.algebra.AlgebraicNumber[];

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        /*private*/ defaultScaleFactor: com.vzome.core.algebra.AlgebraicNumber;

        public constructor(model: com.vzome.core.editor.api.ImplicitSymmetryParameters, context: com.vzome.core.editor.api.Context) {
            super();
            if (this.model === undefined) { this.model = null; }
            if (this.context === undefined) { this.context = null; }
            this.group = "H4";
            if (this.groups === undefined) { this.groups = null; }
            this.generateEdge = [false, false, false, true];
            this.renderEdge = [true, true, true, true];
            this.edgeScales = [null, null, null, null];
            if (this.field === undefined) { this.field = null; }
            if (this.defaultScaleFactor === undefined) { this.defaultScaleFactor = null; }
            this.model = model;
            this.context = context;
            this.field = model.getRealizedModel().getField();
            this.defaultScaleFactor = this.field['createPower$int'](com.vzome.core.math.symmetry.Direction.USER_SCALE + 2);
            for(let i: number = 0; i < this.edgeScales.length; i++) {{
                this.edgeScales[i] = this.field.one();
            };}
            if (null == this.field.getGoldenRatio()){
                this.groups = ["A4", "B4/C4", "D4", "F4"];
                this.group = "F4";
            } else {
                this.groups = ["A4", "B4/C4", "D4", "F4", "H4"];
                this.group = "H4";
            }
        }

        /**
         * 
         * @param {string} action
         */
        public doAction(action: string) {
            switch((action)) {
            case "setQuaternion":
                const strut: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>this.model.getSelectedConstruction(com.vzome.core.construction.Segment);
                if (strut != null){
                    let vector: com.vzome.core.algebra.AlgebraicVector = strut.getOffset();
                    const symm: com.vzome.core.editor.api.OrbitSource = this.model['getSymmetrySystem$']();
                    const zone: com.vzome.core.math.symmetry.Axis = symm.getAxis(vector);
                    let len: com.vzome.core.algebra.AlgebraicNumber = zone.getLength(vector);
                    len = zone.getOrbit().getLengthInUnits(len);
                    vector = zone.normal().scale(len);
                    const vc: com.vzome.desktop.controller.VectorController = <com.vzome.desktop.controller.VectorController><any>super.getSubController("quaternion");
                    vc.setVector(vector.inflateTo4d$());
                } else {
                }
                return;
            default:
                break;
            }
            if ("generate" === action){
                const index: number = PolytopesController.encodeBits(this.generateEdge);
                const edgesToRender: number = PolytopesController.encodeBits(this.renderEdge);
                const vc: com.vzome.desktop.controller.VectorController = <com.vzome.desktop.controller.VectorController><any>super.getSubController("quaternion");
                const quaternion: com.vzome.core.algebra.AlgebraicVector = vc.getVector().scale(this.defaultScaleFactor);
                const params: java.util.Map<string, any> = <any>(new java.util.HashMap<any, any>());
                params.put("groupName", this.group);
                params.put("renderGroupName", this.group);
                params.put("index", index);
                params.put("edgesToRender", edgesToRender);
                params.put("edgeScales", this.edgeScales);
                params.put("quaternion", quaternion);
                this.context.doEdit("Polytope4d", params);
            } else if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "setGroup.")){
                const oldGroup: string = this.group;
                this.group = action.substring("setGroup.".length);
                this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("group", oldGroup, this.group);
            } else if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "edge.")){
                const edgeName: string = action.substring("edge.".length);
                const edge: number = javaemul.internal.IntegerHelper.parseInt(edgeName);
                const state: boolean = this.generateEdge[edge];
                this.generateEdge[edge] = !state;
                this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("edge." + edge, state, this.generateEdge[edge]);
            } else if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "render.")){
                const edgeName: string = action.substring("render.".length);
                const edge: number = javaemul.internal.IntegerHelper.parseInt(edgeName);
                const state: boolean = this.renderEdge[edge];
                this.renderEdge[edge] = !state;
            } else super.doAction(action);
        }

        /*private*/ static encodeBits(bits: boolean[]): number {
            let result: number = 0;
            for(let i: number = 0; i < 4; i++) {{
                if (bits[i])result += 1 << i;
            };}
            return result;
        }

        /**
         * 
         * @param {string} command
         * @param {java.io.File} file
         */
        public doFileAction(command: string, file: java.io.File) {
            try {
                const out: java.io.Writer = new java.io.FileWriter(file);
                try {
                    const index: number = PolytopesController.encodeBits(this.generateEdge);
                    const edgesToRender: number = PolytopesController.encodeBits(this.renderEdge);
                    const vc: com.vzome.desktop.controller.VectorController = <com.vzome.desktop.controller.VectorController><any>super.getSubController("quaternion");
                    let quaternion: com.vzome.core.algebra.AlgebraicVector = vc.getVector().scale(this.defaultScaleFactor);
                    quaternion = quaternion.scale(this.field['createPower$int'](-5));
                    const rightQuat: com.vzome.core.algebra.Quaternion = new com.vzome.core.algebra.Quaternion(this.field, quaternion);
                    const exporter: com.vzome.core.algebra.VefVectorExporter = new com.vzome.core.algebra.VefVectorExporter(out, this.field);
                    this.model.get4dSymmetries().constructPolytope(this.group, index, edgesToRender, this.edgeScales, new PolytopesController.PolytopesController$0(this, rightQuat, exporter));
                    exporter.finishExport();
                } finally {
                    out.close();
                }
            } catch(e) {
                this.mErrors.reportError(com.vzome.desktop.api.Controller.UNKNOWN_ERROR_CODE, [e]);
            }
        }

        /**
         * 
         * @param {string} listName
         * @return {java.lang.String[]}
         */
        public getCommandList(listName: string): string[] {
            return this.groups;
        }

        /**
         * 
         * @param {string} propName
         * @return {string}
         */
        public getProperty(propName: string): string {
            if ("group" === propName){
                return this.group;
            } else if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(propName, "edge.")){
                const edgeName: string = propName.substring("edge.".length);
                const edge: number = javaemul.internal.IntegerHelper.parseInt(edgeName);
                return javaemul.internal.BooleanHelper.toString(this.generateEdge[edge]);
            } else if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(propName, "render.")){
                const edgeName: string = propName.substring("render.".length);
                const edge: number = javaemul.internal.IntegerHelper.parseInt(edgeName);
                return javaemul.internal.BooleanHelper.toString(this.renderEdge[edge]);
            } else return super.getProperty(propName);
        }

        /**
         * 
         * @param {string} name
         * @return {*}
         */
        public getSubController(name: string): com.vzome.desktop.api.Controller {
            switch((name)) {
            default:
                return super.getSubController(name);
            }
        }
    }
    PolytopesController["__class"] = "com.vzome.desktop.controller.PolytopesController";
    PolytopesController["__interfaces"] = ["com.vzome.desktop.api.Controller"];



    export namespace PolytopesController {

        export class PolytopesController$0 implements com.vzome.core.math.symmetry.WythoffConstruction.Listener {
            public __parent: any;
            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} v
             * @return {*}
             */
            public addVertex(v: com.vzome.core.algebra.AlgebraicVector): any {
                const projected: com.vzome.core.algebra.AlgebraicVector = this.rightQuat.leftMultiply(v);
                this.exporter.exportPoint(projected);
                return projected;
            }

            /**
             * 
             * @param {*} p1
             * @param {*} p2
             * @return {*}
             */
            public addEdge(p1: any, p2: any): any {
                this.exporter.exportSegment(<com.vzome.core.algebra.AlgebraicVector>p1, <com.vzome.core.algebra.AlgebraicVector>p2);
                return null;
            }

            /**
             * 
             * @param {java.lang.Object[]} vertices
             * @return {*}
             */
            public addFace(vertices: any[]): any {
                return null;
            }

            constructor(__parent: any, private rightQuat: any, private exporter: any) {
                this.__parent = __parent;
            }
        }
        PolytopesController$0["__interfaces"] = ["com.vzome.core.math.symmetry.WythoffConstruction.Listener"];


    }

}
namespace com.vzome.desktop.controller {
    export class VectorController extends com.vzome.desktop.controller.DefaultController {
        /*private*/ coordinates: com.vzome.desktop.controller.NumberController[];

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        public constructor(initial: com.vzome.core.algebra.AlgebraicVector) {
            super();
            if (this.coordinates === undefined) { this.coordinates = null; }
            if (this.field === undefined) { this.field = null; }
            this.field = initial.getField();
            this.coordinates = (s => { let a=[]; while(s-->0) a.push(null); return a; })(initial.dimension());
            for(let i: number = 0; i < this.coordinates.length; i++) {{
                this.coordinates[i] = new com.vzome.desktop.controller.NumberController(initial.getField());
                this.coordinates[i].setValue(initial.getComponent(i));
            };}
        }

        /**
         * 
         * @param {string} name
         * @return {*}
         */
        public getSubController(name: string): com.vzome.desktop.api.Controller {
            switch((name)) {
            case "w":
                return this.coordinates[0];
            case "x":
                return this.coordinates[1];
            case "y":
                return this.coordinates[2];
            case "z":
                return this.coordinates[3];
            default:
                return super.getSubController(name);
            }
        }

        public setVector(vector: com.vzome.core.algebra.AlgebraicVector) {
            for(let i: number = 0; i < this.coordinates.length; i++) {{
                const numberController: com.vzome.desktop.controller.NumberController = this.coordinates[i];
                const coord: com.vzome.core.algebra.AlgebraicNumber = vector.getComponent(i);
                numberController.setValue(coord);
            };}
        }

        public getVector(): com.vzome.core.algebra.AlgebraicVector {
            const result: com.vzome.core.algebra.AlgebraicVector = this.field.basisVector(this.coordinates.length, 0);
            for(let i: number = 0; i < this.coordinates.length; i++) {{
                const numberController: com.vzome.desktop.controller.NumberController = this.coordinates[i];
                const coord: com.vzome.core.algebra.AlgebraicNumber = numberController.getValue();
                result.setComponent(i, coord);
            };}
            return result;
        }
    }
    VectorController["__class"] = "com.vzome.desktop.controller.VectorController";
    VectorController["__interfaces"] = ["com.vzome.desktop.api.Controller"];


}
namespace com.vzome.desktop.controller {
    export class OrbitSetController extends com.vzome.desktop.controller.DefaultController implements java.beans.PropertyChangeListener {
        /*private*/ colorSource: com.vzome.core.editor.api.OrbitSource;

        /*private*/ orbits: com.vzome.core.math.symmetry.OrbitSet;

        /*private*/ allOrbits: com.vzome.core.math.symmetry.OrbitSet;

        /*private*/ lastOrbit: com.vzome.core.math.symmetry.Direction;

        /*private*/ mOneAtATime: boolean;

        /*private*/ orbitDots: java.util.Map<com.vzome.core.math.symmetry.Direction, OrbitSetController.OrbitState>;

        public constructor(orbits: com.vzome.core.math.symmetry.OrbitSet, allOrbits: com.vzome.core.math.symmetry.OrbitSet, colorSource: com.vzome.core.editor.api.OrbitSource) {
            super();
            if (this.colorSource === undefined) { this.colorSource = null; }
            if (this.orbits === undefined) { this.orbits = null; }
            if (this.allOrbits === undefined) { this.allOrbits = null; }
            this.lastOrbit = null;
            this.mOneAtATime = true;
            this.orbitDots = <any>(new java.util.HashMap<any, any>());
            this.orbits = orbits;
            this.allOrbits = allOrbits;
            this.colorSource = colorSource;
            this.mOneAtATime = orbits.size() === 1;
            this.recalculateDots();
        }

        recalculateDots() {
            this.orbits.retainAll(this.allOrbits);
            const symmetry: com.vzome.core.math.symmetry.Symmetry = this.allOrbits.getSymmetry();
            let test: com.vzome.core.math.RealVector = new com.vzome.core.math.RealVector(0.1, 0.1, 1.0);
            if (symmetry != null && symmetry instanceof <any>com.vzome.core.math.symmetry.OctahedralSymmetry)test = new com.vzome.core.math.RealVector(2.0, 1.0, 4.0); else if (symmetry != null && symmetry instanceof <any>com.vzome.core.math.symmetry.DodecagonalSymmetry)test = new com.vzome.core.math.RealVector(10.0, 1.0, 1.0);
            symmetry.computeOrbitDots();
            this.orbitDots.clear();
            let lastOrbitChanged: boolean = false;
            for(let index=this.allOrbits.getDirections().iterator();index.hasNext();) {
                let dir = index.next();
                {
                    if (this.lastOrbit == null){
                        this.lastOrbit = dir;
                        lastOrbitChanged = true;
                    }
                    const orbit: OrbitSetController.OrbitState = new OrbitSetController.OrbitState();
                    this.orbitDots.put(dir, orbit);
                    orbit.color = this.colorSource.getColor(dir);
                    orbit.dotX = dir.getDotX();
                    if (orbit.dotX >= -90.0){
                        orbit.dotY = dir.getDotY();
                    } else {
                        const axis: com.vzome.core.math.symmetry.Axis = symmetry['getAxis$com_vzome_core_math_RealVector$java_util_Collection'](test, java.util.Collections.singleton<any>(dir));
                        const v: com.vzome.core.algebra.AlgebraicVector = axis.normal();
                        let z: number = v.getComponent(2).evaluate();
                        if (z === 0.0){
                            z = 1.0;
                        }
                        orbit.dotX = v.getComponent(0).evaluate();
                        orbit.dotX = orbit.dotX / z;
                        orbit.dotY = v.getComponent(1).evaluate();
                        orbit.dotY = orbit.dotY / z;
                    }
                }
            }
            if ((this.lastOrbit == null) || (!this.allOrbits.contains(this.lastOrbit))){
                lastOrbitChanged = true;
                if (!this.orbits.isEmpty())this.lastOrbit = this.orbits.last(); else if (!this.orbitDots.isEmpty())this.lastOrbit = this.orbitDots.keySet().iterator().next(); else this.lastOrbit = null;
            }
            if (lastOrbitChanged)this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("selectedOrbit", null, this.lastOrbit == null ? null : this.lastOrbit.getName());
        }

        /**
         * 
         * @param {string} action
         */
        public doAction(action: string) {
            if (action === ("refreshDots")){
                this.recalculateDots();
                return;
            }
            if ((action === ("toggleHalf")) || (action === ("reset")) || (action === ("short")) || (action === ("medium")) || (action === ("long")) || /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "adjustScale.") || (action === ("scaleUp")) || (action === ("scaleDown"))){
                this.getSubController("currentLength").actionPerformed(null, action);
                return;
            }
            if (action === ("setNoDirections")){
                this.orbits.clear();
            } else if (action === ("setAllDirections")){
                this.mOneAtATime = false;
                this.orbits.addAll(this.allOrbits);
            } else if (action === ("rZomeOrbits")){
                this.mOneAtATime = false;
                this.orbits.clear();
                for(let index=this.allOrbits.getDirections().iterator();index.hasNext();) {
                    let dir = index.next();
                    {
                        if (dir.isStandard()){
                            this.orbits.add(dir);
                        }
                    }
                }
            } else if (action === ("predefinedOrbits")){
                this.mOneAtATime = false;
                this.orbits.clear();
                for(let index=this.allOrbits.getDirections().iterator();index.hasNext();) {
                    let dir = index.next();
                    {
                        if (!dir.isAutomatic()){
                            this.orbits.add(dir);
                        }
                    }
                }
            } else if (action === ("oneAtATime")){
                this.mOneAtATime = !this.mOneAtATime;
                if (!this.mOneAtATime)return;
                this.orbits.clear();
                if (this.lastOrbit != null)this.orbits.add(this.lastOrbit);
            } else if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "setSingleOrbit.")){
                const lastValue: boolean = this.mOneAtATime;
                const value: string = action.substring("setSingleOrbit.".length);
                this.mOneAtATime = javaemul.internal.BooleanHelper.parseBoolean(value);
                if (this.mOneAtATime){
                    this.orbits.clear();
                    if (this.lastOrbit != null)this.orbits.add(this.lastOrbit);
                }
                this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("oneAtATime", lastValue, this.mOneAtATime);
            } else if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "enableDirection.")){
                const dirName: string = action.substring("enableDirection.".length);
                const dir: com.vzome.core.math.symmetry.Direction = this.allOrbits.getDirection(dirName);
                if (dir != null && !this.orbits.contains(dir))this.toggleOrbit(dir);
            } else if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "toggleDirection.")){
                const dirName: string = action.substring("toggleDirection.".length);
                const dir: com.vzome.core.math.symmetry.Direction = this.allOrbits.getDirection(dirName);
                this.toggleOrbit(dir);
            } else if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "setSingleDirection.")){
                this.mOneAtATime = true;
                const dirName: string = action.substring("setSingleDirection.".length);
                const dir: com.vzome.core.math.symmetry.Direction = this.allOrbits.getDirection(dirName);
                this.toggleOrbit(dir);
            }
            this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("orbits", true, false);
        }

        /**
         * 
         * @param {java.beans.PropertyChangeEvent} evt
         */
        public propertyChange(evt: java.beans.PropertyChangeEvent) {
            if (("length" === evt.getPropertyName()) && evt.getSource() === this.getSubController("currentLength"))this.firePropertyChange$java_beans_PropertyChangeEvent(evt);
            if ("orbits" === evt.getPropertyName()){
                this.recalculateDots();
                this.firePropertyChange$java_beans_PropertyChangeEvent(evt);
            }
        }

        toggleOrbit(dir: com.vzome.core.math.symmetry.Direction) {
            if (this.mOneAtATime)this.orbits.clear();
            if (this.orbits.add(dir)){
                this.lastOrbit = dir;
                this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("selectedOrbit", null, dir.getName());
            } else if (this.orbits.remove(dir)){
            } else throw new java.lang.IllegalStateException("could not toggle direction " + dir.getName());
        }

        /**
         * 
         * @param {string} name
         * @return {*}
         */
        public getSubController(name: string): com.vzome.desktop.api.Controller {
            if ("currentLength" === name)return super.getSubController("length." + this.getProperty("selectedOrbit"));
            return super.getSubController(name);
        }

        /**
         * 
         * @param {string} string
         * @return {string}
         */
        public getProperty(string: string): string {
            if ("oneAtATime" === string)return javaemul.internal.BooleanHelper.toString(this.mOneAtATime);
            if ("reverseOrbitTriangle" === string)return javaemul.internal.BooleanHelper.toString(this.allOrbits.getSymmetry().reverseOrbitTriangle());
            if ("selectedOrbit" === string)if (this.lastOrbit != null)return this.lastOrbit.getName(); else return null;
            if ("halfSizes" === string)if (this.lastOrbit != null && this.lastOrbit.hasHalfSizes())return "true"; else return "false";
            if ("scaleName.superShort" === string)return (this.lastOrbit == null) ? null : this.lastOrbit.getScaleName(0);
            if ("scaleName.short" === string)return (this.lastOrbit == null) ? null : this.lastOrbit.getScaleName(1);
            if ("scaleName.medium" === string)return (this.lastOrbit == null) ? null : this.lastOrbit.getScaleName(2);
            if ("scaleName.long" === string)return (this.lastOrbit == null) ? null : this.lastOrbit.getScaleName(3);
            if ("color" === string){
                const color: com.vzome.core.construction.Color = this.colorSource.getColor(this.lastOrbit);
                if (color == null)return null;
                const rgb: number = color.getRGB();
                return "0x" + javaemul.internal.IntegerHelper.toHexString(rgb);
            }
            if (((lhs, rhs) => lhs || rhs)(((lhs, rhs) => lhs || rhs)("half" === string, "unitText" === string), "multiplierText" === string))return this.getSubController("currentLength").getProperty(string);
            if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(string, "orbitDot.")){
                const orbitName: string = string.substring("orbitDot.".length);
                const orbit: com.vzome.core.math.symmetry.Direction = this.allOrbits.getDirection(orbitName);
                const dot: OrbitSetController.OrbitState = this.orbitDots.get(orbit);
                if (dot == null)return "0xffffff/0/0";
                return "0x" + javaemul.internal.IntegerHelper.toHexString(dot.color.getRGB()) + "/" + dot.dotX + "/" + dot.dotY;
            }
            if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(string, "orbitEnabled.")){
                const orbitName: string = string.substring("orbitEnabled.".length);
                const orbit: com.vzome.core.math.symmetry.Direction = this.orbits.getDirection(orbitName);
                return javaemul.internal.BooleanHelper.toString(orbit != null);
            }
            return super.getProperty(string);
        }

        /**
         * 
         * @param {string} cmd
         * @param {*} value
         */
        public setModelProperty(cmd: string, value: any) {
            if ("oneAtATime" === cmd)this.mOneAtATime = /* equals */(<any>((o1: any, o2: any) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)("true",value)); else if (((lhs, rhs) => lhs || rhs)("multiplier" === cmd, "half" === cmd))this.getSubController("currentLength").setProperty(cmd, value); else super.setModelProperty(cmd, value);
        }

        /**
         * 
         * @param {string} listName
         * @return {java.lang.String[]}
         */
        public getCommandList(listName: string): string[] {
            if (listName === ("orbits")){
                const result: string[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.orbits.size());
                let i: number = 0;
                for(let index=this.orbits.getDirections().iterator();index.hasNext();) {
                    let dir = index.next();
                    {
                        result[i] = dir.getName();
                        i++;
                    }
                }
                return result;
            }
            if (listName === ("allOrbits")){
                const result: string[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.allOrbits.size());
                let i: number = 0;
                for(let index=this.allOrbits.getDirections().iterator();index.hasNext();) {
                    let dir = index.next();
                    {
                        result[i] = dir.getName();
                        i++;
                    }
                }
                return result;
            }
            return super.getCommandList(listName);
        }
    }
    OrbitSetController["__class"] = "com.vzome.desktop.controller.OrbitSetController";
    OrbitSetController["__interfaces"] = ["java.util.EventListener","java.beans.PropertyChangeListener","com.vzome.desktop.api.Controller"];



    export namespace OrbitSetController {

        export class OrbitState {
            dotX: number;

            dotY: number;

            color: com.vzome.core.construction.Color;

            constructor() {
                if (this.dotX === undefined) { this.dotX = 0; }
                if (this.dotY === undefined) { this.dotY = 0; }
                if (this.color === undefined) { this.color = null; }
            }
        }
        OrbitState["__class"] = "com.vzome.desktop.controller.OrbitSetController.OrbitState";

    }

}
namespace com.vzome.desktop.controller {
    export class StrutBuilderController extends com.vzome.desktop.controller.DefaultController {
        /*private*/ useGraphicalViews: boolean;

        /*private*/ showStrutScales: boolean;

        /*private*/ useWorkingPlane: boolean;

        /*private*/ workingPlaneAxis: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ previewStrut: com.vzome.desktop.controller.PreviewStrut;

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        /*private*/ context: com.vzome.core.editor.api.Context;

        public constructor(context: com.vzome.core.editor.api.Context, field: com.vzome.core.algebra.AlgebraicField) {
            super();
            this.useGraphicalViews = false;
            this.showStrutScales = false;
            this.useWorkingPlane = false;
            this.workingPlaneAxis = null;
            if (this.previewStrut === undefined) { this.previewStrut = null; }
            if (this.field === undefined) { this.field = null; }
            if (this.context === undefined) { this.context = null; }
            this.context = context;
            this.field = field;
        }

        public withGraphicalViews(value: boolean): StrutBuilderController {
            this.useGraphicalViews = value;
            return this;
        }

        public withShowStrutScales(value: boolean): StrutBuilderController {
            this.showStrutScales = value;
            return this;
        }

        /**
         * 
         * @param {string} propName
         * @return {string}
         */
        public getProperty(propName: string): string {
            switch((propName)) {
            case "useGraphicalViews":
                return javaemul.internal.BooleanHelper.toString(this.useGraphicalViews);
            case "useWorkingPlane":
                return javaemul.internal.BooleanHelper.toString(this.useWorkingPlane);
            case "workingPlaneDefined":
                return javaemul.internal.BooleanHelper.toString(this.workingPlaneAxis != null);
            case "showStrutScales":
                return javaemul.internal.BooleanHelper.toString(this.showStrutScales);
            default:
                return super.getProperty(propName);
            }
        }

        /**
         * 
         * @param {string} name
         * @param {*} value
         */
        public setModelProperty(name: string, value: any) {
            switch((name)) {
            case "useGraphicalViews":
                {
                    const old: boolean = this.useGraphicalViews;
                    this.useGraphicalViews = /* equals */(<any>((o1: any, o2: any) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)("true",value));
                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(name, old, this.useGraphicalViews);
                    break;
                };
            case "showStrutScales":
                {
                    const old: boolean = this.showStrutScales;
                    this.showStrutScales = /* equals */(<any>((o1: any, o2: any) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)("true",value));
                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(name, old, this.showStrutScales);
                    break;
                };
            default:
                super.setModelProperty(name, value);
            }
        }

        /**
         * 
         * @param {string} action
         */
        public doAction(action: string) {
            switch((action)) {
            case "toggleWorkingPlane":
                this.useWorkingPlane = !this.useWorkingPlane;
                break;
            case "toggleOrbitViews":
                {
                    const old: boolean = this.useGraphicalViews;
                    this.useGraphicalViews = !old;
                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("useGraphicalViews", old, this.useGraphicalViews);
                    break;
                };
            case "toggleStrutScales":
                {
                    const old: boolean = this.showStrutScales;
                    this.showStrutScales = !old;
                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("showStrutScales", old, this.showStrutScales);
                    break;
                };
            default:
                super.doAction(action);
            }
        }

        public setWorkingPlaneAxis(axis: com.vzome.core.algebra.AlgebraicVector) {
            this.workingPlaneAxis = axis;
            this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("workingPlaneDefined", false, true);
        }

        public setMainScene(mainScene: com.vzome.core.render.RenderingChanges) {
            this.previewStrut = new com.vzome.desktop.controller.PreviewStrut(this.field, mainScene, this.context);
        }

        public getPreviewStrut(): com.vzome.desktop.controller.PreviewStrut {
            return this.previewStrut;
        }

        public startRendering(point: com.vzome.core.construction.Point, worldEye: com.vzome.core.math.RealVector) {
            const axis: com.vzome.core.algebra.AlgebraicVector = this.useWorkingPlane ? this.workingPlaneAxis : null;
            this.previewStrut.startRendering(point, axis, worldEye);
        }

        public setSymmetryController(symmetryController: com.vzome.desktop.controller.SymmetryController) {
            if (this.previewStrut != null)this.previewStrut.setSymmetryController(symmetryController);
        }
    }
    StrutBuilderController["__class"] = "com.vzome.desktop.controller.StrutBuilderController";
    StrutBuilderController["__interfaces"] = ["com.vzome.desktop.api.Controller"];


}
namespace com.vzome.desktop.controller {
    export class NumberController extends com.vzome.desktop.controller.DefaultController {
        /*private*/ value: com.vzome.core.algebra.AlgebraicNumber;

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            super();
            if (this.value === undefined) { this.value = null; }
            if (this.field === undefined) { this.field = null; }
            this.field = field;
            this.value = field.one();
        }

        /**
         * 
         * @param {string} listName
         * @return {java.lang.String[]}
         */
        public getCommandList(listName: string): string[] {
            switch((listName)) {
            case "labels":
                const order: number = this.field.getOrder();
                let result: string[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(order + 1);
                result[0] = "1";
                result[order] = "/";
                for(let i: number = 1; i < order; i++) {result[i] = this.field['getIrrational$int'](i);}
                return result;
            case "values":
                const td: number[] = this.value.toTrailingDivisor();
                result = (s => { let a=[]; while(s-->0) a.push(null); return a; })(td.length);
                for(let i: number = 0; i < td.length; i++) {result[i] = /* toString */(''+(td[i]));}
                return result;
            case "named-values":
                return this.getNamedValues();
            case "math.operations":
                return NumberController.MATH_OPS_$LI$();
            default:
                return super.getCommandList(listName);
            }
        }

        static OPTIONAL_NAMED_VALUES: string[]; public static OPTIONAL_NAMED_VALUES_$LI$(): string[] { if (NumberController.OPTIONAL_NAMED_VALUES == null) { NumberController.OPTIONAL_NAMED_VALUES = ["phi", "rho", "sigma", "alpha", "beta", "gamma", "delta", "epsilon", "theta", "kappa", "lambda", "mu", "seperator", "\u221a2", "\u221a3", "\u221a5", "\u221a6", "\u221a7", "\u221a8", "\u221a10"]; }  return NumberController.OPTIONAL_NAMED_VALUES; }

        /*private*/ getNamedValues(): string[] {
            let seperateNext: boolean = false;
            const list: java.util.List<string> = <any>(new java.util.ArrayList<any>());
            list.add("zero");
            list.add("one");
            for(let index = 0; index < NumberController.OPTIONAL_NAMED_VALUES_$LI$().length; index++) {
                let test = NumberController.OPTIONAL_NAMED_VALUES_$LI$()[index];
                {
                    if (test === ("seperator")){
                        seperateNext = true;
                    } else {
                        if (this.field.getNumberByName(test) != null){
                            if (seperateNext){
                                seperateNext = false;
                                list.add("seperator");
                            }
                            list.add(test);
                        }
                    }
                }
            }
            return list.toArray<any>((s => { let a=[]; while(s-->0) a.push(null); return a; })(list.size()));
        }

        /**
         * 
         * @param {string} property
         * @param {*} value
         */
        public setModelProperty(property: string, value: any) {
            switch((property)) {
            case "values":
                const values: java.util.StringTokenizer = new java.util.StringTokenizer(<string>value);
                const inputs: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(this.field.getOrder());
                let divisor: number = 1;
                for(let i: number = 0; values.hasMoreTokens(); i++) {if (i < inputs.length)inputs[i] = javaemul.internal.IntegerHelper.parseInt(values.nextToken()); else divisor = javaemul.internal.IntegerHelper.parseInt(values.nextToken());;}
                this.value = this.field['createAlgebraicNumber$int_A'](inputs).dividedBy(this.field['createRational$long'](divisor));
                return;
            case "named-value":
                this.setValueByName(/* valueOf */String(value).toString());
                return;
            case "math.operation":
                if (this.doMath(/* valueOf */String(value).toString())){
                    return;
                }
            }
            super.setModelProperty(property, value);
        }

        /*private*/ setValueByName(name: string) {
            const n: com.vzome.core.algebra.AlgebraicNumber = this.field.getNumberByName(name);
            if (n != null){
                this.setValue(n);
            }
        }

        static MATH_OPS: string[]; public static MATH_OPS_$LI$(): string[] { if (NumberController.MATH_OPS == null) { NumberController.MATH_OPS = ["Negate", "Reciprocal", "Square"]; }  return NumberController.MATH_OPS; }

        /*private*/ doMath(operation: string): boolean {
            switch((operation)) {
            case "Negate":
                this.setValue(this.getValue().negate());
                return true;
            case "Reciprocal":
                if (!this.getValue().isZero()){
                    this.setValue(this.getValue().reciprocal());
                }
                return true;
            case "Square":
                this.setValue(this.getValue()['times$com_vzome_core_algebra_AlgebraicNumber'](this.getValue()));
                return true;
            }
            return false;
        }

        /**
         * 
         * @param {string} property
         * @return {string}
         */
        public getProperty(property: string): string {
            switch((property)) {
            case "value":
                return this.value.toString(com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT);
            case "evaluate":
                return /* valueOf */String(this.value.evaluate()).toString();
            default:
                return super.getProperty(property);
            }
        }

        public getValue(): com.vzome.core.algebra.AlgebraicNumber {
            return this.value;
        }

        public setValue(value: com.vzome.core.algebra.AlgebraicNumber) {
            this.value = value;
        }
    }
    NumberController["__class"] = "com.vzome.desktop.controller.NumberController";
    NumberController["__interfaces"] = ["com.vzome.desktop.api.Controller"];


}
namespace com.vzome.desktop.controller {
    export class UndoRedoController extends com.vzome.desktop.controller.DefaultController implements com.vzome.desktop.api.Controller {
        /*private*/ model: com.vzome.core.editor.EditHistory;

        public constructor(model: com.vzome.core.editor.EditHistory) {
            super();
            if (this.model === undefined) { this.model = null; }
            this.model = model;
        }

        /**
         * 
         * @param {string} key
         * @return {string}
         */
        public getProperty(key: string): string {
            switch((key)) {
            case "line.number":
                return /* toString */(''+(this.model.getNextLineNumber()));
            case "breakpoints":
                return <any>(this.model.getBreakpoints().stream().map<any>((x) => x.toString()).collect<any, any>(java.util.stream.Collectors.joining(",")));
            default:
                return super.getProperty(key);
            }
        }

        /**
         * 
         * @param {string} action
         */
        public doAction(action: string) {
            switch((action)) {
            case "undo":
                this.model.undo$boolean(true);
                break;
            case "redo":
                this.model.redo$boolean(true);
                break;
            case "redoToBreakpoint":
                this.model.redoToBreakpoint();
                break;
            case "undoAll":
                this.model.undoAll();
                break;
            case "redoAll":
                this.model.redoAll(-1);
                break;
            default:
                if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "setBreakpoints.")){
                    const breakpointList: string = action.substring("setBreakpoints.".length).trim();
                    const breakpoints: string[] = breakpointList.split(",");
                    const breakpointInts: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(breakpoints.length);
                    for(let i: number = 0; i < breakpointInts.length; i++) {{
                        const breakpoint: string = breakpoints[i];
                        let lineNum: number = -1;
                        try {
                            lineNum = javaemul.internal.IntegerHelper.parseInt(breakpoint);
                        } catch(ex) {
                            this.mErrors.reportError("\'" + breakpoint + "\' is not a valid integer. Line number must be a positive integer.", []);
                        }
                        if (lineNum <= 0){
                            this.mErrors.reportError("Edit number must be a positive integer.", []);
                        } else {
                            breakpointInts[i] = lineNum;
                        }
                    };}
                    this.model.setBreakpoints(breakpointInts);
                } else if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "redoUntilEdit.")){
                    const editNum: string = action.substring("redoUntilEdit.".length).trim();
                    if (!((editNum === ("null")) || (editNum === ("")))){
                        let eNum: number = -1;
                        try {
                            eNum = javaemul.internal.IntegerHelper.parseInt(editNum);
                        } catch(ex) {
                            this.mErrors.reportError("\'" + editNum + "\' is not a valid integer. Edit number must be a positive integer.", []);
                        }
                        if (eNum <= 0){
                            this.mErrors.reportError("Edit number must be a positive integer.", []);
                        } else {
                            this.model.redoAll(eNum);
                        }
                    }
                } else super.doAction(action);
                break;
            }
        }
    }
    UndoRedoController["__class"] = "com.vzome.desktop.controller.UndoRedoController";
    UndoRedoController["__interfaces"] = ["com.vzome.desktop.api.Controller"];


}
namespace com.vzome.desktop.controller {
    export class MeasureController extends com.vzome.desktop.controller.DefaultController implements com.vzome.core.editor.SelectionSummary.Listener {
        /*private*/ selection: com.vzome.core.editor.api.Selection;

        /*private*/ editorModel: com.vzome.core.editor.api.EditorModel;

        /*private*/ measurements: java.util.Map<string, string>;

        /*private*/ renderedModel: com.vzome.core.render.RenderedModel;

        /*private*/ twoPlaces: java.text.NumberFormat;

        /*private*/ fourPlaces: java.text.NumberFormat;

        public constructor(model: com.vzome.core.editor.api.EditorModel, renderedModel: com.vzome.core.render.RenderedModel) {
            super();
            if (this.selection === undefined) { this.selection = null; }
            if (this.editorModel === undefined) { this.editorModel = null; }
            this.measurements = <any>(new java.util.LinkedHashMap<any, any>());
            if (this.renderedModel === undefined) { this.renderedModel = null; }
            this.twoPlaces = java.text.NumberFormat.getInstance();
            this.fourPlaces = java.text.NumberFormat.getInstance();
            this.renderedModel = renderedModel;
            this.selection = model.getSelection();
            this.editorModel = model;
            model.addSelectionSummaryListener(this);
            this.twoPlaces.setMaximumFractionDigits(2);
            this.fourPlaces.setMaximumFractionDigits(4);
        }

        /**
         * 
         * @param {string} listName
         * @return {java.lang.String[]}
         */
        public getCommandList(listName: string): string[] {
            return this.measurements.keySet().toArray<any>((s => { let a=[]; while(s-->0) a.push(null); return a; })(this.measurements.keySet().size()));
        }

        /**
         * 
         * @param {string} key
         * @return {string}
         */
        public getProperty(key: string): string {
            return this.measurements.get(key);
        }

        /**
         * 
         * @param {number} total
         * @param {number} balls
         * @param {number} struts
         * @param {number} panels
         */
        public selectionChanged(total: number, balls: number, struts: number, panels: number) {
            this.measurements.clear();
            if (total !== 0){
                if (balls !== 0){
                    this.measurements.put("balls", /* toString */(''+(balls)));
                }
                if (struts !== 0){
                    this.measurements.put("struts", /* toString */(''+(struts)));
                }
                if (panels !== 0){
                    this.measurements.put("panels", /* toString */(''+(panels)));
                }
                if (total === 1 || total === 2){
                    this.measurements.put("", "");
                }
                if (total === 1){
                    if (panels === 1){
                        const panel: com.vzome.core.model.Panel = com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable(this.selection).next();
                        this.measurements.put("vertices", /* toString */(''+(panel.getVertexCount())));
                    } else if (struts === 1){
                        const strut: com.vzome.core.model.Strut = com.vzome.core.editor.api.Manifestations.getStruts$java_lang_Iterable(this.selection).next();
                        const cm: number = this.renderedModel.measureLengthCm$com_vzome_core_model_Strut(strut);
                        this.measurements.put("length (cm)", this.twoPlaces.format(cm) + " cm");
                        const inches: number = cm / 2.54;
                        this.measurements.put("length (in)", this.twoPlaces.format(inches) + " in");
                        const offset: com.vzome.core.algebra.AlgebraicVector = strut.getOffset();
                        this.measurements.put("quadrance", offset.dot(offset).toString(com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT));
                    } else if (balls === 1){
                        const conn: com.vzome.core.model.Connector = com.vzome.core.editor.api.Manifestations.getConnectors$java_lang_Iterable(this.selection).next();
                        this.measurements.put("location", conn.getLocation().toString());
                    }
                } else if (total === 2){
                    if (panels === 2){
                        let p1: com.vzome.core.model.Panel = null;
                        let p2: com.vzome.core.model.Panel = null;
                        for(let index=com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable(this.selection).iterator();index.hasNext();) {
                            let panel = index.next();
                            {
                                if (p1 == null)p1 = panel; else p2 = panel;
                            }
                        }
                        const radians: number = this.renderedModel.measureDihedralAngle(p1, p2);
                        this.reportAngles(radians);
                    } else if (struts === 2){
                        let s1: com.vzome.core.model.Strut = null;
                        let s2: com.vzome.core.model.Strut = null;
                        for(let index=com.vzome.core.editor.api.Manifestations.getStruts$java_lang_Iterable(this.selection).iterator();index.hasNext();) {
                            let strut = index.next();
                            {
                                if (s1 == null)s1 = strut; else s2 = strut;
                            }
                        }
                        const points: java.util.Set<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.HashSet<any>());
                        points.add(s1.getLocation());
                        points.add(s1.getEnd());
                        points.add(s2.getLocation());
                        points.add(s2.getEnd());
                        if (points.size() > 3){
                            this.measurements.put("coplanar", com.vzome.core.algebra.AlgebraicVectors.areCoplanar(points) ? "yes" : "no");
                        }
                        const radians: number = this.renderedModel.measureAngle(s1, s2);
                        this.reportAngles(radians);
                        this.reportSpread(s1, s2);
                        this.reportRatio(s1, s2);
                    } else if (balls === 2){
                        let b1: com.vzome.core.model.Connector = null;
                        let b2: com.vzome.core.model.Connector = null;
                        for(let index=com.vzome.core.editor.api.Manifestations.getConnectors$java_lang_Iterable(this.selection).iterator();index.hasNext();) {
                            let conn = index.next();
                            {
                                if (b1 == null)b1 = conn; else b2 = conn;
                            }
                        }
                        const cm: number = this.renderedModel.measureDistanceCm(b1, b2);
                        this.measurements.put("distance (cm)", this.twoPlaces.format(cm) + " cm");
                        const inches: number = cm / 2.54;
                        this.measurements.put("distance (in)", this.twoPlaces.format(inches) + " in");
                    }
                }
            }
            this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("measures", false, true);
        }

        /*private*/ reportAngles(radians: number) {
            if (/* isFinite */((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(radians)){
                const fraction: number = radians / Math.PI;
                const supplement: number = 1.0 - fraction;
                this.measurements.put("radians", this.fourPlaces.format(fraction) + "\u03c0");
                this.measurements.put("radians (supplement)", this.fourPlaces.format(supplement) + "\u03c0");
                this.measurements.put("degrees", this.twoPlaces.format(fraction * 180) + "\u00b0");
                this.measurements.put("degrees (supplement)", this.twoPlaces.format(supplement * 180) + "\u00b0");
            } else {
                this.measurements.put("angle", /* toString */(''+(radians)));
            }
        }

        /**
         * Use Rational Trigonometry (the cross law) to compute the spread between struts
         * @param {*} s1
         * @param {*} s2
         * @private
         */
        /*private*/ reportSpread(s1: com.vzome.core.model.Strut, s2: com.vzome.core.model.Strut) {
            const v1: com.vzome.core.algebra.AlgebraicVector = s1.getOffset();
            const v2: com.vzome.core.algebra.AlgebraicVector = s2.getOffset();
            const v3: com.vzome.core.algebra.AlgebraicVector = v2.minus(v1);
            const Q1: com.vzome.core.algebra.AlgebraicNumber = v2.dot(v2);
            const Q2: com.vzome.core.algebra.AlgebraicNumber = v1.dot(v1);
            const Q3: com.vzome.core.algebra.AlgebraicNumber = v3.dot(v3);
            const one: com.vzome.core.algebra.AlgebraicNumber = Q1.getField().one();
            const four: com.vzome.core.algebra.AlgebraicNumber = Q1.getField()['createRational$long'](4);
            const a: com.vzome.core.algebra.AlgebraicNumber = Q1['plus$com_vzome_core_algebra_AlgebraicNumber'](Q2)['minus$com_vzome_core_algebra_AlgebraicNumber'](Q3);
            const denom: com.vzome.core.algebra.AlgebraicNumber = four['times$com_vzome_core_algebra_AlgebraicNumber'](Q1)['times$com_vzome_core_algebra_AlgebraicNumber'](Q2);
            const ratio: com.vzome.core.algebra.AlgebraicNumber = a['times$com_vzome_core_algebra_AlgebraicNumber'](a).dividedBy(denom);
            const spread3: com.vzome.core.algebra.AlgebraicNumber = one['minus$com_vzome_core_algebra_AlgebraicNumber'](ratio);
            this.measurements.put("spread", spread3.toString(com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT));
        }

        /*private*/ reportRatio(s1: com.vzome.core.model.Strut, s2: com.vzome.core.model.Strut) {
            const v1: com.vzome.core.algebra.AlgebraicVector = s1.getOffset();
            const v2: com.vzome.core.algebra.AlgebraicVector = s2.getOffset();
            const ss: com.vzome.core.editor.api.OrbitSource = this.editorModel['getSymmetrySystem$']();
            const axis1: com.vzome.core.math.symmetry.Axis = ss.getAxis(v1);
            const axis2: com.vzome.core.math.symmetry.Axis = ss.getAxis(v2);
            const dir1: com.vzome.core.math.symmetry.Direction = axis1.getDirection();
            const dir2: com.vzome.core.math.symmetry.Direction = axis2.getDirection();
            const sameOrbit: boolean = dir1.equals(dir2);
            let name1: string = dir1.getName();
            let name2: string = dir2.getName();
            const auto: string = "auto";
            if (dir1.isAutomatic()){
                name1 = auto + name1;
            }
            if (dir2.isAutomatic()){
                name2 = auto + name2;
            }
            if (sameOrbit){
                name1 += "\u2081";
                name2 += "\u2082";
            }
            const n1n2: string = name1 + " / " + name2;
            const n2n1: string = name2 + " / " + name1;
            this.measurements.put(" ", " ");
            const len1: number = ss.getSymmetry().embedInR3(v1).length();
            const len2: number = ss.getSymmetry().embedInR3(v2).length();
            const length1: number = /* floatValue */len1;
            const length2: number = /* floatValue */len2;
            const ratio: number = (<any>Math).fround(length1 / length2);
            let comparison: string = "equal";
            if (Math.abs((<any>Math).fround(length1 - length2)) > 1.0E-6){
                comparison = name1 + " " + (length1 > length2 ? ">" : "<") + " " + name2;
            }
            this.measurements.put("relative strut lengths", comparison);
            if (!(comparison === ("equal"))){
                const recip: number = (<any>Math).fround(1.0 / ratio);
                this.measurements.put(n1n2 + " (approx)", this.fourPlaces.format(ratio));
                this.measurements.put(n2n1 + " (approx)", this.fourPlaces.format(recip));
                if (sameOrbit){
                    const exactLength1: com.vzome.core.algebra.AlgebraicNumber = axis1.getLength(v1);
                    const exactength2: com.vzome.core.algebra.AlgebraicNumber = axis2.getLength(v2);
                    const exactRatio: com.vzome.core.algebra.AlgebraicNumber = exactLength1.dividedBy(exactength2);
                    const exactRecip: com.vzome.core.algebra.AlgebraicNumber = exactRatio.reciprocal();
                    this.measurements.put(n1n2, exactRatio.toString(com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT));
                    this.measurements.put(n2n1, exactRecip.toString(com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT));
                }
            }
        }
    }
    MeasureController["__class"] = "com.vzome.desktop.controller.MeasureController";
    MeasureController["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.desktop.api.Controller"];


}
namespace com.vzome.desktop.controller {
    export class ToolController extends com.vzome.desktop.controller.DefaultController {
        /*private*/ tool: com.vzome.api.Tool;

        /*private*/ selectOutputs: boolean;

        /*private*/ justSelect: boolean;

        public constructor(tool: com.vzome.api.Tool) {
            super();
            if (this.tool === undefined) { this.tool = null; }
            if (this.selectOutputs === undefined) { this.selectOutputs = false; }
            if (this.justSelect === undefined) { this.justSelect = false; }
            this.tool = tool;
            this.selectOutputs = true;
            this.justSelect = false;
        }

        /**
         * 
         * @param {string} action
         */
        public doAction(action: string) {
            const selectInputs: boolean = this.tool.isSelectInputs();
            let deleteInputs: boolean = this.tool.isDeleteInputs();
            let copyColors: boolean = this.tool.isCopyColors();
            switch((action)) {
            case "apply":
                const createOutputs: boolean = !this.justSelect;
                this.tool.apply(selectInputs, deleteInputs, createOutputs, this.selectOutputs, copyColors);
                break;
            case "hideTool":
                this.tool.setHidden(true);
                break;
            case "selectParams":
                this.tool.selectParameters();
                break;
            case "selectInputs":
                this.tool.setInputBehaviors(!selectInputs, deleteInputs);
                this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("selectInputs", null, javaemul.internal.BooleanHelper.toString(this.tool.isSelectInputs()));
                break;
            case "deleteInputs":
                deleteInputs = !deleteInputs;
                this.tool.setInputBehaviors(selectInputs && !deleteInputs, deleteInputs);
                if (deleteInputs){
                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("selectInputs", null, "false");
                }
                this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("deleteInputs", null, javaemul.internal.BooleanHelper.toString(deleteInputs));
                break;
            case "copyColors":
                copyColors = !copyColors;
                this.tool.setCopyColors(copyColors);
                this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("copyColors", null, javaemul.internal.BooleanHelper.toString(copyColors));
                break;
            case "selectOutputs":
                this.selectOutputs = !this.selectOutputs;
                this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("selectOutputs", null, javaemul.internal.BooleanHelper.toString(this.selectOutputs));
                break;
            case "createOutputs":
                this.justSelect = !this.justSelect;
                if (this.justSelect){
                    this.selectOutputs = true;
                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("selectOutputs", null, "true");
                }
                this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("createOutputs", null, javaemul.internal.BooleanHelper.toString(!this.justSelect));
                break;
            default:
                super.doAction(action);
            }
        }

        /**
         * 
         * @param {string} name
         * @return {string}
         */
        public getProperty(name: string): string {
            switch((name)) {
            case "id":
                return this.tool.getId();
            case "label":
                return this.tool.getLabel();
            case "kind":
                return this.tool.getCategory();
            case "predefined":
                return javaemul.internal.BooleanHelper.toString(this.tool.isPredefined());
            case "selectInputs":
                return javaemul.internal.BooleanHelper.toString(this.tool.isSelectInputs());
            case "deleteInputs":
                return javaemul.internal.BooleanHelper.toString(this.tool.isDeleteInputs());
            case "copyColors":
                return javaemul.internal.BooleanHelper.toString(this.tool.isCopyColors());
            case "selectOutputs":
                return javaemul.internal.BooleanHelper.toString(this.selectOutputs);
            case "createOutputs":
                return javaemul.internal.BooleanHelper.toString(!this.justSelect);
            default:
                return super.getProperty(name);
            }
        }

        /**
         * 
         * @param {string} name
         * @param {*} value
         */
        public setModelProperty(name: string, value: any) {
            switch((name)) {
            case "label":
                this.tool.setLabel(<string>value);
                this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("label", null, <string>value);
                return;
            default:
                super.setModelProperty(name, value);
            }
        }
    }
    ToolController["__class"] = "com.vzome.desktop.controller.ToolController";
    ToolController["__interfaces"] = ["com.vzome.desktop.api.Controller"];


}
namespace com.vzome.desktop.controller {
    export class PartsController extends com.vzome.desktop.controller.DefaultController implements com.vzome.core.render.RenderingChanges {
        /*private*/ oldOrbits: com.vzome.core.editor.api.OrbitSource;

        /*private*/ newOrbits: com.vzome.core.editor.api.OrbitSource;

        public constructor(orbits: com.vzome.core.editor.api.OrbitSource) {
            super();
            if (this.oldOrbits === undefined) { this.oldOrbits = null; }
            if (this.newOrbits === undefined) { this.newOrbits = null; }
            this.oldOrbits = orbits;
            this.newOrbits = orbits;
        }

        public startSwitch(switchTo: com.vzome.core.editor.api.OrbitSource) {
            this.newOrbits = switchTo;
        }

        public endSwitch() {
            this.oldOrbits = this.newOrbits;
        }

        /**
         * 
         * @param {com.vzome.core.render.RenderedManifestation} rendered
         */
        public manifestationAdded(rendered: com.vzome.core.render.RenderedManifestation) {
            this.fireManifestationCountChanged("add", rendered, this.newOrbits);
        }

        /**
         * 
         * @param {com.vzome.core.render.RenderedManifestation} rendered
         */
        public manifestationRemoved(rendered: com.vzome.core.render.RenderedManifestation) {
            this.fireManifestationCountChanged("remove", rendered, this.oldOrbits);
        }

        fireManifestationCountChanged(action: string, rendered: com.vzome.core.render.RenderedManifestation, orbitSource: com.vzome.core.editor.api.OrbitSource) {
            const man: com.vzome.core.model.Manifestation = rendered.getManifestation();
            let partTypeName: string = null;
            let partInfo: PartsController.PartInfo = null;
            if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                partTypeName = "Ball";
                partInfo = new PartsController.PartInfo(<com.vzome.core.model.Connector><any>man);
            } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                partTypeName = "Strut";
                const length: com.vzome.core.algebra.AlgebraicNumber = rendered.getShape().getLength();
                partInfo = new PartsController.PartInfo(<com.vzome.core.model.Strut><any>man, orbitSource, length);
            } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                partTypeName = "Panel";
                partInfo = new PartsController.PartInfo(<com.vzome.core.model.Panel><any>man, orbitSource);
            }
            if (partTypeName != null && partInfo != null){
                const propertyName: string = action + partTypeName;
                switch((action)) {
                case "add":
                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propertyName, null, partInfo);
                    break;
                case "remove":
                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propertyName, partInfo, null);
                    break;
                default:
                    throw new java.lang.IllegalArgumentException("Unsupported action: " + (action == null ? "<null>" : action) + ".");
                }
            }
        }

        /**
         * 
         */
        public reset() {
        }

        /**
         * 
         * @param {com.vzome.core.render.RenderedManifestation} from
         * @param {com.vzome.core.render.RenderedManifestation} to
         */
        public manifestationSwitched(from: com.vzome.core.render.RenderedManifestation, to: com.vzome.core.render.RenderedManifestation) {
        }

        /**
         * 
         * @param {com.vzome.core.render.RenderedManifestation} manifestation
         */
        public glowChanged(manifestation: com.vzome.core.render.RenderedManifestation) {
        }

        /**
         * 
         * @param {com.vzome.core.render.RenderedManifestation} manifestation
         */
        public colorChanged(manifestation: com.vzome.core.render.RenderedManifestation) {
        }

        /**
         * 
         * @param {com.vzome.core.render.RenderedManifestation} manifestation
         */
        public labelChanged(manifestation: com.vzome.core.render.RenderedManifestation) {
        }

        /**
         * 
         * @param {com.vzome.core.render.RenderedManifestation} manifestation
         */
        public locationChanged(manifestation: com.vzome.core.render.RenderedManifestation) {
        }

        /**
         * 
         * @param {com.vzome.core.render.RenderedManifestation} manifestation
         */
        public orientationChanged(manifestation: com.vzome.core.render.RenderedManifestation) {
        }

        /**
         * 
         * @param {com.vzome.core.render.RenderedManifestation} manifestation
         */
        public shapeChanged(manifestation: com.vzome.core.render.RenderedManifestation) {
        }

        /**
         * 
         * @param {*} shapes
         * @return {boolean}
         */
        public shapesChanged(shapes: com.vzome.core.editor.api.Shapes): boolean {
            return false;
        }
    }
    PartsController["__class"] = "com.vzome.desktop.controller.PartsController";
    PartsController["__interfaces"] = ["com.vzome.core.render.RenderingChanges","com.vzome.desktop.api.Controller"];



    export namespace PartsController {

        /**
         * PartInfo is passed to the PartsPanel in the PropertyChangeEvent.
         * @param {string} name
         * @param {java.lang.Class} partType
         * @class
         */
        export class PartInfo {
            public orbitStr: string;

            public rgbColor: number;

            public sizeNameStr: string;

            public lengthStr: string;

            public strutLength: com.vzome.core.algebra.AlgebraicNumber;

            public automaticDirectionIndex: number;

            public realLength: number;

            public partClass: any;

            public constructor(strut?: any, orbits?: any, length?: any) {
                if (((strut != null && (strut.constructor != null && strut.constructor["__interfaces"] != null && strut.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || strut === null) && ((orbits != null && (orbits.constructor != null && orbits.constructor["__interfaces"] != null && orbits.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.OrbitSource") >= 0)) || orbits === null) && ((length != null && (length.constructor != null && length.constructor["__interfaces"] != null && length.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || length === null)) {
                    let __args = arguments;
                    if (this.orbitStr === undefined) { this.orbitStr = null; } 
                    if (this.rgbColor === undefined) { this.rgbColor = 0; } 
                    if (this.sizeNameStr === undefined) { this.sizeNameStr = null; } 
                    if (this.lengthStr === undefined) { this.lengthStr = null; } 
                    if (this.strutLength === undefined) { this.strutLength = null; } 
                    if (this.automaticDirectionIndex === undefined) { this.automaticDirectionIndex = null; } 
                    if (this.realLength === undefined) { this.realLength = null; } 
                    if (this.partClass === undefined) { this.partClass = null; } 
                    const orbit: com.vzome.core.math.symmetry.Direction = (<com.vzome.core.render.RenderedManifestation><any>(<com.vzome.core.model.StrutImpl><any>strut).getRenderedObject()).getStrutOrbit();
                    this.orbitStr = orbit.getName();
                    this.rgbColor = orbits.getColor(orbit).getRGB();
                    const buf: java.lang.StringBuffer = new java.lang.StringBuffer();
                    orbit.getLengthExpression(buf, length);
                    const lengthExpression: string = buf.toString();
                    const tokens: java.util.StringTokenizer = new java.util.StringTokenizer(lengthExpression, ":");
                    this.sizeNameStr = tokens.nextToken();
                    this.lengthStr = tokens.nextToken();
                    this.strutLength = length;
                    this.automaticDirectionIndex = orbit.isAutomatic() ? javaemul.internal.IntegerHelper.parseInt(this.orbitStr) : -1;
                    this.realLength = length.evaluate();
                    this.partClass = (<any>strut.constructor);
                } else if (((typeof strut === 'string') || strut === null) && ((orbits != null && (orbits["__class"] != null || ((t) => { try { new t; return true; } catch { return false; } })(orbits))) || orbits === null) && length === undefined) {
                    let __args = arguments;
                    let name: any = __args[0];
                    let partType: any = __args[1];
                    if (this.orbitStr === undefined) { this.orbitStr = null; } 
                    if (this.rgbColor === undefined) { this.rgbColor = 0; } 
                    if (this.sizeNameStr === undefined) { this.sizeNameStr = null; } 
                    if (this.lengthStr === undefined) { this.lengthStr = null; } 
                    if (this.strutLength === undefined) { this.strutLength = null; } 
                    if (this.automaticDirectionIndex === undefined) { this.automaticDirectionIndex = null; } 
                    if (this.realLength === undefined) { this.realLength = null; } 
                    if (this.partClass === undefined) { this.partClass = null; } 
                    this.orbitStr = "";
                    this.rgbColor = com.vzome.core.construction.Color.WHITE_$LI$().getRGB();
                    this.sizeNameStr = name;
                    this.lengthStr = "";
                    this.strutLength = null;
                    this.automaticDirectionIndex = -1;
                    this.realLength = 0.0;
                    this.partClass = partType;
                } else if (((strut != null && (strut.constructor != null && strut.constructor["__interfaces"] != null && strut.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) || strut === null) && ((orbits != null && (orbits.constructor != null && orbits.constructor["__interfaces"] != null && orbits.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.OrbitSource") >= 0)) || orbits === null) && length === undefined) {
                    let __args = arguments;
                    let panel: any = __args[0];
                    if (this.orbitStr === undefined) { this.orbitStr = null; } 
                    if (this.rgbColor === undefined) { this.rgbColor = 0; } 
                    if (this.sizeNameStr === undefined) { this.sizeNameStr = null; } 
                    if (this.lengthStr === undefined) { this.lengthStr = null; } 
                    if (this.strutLength === undefined) { this.strutLength = null; } 
                    if (this.automaticDirectionIndex === undefined) { this.automaticDirectionIndex = null; } 
                    if (this.realLength === undefined) { this.realLength = null; } 
                    if (this.partClass === undefined) { this.partClass = null; } 
                    let orbitName: string = "";
                    let color: com.vzome.core.construction.Color = com.vzome.core.construction.Color.WHITE_$LI$();
                    let autoDirIdx: number = -1;
                    const normal: com.vzome.core.algebra.AlgebraicVector = panel['getNormal$']();
                    if (!normal.isOrigin()){
                        const axis: com.vzome.core.math.symmetry.Axis = orbits.getAxis(normal);
                        if (axis != null){
                            const orbit: com.vzome.core.math.symmetry.Direction = axis.getDirection();
                            orbitName = orbit.getName();
                            color = orbits.getColor(orbit);
                            if (orbit.isAutomatic()){
                                autoDirIdx = javaemul.internal.IntegerHelper.parseInt(orbitName);
                            }
                        }
                    }
                    this.orbitStr = orbitName;
                    this.rgbColor = color.getRGB();
                    this.sizeNameStr = "";
                    this.lengthStr = "";
                    this.strutLength = null;
                    this.automaticDirectionIndex = autoDirIdx;
                    this.realLength = 0.0;
                    this.partClass = (<any>panel.constructor);
                } else if (((strut != null && (strut.constructor != null && strut.constructor["__interfaces"] != null && strut.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || strut === null) && orbits === undefined && length === undefined) {
                    let __args = arguments;
                    let ball: any = __args[0];
                    if (this.orbitStr === undefined) { this.orbitStr = null; } 
                    if (this.rgbColor === undefined) { this.rgbColor = 0; } 
                    if (this.sizeNameStr === undefined) { this.sizeNameStr = null; } 
                    if (this.lengthStr === undefined) { this.lengthStr = null; } 
                    if (this.strutLength === undefined) { this.strutLength = null; } 
                    if (this.automaticDirectionIndex === undefined) { this.automaticDirectionIndex = null; } 
                    if (this.realLength === undefined) { this.realLength = null; } 
                    if (this.partClass === undefined) { this.partClass = null; } 
                    this.orbitStr = "";
                    this.rgbColor = com.vzome.core.construction.Color.WHITE_$LI$().getRGB();
                    this.sizeNameStr = "";
                    this.lengthStr = "";
                    this.strutLength = null;
                    this.automaticDirectionIndex = -1;
                    this.realLength = 0.0;
                    this.partClass = (<any>ball.constructor);
                } else throw new Error('invalid overload');
            }
        }
        PartInfo["__class"] = "com.vzome.desktop.controller.PartsController.PartInfo";

    }

}
namespace com.vzome.desktop.controller {
    export class ToolFactoryController extends com.vzome.desktop.controller.DefaultController implements java.beans.PropertyChangeListener {
        /*private*/ factory: com.vzome.api.Tool.Factory;

        public constructor(factory: com.vzome.api.Tool.Factory) {
            super();
            if (this.factory === undefined) { this.factory = null; }
            this.factory = factory;
            factory.addListener(this);
        }

        /**
         * 
         * @param {java.beans.PropertyChangeEvent} evt
         */
        public propertyChange(evt: java.beans.PropertyChangeEvent) {
            switch((evt.getPropertyName())) {
            case "enabled":
                this.firePropertyChange$java_beans_PropertyChangeEvent(evt);
                break;
            default:
                break;
            }
        }

        /**
         * 
         * @param {string} name
         * @return {string}
         */
        public getProperty(name: string): string {
            switch((name)) {
            case "title":
                return this.factory.getLabel();
            case "tooltip":
                return this.factory.getToolTip();
            case "enabled":
                return javaemul.internal.BooleanHelper.toString(this.factory.isEnabled());
            default:
                return super.getProperty(name);
            }
        }

        /**
         * 
         * @param {string} action
         */
        public doAction(action: string) {
            switch((action)) {
            case "createTool":
                this.factory.createTool();
                break;
            default:
                super.doAction(action);
            }
        }
    }
    ToolFactoryController["__class"] = "com.vzome.desktop.controller.ToolFactoryController";
    ToolFactoryController["__interfaces"] = ["java.util.EventListener","java.beans.PropertyChangeListener","com.vzome.desktop.api.Controller"];


}
namespace com.vzome.desktop.controller {
    export class SymmetryController extends com.vzome.desktop.controller.DefaultController {
        /**
         * 
         * @param {string} string
         * @return {string}
         */
        public getProperty(string: string): string {
            switch((string)) {
            case "label":
                return this.label;
            case "name":
                return this.symmetrySystem.getName();
            case "renderingStyle":
                return this.symmetrySystem.getStyle$().getName();
            case "modelResourcePath":
                return this.symmetrySystem.getModelResourcePath();
            default:
                if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(string, "orbitColor.")){
                    const name: string = string.substring("orbitColor.".length);
                    const dir: com.vzome.core.math.symmetry.Direction = this.buildOrbits.getDirection(name);
                    const color: com.vzome.core.construction.Color = this.getColor(dir);
                    return color.toString();
                }
                return super.getProperty(string);
            }
        }

        /*private*/ symmetrySystem: com.vzome.core.editor.SymmetrySystem;

        public availableOrbits: com.vzome.core.math.symmetry.OrbitSet;

        public snapOrbits: com.vzome.core.math.symmetry.OrbitSet;

        public buildOrbits: com.vzome.core.math.symmetry.OrbitSet;

        public renderOrbits: com.vzome.core.math.symmetry.OrbitSet;

        /*private*/ snapper: com.vzome.desktop.controller.OrbitSnapper;

        public availableController: com.vzome.desktop.controller.OrbitSetController;

        public snapController: com.vzome.desktop.controller.OrbitSetController;

        public buildController: com.vzome.desktop.controller.OrbitSetController;

        public renderController: com.vzome.desktop.controller.OrbitSetController;

        public orbitLengths: java.util.Map<com.vzome.core.math.symmetry.Direction, com.vzome.desktop.api.Controller>;

        /*private*/ symmetryToolFactories: java.util.Map<string, com.vzome.desktop.api.Controller>;

        /*private*/ transformToolFactories: java.util.Map<string, com.vzome.desktop.api.Controller>;

        /*private*/ linearMapToolFactories: java.util.Map<string, com.vzome.desktop.api.Controller>;

        /*private*/ renderedModel: com.vzome.core.render.RenderedModel;

        /*private*/ label: string;

        public getSymmetry(): com.vzome.core.math.symmetry.Symmetry {
            return this.symmetrySystem.getSymmetry();
        }

        public getSnapper(): com.vzome.desktop.controller.OrbitSnapper {
            return this.snapper;
        }

        public constructor(label: string, parent: com.vzome.desktop.api.Controller, model: com.vzome.core.editor.SymmetrySystem, mRenderedModel: com.vzome.core.render.RenderedModel) {
            super();
            if (this.symmetrySystem === undefined) { this.symmetrySystem = null; }
            if (this.availableOrbits === undefined) { this.availableOrbits = null; }
            if (this.snapOrbits === undefined) { this.snapOrbits = null; }
            if (this.buildOrbits === undefined) { this.buildOrbits = null; }
            if (this.renderOrbits === undefined) { this.renderOrbits = null; }
            if (this.snapper === undefined) { this.snapper = null; }
            if (this.availableController === undefined) { this.availableController = null; }
            if (this.snapController === undefined) { this.snapController = null; }
            if (this.buildController === undefined) { this.buildController = null; }
            if (this.renderController === undefined) { this.renderController = null; }
            this.orbitLengths = <any>(new java.util.HashMap<any, any>());
            this.symmetryToolFactories = <any>(new java.util.LinkedHashMap<any, any>());
            this.transformToolFactories = <any>(new java.util.LinkedHashMap<any, any>());
            this.linearMapToolFactories = <any>(new java.util.LinkedHashMap<any, any>());
            if (this.renderedModel === undefined) { this.renderedModel = null; }
            if (this.label === undefined) { this.label = null; }
            this.label = label;
            this.symmetrySystem = model;
            this.renderedModel = mRenderedModel;
            const symmetry: com.vzome.core.math.symmetry.Symmetry = model.getSymmetry();
            this.availableOrbits = new com.vzome.core.math.symmetry.OrbitSet(symmetry);
            this.snapOrbits = new com.vzome.core.math.symmetry.OrbitSet(symmetry);
            this.buildOrbits = new com.vzome.core.math.symmetry.OrbitSet(symmetry);
            this.renderOrbits = new com.vzome.core.math.symmetry.OrbitSet(symmetry);
            this.snapper = new com.vzome.desktop.controller.SymmetrySnapper(this.snapOrbits);
            for(let index=symmetry.getOrbitSet().getDirections().iterator();index.hasNext();) {
                let orbit = index.next();
                {
                    if (model.orbitIsStandard(orbit)){
                        this.availableOrbits.add(orbit);
                        this.snapOrbits.add(orbit);
                        if (model.orbitIsBuildDefault(orbit)){
                            this.buildOrbits.add(orbit);
                        }
                    }
                    this.renderOrbits.add(orbit);
                }
            }
            this.availableController = new com.vzome.desktop.controller.OrbitSetController(this.availableOrbits, this.symmetrySystem.getOrbits(), this.symmetrySystem);
            this.addSubController("availableOrbits", this.availableController);
            this.snapController = new com.vzome.desktop.controller.OrbitSetController(this.snapOrbits, this.availableOrbits, this.symmetrySystem);
            this.addSubController("snapOrbits", this.snapController);
            this.buildController = new com.vzome.desktop.controller.OrbitSetController(this.buildOrbits, this.availableOrbits, this.symmetrySystem);
            this.addSubController("buildOrbits", this.buildController);
            if (parent.propertyIsTrue("single.orbit"))try {
                this.buildController.doAction("oneAtATime");
            } catch(e) {
                console.error(e.message, e);
            }
            this.renderController = new com.vzome.desktop.controller.OrbitSetController(this.renderOrbits, this.symmetrySystem.getOrbits(), this.symmetrySystem);
            this.addSubController("renderOrbits", this.renderController);
            for(let index=this.symmetrySystem.getOrbits().getDirections().iterator();index.hasNext();) {
                let orbit = index.next();
                {
                    const unitLength: com.vzome.core.algebra.AlgebraicNumber = this.symmetrySystem.getOrbitUnitLength(orbit);
                    const field: com.vzome.core.algebra.AlgebraicField = symmetry.getField();
                    const lengthModel: com.vzome.desktop.api.Controller = new com.vzome.desktop.controller.LengthController(unitLength, field.one(), field);
                    this.buildController.addSubController("length." + orbit.getName(), lengthModel);
                    this.orbitLengths.put(orbit, lengthModel);
                }
            }
            if (parent.propertyIsTrue("disable.known.directions"))this.symmetrySystem.disableKnownDirection();
            this.availableController.addPropertyListener(this.buildController);
            this.availableController.addPropertyListener(this.snapController);
            this.availableController.addPropertyListener(new SymmetryController.SymmetryController$0(this));
            const presetStyle: string = parent.getProperty("defaultShapes." + model.getSymmetry().getField().getName() + "." + model.getName());
            if (presetStyle != null)this.symmetrySystem.setStyle(presetStyle);
        }

        /**
         * 
         * @param {string} listName
         * @return {java.lang.String[]}
         */
        public getCommandList(listName: string): string[] {
            switch((listName)) {
            case "styles":
                return this.symmetrySystem.getStyleNames();
            case "orbits":
                const result: string[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.symmetrySystem.getOrbits().size());
                let i: number = 0;
                for(let index=this.symmetrySystem.getOrbits().getDirections().iterator();index.hasNext();) {
                    let orbit = index.next();
                    {
                        result[i] = orbit.getName();
                        i++;
                    }
                }
                return result;
            case "symmetryToolFactories":
                if (this.symmetryToolFactories.isEmpty()){
                    for(let index=this.symmetrySystem.getToolFactories(com.vzome.api.Tool.Kind.SYMMETRY).iterator();index.hasNext();) {
                        let factory = index.next();
                        this.symmetryToolFactories.put(factory.getId(), new com.vzome.desktop.controller.ToolFactoryController(factory))
                    }
                }
                return this.symmetryToolFactories.keySet().toArray<any>([]);
            case "transformToolFactories":
                if (this.transformToolFactories.isEmpty()){
                    for(let index=this.symmetrySystem.getToolFactories(com.vzome.api.Tool.Kind.TRANSFORM).iterator();index.hasNext();) {
                        let factory = index.next();
                        this.transformToolFactories.put(factory.getId(), new com.vzome.desktop.controller.ToolFactoryController(factory))
                    }
                }
                return this.transformToolFactories.keySet().toArray<any>([]);
            case "linearMapToolFactories":
                if (this.linearMapToolFactories.isEmpty()){
                    for(let index=this.symmetrySystem.getToolFactories(com.vzome.api.Tool.Kind.LINEAR_MAP).iterator();index.hasNext();) {
                        let factory = index.next();
                        this.linearMapToolFactories.put(factory.getId(), new com.vzome.desktop.controller.ToolFactoryController(factory))
                    }
                }
                return this.linearMapToolFactories.keySet().toArray<any>([]);
            case "builtInSymmetryTools":
                const toolNames: java.util.List<string> = <any>(new java.util.ArrayList<any>());
                for(let index=this.symmetrySystem.getPredefinedTools(com.vzome.api.Tool.Kind.SYMMETRY).iterator();index.hasNext();) {
                    let tool = index.next();
                    toolNames.add(tool.getId())
                }
                return toolNames.toArray<any>([]);
            case "builtInTransformTools":
                const transformToolNames: java.util.List<string> = <any>(new java.util.ArrayList<any>());
                for(let index=this.symmetrySystem.getPredefinedTools(com.vzome.api.Tool.Kind.TRANSFORM).iterator();index.hasNext();) {
                    let tool = index.next();
                    transformToolNames.add(tool.getId())
                }
                return transformToolNames.toArray<any>([]);
            default:
                return super.getCommandList(listName);
            }
        }

        /**
         * 
         * @param {string} name
         * @return {*}
         */
        public getSubController(name: string): com.vzome.desktop.api.Controller {
            switch((name)) {
            case "availableOrbits":
                return this.availableController;
            case "snapOrbits":
                return this.snapController;
            case "buildOrbits":
                return this.buildController;
            case "renderOrbits":
                return this.renderController;
            default:
                if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(name, "length.")){
                    const dirName: string = name.substring("length.".length);
                    const dir: com.vzome.core.math.symmetry.Direction = this.symmetrySystem.getOrbits().getDirection(dirName);
                    return this.getLengthController(dir);
                }
                let result: com.vzome.desktop.api.Controller = this.symmetryToolFactories.get(name);
                if (result != null)return result;
                result = this.transformToolFactories.get(name);
                if (result != null)return result;
                result = this.linearMapToolFactories.get(name);
                if (result != null)return result;
                return super.getSubController(name);
            }
        }

        /**
         * 
         * @param {string} action
         */
        public doAction(action: string) {
            switch((action)) {
            case "rZomeOrbits":
            case "predefinedOrbits":
            case "setAllDirections":
                this.availableController.doAction(action);
                break;
            case "ReplaceWithShape":
                action += "/" + this.symmetrySystem.getName() + ":" + this.symmetrySystem.getStyle$().getName();
                super.doAction(action);
                break;
            case "resetOrbitColors":
                this.symmetrySystem.resetColors();
                this.availableController.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("orbits", true, false);
                break;
            default:
                if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "setStyle.")){
                    const styleName: string = action.substring("setStyle.".length);
                    this.symmetrySystem.setStyle(styleName);
                    this.renderedModel.setShapes(this.symmetrySystem.getShapes());
                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("renderingStyle", null, styleName);
                } else {
                    const handled: boolean = this.symmetrySystem.doAction(action);
                    if (!handled)super.doAction(action);
                }
                break;
            }
        }

        /*private*/ getLengthController(orbit: com.vzome.core.math.symmetry.Direction): com.vzome.desktop.api.Controller {
            let result: com.vzome.desktop.api.Controller = this.orbitLengths.get(orbit);
            if (result == null && orbit != null){
                const unitLength: com.vzome.core.algebra.AlgebraicNumber = this.symmetrySystem.getOrbitUnitLength(orbit);
                const field: com.vzome.core.algebra.AlgebraicField = this.symmetrySystem.getSymmetry().getField();
                result = new com.vzome.desktop.controller.LengthController(unitLength, field.one(), field);
                this.buildController.addSubController("length." + orbit.getName(), result);
                this.orbitLengths.put(orbit, result);
                this.renderOrbits.add(orbit);
                this.availableOrbits.add(orbit);
            }
            return result;
        }

        public getOrbits(): com.vzome.core.math.symmetry.OrbitSet {
            return this.symmetrySystem.getOrbits();
        }

        public getOrbitSource(): com.vzome.core.editor.api.OrbitSource {
            return this.symmetrySystem;
        }

        public getZone(offset: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.math.symmetry.Axis {
            return this.symmetrySystem.getAxis(offset);
        }

        public getColor(orbit: com.vzome.core.math.symmetry.Direction): com.vzome.core.construction.Color {
            return this.symmetrySystem.getColor(orbit);
        }

        public getBuildOrbits(): com.vzome.core.math.symmetry.OrbitSet {
            return this.buildOrbits;
        }

        public getRenderingStyle(): com.vzome.core.editor.api.Shapes {
            return this.symmetrySystem.getRenderingStyle();
        }
    }
    SymmetryController["__class"] = "com.vzome.desktop.controller.SymmetryController";
    SymmetryController["__interfaces"] = ["com.vzome.desktop.api.Controller"];



    export namespace SymmetryController {

        export class SymmetryController$0 implements java.beans.PropertyChangeListener {
            public __parent: any;
            /**
             * 
             * @param {java.beans.PropertyChangeEvent} event
             */
            public propertyChange(event: java.beans.PropertyChangeEvent) {
                if ("orbits" === event.getPropertyName()){
                }
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }
        SymmetryController$0["__interfaces"] = ["java.util.EventListener","java.beans.PropertyChangeListener"];


    }

}
namespace com.vzome.desktop.controller {
    export class ToolsController extends com.vzome.desktop.controller.DefaultController implements java.beans.PropertyChangeListener {
        /*private*/ tools: com.vzome.core.editor.ToolsModel;

        public constructor(tools: com.vzome.core.editor.ToolsModel) {
            super();
            if (this.tools === undefined) { this.tools = null; }
            this.tools = tools;
            tools.addPropertyListener(this);
        }

        /**
         * 
         * @param {string} name
         * @return {*}
         */
        public getSubController(name: string): com.vzome.desktop.api.Controller {
            const tool: com.vzome.api.Tool = this.tools.get(name);
            if (tool != null){
                const controller: com.vzome.desktop.api.Controller = new com.vzome.desktop.controller.ToolController(tool);
                this.addSubController(name, controller);
                return controller;
            }
            return null;
        }

        public addTool(tool: com.vzome.api.Tool) {
            const controller: com.vzome.desktop.api.Controller = new com.vzome.desktop.controller.ToolController(tool);
            this.addSubController(tool.getId(), controller);
            this.firePropertyChange$java_beans_PropertyChangeEvent(new java.beans.PropertyChangeEvent(this, "tool.added", null, controller));
        }

        /**
         * 
         * @param {java.beans.PropertyChangeEvent} evt
         */
        public propertyChange(evt: java.beans.PropertyChangeEvent) {
            switch((evt.getPropertyName())) {
            case "customTools":
            case "customBookmarks":
                this.firePropertyChange$java_beans_PropertyChangeEvent(new java.beans.PropertyChangeEvent(this, evt.getPropertyName(), null, evt.getNewValue()));
                break;
            case "tool.instances":
                if (evt.getOldValue() == null){
                    const tool: com.vzome.api.Tool = <com.vzome.api.Tool><any>evt.getNewValue();
                    if (tool.isPredefined() || tool.isHidden())return;
                    const controller: com.vzome.desktop.api.Controller = new com.vzome.desktop.controller.ToolController(tool);
                    this.firePropertyChange$java_beans_PropertyChangeEvent(new java.beans.PropertyChangeEvent(this, "tool.added", null, controller));
                } else {
                    const tool: com.vzome.api.Tool = <com.vzome.api.Tool><any>evt.getOldValue();
                    this.firePropertyChange$java_beans_PropertyChangeEvent(new java.beans.PropertyChangeEvent(this, "tool.hidden", tool.getId(), null));
                }
                break;
            default:
                break;
            }
        }

        /**
         * 
         * @param {string} listName
         * @return {java.lang.String[]}
         */
        public getCommandList(listName: string): string[] {
            switch((listName)) {
            case "customTools":
                return this.tools.getToolIDs(false);
            case "customBookmarks":
                return this.tools.getToolIDs(true);
            default:
                break;
            }
            return super.getCommandList(listName);
        }
    }
    ToolsController["__class"] = "com.vzome.desktop.controller.ToolsController";
    ToolsController["__interfaces"] = ["java.util.EventListener","java.beans.PropertyChangeListener","com.vzome.desktop.api.Controller"];


}
namespace com.vzome.desktop.controller {
    export class LengthController extends com.vzome.desktop.controller.DefaultController {
        /**
         * This is a permanent adjustment of the scale slider.  When the scale reads 0 for the user,
         * the actual scale used internally will be SCALE_OFFSET.
         */
        public static SCALE_OFFSET: number; public static SCALE_OFFSET_$LI$(): number { if (LengthController.SCALE_OFFSET == null) { LengthController.SCALE_OFFSET = com.vzome.core.math.symmetry.Direction.USER_SCALE; }  return LengthController.SCALE_OFFSET; }

        currentScales: LengthController.ScaleController[];

        unitController: com.vzome.desktop.controller.NumberController;

        /**
         * This is the internal factor applied, determined by the orbit, and fixed.
         */
        fixedFactor: com.vzome.core.algebra.AlgebraicNumber;

        /**
         * This is the user's basis for scale... when the slider is centered on "unit", this is the length value.
         */
        unitFactor: com.vzome.core.algebra.AlgebraicNumber;

        multiplier: number;

        standardUnitFactor: com.vzome.core.algebra.AlgebraicNumber;

        /*private*/ half: boolean;

        field: com.vzome.core.algebra.AlgebraicField;

        public constructor(fixedFactor?: any, standardUnitFactor?: any, field?: any) {
            if (((fixedFactor != null && (fixedFactor.constructor != null && fixedFactor.constructor["__interfaces"] != null && fixedFactor.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || fixedFactor === null) && ((standardUnitFactor != null && (standardUnitFactor.constructor != null && standardUnitFactor.constructor["__interfaces"] != null && standardUnitFactor.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || standardUnitFactor === null) && ((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null)) {
                let __args = arguments;
                super();
                if (this.currentScales === undefined) { this.currentScales = null; } 
                if (this.unitController === undefined) { this.unitController = null; } 
                if (this.fixedFactor === undefined) { this.fixedFactor = null; } 
                if (this.unitFactor === undefined) { this.unitFactor = null; } 
                if (this.multiplier === undefined) { this.multiplier = 0; } 
                if (this.standardUnitFactor === undefined) { this.standardUnitFactor = null; } 
                if (this.field === undefined) { this.field = null; } 
                this.half = false;
                this.fixedFactor = fixedFactor;
                this.standardUnitFactor = standardUnitFactor;
                this.field = field;
                this.multiplier = 0;
                this.unitFactor = standardUnitFactor;
                this.currentScales = (s => { let a=[]; while(s-->0) a.push(null); return a; })(field.getNumMultipliers());
                for(let i: number = 0; i < this.currentScales.length; i++) {{
                    this.currentScales[i] = new LengthController.ScaleController(this);
                    this.addSubController("scale." + i, this.currentScales[i]);
                };}
                this.unitController = new com.vzome.desktop.controller.NumberController(field);
                this.addSubController("unit", this.unitController);
            } else if (((fixedFactor != null && (fixedFactor.constructor != null && fixedFactor.constructor["__interfaces"] != null && fixedFactor.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || fixedFactor === null) && standardUnitFactor === undefined && field === undefined) {
                let __args = arguments;
                let field: any = __args[0];
                {
                    let __args = arguments;
                    let fixedFactor: any = __args[2].one();
                    let standardUnitFactor: any = __args[2].one();
                    super();
                    if (this.currentScales === undefined) { this.currentScales = null; } 
                    if (this.unitController === undefined) { this.unitController = null; } 
                    if (this.fixedFactor === undefined) { this.fixedFactor = null; } 
                    if (this.unitFactor === undefined) { this.unitFactor = null; } 
                    if (this.multiplier === undefined) { this.multiplier = 0; } 
                    if (this.standardUnitFactor === undefined) { this.standardUnitFactor = null; } 
                    if (this.field === undefined) { this.field = null; } 
                    this.half = false;
                    this.fixedFactor = fixedFactor;
                    this.standardUnitFactor = standardUnitFactor;
                    this.field = field;
                    this.multiplier = 0;
                    this.unitFactor = standardUnitFactor;
                    this.currentScales = (s => { let a=[]; while(s-->0) a.push(null); return a; })(field.getNumMultipliers());
                    for(let i: number = 0; i < this.currentScales.length; i++) {{
                        this.currentScales[i] = new LengthController.ScaleController(this);
                        this.addSubController("scale." + i, this.currentScales[i]);
                    };}
                    this.unitController = new com.vzome.desktop.controller.NumberController(field);
                    this.addSubController("unit", this.unitController);
                }
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {string} name
         * @return {*}
         */
        public getSubController(name: string): com.vzome.desktop.api.Controller {
            switch((name)) {
            case "unit":
                return this.unitController;
            case "scale":
                return this.currentScales[this.multiplier];
            default:
                return super.getSubController(name);
            }
        }

        public fireLengthChange() {
            this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("length", true, false);
        }

        resetScales() {
            for(let i: number = 0; i < this.currentScales.length; i++) {{
                this.currentScales[i].setScale(0);
            };}
        }

        /**
         * 
         * @param {string} action
         */
        public doAction(action: string) {
            switch((action)) {
            case "setCustomUnit":
                this.unitController.setValue(this.unitFactor);
                return;
            case "getCustomUnit":
                this.unitFactor = this.unitController.getValue();
                this.resetScales();
                this.multiplier = 0;
                this.fireLengthChange();
                return;
            case "toggleHalf":
                {
                    this.half = !this.half;
                    this.fireLengthChange();
                    return;
                };
            case "reset":
            case "short":
                {
                    this.unitFactor = this.standardUnitFactor;
                    this.resetScales();
                    this.multiplier = 0;
                    this.fireLengthChange();
                    return;
                };
            case "supershort":
                {
                    this.unitFactor = this.standardUnitFactor;
                    this.resetScales();
                    this.currentScales[0].setScale(-1);
                    this.multiplier = 0;
                    this.fireLengthChange();
                    return;
                };
            case "medium":
                {
                    this.unitFactor = this.standardUnitFactor;
                    this.resetScales();
                    this.currentScales[0].setScale(1);
                    this.multiplier = 0;
                    this.fireLengthChange();
                    return;
                };
            case "long":
                {
                    this.unitFactor = this.standardUnitFactor;
                    this.resetScales();
                    this.currentScales[0].setScale(2);
                    this.multiplier = 0;
                    this.fireLengthChange();
                    return;
                };
            case "scaleUp":
            case "scaleDown":
                this.currentScales[this.multiplier].doAction(action);
                return;
            case "newZeroScale":
                {
                    this.unitFactor = this.applyScales(this.unitFactor);
                    this.resetScales();
                    this.multiplier = 0;
                    this.fireLengthChange();
                    return;
                };
            default:
                if (/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "setMultiplier.")){
                    action = action.substring("setMultiplier.".length);
                    const i: number = javaemul.internal.IntegerHelper.parseInt(action);
                    this.multiplier = i;
                    this.fireLengthChange();
                } else super.doAction(action);
            }
        }

        /**
         * 
         * @param {string} property
         * @param {*} value
         */
        public setModelProperty(property: string, value: any) {
            switch((property)) {
            case "half":
                {
                    const oldHalf: boolean = this.half;
                    this.half = javaemul.internal.BooleanHelper.parseBoolean(<string>value);
                    if (this.half !== oldHalf)this.fireLengthChange();
                    break;
                };
            case "scale":
                {
                    this.currentScales[this.multiplier].setModelProperty(property, value);
                    return;
                };
            default:
                super.setModelProperty(property, value);
            }
        }

        /**
         * 
         * @param {string} name
         * @return {string}
         */
        public getProperty(name: string): string {
            switch((name)) {
            case "multiplier":
                return /* toString */(''+(this.multiplier));
            case "half":
                return javaemul.internal.BooleanHelper.toString(this.half);
            case "scale":
                return this.currentScales[this.multiplier].getProperty(name);
            case "unitText":
                return this.readable(this.unitFactor);
            case "unitIsCustom":
                return javaemul.internal.BooleanHelper.toString(!/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(this.unitFactor,this.standardUnitFactor)));
            case "lengthText":
                {
                    let result: com.vzome.core.algebra.AlgebraicNumber = this.unitFactor;
                    result = this.applyScales(result);
                    return this.readable(result);
                };
            case "lengthMathML":
                {
                    let result: com.vzome.core.algebra.AlgebraicNumber = this.unitFactor;
                    result = this.applyScales(result);
                    return result.getMathML();
                };
            case "scaleFactorHtml":
                {
                    let html: string = "";
                    for(let i: number = 0; i < this.currentScales.length; i++) {{
                        html += this.field['getIrrational$int'](i + 1) + this.currentScales[i].getProperty("scaleHtml") + "  \u2715  ";
                    };}
                    return html;
                };
            default:
                return super.getProperty(name);
            }
        }

        applyScales(value: com.vzome.core.algebra.AlgebraicNumber): com.vzome.core.algebra.AlgebraicNumber {
            for(let i: number = 0; i < this.currentScales.length; i++) {{
                const scale: number = this.currentScales[i].getScale();
                value = value['times$com_vzome_core_algebra_AlgebraicNumber'](this.field['createPower$int$int'](scale, i + 1));
            };}
            return value;
        }

        readable(unitFactor2: com.vzome.core.algebra.AlgebraicNumber): string {
            const buf: java.lang.StringBuffer = new java.lang.StringBuffer();
            unitFactor2.getNumberExpression(buf, com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT);
            return buf.toString();
        }

        /**
         * Get the actual length value to use when rendering.  This value will multiply the zone's normal vector,
         * whatever its length is (not necessarily a unit vector).
         * @return {*}
         */
        public getValue(): com.vzome.core.algebra.AlgebraicNumber {
            let result: com.vzome.core.algebra.AlgebraicNumber = this.unitFactor['times$com_vzome_core_algebra_AlgebraicNumber'](this.fixedFactor);
            if (this.half)result = result['times$com_vzome_core_algebra_AlgebraicNumber'](this.field['createRational$long$long'](1, 2));
            result = result['times$com_vzome_core_algebra_AlgebraicNumber'](this.field['createPower$int'](LengthController.SCALE_OFFSET_$LI$()));
            result = this.applyScales(result);
            return result;
        }

        public getScale(): number {
            return this.currentScales[this.multiplier].getScale();
        }

        public setScale(amt: number) {
            this.currentScales[this.multiplier].setScale(amt);
        }

        /**
         * This is basically an inverse of getValue(), but with scale fixed at zero,
         * thus forcing unitFactor to float.
         * 
         * @param {*} length
         */
        public setActualLength(length: com.vzome.core.algebra.AlgebraicNumber) {
            this.half = false;
            this.resetScales();
            length = length['times$com_vzome_core_algebra_AlgebraicNumber'](this.field['createPower$int'](-LengthController.SCALE_OFFSET_$LI$()));
            this.unitFactor = length.dividedBy(this.fixedFactor);
            this.fireLengthChange();
        }
    }
    LengthController["__class"] = "com.vzome.desktop.controller.LengthController";
    LengthController["__interfaces"] = ["com.vzome.desktop.api.Controller"];



    export namespace LengthController {

        /**
         * A model for a scale slider.  Value range centers on scale 0.
         * 
         * Actual scale
         * 
         * @author Scott Vorthmann
         * @extends com.vzome.desktop.controller.DefaultController
         * @class
         */
        export class ScaleController extends com.vzome.desktop.controller.DefaultController {
            public __parent: any;
            static MAX_SCALE: number = 6;

            static MIN_SCALE: number = -6;

            /**
             * 
             * @param {string} action
             */
            public doAction(action: string) {
                if ("scaleUp" === action)this.setScale(this.scale + 1); else if ("scaleDown" === action)this.setScale(this.scale - 1); else super.doAction(action);
            }

            scale: number;

            /**
             * 
             * @param {string} property
             * @param {*} value
             */
            public setModelProperty(property: string, value: any) {
                if ("scale" === property){
                    this.setScale(javaemul.internal.IntegerHelper.parseInt(<string>value));
                    return;
                } else super.setModelProperty(property, value);
            }

            /**
             * 
             * @param {string} string
             * @return {string}
             */
            public getProperty(string: string): string {
                if ("scale" === string)return /* toString */(''+(this.scale));
                if ("scaleHtml" === string){
                    if (this.scale === 0)return "\u2070";
                    const absScale: number = Math.abs(this.scale);
                    let result: string = (absScale === this.scale) ? "" : "\u207b";
                    switch((absScale)) {
                    case 1:
                        result += "\u00b9";
                        break;
                    case 2:
                        result += "\u00b2";
                        break;
                    case 3:
                        result += "\u00b3";
                        break;
                    case 4:
                        result += "\u2074";
                        break;
                    case 5:
                        result += "\u2075";
                        break;
                    case 6:
                        result += "\u2076";
                        break;
                    case 7:
                        result += "\u2077";
                        break;
                    case 8:
                        result += "\u2078";
                        break;
                    case 9:
                        result += "\u2079";
                        break;
                    default:
                        result += "\u207f";
                        break;
                    }
                    return result;
                }
                return super.getProperty(string);
            }

            public setScale(amt: number) {
                const oldScale: number = this.scale;
                this.scale = amt;
                if (this.scale > ScaleController.MAX_SCALE)this.scale = ScaleController.MAX_SCALE; else if (this.scale < ScaleController.MIN_SCALE)this.scale = ScaleController.MIN_SCALE;
                if (oldScale !== this.scale)this.__parent.fireLengthChange();
            }

            getScale(): number {
                return this.scale;
            }

            constructor(__parent: any) {
                super();
                this.__parent = __parent;
                this.scale = 0;
            }
        }
        ScaleController["__class"] = "com.vzome.desktop.controller.LengthController.ScaleController";
        ScaleController["__interfaces"] = ["com.vzome.desktop.api.Controller"];


    }

}
namespace com.vzome.desktop.controller {
    export class PreviewStrut implements java.beans.PropertyChangeListener {
        /*private*/ model: com.vzome.core.model.RealizedModelImpl;

        /*private*/ editorModel: com.vzome.core.editor.api.EditorModel;

        /*private*/ rendering: com.vzome.core.render.RenderedModel;

        /*private*/ zoneBall: com.vzome.desktop.controller.ZoneVectorBall;

        /*private*/ context: com.vzome.core.editor.api.Context;

        /*private*/ point: com.vzome.core.construction.Point;

        /*private*/ zone: com.vzome.core.math.symmetry.Axis;

        /*private*/ symmetryController: com.vzome.desktop.controller.SymmetryController;

        /*private*/ length: com.vzome.desktop.controller.LengthController;

        /*private*/ strut: com.vzome.core.edits.StrutCreation;

        /*private*/ workingPlaneDual: number[];

        static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (PreviewStrut.logger == null) { PreviewStrut.logger = java.util.logging.Logger.getLogger("org.vorthmann.zome.app.impl.PreviewStrut"); }  return PreviewStrut.logger; }

        public constructor(field: com.vzome.core.algebra.AlgebraicField, mainScene: com.vzome.core.render.RenderingChanges, context: com.vzome.core.editor.api.Context) {
            if (this.model === undefined) { this.model = null; }
            if (this.editorModel === undefined) { this.editorModel = null; }
            if (this.rendering === undefined) { this.rendering = null; }
            if (this.zoneBall === undefined) { this.zoneBall = null; }
            if (this.context === undefined) { this.context = null; }
            if (this.point === undefined) { this.point = null; }
            if (this.zone === undefined) { this.zone = null; }
            if (this.symmetryController === undefined) { this.symmetryController = null; }
            if (this.length === undefined) { this.length = null; }
            if (this.strut === undefined) { this.strut = null; }
            this.workingPlaneDual = null;
            this.context = context;
            this.rendering = new com.vzome.core.render.RenderedModel(field, null);
            const transp: com.vzome.core.render.TransparentRendering = new com.vzome.core.render.TransparentRendering(mainScene);
            this.rendering.addListener(transp);
            this.model = new com.vzome.core.model.RealizedModelImpl(field, new com.vzome.core.math.Projection.Default(field));
            this.model.addListener(this.rendering);
            this.editorModel = new PreviewStrut.PreviewStrut$0(this);
            this.zoneBall = new PreviewStrut.PreviewStrut$1(this);
        }

        /**
         * 
         * @param {*} obj
         * @return {boolean}
         */
        public equals(obj: any): boolean {
            if (this === obj)return true;
            if (obj == null)return false;
            if ((<any>this.constructor) !== (<any>obj.constructor))return false;
            return false;
        }

        /**
         * 
         * @return {number}
         */
        public hashCode(): number {
            return /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})(this));
        }

        /*private*/ setZone(zone: com.vzome.core.math.symmetry.Axis) {
            this.zone = zone;
        }

        public startRendering(point: com.vzome.core.construction.Point, workingPlaneAxis: com.vzome.core.algebra.AlgebraicVector, worldEye: com.vzome.core.math.RealVector) {
            this.point = point;
            let orbits: com.vzome.core.math.symmetry.OrbitSet = this.symmetryController.getBuildOrbits();
            if (workingPlaneAxis != null){
                orbits = new com.vzome.core.math.symmetry.PlaneOrbitSet(orbits, workingPlaneAxis);
                const normal: com.vzome.core.math.RealVector = workingPlaneAxis.toRealVector();
                let other: com.vzome.core.math.RealVector = new com.vzome.core.math.RealVector(1.0, 0.0, 0.0);
                let v1: com.vzome.core.math.RealVector = normal.cross(other);
                const len: number = v1.length();
                if (len < 1.0E-4){
                    other = new com.vzome.core.math.RealVector(0.0, 1.0, 0.0);
                    v1 = normal.cross(other);
                }
                const v2: com.vzome.core.math.RealVector = normal.cross(v1);
                const p: com.vzome.core.math.RealVector = this.point.getLocation().toRealVector();
                const q: com.vzome.core.math.RealVector = p.plus(v1);
                const r: com.vzome.core.math.RealVector = p.plus(v2);
                const e12: number = (<any>Math).fround((<any>Math).fround(p.x * q.y) - (<any>Math).fround(q.x * p.y));
                const e23: number = (<any>Math).fround((<any>Math).fround(p.y * q.z) - (<any>Math).fround(q.y * p.z));
                const e31: number = (<any>Math).fround((<any>Math).fround(p.z * q.x) - (<any>Math).fround(q.z * p.x));
                const e10: number = (<any>Math).fround(p.x - q.x);
                const e20: number = (<any>Math).fround(p.y - q.y);
                const e30: number = (<any>Math).fround(p.z - q.z);
                const P_e123: number = e12 * r.z + e23 * r.x + e31 * r.y;
                const P_e310: number = e10 * r.z + e31 * 1.0 - e30 * r.x;
                const P_e320: number = e20 * r.z - e30 * r.y - e23 * 1.0;
                const P_e120: number = e12 * 1.0 + e20 * r.x - e10 * r.y;
                this.workingPlaneDual = [0, 0, 0, 0];
                this.workingPlaneDual[0] = -P_e123;
                this.workingPlaneDual[1] = -P_e320;
                this.workingPlaneDual[2] = P_e310;
                this.workingPlaneDual[3] = P_e120;
            }
            this.zone = this.zoneBall.initializeZone(orbits, worldEye);
            if (this.zone == null){
                this.length = null;
                return;
            }
            this.length = <com.vzome.desktop.controller.LengthController><any>this.symmetryController.orbitLengths.get(this.zone.getDirection());
            this.adjustStrut();
            this.length.addPropertyListener(this);
        }

        public finishPreview() {
            if (this.length == null)return;
            this.length.removePropertyListener(this);
            this.strut.undo();
            this.strut = null;
            if (PreviewStrut.logger_$LI$().isLoggable(java.util.logging.Level.FINE))PreviewStrut.logger_$LI$().fine("preview finished at  " + this.zone);
            const params: java.util.Map<string, any> = <any>(new java.util.HashMap<any, any>());
            params.put("anchor", this.point);
            params.put("zone", this.zone);
            params.put("length", this.length.getValue());
            this.context.doEdit("StrutCreation", params);
            this.point = null;
            this.zone = null;
            this.length = null;
            this.workingPlaneDual = null;
        }

        /*private*/ adjustStrut() {
            if (this.strut != null)this.strut.undo();
            if (this.length == null)return;
            if (PreviewStrut.logger_$LI$().isLoggable(java.util.logging.Level.FINER))PreviewStrut.logger_$LI$().finer("preview now " + this.zone);
            this.strut = new com.vzome.core.edits.StrutCreation(this.point, this.zone, this.length.getValue(), this.editorModel);
            this.strut.perform();
        }

        /**
         * 
         * @param {java.beans.PropertyChangeEvent} evt
         */
        public propertyChange(evt: java.beans.PropertyChangeEvent) {
            if ("length" === evt.getPropertyName())this.adjustStrut();
        }

        public setSymmetryController(symmetryController: com.vzome.desktop.controller.SymmetryController) {
            this.symmetryController = symmetryController;
            this.rendering.setOrbitSource(symmetryController.getOrbitSource());
        }

        /*private*/ usingWorkingPlane(): boolean {
            return this.workingPlaneDual != null;
        }

        public trackballRolled(rowMajor: com.vzome.core.math.RealVector[]) {
            if (this.point != null && !this.usingWorkingPlane())this.zoneBall.trackballRolled(rowMajor);
        }

        public workingPlaneDrag(ray: com.vzome.core.math.Line) {
            if (this.usingWorkingPlane()){
                if (this.point == null && PreviewStrut.logger_$LI$().isLoggable(java.util.logging.Level.SEVERE)){
                    PreviewStrut.logger_$LI$().severe("No point during workingPlaneDrag!");
                    return;
                }
                const planeIntersection: com.vzome.core.math.RealVector = this.intersectWorkingPlane(ray);
                const vectorInPlane: com.vzome.core.math.RealVector = planeIntersection.minus(this.point.getLocation().toRealVector());
                const almostPlanarVector: com.vzome.core.math.RealVector = new com.vzome.core.math.RealVector(vectorInPlane.x, vectorInPlane.y, vectorInPlane.z);
                this.zoneBall.setVector(almostPlanarVector);
            }
        }

        /*private*/ intersectWorkingPlane(ray: com.vzome.core.math.Line): com.vzome.core.math.RealVector {
            const s: com.vzome.core.math.RealVector = ray.getOrigin();
            const t: com.vzome.core.math.RealVector = s.plus(ray.getDirection());
            const e12: number = (<any>Math).fround((<any>Math).fround(s.x * t.y) - (<any>Math).fround(t.x * s.y));
            const e23: number = (<any>Math).fround((<any>Math).fround(s.y * t.z) - (<any>Math).fround(t.y * s.z));
            const e31: number = (<any>Math).fround((<any>Math).fround(s.z * t.x) - (<any>Math).fround(t.z * s.x));
            const e10: number = (<any>Math).fround(s.x - t.x);
            const e20: number = (<any>Math).fround(s.y - t.y);
            const e30: number = (<any>Math).fround(s.z - t.z);
            const x_e1: number = -this.workingPlaneDual[2] * e12 - this.workingPlaneDual[0] * e10 + this.workingPlaneDual[3] * e31;
            const x_e2: number = -this.workingPlaneDual[3] * e23 - this.workingPlaneDual[0] * e20 + this.workingPlaneDual[1] * e12;
            const x_e3: number = -this.workingPlaneDual[1] * e31 - this.workingPlaneDual[0] * e30 + this.workingPlaneDual[2] * e23;
            const x_e0: number = this.workingPlaneDual[1] * e10 + this.workingPlaneDual[2] * e20 + this.workingPlaneDual[3] * e30;
            return new com.vzome.core.math.RealVector(x_e1 / x_e0, x_e2 / x_e0, x_e3 / x_e0);
        }

        public getLengthController(): com.vzome.desktop.controller.LengthController {
            return this.length;
        }
    }
    PreviewStrut["__class"] = "com.vzome.desktop.controller.PreviewStrut";
    PreviewStrut["__interfaces"] = ["java.util.EventListener","java.beans.PropertyChangeListener"];



    export namespace PreviewStrut {

        export class PreviewStrut$0 implements com.vzome.core.editor.api.EditorModel {
            public __parent: any;
            /**
             * 
             * @return {*}
             */
            public getRealizedModel(): com.vzome.core.model.RealizedModel {
                return this.__parent.model;
            }

            /**
             * 
             * @return {*}
             */
            public getSelection(): com.vzome.core.editor.api.Selection {
                return null;
            }

            public getSymmetrySystem$(): com.vzome.core.editor.api.OrbitSource {
                return null;
            }

            public getSymmetrySystem$java_lang_String(name: string): com.vzome.core.editor.api.OrbitSource {
                return null;
            }

            /**
             * 
             * @param {string} name
             * @return {*}
             */
            public getSymmetrySystem(name?: any): com.vzome.core.editor.api.OrbitSource {
                if (((typeof name === 'string') || name === null)) {
                    return <any>this.getSymmetrySystem$java_lang_String(name);
                } else if (name === undefined) {
                    return <any>this.getSymmetrySystem$();
                } else throw new Error('invalid overload');
            }

            /**
             * 
             * @return {*}
             */
            public get4dSymmetries(): com.vzome.core.math.symmetry.Symmetries4D {
                return null;
            }

            /**
             * 
             * @param {*} listener
             */
            public addSelectionSummaryListener(listener: com.vzome.core.editor.SelectionSummary.Listener) {
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }
        PreviewStrut$0["__interfaces"] = ["com.vzome.core.editor.api.EditorModel","com.vzome.core.editor.api.SymmetryAware"];



        export class PreviewStrut$1 extends com.vzome.desktop.controller.ZoneVectorBall {
            public __parent: any;
            /**
             * 
             * @param {com.vzome.core.math.symmetry.Axis} oldZone
             * @param {com.vzome.core.math.symmetry.Axis} newZone
             */
            zoneChanged(oldZone: com.vzome.core.math.symmetry.Axis, newZone: com.vzome.core.math.symmetry.Axis) {
                if (this.__parent.length != null)this.__parent.length.removePropertyListener(this.__parent);
                this.__parent.setZone(newZone);
                if (newZone == null)return;
                this.__parent.length = <com.vzome.desktop.controller.LengthController><any>this.__parent.symmetryController.orbitLengths.get(newZone.getDirection());
                this.__parent.adjustStrut();
                this.__parent.length.addPropertyListener(this.__parent);
            }

            constructor(__parent: any) {
                super();
                this.__parent = __parent;
            }
        }

    }

}
namespace com.vzome.core.exporters2d {
    /**
     * @author scottv
     * @class
     * @extends com.vzome.core.exporters2d.SnapshotExporter
     */
    export class SVGExporter extends com.vzome.core.exporters2d.SnapshotExporter {
        /**
         * 
         * @param {java.awt.Color} bgColor
         */
        outputBackground(bgColor: java.awt.Color) {
            this.output.print("<rect fill=\'#");
            const color: number = bgColor.getRGB() & 16777215;
            this.output.print(javaemul.internal.IntegerHelper.toHexString(color));
            this.output.println$java_lang_Object("\' x=\'1\' y=\'1\' width=\'" + this.width + "\' height=\'" + this.height + "\'/>");
        }

        /**
         * 
         * @param {java.awt.geom.Rectangle2D} rect
         * @param {number} strokeWidth
         */
        outputPrologue(rect: java.awt.geom.Rectangle2D, strokeWidth: number) {
            this.output.println$java_lang_Object("<?xml version=\'1.0\'?>");
            this.output.println$java_lang_Object("<svg version=\'1.1\' xmlns=\'http://www.w3.org/2000/svg\'");
            if (strokeWidth > 0)this.output.println$java_lang_Object("   stroke=\'black\' stroke-linejoin=\'round\' stroke-width=\'" + strokeWidth + "\' ");
            this.output.println$java_lang_Object("   viewBox=\'0 0 " + this.width + " " + this.height + "\' >");
            this.XY_FORMAT.setMaximumFractionDigits(2);
        }

        /**
         * 
         * @param {com.vzome.core.exporters2d.Java2dSnapshot.LineSegment} line
         * @param {boolean} monochrome
         */
        outputLine(line: com.vzome.core.exporters2d.Java2dSnapshot.LineSegment, monochrome: boolean) {
            this.output.print("<path stroke=\'#");
            let color: number = line.getColor().getRGB() & 16777215;
            if (monochrome)color = java.awt.Color.BLACK_$LI$().getRGB() & 16777215;
            const hex: string = javaemul.internal.IntegerHelper.toHexString(color);
            for(let i: number = 0; i < 6 - hex.length; i++) {this.output.print('0');}
            this.output.print(hex);
            this.output.print("\' d=\'");
            this.renderPath(line.getPath());
            this.output.println$java_lang_Object("\'/>");
        }

        /**
         * 
         * @param {com.vzome.core.exporters2d.Java2dSnapshot.Polygon} polygon
         * @param {boolean} doOutline
         */
        outputPolygon(polygon: com.vzome.core.exporters2d.Java2dSnapshot.Polygon, doOutline: boolean) {
            this.output.print("<path fill=\'#");
            const color: number = polygon.getColor().getRGB() & 16777215;
            const hex: string = javaemul.internal.IntegerHelper.toHexString(color);
            for(let i: number = 0; i < 6 - hex.length; i++) {this.output.print('0');}
            this.output.print(hex);
            this.output.print("\' d=\'");
            this.renderPath(polygon.getPath());
            this.output.println$java_lang_Object("\'/>");
        }

        /**
         * 
         */
        outputPostlogue() {
            this.output.println$();
            this.output.println$java_lang_Object("</svg>");
        }

        /**
         * 
         * @param {number} r
         * @param {number} g
         * @param {number} b
         */
        setRGBStrokeColor(r: number, g: number, b: number) {
        }

        /**
         * 
         * @param {number} r
         * @param {number} g
         * @param {number} b
         */
        setRGBFillColor(r: number, g: number, b: number) {
        }

        /**
         * 
         */
        beginPath() {
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        moveToPoint(x: number, y: number) {
            this.output.print("M " + this.XY_FORMAT.format(x) + " " + this.XY_FORMAT.format((<any>Math).fround(this.height - y)) + " ");
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        addLineToPoint(x: number, y: number) {
            this.output.print("L " + this.XY_FORMAT.format(x) + " " + this.XY_FORMAT.format((<any>Math).fround(this.height - y)) + " ");
        }

        /**
         * 
         */
        closePath() {
            this.output.print(" z");
        }

        /**
         * 
         */
        fillPath() {
        }

        /**
         * 
         */
        strokePath() {
        }
    }
    SVGExporter["__class"] = "com.vzome.core.exporters2d.SVGExporter";

}
namespace com.vzome.core.exporters2d {
    export class PDFExporter extends com.vzome.core.exporters2d.SnapshotExporter {
        /**
         * 
         * @param {number} r
         * @param {number} g
         * @param {number} b
         */
        setRGBStrokeColor(r: number, g: number, b: number) {
            this.output.print(" " + this.RGB_FORMAT.format(r) + " " + this.RGB_FORMAT.format(g) + " " + this.RGB_FORMAT.format(b) + " RG");
        }

        /**
         * 
         * @param {number} r
         * @param {number} g
         * @param {number} b
         */
        setRGBFillColor(r: number, g: number, b: number) {
            this.output.print(" " + this.RGB_FORMAT.format(r) + " " + this.RGB_FORMAT.format(g) + " " + this.RGB_FORMAT.format(b) + " rg");
        }

        /**
         * 
         */
        beginPath() {
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        moveToPoint(x: number, y: number) {
            this.output.print(" " + this.XY_FORMAT.format(x) + " " + this.XY_FORMAT.format(y) + " m");
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        addLineToPoint(x: number, y: number) {
            this.output.print(" " + this.XY_FORMAT.format(x) + " " + this.XY_FORMAT.format(y) + " l");
        }

        /**
         * 
         */
        closePath() {
            this.output.print(" h");
        }

        /**
         * 
         */
        fillPath() {
            this.output.print(" f");
        }

        /**
         * 
         */
        strokePath() {
            this.output.print(" S\n");
        }

        /*private*/ streamStart: number;

        /**
         * 
         * @param {java.awt.geom.Rectangle2D} rect
         * @param {number} strokeWidth
         */
        outputPrologue(rect: java.awt.geom.Rectangle2D, strokeWidth: number) {
            this.includeFile("com/vzome/core/exporters/prologue.pdf");
            this.streamStart = this.output.getBytesTotal();
            if (strokeWidth > 0)this.output.print(strokeWidth + " w 1 j\n");
            this.RGB_FORMAT.setMaximumFractionDigits(3);
            this.XY_FORMAT.setMaximumFractionDigits(2);
        }

        /**
         * 
         * @param {java.awt.Color} bgColor
         */
        outputBackground(bgColor: java.awt.Color) {
            const rgb: number[] = bgColor.getRGBColorComponents(null);
            this.setRGBFillColor(rgb[0], rgb[1], rgb[2]);
            this.beginPath();
            this.output.print(" 0 0 " + this.width + " " + this.height + " re\n");
            this.closePath();
            this.fillPath();
        }

        /**
         * 
         */
        outputPostlogue() {
            const streamLen: number = this.output.getBytesTotal() - this.streamStart;
            this.output.print("endstream\n");
            this.output.print("endobj\n");
            const sizeOffset: number = this.output.getBytesTotal();
            this.output.print("5 0 obj " + streamLen + " endobj\n");
            const boxOffset: number = this.output.getBytesTotal();
            this.output.print("6 0 obj [0 0 " + this.width + " " + this.height + "] endobj\n");
            const startXref: number = this.output.getBytesTotal();
            this.includeFile("com/vzome/core/exporters/postlogue.pdf");
            let num: string = /* toString */(''+(sizeOffset));
            for(let i: number = 0; i + num.length < 10; i++) {this.output.print("0");}
            this.output.print(num + " 00000 n \n");
            num = /* toString */(''+(boxOffset));
            for(let i: number = 0; i + num.length < 10; i++) {this.output.print("0");}
            this.output.print(num + " 00000 n \n");
            this.output.print("trailer\n");
            this.output.print("<< /Size 7 /Root 1 0 R >>\n");
            this.output.print("startxref\n");
            this.output.print(startXref + "\n");
            this.output.print("%%EOF\n");
        }

        constructor() {
            super();
            if (this.streamStart === undefined) { this.streamStart = 0; }
        }
    }
    PDFExporter["__class"] = "com.vzome.core.exporters2d.PDFExporter";

}
namespace com.vzome.core.exporters2d {
    export class PostScriptExporter extends com.vzome.core.exporters2d.SnapshotExporter {
        /**
         * 
         */
        setBlackStrokeColor() {
            this.output.print(" 0 setgray");
        }

        /**
         * 
         * @param {number} r
         * @param {number} g
         * @param {number} b
         */
        setRGBStrokeColor(r: number, g: number, b: number) {
            this.output.print(" " + this.RGB_FORMAT.format(r) + " " + this.RGB_FORMAT.format(g) + " " + this.RGB_FORMAT.format(b) + " setrgbcolor");
        }

        /**
         * 
         * @param {number} r
         * @param {number} g
         * @param {number} b
         */
        setRGBFillColor(r: number, g: number, b: number) {
            this.output.print(" " + this.RGB_FORMAT.format(r) + " " + this.RGB_FORMAT.format(g) + " " + this.RGB_FORMAT.format(b) + " setrgbcolor");
        }

        /**
         * 
         */
        beginPath() {
            this.output.print(" newpath");
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        moveToPoint(x: number, y: number) {
            this.output.print(" " + this.XY_FORMAT.format(x) + " " + this.XY_FORMAT.format(y) + " moveto");
        }

        /**
         * 
         * @param {number} x
         * @param {number} y
         */
        addLineToPoint(x: number, y: number) {
            this.output.print(" " + this.XY_FORMAT.format(x) + " " + this.XY_FORMAT.format(y) + " lineto");
        }

        /**
         * 
         */
        closePath() {
            this.output.print(" closepath");
        }

        /**
         * 
         */
        fillPath() {
            this.output.print(" fill");
        }

        /**
         * 
         */
        strokePath() {
            this.output.print(" stroke\n");
        }

        /**
         * 
         * @param {java.awt.geom.Rectangle2D} rect
         * @param {number} strokeWidth
         */
        outputPrologue(rect: java.awt.geom.Rectangle2D, strokeWidth: number) {
            if (strokeWidth > 0)this.output.print(strokeWidth + " setlinewidth 1 setlinejoin\n");
            this.RGB_FORMAT.setMaximumFractionDigits(3);
            this.XY_FORMAT.setMaximumFractionDigits(3);
        }

        /**
         * 
         * @param {java.awt.Color} bgColor
         */
        outputBackground(bgColor: java.awt.Color) {
            const rgb: number[] = bgColor.getRGBColorComponents(null);
            this.setRGBFillColor(rgb[0], rgb[1], rgb[2]);
            this.beginPath();
            this.moveToPoint(0.0, 0.0);
            this.addLineToPoint(0.0, this.height);
            this.addLineToPoint(this.width, this.height);
            this.addLineToPoint(this.width, 0.0);
            this.addLineToPoint(0.0, 0.0);
            this.closePath();
            this.fillPath();
        }

        /**
         * 
         */
        outputPostlogue() {
        }
    }
    PostScriptExporter["__class"] = "com.vzome.core.exporters2d.PostScriptExporter";

}
namespace com.vzome.core.exporters {
    export class PlyExporter extends com.vzome.core.exporters.GeometryExporter {
        static __static_initialized: boolean = false;
        static __static_initialize() { if (!PlyExporter.__static_initialized) { PlyExporter.__static_initialized = true; PlyExporter.__static_initializer_0(); } }

        static FORMAT: java.text.NumberFormat; public static FORMAT_$LI$(): java.text.NumberFormat { PlyExporter.__static_initialize(); if (PlyExporter.FORMAT == null) { PlyExporter.FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US); }  return PlyExporter.FORMAT; }

        /*private*/ vertexData: java.util.Map<com.vzome.core.algebra.AlgebraicVector, number>;

        /*private*/ vertices: java.lang.StringBuffer;

        static  __static_initializer_0() {
            if (PlyExporter.FORMAT_$LI$() != null && PlyExporter.FORMAT_$LI$() instanceof <any>java.text.DecimalFormat){
                (<java.text.DecimalFormat>PlyExporter.FORMAT_$LI$()).applyPattern("0.000000E00");
            }
        }

        /**
         * 
         * @param {java.io.File} directory
         * @param {java.io.Writer} writer
         * @param {number} height
         * @param {number} width
         */
        public doExport(directory: java.io.File, writer: java.io.Writer, height: number, width: number) {
            let numPanels: number = 0;
            const panels: java.lang.StringBuffer = new java.lang.StringBuffer();
            this.vertexData = <any>(new java.util.LinkedHashMap<any, any>());
            this.vertices = new java.lang.StringBuffer();
            const output: java.io.PrintWriter = new java.io.PrintWriter(writer);
            output.println$java_lang_Object("ply");
            output.println$java_lang_Object("format ascii 1.0");
            output.println$java_lang_Object("comment   Exported by vZome, http://vzome.com");
            output.println$java_lang_Object("comment     All vertex data is in inches");
            for(let index=this.mModel.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    const man: com.vzome.core.model.Manifestation = rm.getManifestation();
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                        ++numPanels;
                        const vs: java.util.List<number> = <any>(new java.util.ArrayList<any>());
                        for(let index=(<com.vzome.core.model.Panel><any>man).iterator();index.hasNext();) {
                            let vertex = index.next();
                            {
                                vs.add(this.getVertexIndex(vertex));
                            }
                        }
                        panels.append(vs.size());
                        for(let index=vs.iterator();index.hasNext();) {
                            let v = index.next();
                            {
                                panels.append(" ");
                                panels.append(v);
                            }
                        }
                        panels.append("\n");
                    }
                }
            }
            output.println$java_lang_Object("element vertex " + this.vertexData.size());
            output.println$java_lang_Object("property float x");
            output.println$java_lang_Object("property float y");
            output.println$java_lang_Object("property float z");
            output.println$java_lang_Object("element face " + numPanels);
            output.println$java_lang_Object("property list uchar int vertex_indices");
            output.println$java_lang_Object("end_header");
            output.print(this.vertices);
            output.print(panels);
            output.flush();
        }

        getVertexIndex(vertexVector: com.vzome.core.algebra.AlgebraicVector): number {
            let obj: number = this.vertexData.get(vertexVector);
            if (obj == null){
                const key: com.vzome.core.algebra.AlgebraicVector = vertexVector;
                const index: number = this.vertexData.size();
                obj = index;
                this.vertexData.put(key, obj);
                this.vertices.append(this.mModel.renderVector(vertexVector).spacedString() + "\n");
            }
            return obj;
        }

        /**
         * 
         * @return {string}
         */
        public getFileExtension(): string {
            return "ply";
        }

        constructor() {
            super();
            if (this.vertexData === undefined) { this.vertexData = null; }
            if (this.vertices === undefined) { this.vertices = null; }
        }
    }
    PlyExporter["__class"] = "com.vzome.core.exporters.PlyExporter";

}
namespace com.vzome.fields.sqrtphi {
    /**
     * Everything here is stateless, or at worst, a cache (like Shapes).
     * An instance of this can be shared by many DocumentModels.
     * This is why it does not have tool factories, though it does
     * dictate what tool factories will be present.
     * 
     * @author vorth
     * @param {*} field
     * @class
     * @extends com.vzome.core.kinds.DefaultFieldApplication
     */
    export class SqrtPhiFieldApplication extends com.vzome.core.kinds.DefaultFieldApplication {
        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            super(field);
            this.icosahedralPerspective = new SqrtPhiFieldApplication.SqrtPhiFieldApplication$0(this, new com.vzome.core.math.symmetry.IcosahedralSymmetry(this.getField()));
            this.pentagonalPerspective = new SqrtPhiFieldApplication.SqrtPhiFieldApplication$1(this, new com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry(this.getField(), null));
            this.H4 = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", this.getField());
            this.h4Builder = null;
            const octahedralPerspective: com.vzome.core.kinds.OctahedralSymmetryPerspective = <com.vzome.core.kinds.OctahedralSymmetryPerspective><any>super.getDefaultSymmetryPerspective();
            const symm: com.vzome.core.math.symmetry.OctahedralSymmetry = octahedralPerspective.getSymmetry();
            const scale: com.vzome.core.algebra.AlgebraicNumber = field['createPower$int'](6);
            symm.getDirection("blue").setUnitLength(scale);
            symm.getDirection("green").setUnitLength(scale);
            symm.getDirection("yellow").setUnitLength(scale);
            let x: com.vzome.core.algebra.AlgebraicNumber = field['createAlgebraicNumber$int_A']([0, -1, 0, 0]);
            let y: com.vzome.core.algebra.AlgebraicNumber = field['createAlgebraicNumber$int_A']([-1, 0, 0, 0]);
            let z: com.vzome.core.algebra.AlgebraicNumber = field.zero();
            const unitLength: com.vzome.core.algebra.AlgebraicNumber = field['createPower$int'](4);
            let norm: com.vzome.core.algebra.AlgebraicVector = new com.vzome.core.algebra.AlgebraicVector(x, y, z);
            symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("slate", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, norm, true, false, unitLength);
            x = field['createAlgebraicNumber$int_A']([0, 1, 0, -1]);
            y = field.one();
            z = field.one();
            norm = new com.vzome.core.algebra.AlgebraicVector(x, y, z);
            symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("mauve", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, norm, true, false, unitLength);
            x = field['createAlgebraicNumber$int_A']([1, 0, -1, 0]);
            y = field['createAlgebraicNumber$int_A']([0, -1, 0, 0]);
            z = field['createAlgebraicNumber$int_A']([0, -1, 0, 1]);
            norm = new com.vzome.core.algebra.AlgebraicVector(x, y, z);
            symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("ivory", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, norm, true, false, unitLength);
            const defaultShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.OctahedralShapes("octahedral", "octahedra", symm);
            octahedralPerspective.setDefaultGeometry(defaultShapes);
        }

        /**
         * 
         * @return {string}
         */
        public getLabel(): string {
            return "\u221a\u03c6";
        }

        /*private*/ icosahedralPerspective: com.vzome.core.kinds.IcosahedralSymmetryPerspective;

        /*private*/ pentagonalPerspective: com.vzome.core.editor.SymmetryPerspective;

        /*private*/ H4: com.vzome.core.math.symmetry.QuaternionicSymmetry;

        /**
         * 
         * @return {*}
         */
        public getSymmetryPerspectives(): java.util.Collection<com.vzome.core.editor.SymmetryPerspective> {
            return java.util.Arrays.asList<any>(this.pentagonalPerspective, super.getDefaultSymmetryPerspective(), this.icosahedralPerspective);
        }

        /**
         * 
         * @return {*}
         */
        public getDefaultSymmetryPerspective(): com.vzome.core.editor.SymmetryPerspective {
            return this.pentagonalPerspective;
        }

        /**
         * 
         * @param {string} symmName
         * @return {*}
         */
        public getSymmetryPerspective(symmName: string): com.vzome.core.editor.SymmetryPerspective {
            switch((symmName)) {
            case "pentagonal":
                return this.pentagonalPerspective;
            case "icosahedral":
                return this.icosahedralPerspective;
            default:
                return super.getSymmetryPerspective(symmName);
            }
        }

        /**
         * 
         * @param {string} name
         * @return {com.vzome.core.math.symmetry.QuaternionicSymmetry}
         */
        public getQuaternionSymmetry(name: string): com.vzome.core.math.symmetry.QuaternionicSymmetry {
            switch((name)) {
            case "H_4":
                return this.H4;
            default:
                return null;
            }
        }

        /*private*/ h4Builder: com.vzome.core.commands.CommandUniformH4Polytope;

        /**
         * 
         * @param {string} groupName
         * @param {number} index
         * @param {number} edgesToRender
         * @param {com.vzome.core.algebra.AlgebraicNumber[]} edgeScales
         * @param {*} listener
         */
        public constructPolytope(groupName: string, index: number, edgesToRender: number, edgeScales: com.vzome.core.algebra.AlgebraicNumber[], listener: com.vzome.core.math.symmetry.WythoffConstruction.Listener) {
            switch((groupName)) {
            case "H4":
                if (this.h4Builder == null){
                    const qsymm: com.vzome.core.math.symmetry.QuaternionicSymmetry = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", this.getField());
                    this.h4Builder = new com.vzome.core.commands.CommandUniformH4Polytope(this.getField(), qsymm, 0);
                }
                this.h4Builder.generate(index, edgesToRender, edgeScales, listener);
                break;
            default:
                super.constructPolytope(groupName, index, edgesToRender, edgeScales, listener);
                break;
            }
        }
    }
    SqrtPhiFieldApplication["__class"] = "com.vzome.fields.sqrtphi.SqrtPhiFieldApplication";
    SqrtPhiFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D","com.vzome.core.editor.FieldApplication"];



    export namespace SqrtPhiFieldApplication {

        export class SqrtPhiFieldApplication$0 extends com.vzome.core.kinds.IcosahedralSymmetryPerspective {
            public __parent: any;
            constructor(__parent: any, __arg0: any) {
                super(__arg0);
                this.__parent = __parent;
                (() => {
                    const icosaSymm: com.vzome.core.math.symmetry.IcosahedralSymmetry = this.getSymmetry();
                    const tinyIcosaShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "sqrtPhi/tinyIcosahedra", "tiny icosahedra", null, icosaSymm);
                    const icosahedralShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "sqrtPhi/zome", "solid Zome", icosaSymm, tinyIcosaShapes);
                    this.clearShapes();
                    this.addShapes(icosahedralShapes);
                    this.setDefaultGeometry(tinyIcosaShapes);
                })();
            }
        }
        SqrtPhiFieldApplication$0["__interfaces"] = ["com.vzome.core.editor.SymmetryPerspective"];



        export class SqrtPhiFieldApplication$1 extends com.vzome.core.kinds.AbstractSymmetryPerspective {
            public __parent: any;
            /**
             * 
             * @return {com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry}
             */
            public getSymmetry(): com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry {
                return <com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry><any>super.getSymmetry();
            }

            /**
             * 
             * @param {com.vzome.api.Tool.Kind} kind
             * @param {com.vzome.core.editor.ToolsModel} tools
             * @return {*}
             */
            public createToolFactories(kind: com.vzome.api.Tool.Kind, tools: com.vzome.core.editor.ToolsModel): java.util.List<com.vzome.api.Tool.Factory> {
                const result: java.util.List<com.vzome.api.Tool.Factory> = <any>(new java.util.ArrayList<any>());
                const pentaSymm: com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry = this.getSymmetry();
                switch((kind)) {
                case com.vzome.api.Tool.Kind.SYMMETRY:
                    result.add(new com.vzome.core.tools.SymmetryToolFactory(tools, pentaSymm));
                    result.add(new com.vzome.core.tools.InversionToolFactory(tools));
                    result.add(new com.vzome.core.tools.LineReflectionToolFactory(tools));
                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools));
                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, pentaSymm));
                    break;
                case com.vzome.api.Tool.Kind.TRANSFORM:
                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, pentaSymm));
                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, pentaSymm));
                    result.add(new com.vzome.core.tools.TranslationToolFactory(tools));
                    result.add(new com.vzome.core.tools.ProjectionToolFactory(tools));
                    break;
                case com.vzome.api.Tool.Kind.LINEAR_MAP:
                    result.add(new com.vzome.core.tools.LinearMapToolFactory(tools, pentaSymm, false));
                    break;
                default:
                    break;
                }
                return result;
            }

            /**
             * 
             * @param {com.vzome.api.Tool.Kind} kind
             * @param {com.vzome.core.editor.ToolsModel} tools
             * @return {*}
             */
            public predefineTools(kind: com.vzome.api.Tool.Kind, tools: com.vzome.core.editor.ToolsModel): java.util.List<com.vzome.api.Tool> {
                const result: java.util.List<com.vzome.api.Tool> = <any>(new java.util.ArrayList<any>());
                const pentaSymm: com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry = this.getSymmetry();
                switch((kind)) {
                case com.vzome.api.Tool.Kind.SYMMETRY:
                    result.add(new com.vzome.core.tools.SymmetryToolFactory(tools, pentaSymm).createPredefinedTool("pentagonal antiprism around origin"));
                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, pentaSymm).createPredefinedTool("fivefold symmetry through origin"));
                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools).createPredefinedTool("reflection through red plane"));
                    break;
                case com.vzome.api.Tool.Kind.TRANSFORM:
                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, pentaSymm).createPredefinedTool("scale down"));
                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, pentaSymm).createPredefinedTool("scale up"));
                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, pentaSymm, true).createPredefinedTool("fivefold rotation through origin"));
                    break;
                default:
                    break;
                }
                return result;
            }

            axialsymm: com.vzome.core.commands.Command;

            /**
             * 
             * @param {string} action
             * @return {*}
             */
            public getLegacyCommand(action: string): com.vzome.core.commands.Command {
                switch((action)) {
                case "axialsymm":
                    return this.axialsymm;
                default:
                    return super.getLegacyCommand(action);
                }
            }

            /**
             * 
             * @return {string}
             */
            public getModelResourcePath(): string {
                return "org/vorthmann/zome/app/pentagonal.vZome";
            }

            constructor(__parent: any, __arg0: any) {
                super(__arg0);
                this.__parent = __parent;
                (() => {
                    const pentaSymm: com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry = this.getSymmetry();
                    pentaSymm.createStandardOrbits("blue");
                    const octahedralShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.OctahedralShapes("octahedral", "octahedra", pentaSymm);
                    const kostickShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "sqrtPhi/fivefold", "Kostick", pentaSymm, octahedralShapes);
                    this.setDefaultGeometry(kostickShapes);
                    this.addShapes(octahedralShapes);
                    this.axialsymm = new com.vzome.core.commands.CommandAxialSymmetry(pentaSymm);
                })();
                if (this.axialsymm === undefined) { this.axialsymm = null; }
            }
        }
        SqrtPhiFieldApplication$1["__interfaces"] = ["com.vzome.core.editor.SymmetryPerspective"];


    }

}
namespace com.vzome.core.exporters {
    /**
     * An exporter that produces a parametric OpenSCAD file,
     * to support generation of STL files for struts of arbitrary length.
     * This is based on Aaron Siegel's "zome-strut.scad" library.
     * 
     * @author vorth
     * @class
     * @extends com.vzome.core.exporters.DocumentExporter
     */
    export class OpenScadExporter extends com.vzome.core.exporters.DocumentExporter {
        /**
         * 
         * @param {*} doc
         * @param {java.io.File} file
         * @param {java.io.Writer} writer
         * @param {number} height
         * @param {number} width
         */
        public exportDocument(doc: com.vzome.core.exporters.DocumentIntf, file: java.io.File, writer: java.io.Writer, height: number, width: number) {
            const toolsModel: com.vzome.core.editor.ToolsModel = doc.getToolsModel();
            this.mModel = doc.getRenderedModel();
            const field: com.vzome.core.algebra.AbstractAlgebraicField = <com.vzome.core.algebra.AbstractAlgebraicField><any>this.mModel.getField();
            const tipBookmark: java.util.Optional<com.vzome.core.editor.Tool> = toolsModel.values().stream().filter((tool) => "tip vertex" === tool.getLabel()).findAny();
            if (!tipBookmark.isPresent())throw new com.vzome.core.commands.Command.Failure("You must have a bookmark named \"tip vertex\" for the strut endpoint.");
            const tipItems: java.util.List<com.vzome.core.construction.Construction> = tipBookmark.get().getParameters();
            const tipPoint: com.vzome.core.construction.Construction = tipItems.get(0);
            if (tipItems.size() > 1 || !(tipPoint != null && tipPoint instanceof <any>com.vzome.core.construction.Point))throw new com.vzome.core.commands.Command.Failure("The \"tip vertex\" bookmark must select a single ball.");
            const tipVertex: com.vzome.core.algebra.AlgebraicVector = (<com.vzome.core.construction.Point>tipPoint).getLocation();
            const floatingBookmark: java.util.Optional<com.vzome.core.editor.Tool> = toolsModel.values().stream().filter((tool) => "floating panels" === tool.getLabel()).findAny();
            let floatingVerticesSet: java.util.SortedSet<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.TreeSet<any>());
            if (!floatingBookmark.isPresent())throw new com.vzome.core.commands.Command.Failure("You must have a bookmark named \"floating panels\".");
            for(let index=floatingBookmark.get().getParameters().iterator();index.hasNext();) {
                let polygon = index.next();
                {
                    if (!(polygon != null && polygon instanceof <any>com.vzome.core.construction.Polygon))throw new com.vzome.core.commands.Command.Failure("The \"floating panels\" bookmark must select only panels.");
                    {
                        let array = (<com.vzome.core.construction.Polygon>polygon).getVertices();
                        for(let index = 0; index < array.length; index++) {
                            let vertex = array[index];
                            {
                                floatingVerticesSet.add(vertex);
                            }
                        }
                    }
                }
            }
            let bottomFaceNormal: com.vzome.core.algebra.AlgebraicVector = null;
            const bottomFaceBookmark: java.util.Optional<com.vzome.core.editor.Tool> = toolsModel.values().stream().filter((tool) => "bottom face" === tool.getLabel()).findAny();
            if (bottomFaceBookmark.isPresent()){
                const bottomFaceItems: java.util.List<com.vzome.core.construction.Construction> = bottomFaceBookmark.get().getParameters();
                const bottomFacePanel: com.vzome.core.construction.Construction = bottomFaceItems.get(0);
                if (bottomFaceItems.size() > 1 || !(bottomFacePanel != null && bottomFacePanel instanceof <any>com.vzome.core.construction.Polygon))throw new com.vzome.core.commands.Command.Failure("The \"bottom face\" bookmark must select a single panel.");
                bottomFaceNormal = (<com.vzome.core.construction.Polygon>bottomFacePanel).getNormal();
            }
            let fixedVerticesSet: java.util.SortedSet<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.TreeSet<any>());
            let orbitName: string = null;
            for(let index=this.mModel.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    const man: com.vzome.core.model.Manifestation = rm.getManifestation();
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                        const panel: com.vzome.core.model.Panel = <com.vzome.core.model.Panel><any>man;
                        for(let index=panel.iterator();index.hasNext();) {
                            let vertex = index.next();
                            {
                                if (!floatingVerticesSet.contains(vertex))fixedVerticesSet.add(vertex);
                            }
                        }
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        if (orbitName != null)throw new com.vzome.core.commands.Command.Failure("The model must contain a single prototype strut.");
                        orbitName = rm.getStrutOrbit().getName();
                    }
                }
            }
            if (orbitName == null)throw new com.vzome.core.commands.Command.Failure("The model must contain a single prototype strut.");
            const sortedFixedVertexList: java.util.ArrayList<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>(fixedVerticesSet));
            const sortedFloatingVertexList: java.util.ArrayList<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>(floatingVerticesSet));
            fixedVerticesSet = null;
            floatingVerticesSet = null;
            this.output = new java.io.PrintWriter(writer);
            let prelude: string = super.getBoilerplate("com/vzome/core/exporters/zome-strut-prelude.scad");
            prelude = /* replaceAll */prelude.replace(new RegExp("%%ORBIT%%", 'g'),orbitName);
            this.output.println$java_lang_Object(prelude);
            this.output.println$java_lang_Object("  irrational = " + field.getCoefficients()[1] + ";");
            this.output.println$();
            this.output.println$java_lang_Object("module " + orbitName + "_strut( size, scalar=1.0, offsets=0 ) {");
            this.output.println$();
            if (bottomFaceNormal == null){
                this.output.println$java_lang_Object("  // WARNING: The vZome design contained no \"bottom face\" bookmark.");
                this.output.println$java_lang_Object("  bottom_face_normal = [ 0, 0, -1 ];");
            } else {
                const bottomFaceDirection: com.vzome.core.math.RealVector = this.mModel.renderVector(bottomFaceNormal).normalize();
                this.output.println$java_lang_Object("  bottom_face_normal = [ " + bottomFaceDirection.toString$() + " ];");
            }
            this.output.println$();
            const mmScaling: number = this.mModel.getCmScaling() * 10.0;
            const tipVertexString: string = this.mModel.renderVector(tipVertex).scale(mmScaling).toString$();
            this.output.println$java_lang_Object("  tip_vertex = [ " + tipVertexString + " ];");
            this.output.println$();
            this.output.println$java_lang_Object("  fixed_vertices = [ ");
            for(let index=sortedFixedVertexList.iterator();index.hasNext();) {
                let vertex = index.next();
                {
                    this.output.print("[ ");
                    this.output.print(this.mModel.renderVector(vertex).scale(mmScaling).toString$());
                    this.output.print(" ], ");
                }
            }
            this.output.println$java_lang_Object(" ];");
            this.output.println$java_lang_Object("  floating_vertices = [ ");
            for(let index=sortedFloatingVertexList.iterator();index.hasNext();) {
                let vertex = index.next();
                {
                    this.output.print("[ ");
                    this.output.print(this.mModel.renderVector(vertex).scale(mmScaling).toString$());
                    this.output.print(" ], ");
                }
            }
            this.output.println$java_lang_Object(" ];");
            this.output.println$java_lang_Object("  faces = [ ");
            for(let index=this.mModel.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    const man: com.vzome.core.model.Manifestation = rm.getManifestation();
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                        this.output.print("[ ");
                        const panel: com.vzome.core.model.Panel = <com.vzome.core.model.Panel><any>man;
                        const stack: java.util.Stack<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.Stack<com.vzome.core.algebra.AlgebraicVector>());
                        for(let index=panel.iterator();index.hasNext();) {
                            let vertex = index.next();
                            {
                                stack.push(vertex);
                            }
                        }
                        while((!stack.isEmpty())) {{
                            const vertex: com.vzome.core.algebra.AlgebraicVector = stack.pop();
                            let index: number = sortedFixedVertexList.indexOf(vertex);
                            if (index < 0){
                                index = sortedFixedVertexList.size() + sortedFloatingVertexList.indexOf(vertex);
                            }
                            this.output.print(index + ", ");
                        }};
                        this.output.print("], ");
                    }
                }
            }
            this.output.println$java_lang_Object(" ];");
            this.output.println$java_lang_Object("  zome_strut( tip_vertex, fixed_vertices, floating_vertices, faces, bottom_face_normal, size, scalar, offsets );");
            this.output.println$java_lang_Object("}");
            this.output.flush();
        }

        /**
         * 
         * @return {string}
         */
        public getFileExtension(): string {
            return "scad";
        }

        /**
         * 
         * @param {java.io.File} file
         * @param {java.io.Writer} writer
         * @param {number} height
         * @param {number} width
         */
        public doExport(file: java.io.File, writer: java.io.Writer, height: number, width: number) {
        }

        constructor() {
            super();
        }
    }
    OpenScadExporter["__class"] = "com.vzome.core.exporters.OpenScadExporter";
    OpenScadExporter["__interfaces"] = ["com.vzome.core.exporters.DocumentExporterIntf"];


}
namespace com.vzome.core.exporters {
    /**
     * Renders out to POV-Ray using #declare statements to reuse geometry.
     * @author vorth
     * @class
     * @extends com.vzome.core.exporters.DocumentExporter
     */
    export class POVRayExporter extends com.vzome.core.exporters.DocumentExporter {
        static FORMAT: java.text.NumberFormat; public static FORMAT_$LI$(): java.text.NumberFormat { if (POVRayExporter.FORMAT == null) { POVRayExporter.FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US); }  return POVRayExporter.FORMAT; }

        static PREAMBLE_FILE: string = "com/vzome/core/exporters/povray/preamble.pov";

        public mapViewToWorld(view: com.vzome.core.viewing.CameraIntf, vector: com.vzome.core.math.RealVector) {
        }

        /**
         * 
         * @return {boolean}
         */
        public needsManifestations(): boolean {
            return false;
        }

        /**
         * 
         * @param {java.io.File} povFile
         * @param {java.io.Writer} writer
         * @param {number} height
         * @param {number} width
         */
        public doExport(povFile: java.io.File, writer: java.io.Writer, height: number, width: number) {
            this.output = new java.io.PrintWriter(writer);
            const lookDir: com.vzome.core.math.RealVector = this.mScene.getLookDirectionRV();
            const upDir: com.vzome.core.math.RealVector = this.mScene.getUpDirectionRV();
            POVRayExporter.FORMAT_$LI$().setMaximumFractionDigits(8);
            this.output.println$();
            this.output.println$();
            this.output.println$java_lang_Object("#declare           look_dir = " + this.printTuple3d(lookDir) + ";");
            this.output.println$();
            this.output.println$java_lang_Object("#declare             up_dir = " + this.printTuple3d(upDir) + ";");
            this.output.println$();
            this.output.println$java_lang_Object("#declare viewpoint_distance = " + this.mScene.getViewDistance() + ";");
            this.output.println$();
            this.output.println$java_lang_Object("#declare      look_at_point = " + this.printTuple3d(this.mScene.getLookAtPointRV()) + ";");
            this.output.println$();
            this.output.println$java_lang_Object("#declare      field_of_view = " + this.mScene.getFieldOfView() + ";");
            this.output.println$();
            this.output.println$java_lang_Object("#declare      parallel_proj = " + (this.mScene.isPerspective() ? 0 : 1) + ";");
            this.output.println$();
            const preamble: string = com.vzome.xml.ResourceLoader.loadStringResource(POVRayExporter.PREAMBLE_FILE);
            this.output.println$java_lang_Object(preamble);
            this.output.println$();
            for(let i: number = 0; i < 3; i++) {{
                const color: com.vzome.core.construction.Color = this.mLights.getDirectionalLightColor(i);
                let rv: com.vzome.core.math.RealVector = this.mLights.getDirectionalLightVector(i);
                rv = this.mScene.mapViewToWorld(rv);
                this.output.print("light_source { -light_distance * " + this.printTuple3d(rv));
                this.output.print(" ");
                this.printColor(color);
                this.output.println$java_lang_Object(" * multiplier_light_" + (i + 1) + " }");
                this.output.println$();
            };}
            this.output.print("#declare ambient_color = ");
            this.printColor(this.mLights.getAmbientColor());
            this.output.println$java_lang_Object(";");
            this.output.println$();
            this.output.println$java_lang_Object("#default { texture { finish { phong 0.3 ambient multiplier_ambient * ambient_color diffuse 0.6 } } }");
            this.output.println$();
            this.output.print("background { ");
            this.printColor(this.mLights.getBackgroundColor());
            this.output.println$java_lang_Object(" }");
            this.output.println$();
            const instances: java.lang.StringBuffer = new java.lang.StringBuffer();
            const field: com.vzome.core.algebra.AlgebraicField = this.mModel.getField();
            const embedding: com.vzome.core.math.symmetry.Embedding = this.mModel.getEmbedding();
            let embeddingTransform: string = " ";
            if (!embedding.isTrivial()){
                embeddingTransform = " transform embedding ";
                this.output.print("#declare embedding = transform { matrix < ");
                for(let i: number = 0; i < 3; i++) {{
                    const columnSelect: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, i);
                    const columnI: com.vzome.core.math.RealVector = embedding.embedInR3(columnSelect);
                    this.output.print(columnI.x);
                    this.output.print(", ");
                    this.output.print(columnI.y);
                    this.output.print(", ");
                    this.output.print(columnI.z);
                    this.output.print(", ");
                };}
                this.output.println$java_lang_Object(" 0, 0, 0 > }");
                this.output.flush();
            }
            let numTransforms: number = 0;
            const shapes: java.util.HashSet<string> = <any>(new java.util.HashSet<any>());
            const transforms: java.util.Map<com.vzome.core.algebra.AlgebraicMatrix, string> = <any>(new java.util.HashMap<any, any>());
            const colors: java.util.Map<com.vzome.core.construction.Color, string> = <any>(new java.util.HashMap<any, any>());
            for(let index=this.mModel.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    const shapeName: string = "S" + /* replaceAll */rm.getShapeId().toString().replace(new RegExp("-", 'g'),"");
                    if (!shapes.contains(shapeName)){
                        shapes.add(shapeName);
                        this.exportShape(shapeName, rm.getShape());
                    }
                    const transform: com.vzome.core.algebra.AlgebraicMatrix = rm.getOrientation();
                    let transformName: string = transforms.get(transform);
                    if (transformName == null){
                        transformName = "trans" + numTransforms++;
                        transforms.put(transform, transformName);
                        this.exportTransform(transformName, transform);
                    }
                    let color: com.vzome.core.construction.Color = rm.getColor();
                    if (color == null)color = com.vzome.core.construction.Color.WHITE_$LI$();
                    let colorName: string = colors.get(color);
                    if (colorName == null){
                        colorName = this.nameColor(color);
                        colors.put(color, colorName);
                        this.exportColor(colorName, color);
                    }
                    instances.append("object { " + shapeName + " transform " + transformName + " translate ");
                    instances.append("(<");
                    let loc: com.vzome.core.algebra.AlgebraicVector = rm.getLocationAV();
                    if (loc == null)loc = rm.getShape().getField().origin(3);
                    this.appendVector(loc, instances);
                    instances.append(">)");
                    instances.append(embeddingTransform + "transform anim texture { " + colorName + " } }");
                    instances.append(java.lang.System.getProperty("line.separator"));
                }
            }
            this.output.println$java_lang_Object(instances.toString());
            this.output.flush();
            if (povFile == null)return;
            let filename: string = povFile.getName();
            const index: number = filename.lastIndexOf(".pov");
            if (index > 0){
                filename = filename.substring(0, index);
            }
            const file: java.io.File = new java.io.File(povFile.getParentFile(), filename + ".ini");
            this.output = new java.io.PrintWriter(new java.io.FileWriter(file));
            this.output.println$java_lang_Object("+W" + 600);
            this.output.println$java_lang_Object("+H" + 600);
            this.output.println$java_lang_Object("+A");
            this.output.println$java_lang_Object("Input_File_Name=" + filename + ".pov");
            this.output.println$java_lang_Object("Output_File_Name=" + filename + ".png");
            this.output.close();
        }

        nameColor(color: com.vzome.core.construction.Color): string {
            return "color_" + /* replace */color.toString().split(',').join('_');
        }

        /*private*/ printTuple3d(t: com.vzome.core.math.RealVector): string {
            const buf: java.lang.StringBuilder = new java.lang.StringBuilder("<");
            buf.append(POVRayExporter.FORMAT_$LI$().format(t.x));
            buf.append(",");
            buf.append(POVRayExporter.FORMAT_$LI$().format(t.y));
            buf.append(",");
            buf.append(POVRayExporter.FORMAT_$LI$().format(t.z));
            buf.append(">");
            return buf.toString();
        }

        exportColor(name: string, color: com.vzome.core.construction.Color) {
            this.output.print("#declare " + /* replace */name.split('.').join('_') + " = texture { pigment { ");
            this.printColor(color);
            this.output.println$java_lang_Object(" } };");
        }

        /*private*/ printColor(color: com.vzome.core.construction.Color) {
            const doAlpha: boolean = color.getAlpha() < 255;
            if (doAlpha)this.output.print("color rgbf <"); else this.output.print("color rgb <");
            const rgb: number[] = color.getRGBColorComponents([0, 0, 0, 0]);
            this.output.print(POVRayExporter.FORMAT_$LI$().format(rgb[0]) + ",");
            this.output.print(POVRayExporter.FORMAT_$LI$().format(rgb[1]) + ",");
            if (doAlpha){
                this.output.print(POVRayExporter.FORMAT_$LI$().format(rgb[2]) + ",");
                this.output.print(POVRayExporter.FORMAT_$LI$().format(rgb[3]));
            } else {
                this.output.print(POVRayExporter.FORMAT_$LI$().format(rgb[2]));
            }
            this.output.print(">");
        }

        appendVector(loc: com.vzome.core.algebra.AlgebraicVector, buf: java.lang.StringBuffer) {
            const vector: com.vzome.core.math.RealVector = loc.toRealVector();
            buf.append(POVRayExporter.FORMAT_$LI$().format(vector.x));
            buf.append(", ");
            buf.append(POVRayExporter.FORMAT_$LI$().format(vector.y));
            buf.append(", ");
            buf.append(POVRayExporter.FORMAT_$LI$().format(vector.z));
        }

        /*private*/ exportShape(shapeName: string, poly: com.vzome.core.math.Polyhedron) {
            this.output.print("#declare " + shapeName + " = ");
            const vertices: java.util.List<com.vzome.core.algebra.AlgebraicVector> = poly.getVertexList();
            this.output.println$java_lang_Object("mesh {");
            poly.getTriangleFaces();
            for(let index=poly.getTriangleFaces().iterator();index.hasNext();) {
                let face = index.next();
                {
                    this.output.print("triangle {");
                    for(let loopIndex = 0; loopIndex < face.vertices.length; loopIndex++) {
                        let index = face.vertices[loopIndex];
                        {
                            const loc: com.vzome.core.algebra.AlgebraicVector = vertices.get(index);
                            const buf: java.lang.StringBuffer = new java.lang.StringBuffer();
                            buf.append("<");
                            this.appendVector(loc, buf);
                            buf.append(">");
                            this.output.print(buf.toString());
                        }
                    }
                    this.output.println$java_lang_Object("}");
                }
            }
            this.output.println$java_lang_Object("}");
            this.output.flush();
        }

        /*private*/ exportTransform(name: string, transform: com.vzome.core.algebra.AlgebraicMatrix) {
            const field: com.vzome.core.algebra.AlgebraicField = this.mModel.getField();
            this.output.print("#declare " + name + " = transform { matrix < ");
            const buf: java.lang.StringBuffer = new java.lang.StringBuffer();
            for(let i: number = 0; i < 3; i++) {{
                const columnSelect: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, i);
                const columnI: com.vzome.core.algebra.AlgebraicVector = transform.timesColumn(columnSelect);
                this.appendVector(columnI, buf);
                buf.append(", ");
            };}
            this.output.print(buf);
            this.output.println$java_lang_Object(" 0, 0, 0 > }");
            this.output.flush();
        }

        /**
         * 
         * @return {string}
         */
        public getFileExtension(): string {
            return "pov";
        }

        constructor() {
            super();
        }
    }
    POVRayExporter["__class"] = "com.vzome.core.exporters.POVRayExporter";
    POVRayExporter["__interfaces"] = ["com.vzome.core.exporters.DocumentExporterIntf"];


}
namespace com.vzome.core.exporters {
    export class PartGeometryExporter extends com.vzome.core.exporters.VefExporter implements com.vzome.core.exporters.DocumentExporterIntf {
        /*private*/ selection: com.vzome.core.editor.api.Selection;

        public exportDocument(doc: com.vzome.core.exporters.DocumentIntf, file: java.io.File, writer: java.io.Writer, height: number, width: number) {
            this.mModel = doc.getRenderedModel();
            this.selection = doc.getEditorModel().getSelection();
            this.doExport(file, writer, height, width);
            this.selection = null;
            this.mModel = null;
        }

        /**
         * 
         * @param {java.io.File} directory
         * @param {java.io.Writer} writer
         * @param {number} height
         * @param {number} width
         */
        public doExport(directory: java.io.File, writer: java.io.Writer, height: number, width: number) {
            const field: com.vzome.core.algebra.AlgebraicField = this.mModel.getField();
            const exporter: com.vzome.core.model.VefModelExporter = new com.vzome.core.model.VefModelExporter(writer, field);
            for(let index=this.mModel.iterator();index.hasNext();) {
                let rm = index.next();
                {
                    exporter.exportManifestation(rm.getManifestation());
                }
            }
            exporter.finish();
            this.exportSelection(exporter);
        }

        /*private*/ exportSelection(exporter: com.vzome.core.model.VefModelExporter) {
            let tip: com.vzome.core.model.Connector = null;
            const arrayComparator: com.vzome.core.generic.ArrayComparator<com.vzome.core.algebra.AlgebraicVector> = <any>(new com.vzome.core.generic.ArrayComparator<any>());
            const panelVertices: java.util.SortedSet<com.vzome.core.algebra.AlgebraicVector[]> = <any>(new java.util.TreeSet<any>(<any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0, arg1) =>  (funcInst['compare'] ? funcInst['compare'] : funcInst) .call(funcInst, arg0, arg1)})(arrayComparator.getLengthFirstArrayComparator()))));
            const vertexArrayPanelMap: java.util.Map<com.vzome.core.algebra.AlgebraicVector[], com.vzome.core.model.Panel> = <any>(new java.util.HashMap<any, any>());
            for(let index=this.selection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        if (tip == null){
                            tip = <com.vzome.core.model.Connector><any>man;
                        }
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                        const panel: com.vzome.core.model.Panel = <com.vzome.core.model.Panel><any>man;
                        const corners: java.util.ArrayList<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>(panel.getVertexCount()));
                        for(let index=panel.iterator();index.hasNext();) {
                            let vertex = index.next();
                            {
                                corners.add(vertex);
                            }
                        }
                        const cornerArray: com.vzome.core.algebra.AlgebraicVector[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(corners.size());
                        corners.toArray<any>(cornerArray);
                        panelVertices.add(cornerArray);
                        vertexArrayPanelMap.put(cornerArray, panel);
                    }
                }
            }
            if (tip != null){
                exporter.exportSelectedManifestation(null);
                exporter.exportSelectedManifestation(tip);
                if (!panelVertices.isEmpty()){
                    exporter.exportSelectedManifestation(null);
                    for(let index=panelVertices.iterator();index.hasNext();) {
                        let vertexArray = index.next();
                        {
                            const panel: com.vzome.core.model.Panel = vertexArrayPanelMap.get(vertexArray);
                            exporter.exportSelectedManifestation(panel);
                        }
                    }
                }
                exporter.exportSelectedManifestation(null);
            }
        }

        constructor() {
            super();
            if (this.selection === undefined) { this.selection = null; }
        }
    }
    PartGeometryExporter["__class"] = "com.vzome.core.exporters.PartGeometryExporter";
    PartGeometryExporter["__interfaces"] = ["com.vzome.core.exporters.DocumentExporterIntf"];


}
namespace com.vzome.core.zomic.program {
    export class Reflect extends com.vzome.core.zomic.program.Permute {
        /**
         * 
         * @param {*} visitor
         */
        public accept(visitor: com.vzome.core.zomic.program.Visitor) {
            visitor.visitReflect(this.getAxis());
        }

        public constructor() {
            super(null);
        }

        /**
         * 
         * @param {com.vzome.core.math.symmetry.Axis} axis
         */
        public setAxis(axis: com.vzome.core.math.symmetry.Axis) {
            super.setAxis(axis);
        }
    }
    Reflect["__class"] = "com.vzome.core.zomic.program.Reflect";

}
namespace com.vzome.core.zomic.program {
    export class Rotate extends com.vzome.core.zomic.program.Permute {
        /*private*/ steps: number;

        /**
         * 
         * @param {*} visitor
         */
        public accept(visitor: com.vzome.core.zomic.program.Visitor) {
            visitor.visitRotate(this.getAxis(), this.steps);
        }

        public constructor(axis: com.vzome.core.math.symmetry.Axis, steps: number) {
            super(axis);
            if (this.steps === undefined) { this.steps = 0; }
            this.steps = steps;
        }

        public setSteps(steps: number) {
            this.steps = steps;
        }
    }
    Rotate["__class"] = "com.vzome.core.zomic.program.Rotate";

}
namespace com.vzome.core.zomic.program {
    export class Repeat extends com.vzome.core.zomic.program.Nested {
        /*private*/ repetitions: number;

        public constructor(repetitions: number) {
            super();
            if (this.repetitions === undefined) { this.repetitions = 0; }
            this.repetitions = repetitions;
        }

        /**
         * 
         * @param {*} visitor
         */
        public accept(visitor: com.vzome.core.zomic.program.Visitor) {
            visitor.visitRepeat(this, this.repetitions);
        }
    }
    Repeat["__class"] = "com.vzome.core.zomic.program.Repeat";

}
namespace com.vzome.core.zomic.program {
    /**
     * Description here.
     * 
     * @author Scott Vorthmann 2003
     * @param {number} state
     * @class
     * @extends com.vzome.core.zomic.program.Nested
     */
    export class Save extends com.vzome.core.zomic.program.Nested {
        /*private*/ m_state: number;

        public constructor(state: number) {
            super();
            if (this.m_state === undefined) { this.m_state = 0; }
            this.m_state = state;
        }

        /**
         * 
         * @param {*} visitor
         */
        public accept(visitor: com.vzome.core.zomic.program.Visitor) {
            visitor.visitSave(this, this.m_state);
        }

        public setState(state: number) {
            this.m_state = state;
        }
    }
    Save["__class"] = "com.vzome.core.zomic.program.Save";

}
namespace com.vzome.core.zomic.program {
    export class Symmetry extends com.vzome.core.zomic.program.Nested {
        /*private*/ permute: com.vzome.core.zomic.program.Permute;

        /**
         * 
         * @param {*} visitor
         */
        public accept(visitor: com.vzome.core.zomic.program.Visitor) {
            visitor.visitSymmetry(this, this.permute);
        }

        public setPermute(permute: com.vzome.core.zomic.program.Permute) {
            this.permute = permute;
        }

        public getPermute(): com.vzome.core.zomic.program.Permute {
            return this.permute;
        }

        constructor() {
            super();
            if (this.permute === undefined) { this.permute = null; }
        }
    }
    Symmetry["__class"] = "com.vzome.core.zomic.program.Symmetry";

}
namespace com.vzome.core.zomic {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.math.symmetry.IcosahedralSymmetry} symm
     * @class
     * @extends com.vzome.core.math.symmetry.NamingConvention
     */
    export class ZomicNamingConvention extends com.vzome.core.math.symmetry.NamingConvention {
        public static SHORT: number = 3;

        public static MEDIUM: number = 4;

        public static LONG: number = 5;

        public constructor(symm: com.vzome.core.math.symmetry.IcosahedralSymmetry) {
            super();
            let dir: com.vzome.core.math.symmetry.Direction = symm.getDirection("red");
            const redNames: com.vzome.core.math.symmetry.DirectionNaming = new com.vzome.core.zomic.ZomodDirectionNaming(dir, [0, 1, 2, 15, 17, 46]);
            this.addDirectionNaming(redNames);
            dir = symm.getDirection("yellow");
            const yellowNames: com.vzome.core.math.symmetry.DirectionNaming = new com.vzome.core.zomic.ZomodDirectionNaming(dir, [6, 9, 12, 0, 3, 1, 14, 5, 24, 17]);
            this.addDirectionNaming(yellowNames);
            dir = symm.getDirection("blue");
            this.addDirectionNaming(new com.vzome.core.zomic.ZomodDirectionNaming(dir, [9, 12, 0, 3, 6, 1, 14, 18, 26, 52, 58, 4, 7, 2, 5]));
            dir = symm.getDirection("olive");
            this.addDirectionNaming(new com.vzome.core.math.symmetry.DirectionNaming(dir, dir.getName()));
            dir = symm.getDirection("maroon");
            this.addDirectionNaming(new com.vzome.core.math.symmetry.DirectionNaming(dir, dir.getName()));
            dir = symm.getDirection("lavender");
            this.addDirectionNaming(new com.vzome.core.math.symmetry.DirectionNaming(dir, dir.getName()));
            dir = symm.getDirection("rose");
            this.addDirectionNaming(new com.vzome.core.math.symmetry.DirectionNaming(dir, dir.getName()));
            dir = symm.getDirection("navy");
            this.addDirectionNaming(new com.vzome.core.math.symmetry.DirectionNaming(dir, dir.getName()));
            dir = symm.getDirection("turquoise");
            this.addDirectionNaming(new com.vzome.core.math.symmetry.DirectionNaming(dir, dir.getName()));
            dir = symm.getDirection("coral");
            this.addDirectionNaming(new com.vzome.core.math.symmetry.DirectionNaming(dir, dir.getName()));
            dir = symm.getDirection("sulfur");
            this.addDirectionNaming(new com.vzome.core.math.symmetry.DirectionNaming(dir, dir.getName()));
            dir = symm.getDirection("green");
            this.addDirectionNaming(new com.vzome.core.zomic.GreenDirectionNaming(dir, redNames, yellowNames));
            dir = symm.getDirection("orange");
            this.addDirectionNaming(new com.vzome.core.zomic.GreenDirectionNaming(dir, redNames, yellowNames));
            dir = symm.getDirection("purple");
            this.addDirectionNaming(new ZomicNamingConvention.ZomicNamingConvention$0(this, dir, redNames, yellowNames));
            dir = symm.getDirection("black");
            this.addDirectionNaming(new com.vzome.core.zomic.BlackDirectionNaming(dir, redNames, yellowNames));
        }
    }
    ZomicNamingConvention["__class"] = "com.vzome.core.zomic.ZomicNamingConvention";


    export namespace ZomicNamingConvention {

        export class ZomicNamingConvention$0 extends com.vzome.core.zomic.GreenDirectionNaming {
            public __parent: any;
            public getName$com_vzome_core_math_symmetry_Axis(axis: com.vzome.core.math.symmetry.Axis): string {
                let orn: number = axis.getOrientation();
                const redNeighbor: com.vzome.core.math.symmetry.Axis = this.mRedNames.getDirection().getAxis$int$int(axis.getSense(), orn);
                const redName: string = this.mRedNames.getName$com_vzome_core_math_symmetry_Axis(redNeighbor);
                const rot: com.vzome.core.math.symmetry.Permutation = redNeighbor.getRotationPermutation();
                orn = rot.mapIndex(rot.mapIndex(orn));
                if (axis.getSense() === com.vzome.core.math.symmetry.Symmetry.MINUS)orn = rot.mapIndex(orn);
                const yellowNeighbor: com.vzome.core.math.symmetry.Axis = this.mYellowNames.getDirection().getAxis$int$int(axis.getSense(), orn);
                const yellowName: string = this.mYellowNames.getName$com_vzome_core_math_symmetry_Axis(yellowNeighbor).substring(1);
                return redName + yellowName;
            }

            /**
             * 
             * @param {com.vzome.core.math.symmetry.Axis} axis
             * @return {string}
             */
            public getName(axis?: any): string {
                if (((axis != null && axis instanceof <any>com.vzome.core.math.symmetry.Axis) || axis === null)) {
                    return <any>this.getName$com_vzome_core_math_symmetry_Axis(axis);
                } else if (axis === undefined) {
                    return <any>this.getName$();
                } else throw new Error('invalid overload');
            }

            constructor(__parent: any, __arg0: any, __arg1: any, __arg2: any) {
                super(__arg0, __arg1, __arg2);
                this.__parent = __parent;
            }
        }

    }

}
namespace com.vzome.core.kinds {
    /**
     * Everything here is stateless, or at worst, a cache (like Shapes).
     * An instance of this can be shared by many DocumentModels.
     * This is why it does not have tool factories, though it does
     * dictate what tool factories will be present.
     * 
     * @author vorth
     * @param {*} field
     * @class
     * @extends com.vzome.core.kinds.DefaultFieldApplication
     */
    export class SnubDodecFieldApplication extends com.vzome.core.kinds.DefaultFieldApplication {
        /*private*/ icosahedralPerspective: com.vzome.core.kinds.IcosahedralSymmetryPerspective;

        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            super(field);
            if (this.icosahedralPerspective === undefined) { this.icosahedralPerspective = null; }
            this.h4Builder = null;
            this.cmdTauDivide = new com.vzome.core.commands.CommandTauDivision();
            const icosaSymm: com.vzome.core.math.symmetry.IcosahedralSymmetry = new SnubDodecFieldApplication.SnubDodecFieldApplication$0(this, field);
            this.icosahedralPerspective = new com.vzome.core.kinds.IcosahedralSymmetryPerspective(icosaSymm);
        }

        /**
         * 
         * @return {string}
         */
        public getName(): string {
            return this.getField().getName();
        }

        /**
         * 
         * @return {string}
         */
        public getLabel(): string {
            return "Snub Dodecahedron";
        }

        /**
         * 
         * @return {*}
         */
        public getSymmetryPerspectives(): java.util.Collection<com.vzome.core.editor.SymmetryPerspective> {
            return java.util.Arrays.asList<any>(this.icosahedralPerspective, super.getDefaultSymmetryPerspective());
        }

        /**
         * 
         * @return {*}
         */
        public getDefaultSymmetryPerspective(): com.vzome.core.editor.SymmetryPerspective {
            return this.icosahedralPerspective;
        }

        /**
         * 
         * @param {string} symmName
         * @return {*}
         */
        public getSymmetryPerspective(symmName: string): com.vzome.core.editor.SymmetryPerspective {
            switch((symmName)) {
            case "icosahedral":
                return this.icosahedralPerspective;
            default:
                return super.getSymmetryPerspective(symmName);
            }
        }

        /**
         * 
         * @param {string} name
         * @return {com.vzome.core.math.symmetry.QuaternionicSymmetry}
         */
        public getQuaternionSymmetry(name: string): com.vzome.core.math.symmetry.QuaternionicSymmetry {
            return this.icosahedralPerspective.getQuaternionSymmetry(name);
        }

        /**
         * 
         * @param {*} toolFactories
         * @param {com.vzome.core.editor.ToolsModel} tools
         */
        public registerToolFactories(toolFactories: java.util.Map<string, com.vzome.api.Tool.Factory>, tools: com.vzome.core.editor.ToolsModel) {
            super.registerToolFactories(toolFactories, tools);
            const symm: com.vzome.core.math.symmetry.IcosahedralSymmetry = this.icosahedralPerspective.getSymmetry();
            toolFactories.put("AxialStretchTool", new com.vzome.core.tools.AxialStretchTool.Factory(tools, symm, false, false, false));
            toolFactories.put("SymmetryTool", new com.vzome.core.tools.IcosahedralToolFactory(tools, symm));
        }

        /*private*/ h4Builder: com.vzome.core.commands.CommandUniformH4Polytope;

        /**
         * 
         * @param {string} groupName
         * @param {number} index
         * @param {number} edgesToRender
         * @param {com.vzome.core.algebra.AlgebraicNumber[]} edgeScales
         * @param {*} listener
         */
        public constructPolytope(groupName: string, index: number, edgesToRender: number, edgeScales: com.vzome.core.algebra.AlgebraicNumber[], listener: com.vzome.core.math.symmetry.WythoffConstruction.Listener) {
            switch((groupName)) {
            case "H4":
                if (this.h4Builder == null){
                    const qsymm: com.vzome.core.math.symmetry.QuaternionicSymmetry = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", this.getField());
                    this.h4Builder = new com.vzome.core.commands.CommandUniformH4Polytope(this.getField(), qsymm, 0);
                }
                this.h4Builder.generate(index, edgesToRender, edgeScales, listener);
                break;
            default:
                super.constructPolytope(groupName, index, edgesToRender, edgeScales, listener);
                break;
            }
        }

        /*private*/ cmdTauDivide: com.vzome.core.commands.Command;

        /**
         * 
         * @param {string} action
         * @return {*}
         */
        public getLegacyCommand(action: string): com.vzome.core.commands.Command {
            switch((action)) {
            case "tauDivide":
                return this.cmdTauDivide;
            default:
                return super.getLegacyCommand(action);
            }
        }
    }
    SnubDodecFieldApplication["__class"] = "com.vzome.core.kinds.SnubDodecFieldApplication";
    SnubDodecFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D","com.vzome.core.editor.FieldApplication"];



    export namespace SnubDodecFieldApplication {

        export class SnubDodecFieldApplication$0 extends com.vzome.core.math.symmetry.IcosahedralSymmetry {
            public __parent: any;
            /**
             * 
             */
            createOtherOrbits() {
                super.createOtherOrbits();
                const vSnubPentagon: com.vzome.core.algebra.AlgebraicVector = this.mField.createIntegerVector([[4, -4, 0, 0, -2, 2], [-4, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 2]]);
                const vSnubTriangle: com.vzome.core.algebra.AlgebraicVector = this.mField.createIntegerVector([[0, -4, -2, 0, 0, 2], [-4, 4, 0, -2, 2, -2], [-4, 0, -2, -2, 2, 0]]);
                const vSnubDiagonal: com.vzome.core.algebra.AlgebraicVector = this.mField.createIntegerVector([[8, 0, 0, 4, -4, 0], [0, -4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]);
                const vSnubFaceNorm: com.vzome.core.algebra.AlgebraicVector = this.mField.createIntegerVector([[-1, 0, 1, -1, 1, 0], [1, 0, 0, 0, 0, 0], [1, 0, -1, 2, 0, 1]]);
                const vSnubVertex: com.vzome.core.algebra.AlgebraicVector = this.mField.createIntegerVector([[1, 0, 0, 0, 0, 0], [1, 0, -1, 1, -1, 0], [1, 0, 0, 1, -1, 1]]);
                const scale: com.vzome.core.algebra.AlgebraicNumber = this.mField['createPower$int'](-3);
                let scaleFaceNorm: com.vzome.core.algebra.AlgebraicNumber;
                let scaleVertex: com.vzome.core.algebra.AlgebraicNumber = this.mField.one();
                scaleFaceNorm = this.mField['createAlgebraicNumber$int_A']([-3, 2, 2, -1, 5, -3]).reciprocal();
                scaleVertex = this.mField['createAlgebraicNumber$int_A$int']([-3, 2, 7, -4, 2, -1], 3).reciprocal();
                this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubPentagon", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubPentagon, false, false, scale).withCorrection();
                this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubTriangle", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubTriangle, false, false, scale).withCorrection();
                this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubDiagonal", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubDiagonal, false, false, scale).withCorrection();
                this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubFaceNormal", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubFaceNorm, false, false, scale['times$com_vzome_core_algebra_AlgebraicNumber'](scaleFaceNorm)).withCorrection();
                this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubVertex", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubVertex, true, false, scale['times$com_vzome_core_algebra_AlgebraicNumber'](scaleVertex)).withCorrection();
            }

            constructor(__parent: any, __arg0: any) {
                super(__arg0);
                this.__parent = __parent;
            }
        }
        SnubDodecFieldApplication$0["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry","com.vzome.core.math.symmetry.Embedding"];


    }

}
namespace com.vzome.core.kinds {
    /**
     * Everything here is stateless, or at worst, a cache (like Shapes).
     * An instance of this can be shared by many DocumentModels.
     * This is why it does not have tool factories, though it does
     * dictate what tool factories will be present.
     * 
     * @author Scott Vorthmann
     * @param {*} field
     * @class
     * @extends com.vzome.core.kinds.DefaultFieldApplication
     */
    export class RootTwoFieldApplication extends com.vzome.core.kinds.DefaultFieldApplication {
        public constructor(field: com.vzome.core.algebra.AlgebraicField) {
            super(field);
            this.synestructicsSymmetry = new RootTwoFieldApplication.RootTwoFieldApplication$0(this, this.getField(), "orange");
            this.synestructicsPerspective = new RootTwoFieldApplication.RootTwoFieldApplication$1(this, this.synestructicsSymmetry);
            const octahedralPerspective: com.vzome.core.kinds.OctahedralSymmetryPerspective = <com.vzome.core.kinds.OctahedralSymmetryPerspective><any>super.getDefaultSymmetryPerspective();
            const symmetry: com.vzome.core.math.symmetry.AbstractSymmetry = octahedralPerspective.getSymmetry();
            symmetry.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean("yellow", 0, 4, [[1, 1, 0, 1], [1, 1, 0, 1], [1, 1, 0, 1]], true);
            symmetry.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean("green", 1, 8, [[0, 1, 1, 2], [0, 1, 1, 2], [0, 1, 0, 1]], true);
            symmetry.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean("brown", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 1, 0, 1], [1, 1, 0, 1], [2, 1, 0, 1]], true);
            const defaultShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "rootTwoSmall", "small octahedra", "small connectors", symmetry);
            octahedralPerspective.setDefaultGeometry(defaultShapes);
            octahedralPerspective.addShapes(new com.vzome.core.viewing.ExportedVEFShapes(null, "rootTwoBig", "ornate", symmetry, defaultShapes));
            const rootTwoShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.SchochShapes(null, "rootTwo", "Schoch solid", symmetry, defaultShapes);
            octahedralPerspective.addShapes(rootTwoShapes);
            octahedralPerspective.addShapes(new com.vzome.core.viewing.SchochShapes(null, "root2Lifelike", "Schoch lifelike", symmetry, rootTwoShapes));
        }

        /**
         * 
         * @return {string}
         */
        public getLabel(): string {
            return "\u221a2";
        }

        /*private*/ synestructicsSymmetry: com.vzome.core.math.symmetry.Symmetry;

        /*private*/ synestructicsPerspective: com.vzome.core.editor.SymmetryPerspective;

        /**
         * 
         * @return {*}
         */
        public getSymmetryPerspectives(): java.util.Collection<com.vzome.core.editor.SymmetryPerspective> {
            return java.util.Arrays.asList<any>(super.getDefaultSymmetryPerspective(), this.synestructicsPerspective);
        }

        /**
         * 
         * @param {string} symmName
         * @return {*}
         */
        public getSymmetryPerspective(symmName: string): com.vzome.core.editor.SymmetryPerspective {
            switch((symmName)) {
            case "synestructics":
                return this.synestructicsPerspective;
            default:
                return super.getSymmetryPerspective(symmName);
            }
        }
    }
    RootTwoFieldApplication["__class"] = "com.vzome.core.kinds.RootTwoFieldApplication";
    RootTwoFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D","com.vzome.core.editor.FieldApplication"];



    export namespace RootTwoFieldApplication {

        export class RootTwoFieldApplication$0 extends com.vzome.core.math.symmetry.OctahedralSymmetry {
            public __parent: any;
            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return "synestructics";
            }

            /**
             * 
             * @param {com.vzome.core.math.symmetry.SpecialOrbit} which
             * @return {com.vzome.core.math.symmetry.Direction}
             */
            public getSpecialOrbit(which: com.vzome.core.math.symmetry.SpecialOrbit): com.vzome.core.math.symmetry.Direction {
                switch((which)) {
                case com.vzome.core.math.symmetry.SpecialOrbit.BLUE:
                    return this.getDirection(this.frameColor);
                case com.vzome.core.math.symmetry.SpecialOrbit.RED:
                    return this.getDirection("magenta");
                case com.vzome.core.math.symmetry.SpecialOrbit.YELLOW:
                    return this.getDirection("yellow");
                default:
                    return null;
                }
            }

            /**
             * 
             * @return {com.vzome.core.algebra.AlgebraicVector[]}
             */
            public getOrbitTriangle(): com.vzome.core.algebra.AlgebraicVector[] {
                const magentaVertex: com.vzome.core.algebra.AlgebraicVector = this.getDirection("magenta").getPrototype();
                const orangeVertex: com.vzome.core.algebra.AlgebraicVector = this.getDirection(this.frameColor).getPrototype();
                const yellowVertex: com.vzome.core.algebra.AlgebraicVector = this.getDirection("yellow").getPrototype();
                return [magentaVertex, orangeVertex, yellowVertex];
            }

            /**
             * 
             */
            createOtherOrbits() {
                let v: com.vzome.core.algebra.AlgebraicVector = new com.vzome.core.algebra.AlgebraicVector(this.mField.one(), this.mField.one(), this.mField.one());
                this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("yellow", 0, 4, v, true);
                const sqrt2: com.vzome.core.algebra.AlgebraicNumber = this.mField['createPower$int'](1);
                const half: com.vzome.core.algebra.AlgebraicNumber = this.mField['createRational$long$long'](1, 2);
                v = new com.vzome.core.algebra.AlgebraicVector(sqrt2, sqrt2, this.mField.zero()).scale(half);
                this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("magenta", 1, 8, v, true);
                v = new com.vzome.core.algebra.AlgebraicVector(this.mField.one(), this.mField.one(), this.mField.one()['plus$com_vzome_core_algebra_AlgebraicNumber'](this.mField.one()));
                this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("brown", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, v, true);
            }

            constructor(__parent: any, __arg0: any, __arg1: any) {
                super(__arg0, __arg1);
                this.__parent = __parent;
            }
        }
        RootTwoFieldApplication$0["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry","com.vzome.core.math.symmetry.Embedding"];



        export class RootTwoFieldApplication$1 extends com.vzome.core.kinds.AbstractSymmetryPerspective {
            public __parent: any;
            /**
             * 
             * @param {com.vzome.api.Tool.Kind} kind
             * @param {com.vzome.core.editor.ToolsModel} tools
             * @return {*}
             */
            public createToolFactories(kind: com.vzome.api.Tool.Kind, tools: com.vzome.core.editor.ToolsModel): java.util.List<com.vzome.api.Tool.Factory> {
                const result: java.util.List<com.vzome.api.Tool.Factory> = <any>(new java.util.ArrayList<any>());
                switch((kind)) {
                case com.vzome.api.Tool.Kind.SYMMETRY:
                    result.add(new com.vzome.core.tools.OctahedralToolFactory(tools, this.symmetry));
                    result.add(new com.vzome.core.tools.TetrahedralToolFactory(tools, this.symmetry));
                    result.add(new com.vzome.core.tools.InversionToolFactory(tools));
                    result.add(new com.vzome.core.tools.LineReflectionToolFactory(tools));
                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools));
                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry));
                    break;
                case com.vzome.api.Tool.Kind.TRANSFORM:
                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry));
                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry));
                    result.add(new com.vzome.core.tools.TranslationToolFactory(tools));
                    result.add(new com.vzome.core.tools.ProjectionToolFactory(tools));
                    break;
                case com.vzome.api.Tool.Kind.LINEAR_MAP:
                    result.add(new com.vzome.core.tools.LinearMapToolFactory(tools, this.symmetry, false));
                    break;
                default:
                    break;
                }
                return result;
            }

            /**
             * 
             * @param {com.vzome.api.Tool.Kind} kind
             * @param {com.vzome.core.editor.ToolsModel} tools
             * @return {*}
             */
            public predefineTools(kind: com.vzome.api.Tool.Kind, tools: com.vzome.core.editor.ToolsModel): java.util.List<com.vzome.api.Tool> {
                const result: java.util.List<com.vzome.api.Tool> = <any>(new java.util.ArrayList<any>());
                switch((kind)) {
                case com.vzome.api.Tool.Kind.SYMMETRY:
                    result.add(new com.vzome.core.tools.OctahedralToolFactory(tools, this.symmetry).createPredefinedTool("octahedral around origin"));
                    result.add(new com.vzome.core.tools.TetrahedralToolFactory(tools, this.symmetry).createPredefinedTool("tetrahedral around origin"));
                    result.add(new com.vzome.core.tools.InversionToolFactory(tools).createPredefinedTool("reflection through origin"));
                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools).createPredefinedTool("reflection through XY plane"));
                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry).createPredefinedTool("symmetry around green through origin"));
                    break;
                case com.vzome.api.Tool.Kind.TRANSFORM:
                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale down"));
                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale up"));
                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry, true).createPredefinedTool("rotate around green through origin"));
                    result.add(new com.vzome.core.tools.TranslationToolFactory(tools).createPredefinedTool("b1 move along +X"));
                    break;
                default:
                    break;
                }
                return result;
            }

            /**
             * 
             * @return {string}
             */
            public getModelResourcePath(): string {
                return "org/vorthmann/zome/app/octahedral-vef.vZome";
            }

            constructor(__parent: any, __arg0: any) {
                super(__arg0);
                this.__parent = __parent;
                (() => {
                    const defaultShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "rootTwoSmall", "small octahedra", this.symmetry, null);
                    const synestructicsShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "rootTwo", "Synestructics", this.symmetry, defaultShapes);
                    const ornateShapes: com.vzome.core.viewing.AbstractShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "rootTwoBig", "ornate", this.symmetry, defaultShapes);
                    this.setDefaultGeometry(defaultShapes);
                    this.addShapes(synestructicsShapes);
                    this.addShapes(ornateShapes);
                })();
            }
        }
        RootTwoFieldApplication$1["__interfaces"] = ["com.vzome.core.editor.SymmetryPerspective"];


    }

}
namespace com.vzome.core.viewing {
    export class SchochShapes extends com.vzome.core.viewing.ExportedVEFShapes {
        static serialVersionUID: number = 1;

        public constructor(prefsFolder: java.io.File, name: string, alias: string, symmetry: com.vzome.core.math.symmetry.AbstractSymmetry, defaultShapes: com.vzome.core.viewing.AbstractShapes) {
            super(prefsFolder, name, alias, symmetry, defaultShapes);
        }

        /**
         * 
         * @return {number}
         */
        public getCmScaling(): number {
            return 1.0;
        }
    }
    SchochShapes["__class"] = "com.vzome.core.viewing.SchochShapes";
    SchochShapes["__interfaces"] = ["com.vzome.core.editor.api.Shapes"];


}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @param {*} projection
     * @class
     * @extends com.vzome.core.commands.AbstractCommand
     */
    export class CommandImportVEFData extends com.vzome.core.commands.AbstractCommand {
        public static X: number = 0;

        public static Y: number = 1;

        public static Z: number = 2;

        public static W: number = 3;

        public static VEF_STRING_ATTR_NAME: string = "org.vorthmann.zome.commands.CommandImportVEFData.vef.string";

        public static FIELD_ATTR_NAME: string = "org.vorthmann.zome.commands.CommandImportVEFData.field";

        public static NO_INVERSION_ATTR_NAME: string = "org.vorthmann.zome.commands.CommandImportVEFData.no.inversion";

        static PARAM_SIGNATURE: any[][]; public static PARAM_SIGNATURE_$LI$(): any[][] { if (CommandImportVEFData.PARAM_SIGNATURE == null) { CommandImportVEFData.PARAM_SIGNATURE = [[com.vzome.core.commands.Command.GENERIC_PARAM_NAME, com.vzome.core.construction.Construction]]; }  return CommandImportVEFData.PARAM_SIGNATURE; }

        static ATTR_SIGNATURE: any[][]; public static ATTR_SIGNATURE_$LI$(): any[][] { if (CommandImportVEFData.ATTR_SIGNATURE == null) { CommandImportVEFData.ATTR_SIGNATURE = [[CommandImportVEFData.VEF_STRING_ATTR_NAME, String], [com.vzome.core.commands.Command.FIELD_ATTR_NAME, java.io.InputStream], [CommandImportVEFData.NO_INVERSION_ATTR_NAME, java.io.InputStream]]; }  return CommandImportVEFData.ATTR_SIGNATURE; }

        /*private*/ mProjection: com.vzome.core.math.Projection;

        public constructor(projection?: any) {
            if (((projection != null && (projection.constructor != null && projection.constructor["__interfaces"] != null && projection.constructor["__interfaces"].indexOf("com.vzome.core.math.Projection") >= 0)) || projection === null)) {
                let __args = arguments;
                super();
                if (this.mProjection === undefined) { this.mProjection = null; } 
                this.quaternionVector = null;
                this.mProjection = projection;
            } else if (projection === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let projection: any = null;
                    super();
                    if (this.mProjection === undefined) { this.mProjection = null; } 
                    this.quaternionVector = null;
                    this.mProjection = projection;
                }
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getParameterSignature(): any[][] {
            return CommandImportVEFData.PARAM_SIGNATURE_$LI$();
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return CommandImportVEFData.ATTR_SIGNATURE_$LI$();
        }

        /**
         * 
         * @param {string} attrName
         * @return {boolean}
         */
        public attributeIs3D(attrName: string): boolean {
            return !("symmetry.axis.segment" === attrName);
        }

        /*private*/ quaternionVector: com.vzome.core.algebra.AlgebraicVector;

        /**
         * Only called when migrating a 2.0 model file.
         * @param {com.vzome.core.algebra.AlgebraicVector} offset
         */
        public setQuaternion(offset: com.vzome.core.algebra.AlgebraicVector) {
            this.quaternionVector = offset;
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         * @return {com.vzome.core.commands.AttributeMap}
         */
        public setXml(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat): com.vzome.core.commands.AttributeMap {
            const attrs: com.vzome.core.commands.AttributeMap = super.setXml(xml, format);
            this.quaternionVector = format.parseRationalVector(xml, "quaternion");
            return attrs;
        }

        /**
         * 
         * @param {*} result
         * @param {com.vzome.core.commands.AttributeMap} attributes
         */
        public getXml(result: org.w3c.dom.Element, attributes: com.vzome.core.commands.AttributeMap) {
            if (this.quaternionVector != null)com.vzome.xml.DomUtils.addAttribute(result, "quaternion", this.quaternionVector.toParsableString());
            super.getXml(result, attributes);
        }

        /**
         * 
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        public setFixedAttributes(attributes: com.vzome.core.commands.AttributeMap, format: com.vzome.core.commands.XmlSaveFormat) {
            if (!attributes.containsKey(CommandImportVEFData.FIELD_ATTR_NAME))attributes.put(CommandImportVEFData.FIELD_ATTR_NAME, format.getField());
            super.setFixedAttributes(attributes, format);
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attributes: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const result: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            let field: com.vzome.core.algebra.AlgebraicField = <com.vzome.core.algebra.AlgebraicField><any>attributes.get(CommandImportVEFData.FIELD_ATTR_NAME);
            if (field == null)field = <com.vzome.core.algebra.AlgebraicField><any>attributes.get(com.vzome.core.commands.Command.FIELD_ATTR_NAME);
            const symmAxis: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME);
            const vefData: string = <string>attributes.get(CommandImportVEFData.VEF_STRING_ATTR_NAME);
            const noInversion: boolean = <boolean>attributes.get(CommandImportVEFData.NO_INVERSION_ATTR_NAME);
            let projection: com.vzome.core.math.Projection = this.mProjection;
            if (projection == null){
                let quaternion: com.vzome.core.algebra.AlgebraicVector = this.quaternionVector;
                if (quaternion == null)quaternion = (symmAxis == null) ? null : symmAxis.getOffset();
                if (quaternion != null)quaternion = quaternion.scale(field['createPower$int'](-5));
                projection = quaternion == null ? null : new com.vzome.core.math.QuaternionProjection(field, null, quaternion);
            }
            if (noInversion != null && noInversion)new CommandImportVEFData.VefToModelNoInversion(this, projection, field, effects).parseVEF(vefData, field); else new com.vzome.core.construction.VefToModel(projection, effects, field['createPower$int'](5), null).parseVEF(vefData, field);
            return result;
        }
    }
    CommandImportVEFData["__class"] = "com.vzome.core.commands.CommandImportVEFData";
    CommandImportVEFData["__interfaces"] = ["com.vzome.core.commands.Command"];



    export namespace CommandImportVEFData {

        export class VefToModelNoInversion extends com.vzome.core.construction.VefToModel {
            public __parent: any;
            mProjected: com.vzome.core.algebra.AlgebraicVector[][];

            mUsedPoints: java.util.Set<com.vzome.core.construction.Point>;

            public constructor(__parent: any, projection: com.vzome.core.math.Projection, field: com.vzome.core.algebra.AlgebraicField, effects: com.vzome.core.construction.ConstructionChanges) {
                super(projection, effects, field['createPower$int'](5), null);
                this.__parent = __parent;
                if (this.mProjected === undefined) { this.mProjected = null; }
                this.mUsedPoints = <any>(new java.util.HashSet<any>());
            }

            /**
             * 
             * @param {number} index
             * @param {com.vzome.core.algebra.AlgebraicVector} location
             */
            addVertex(index: number, location: com.vzome.core.algebra.AlgebraicVector) {
                if (this.scale != null){
                    location = location.scale(this.scale);
                }
                if (this.mProjection != null)location = this.mProjection.projectImage(location, this.wFirst());
                this.mVertices[index] = new com.vzome.core.construction.FreePoint(location);
            }

            /**
             * 
             * @param {number} numEdges
             */
            startEdges(numEdges: number) {
                this.mProjected = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([numEdges, 2]);
            }

            /**
             * 
             * @param {number} index
             * @param {number} v1
             * @param {number} v2
             */
            addEdge(index: number, v1: number, v2: number) {
                const p1: com.vzome.core.construction.Point = this.mVertices[v1];
                const p2: com.vzome.core.construction.Point = this.mVertices[v2];
                if (p1 == null || p2 == null)return;
                const seg: com.vzome.core.construction.Segment = new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                const pr1: com.vzome.core.algebra.AlgebraicVector = p1.getLocation().projectTo3d(this.wFirst()).negate();
                const pr2: com.vzome.core.algebra.AlgebraicVector = p2.getLocation().projectTo3d(this.wFirst()).negate();
                for(let i: number = 0; i < index; i++) {{
                    if (pr1.equals(this.mProjected[i][0]) && pr2.equals(this.mProjected[i][1]))return;
                    if (pr2.equals(this.mProjected[i][0]) && pr1.equals(this.mProjected[i][1]))return;
                };}
                this.mProjected[index][0] = pr1.negate();
                this.mProjected[index][1] = pr2.negate();
                this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](seg);
                this.mUsedPoints.add(p1);
                this.mUsedPoints.add(p2);
            }

            /**
             * 
             */
            endEdges() {
                for(let index=this.mUsedPoints.iterator();index.hasNext();) {
                    let point = index.next();
                    {
                        this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](point);
                    }
                }
            }
        }
        VefToModelNoInversion["__class"] = "com.vzome.core.commands.CommandImportVEFData.VefToModelNoInversion";

    }

}
namespace com.vzome.core.construction {
    export class PolygonFromVertices extends com.vzome.core.construction.Polygon {
        /*private*/ __com_vzome_core_construction_PolygonFromVertices_mVertices: com.vzome.core.construction.Point[];

        public constructor(points?: any) {
            if (((points != null && (points.constructor != null && points.constructor["__interfaces"] != null && points.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || points === null)) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let vertices: any = points.toArray<any>((s => { let a=[]; while(s-->0) a.push(null); return a; })(points.size()));
                    super(vertices.length === 0 ? null : vertices[0].field);
                    if (this.__com_vzome_core_construction_PolygonFromVertices_mVertices === undefined) { this.__com_vzome_core_construction_PolygonFromVertices_mVertices = null; } 
                    this.__com_vzome_core_construction_PolygonFromVertices_mVertices = vertices;
                    this.mapParamsToState();
                }
            } else if (((points != null && points instanceof <any>Array && (points.length == 0 || points[0] == null ||(points[0] != null && points[0] instanceof <any>com.vzome.core.construction.Point))) || points === null)) {
                let __args = arguments;
                let vertices: any = __args[0];
                super(vertices.length === 0 ? null : vertices[0].field);
                if (this.__com_vzome_core_construction_PolygonFromVertices_mVertices === undefined) { this.__com_vzome_core_construction_PolygonFromVertices_mVertices = null; } 
                this.__com_vzome_core_construction_PolygonFromVertices_mVertices = vertices;
                this.mapParamsToState();
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            const locs: com.vzome.core.algebra.AlgebraicVector[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.__com_vzome_core_construction_PolygonFromVertices_mVertices.length);
            for(let i: number = 0; i < this.__com_vzome_core_construction_PolygonFromVertices_mVertices.length; i++) {locs[i] = this.__com_vzome_core_construction_PolygonFromVertices_mVertices[i].getLocation();}
            return this.setStateVariable(locs, false);
        }
    }
    PolygonFromVertices["__class"] = "com.vzome.core.construction.PolygonFromVertices";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.construction.Transformation} transform
     * @param {com.vzome.core.construction.Polygon} prototype
     * @class
     * @extends com.vzome.core.construction.Polygon
     */
    export class TransformedPolygon extends com.vzome.core.construction.Polygon {
        /*private*/ mTransform: com.vzome.core.construction.Transformation;

        /*private*/ mPrototype: com.vzome.core.construction.Polygon;

        public constructor(transform: com.vzome.core.construction.Transformation, prototype: com.vzome.core.construction.Polygon) {
            super(prototype.field);
            if (this.mTransform === undefined) { this.mTransform = null; }
            if (this.mPrototype === undefined) { this.mPrototype = null; }
            this.mTransform = transform;
            this.mPrototype = prototype;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            const vertices: com.vzome.core.algebra.AlgebraicVector[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.mPrototype.getVertexCount());
            for(let i: number = 0; i < vertices.length; i++) {{
                vertices[i] = this.mTransform.transform$com_vzome_core_algebra_AlgebraicVector(this.mPrototype.getVertex(i));
            };}
            return this.setStateVariable(vertices, false);
        }
    }
    TransformedPolygon["__class"] = "com.vzome.core.construction.TransformedPolygon";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.algebra.Quaternion} leftQuaternion
     * @param {com.vzome.core.algebra.Quaternion} rightQuaternion
     * @param {com.vzome.core.construction.Polygon} prototype
     * @class
     * @extends com.vzome.core.construction.Polygon
     */
    export class PolygonRotated4D extends com.vzome.core.construction.Polygon {
        /*private*/ mLeftQuaternion: com.vzome.core.algebra.Quaternion;

        /*private*/ mRightQuaternion: com.vzome.core.algebra.Quaternion;

        /*private*/ mPrototype: com.vzome.core.construction.Polygon;

        public constructor(leftQuaternion: com.vzome.core.algebra.Quaternion, rightQuaternion: com.vzome.core.algebra.Quaternion, prototype: com.vzome.core.construction.Polygon) {
            super(prototype.field);
            if (this.mLeftQuaternion === undefined) { this.mLeftQuaternion = null; }
            if (this.mRightQuaternion === undefined) { this.mRightQuaternion = null; }
            if (this.mPrototype === undefined) { this.mPrototype = null; }
            this.mLeftQuaternion = leftQuaternion;
            this.mRightQuaternion = rightQuaternion;
            this.mPrototype = prototype;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.mPrototype.isImpossible())return this.setStateVariable(null, true);
            const vertices: com.vzome.core.algebra.AlgebraicVector[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(this.mPrototype.getVertexCount());
            for(let i: number = 0; i < vertices.length; i++) {{
                let loc: com.vzome.core.algebra.AlgebraicVector = this.mRightQuaternion.leftMultiply(this.mPrototype.getVertex(i));
                loc = this.mLeftQuaternion.rightMultiply(loc);
                vertices[i] = loc;
            };}
            return this.setStateVariable(vertices, false);
        }
    }
    PolygonRotated4D["__class"] = "com.vzome.core.construction.PolygonRotated4D";

}
namespace com.vzome.core.construction {
    export class MatrixTransformation extends com.vzome.core.construction.Transformation {
        public constructor(matrix: com.vzome.core.algebra.AlgebraicMatrix, center: com.vzome.core.algebra.AlgebraicVector) {
            super(center.getField());
            this.setStateVariables(matrix, center, false);
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            return true;
        }
    }
    MatrixTransformation["__class"] = "com.vzome.core.construction.MatrixTransformation";

}
namespace com.vzome.core.construction {
    /**
     * @param prototype
     * @param {com.vzome.core.construction.Plane} projectionPlane
     * @param {com.vzome.core.construction.Line} projectionLine
     * @class
     * @extends com.vzome.core.construction.Transformation
     * @author Scott Vorthmann
     */
    export class PlaneProjection extends com.vzome.core.construction.Transformation {
        /*private*/ projectionPlane: com.vzome.core.construction.Plane;

        /*private*/ projectionVector: com.vzome.core.algebra.AlgebraicVector;

        public constructor(projectionPlane: com.vzome.core.construction.Plane, projectionLine: com.vzome.core.construction.Line) {
            super(projectionPlane.field);
            if (this.projectionPlane === undefined) { this.projectionPlane = null; }
            if (this.projectionVector === undefined) { this.projectionVector = null; }
            this.projectionPlane = projectionPlane;
            if (projectionLine == null)this.projectionVector = projectionPlane.getNormal(); else this.projectionVector = projectionLine.getDirection();
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.projectionPlane.isImpossible())this.setStateVariables(null, null, true);
            const loc: com.vzome.core.algebra.AlgebraicVector = this.projectionPlane.getBase();
            return this.setStateVariables(null, loc, false);
        }

        public transform$com_vzome_core_algebra_AlgebraicVector(arg: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            const line: com.vzome.core.construction.Line = new com.vzome.core.construction.LineFromPointAndVector(arg, this.projectionVector);
            const point: com.vzome.core.construction.Point = new com.vzome.core.construction.LinePlaneIntersectionPoint(this.projectionPlane, line);
            return point.getLocation();
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} arg
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public transform(arg?: any): any {
            if (((arg != null && arg instanceof <any>com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                return <any>this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
            } else if (((arg != null && arg instanceof <any>com.vzome.core.construction.Construction) || arg === null)) {
                return <any>this.transform$com_vzome_core_construction_Construction(arg);
            } else throw new Error('invalid overload');
        }

        public transform$com_vzome_core_construction_Construction(c: com.vzome.core.construction.Construction): com.vzome.core.construction.Construction {
            if (c != null && c instanceof <any>com.vzome.core.construction.Segment){
                if (com.vzome.core.algebra.AlgebraicVectors.areParallel(this.projectionVector, (<com.vzome.core.construction.Segment>c).getOffset())){
                    return new com.vzome.core.construction.LinePlaneIntersectionPoint(this.projectionPlane, new com.vzome.core.construction.LineExtensionOfSegment(<com.vzome.core.construction.Segment>c));
                }
            } else if (c != null && c instanceof <any>com.vzome.core.construction.Polygon){
                let p: com.vzome.core.construction.Polygon = <com.vzome.core.construction.Polygon>c;
                const points: java.util.List<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>(1 + p.getVertexCount()));
                points.add(p.getVertex(0).plus(this.projectionVector));
                for(let i: number = 0; i < p.getVertexCount(); i++) {{
                    points.add(p.getVertex(i));
                };}
                if (com.vzome.core.algebra.AlgebraicVectors.areCoplanar(points)){
                    p = <com.vzome.core.construction.Polygon>super.transform$com_vzome_core_construction_Construction(p);
                    let min: com.vzome.core.algebra.AlgebraicVector = p.getVertex(0);
                    let max: com.vzome.core.algebra.AlgebraicVector = min;
                    for(let i: number = 1; i < p.getVertexCount(); i++) {{
                        const v: com.vzome.core.algebra.AlgebraicVector = p.getVertex(i);
                        if (v.compareTo(min) === -1){
                            min = v;
                        }
                        if (v.compareTo(max) === 1){
                            max = v;
                        }
                    };}
                    const p1: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(min);
                    const p2: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(max);
                    return new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                }
            }
            return super.transform$com_vzome_core_construction_Construction(c);
        }
    }
    PlaneProjection["__class"] = "com.vzome.core.construction.PlaneProjection";

}
namespace com.vzome.core.construction {
    export class Scaling extends com.vzome.core.construction.Transformation {
        /*private*/ s1: com.vzome.core.construction.Segment;

        /*private*/ s2: com.vzome.core.construction.Segment;

        /*private*/ center: com.vzome.core.construction.Point;

        /*private*/ symmetry: com.vzome.core.math.symmetry.Symmetry;

        public constructor(s1: com.vzome.core.construction.Segment, s2: com.vzome.core.construction.Segment, center: com.vzome.core.construction.Point, symmetry: com.vzome.core.math.symmetry.Symmetry) {
            super(s1.field);
            if (this.s1 === undefined) { this.s1 = null; }
            if (this.s2 === undefined) { this.s2 = null; }
            if (this.center === undefined) { this.center = null; }
            if (this.symmetry === undefined) { this.symmetry = null; }
            this.mOffset = this.field.projectTo3d(center.getLocation(), true);
            this.s1 = s1;
            this.s2 = s2;
            this.center = center;
            this.symmetry = symmetry;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            const zone1: com.vzome.core.math.symmetry.Axis = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](this.s1.getOffset());
            const zone2: com.vzome.core.math.symmetry.Axis = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](this.s2.getOffset());
            const orbit: com.vzome.core.math.symmetry.Direction = zone1.getDirection();
            if (orbit !== zone2.getDirection())return this.setStateVariables(null, null, true);
            const len1: com.vzome.core.algebra.AlgebraicNumber = zone1.getLength(this.s1.getOffset());
            const len2: com.vzome.core.algebra.AlgebraicNumber = zone2.getLength(this.s2.getOffset());
            const scale: com.vzome.core.algebra.AlgebraicNumber = len2.dividedBy(len1);
            const transform: com.vzome.core.algebra.AlgebraicMatrix = new com.vzome.core.algebra.AlgebraicMatrix(this.field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X).scale(scale), this.field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y).scale(scale), this.field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z).scale(scale));
            return this.setStateVariables(transform, this.center.getLocation(), false);
        }
    }
    Scaling["__class"] = "com.vzome.core.construction.Scaling";

}
namespace com.vzome.core.construction {
    /**
     * @param prototype
     * @param {*} symm
     * @param {number} orientation
     * @param {com.vzome.core.construction.Point} center
     * @class
     * @extends com.vzome.core.construction.Transformation
     * @author Scott Vorthmann
     */
    export class SymmetryTransformation extends com.vzome.core.construction.Transformation {
        /*private*/ mCenter: com.vzome.core.construction.Point;

        mSymmetry: com.vzome.core.math.symmetry.Symmetry;

        mOrientation: number;

        public constructor(symm: com.vzome.core.math.symmetry.Symmetry, orientation: number, center: com.vzome.core.construction.Point) {
            super(center.field);
            if (this.mCenter === undefined) { this.mCenter = null; }
            if (this.mSymmetry === undefined) { this.mSymmetry = null; }
            if (this.mOrientation === undefined) { this.mOrientation = 0; }
            this.mSymmetry = symm;
            this.mOrientation = orientation;
            this.mCenter = center;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.mCenter.isImpossible())return this.setStateVariables(null, null, true);
            const loc: com.vzome.core.algebra.AlgebraicVector = this.mCenter.getLocation().projectTo3d(true);
            const matrix: com.vzome.core.algebra.AlgebraicMatrix = this.mSymmetry.getMatrix(this.mOrientation);
            return this.setStateVariables(matrix, loc, false);
        }
    }
    SymmetryTransformation["__class"] = "com.vzome.core.construction.SymmetryTransformation";

}
namespace com.vzome.core.construction {
    export class PointToPointTranslation extends com.vzome.core.construction.Transformation {
        public constructor(p1: com.vzome.core.construction.Point, p2: com.vzome.core.construction.Point) {
            super(p1.field);
            this.mOffset = this.field.projectTo3d(p2.getLocation().minus(p1.getLocation()), true);
        }

        public transform$com_vzome_core_algebra_AlgebraicVector(arg: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            return arg.plus(this.mOffset);
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} arg
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public transform(arg?: any): any {
            if (((arg != null && arg instanceof <any>com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                return <any>this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
            } else if (((arg != null && arg instanceof <any>com.vzome.core.construction.Construction) || arg === null)) {
                return <any>this.transform$com_vzome_core_construction_Construction(arg);
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            return this.setStateVariables(null, null, false);
        }
    }
    PointToPointTranslation["__class"] = "com.vzome.core.construction.PointToPointTranslation";

}
namespace com.vzome.core.construction {
    export class LineReflection extends com.vzome.core.construction.Transformation {
        /*private*/ two: com.vzome.core.algebra.AlgebraicNumber;

        /*private*/ mMirrorLine: com.vzome.core.construction.Line;

        /*private*/ mStart: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ mEnd: com.vzome.core.algebra.AlgebraicVector;

        public constructor(axis: com.vzome.core.construction.Segment) {
            super(axis.field);
            if (this.two === undefined) { this.two = null; }
            if (this.mMirrorLine === undefined) { this.mMirrorLine = null; }
            if (this.mStart === undefined) { this.mStart = null; }
            if (this.mEnd === undefined) { this.mEnd = null; }
            this.two = this.field['createRational$long'](2);
            this.mMirrorLine = new com.vzome.core.construction.LineExtensionOfSegment(axis);
            this.mStart = axis.getStart();
            this.mEnd = axis.getEnd();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            return true;
        }

        public transform$com_vzome_core_algebra_AlgebraicVector(arg: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            const norm1: com.vzome.core.algebra.AlgebraicVector = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(this.mStart, this.mEnd, arg);
            if (norm1.isOrigin()){
                return arg;
            }
            const norm2: com.vzome.core.algebra.AlgebraicVector = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(this.mStart, this.mEnd, this.mEnd.plus(norm1));
            const line2: com.vzome.core.construction.Line = new com.vzome.core.construction.LineFromPointAndVector(arg, norm2);
            const point: com.vzome.core.construction.Point = new com.vzome.core.construction.LineLineIntersectionPoint(this.mMirrorLine, line2);
            const intersection: com.vzome.core.algebra.AlgebraicVector = point.getLocation();
            const translation: com.vzome.core.algebra.AlgebraicVector = intersection.minus(arg).scale(this.two);
            return arg.plus(translation);
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} arg
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public transform(arg?: any): any {
            if (((arg != null && arg instanceof <any>com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                return <any>this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
            } else if (((arg != null && arg instanceof <any>com.vzome.core.construction.Construction) || arg === null)) {
                return <any>this.transform$com_vzome_core_construction_Construction(arg);
            } else throw new Error('invalid overload');
        }
    }
    LineReflection["__class"] = "com.vzome.core.construction.LineReflection";

}
namespace com.vzome.core.construction {
    /**
     * This assumes that the starting basis is the usual X,Y,Z basis
     * @param {boolean} originalScaling
     * @param prototype
     * @param {com.vzome.core.construction.Segment} newX
     * @param {com.vzome.core.construction.Segment} newY
     * @param {com.vzome.core.construction.Segment} newZ
     * @param {com.vzome.core.construction.Point} kernel
     * @class
     * @extends com.vzome.core.construction.Transformation
     * @author Scott Vorthmann
     */
    export class ChangeOfBasis extends com.vzome.core.construction.Transformation {
        /*private*/ mOld: com.vzome.core.construction.Segment[];

        /*private*/ mNew: com.vzome.core.construction.Segment[];

        /*private*/ mKernel: com.vzome.core.construction.Point;

        /*private*/ scale: com.vzome.core.algebra.AlgebraicNumber;

        public constructor(newX?: any, newY?: any, newZ?: any, kernel?: any, originalScaling?: any) {
            if (((newX != null && newX instanceof <any>com.vzome.core.construction.Segment) || newX === null) && ((newY != null && newY instanceof <any>com.vzome.core.construction.Segment) || newY === null) && ((newZ != null && newZ instanceof <any>com.vzome.core.construction.Segment) || newZ === null) && ((kernel != null && kernel instanceof <any>com.vzome.core.construction.Point) || kernel === null) && ((typeof originalScaling === 'boolean') || originalScaling === null)) {
                let __args = arguments;
                super(newX.field);
                if (this.mOld === undefined) { this.mOld = null; } 
                if (this.mNew === undefined) { this.mNew = null; } 
                if (this.mKernel === undefined) { this.mKernel = null; } 
                if (this.scale === undefined) { this.scale = null; } 
                this.mNew = [newX, newY, newZ];
                this.mOld = null;
                this.mKernel = kernel;
                if (originalScaling)this.scale = this.field['createPower$int'](-5); else this.scale = this.field['createRational$long$long'](1, 2)['times$com_vzome_core_algebra_AlgebraicNumber'](this.field['createPower$int'](-3));
                this.mapParamsToState();
            } else if (((newX != null && newX instanceof <any>Array && (newX.length == 0 || newX[0] == null ||(newX[0] != null && newX[0] instanceof <any>com.vzome.core.construction.Segment))) || newX === null) && ((newY != null && newY instanceof <any>Array && (newY.length == 0 || newY[0] == null ||(newY[0] != null && newY[0] instanceof <any>com.vzome.core.construction.Segment))) || newY === null) && ((newZ != null && newZ instanceof <any>com.vzome.core.construction.Point) || newZ === null) && kernel === undefined && originalScaling === undefined) {
                let __args = arguments;
                let oldBasis: any = __args[0];
                let newBasis: any = __args[1];
                let kernel: any = __args[2];
                super(oldBasis[0].field);
                if (this.mOld === undefined) { this.mOld = null; } 
                if (this.mNew === undefined) { this.mNew = null; } 
                if (this.mKernel === undefined) { this.mKernel = null; } 
                if (this.scale === undefined) { this.scale = null; } 
                this.mOld = oldBasis;
                this.mNew = newBasis;
                this.mKernel = kernel;
                this.scale = this.field['createRational$long'](2)['times$com_vzome_core_algebra_AlgebraicNumber'](this.field['createPower$int'](-7));
                this.mapParamsToState();
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            const loc: com.vzome.core.algebra.AlgebraicVector = this.mKernel.getLocation();
            if (this.mOld != null){
                const oldCommon: com.vzome.core.algebra.AlgebraicVector = ChangeOfBasis.findCommonVertex(this.mOld[0], this.mOld[1]);
                const offsets: com.vzome.core.algebra.AlgebraicVector[] = [null, null, null];
                for(let i: number = 0; i < offsets.length; i++) {{
                    offsets[i] = this.mOld[i].getOffset().scale(this.scale);
                    if (oldCommon.equals(this.mOld[i].getEnd()))offsets[i] = offsets[i].negate();
                };}
                const oldMatrix: com.vzome.core.algebra.AlgebraicMatrix = new com.vzome.core.algebra.AlgebraicMatrix(offsets);
                const newCommon: com.vzome.core.algebra.AlgebraicVector = ChangeOfBasis.findCommonVertex(this.mNew[0], this.mNew[1]);
                for(let i: number = 0; i < offsets.length; i++) {{
                    offsets[i] = this.mNew[i].getOffset().scale(this.scale);
                    if (newCommon.equals(this.mNew[i].getEnd()))offsets[i] = offsets[i].negate();
                };}
                const newMatrix: com.vzome.core.algebra.AlgebraicMatrix = new com.vzome.core.algebra.AlgebraicMatrix(offsets);
                const transform: com.vzome.core.algebra.AlgebraicMatrix = newMatrix.times(oldMatrix.inverse());
                return this.setStateVariables(transform, loc, false);
            } else {
                const transform: com.vzome.core.algebra.AlgebraicMatrix = new com.vzome.core.algebra.AlgebraicMatrix(this.mNew[0].getOffset().scale(this.scale), this.mNew[1].getOffset().scale(this.scale), this.mNew[2].getOffset().scale(this.scale));
                return this.setStateVariables(transform, loc, false);
            }
        }

        public static findCommonVertex(s1: com.vzome.core.construction.Segment, s2: com.vzome.core.construction.Segment): com.vzome.core.algebra.AlgebraicVector {
            let common: com.vzome.core.algebra.AlgebraicVector = s1.getStart();
            if (common.equals(s2.getStart()) || common.equals(s2.getEnd()))return common; else {
                common = s1.getEnd();
                if (common.equals(s2.getStart()) || common.equals(s2.getEnd()))return common; else return null;
            }
        }
    }
    ChangeOfBasis["__class"] = "com.vzome.core.construction.ChangeOfBasis";

}
namespace com.vzome.core.construction {
    export class Translation extends com.vzome.core.construction.Transformation {
        /*private*/ mOffset: com.vzome.core.algebra.AlgebraicVector;

        public constructor(offset: com.vzome.core.algebra.AlgebraicVector) {
            super(offset.getField());
            if (this.mOffset === undefined) { this.mOffset = null; }
            this.mOffset = offset;
        }

        public transform$com_vzome_core_algebra_AlgebraicVector(arg: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            arg = arg.plus(this.mOffset);
            return arg;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} arg
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public transform(arg?: any): any {
            if (((arg != null && arg instanceof <any>com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                return <any>this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
            } else if (((arg != null && arg instanceof <any>com.vzome.core.construction.Construction) || arg === null)) {
                return <any>this.transform$com_vzome_core_construction_Construction(arg);
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            return this.setStateVariables(null, null, false);
        }
    }
    Translation["__class"] = "com.vzome.core.construction.Translation";

}
namespace com.vzome.core.construction {
    /**
     * @param prototype
     * @param {com.vzome.core.construction.Plane} mirror
     * @class
     * @extends com.vzome.core.construction.Transformation
     * @author Scott Vorthmann
     */
    export class PlaneReflection extends com.vzome.core.construction.Transformation {
        /*private*/ mMirror: com.vzome.core.construction.Plane;

        /*private*/ mNormal: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ mBase: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ mNormDotReciprocal: com.vzome.core.algebra.AlgebraicNumber;

        public constructor(mirror: com.vzome.core.construction.Plane) {
            super(mirror.field);
            if (this.mMirror === undefined) { this.mMirror = null; }
            if (this.mNormal === undefined) { this.mNormal = null; }
            if (this.mBase === undefined) { this.mBase = null; }
            if (this.mNormDotReciprocal === undefined) { this.mNormDotReciprocal = null; }
            this.mMirror = mirror;
            this.mNormal = mirror.getNormal();
            this.mBase = mirror.getBase();
            this.mNormDotReciprocal = this.mNormal.dot(this.mNormal).reciprocal();
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.mMirror.isImpossible())this.setStateVariables(null, null, true);
            const loc: com.vzome.core.algebra.AlgebraicVector = this.mMirror.getBase();
            return this.setStateVariables(null, loc, false);
        }

        public transform$com_vzome_core_algebra_AlgebraicVector(arg: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            arg = arg.minus(this.mBase);
            let xy: com.vzome.core.algebra.AlgebraicNumber = arg.dot(this.mNormal);
            xy = xy['times$com_vzome_core_algebra_AlgebraicNumber'](this.field['createRational$long'](2));
            arg = arg.minus(this.mNormal.scale(xy['times$com_vzome_core_algebra_AlgebraicNumber'](this.mNormDotReciprocal)));
            return arg.plus(this.mBase);
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} arg
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public transform(arg?: any): any {
            if (((arg != null && arg instanceof <any>com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                return <any>this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
            } else if (((arg != null && arg instanceof <any>com.vzome.core.construction.Construction) || arg === null)) {
                return <any>this.transform$com_vzome_core_construction_Construction(arg);
            } else throw new Error('invalid overload');
        }
    }
    PlaneReflection["__class"] = "com.vzome.core.construction.PlaneReflection";

}
namespace com.vzome.core.construction {
    export class MoveAndRotate extends com.vzome.core.construction.Transformation {
        /*private*/ rotation: com.vzome.core.construction.MatrixTransformation;

        /*private*/ translation: com.vzome.core.construction.Translation;

        public constructor(rotation: com.vzome.core.algebra.AlgebraicMatrix, start: com.vzome.core.algebra.AlgebraicVector, end: com.vzome.core.algebra.AlgebraicVector) {
            super(start.getField());
            if (this.rotation === undefined) { this.rotation = null; }
            if (this.translation === undefined) { this.translation = null; }
            this.rotation = new com.vzome.core.construction.MatrixTransformation(rotation, start);
            this.translation = new com.vzome.core.construction.Translation(end.minus(start));
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            return this.rotation.mapParamsToState() && this.translation.mapParamsToState();
        }

        public transform$com_vzome_core_algebra_AlgebraicVector(arg: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            return this.translation.transform$com_vzome_core_algebra_AlgebraicVector(this.rotation.transform$com_vzome_core_algebra_AlgebraicVector(arg));
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} arg
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public transform(arg?: any): any {
            if (((arg != null && arg instanceof <any>com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                return <any>this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
            } else if (((arg != null && arg instanceof <any>com.vzome.core.construction.Construction) || arg === null)) {
                return <any>this.transform$com_vzome_core_construction_Construction(arg);
            } else throw new Error('invalid overload');
        }
    }
    MoveAndRotate["__class"] = "com.vzome.core.construction.MoveAndRotate";

}
namespace com.vzome.core.construction {
    /**
     * @param prototype
     * @param {com.vzome.core.construction.Plane} projectionPlane
     * @param {com.vzome.core.construction.Point} perspectivePoint
     * @class
     * @extends com.vzome.core.construction.Transformation
     * @author Scott Vorthmann
     */
    export class PerspectiveProjection extends com.vzome.core.construction.Transformation {
        /*private*/ projectionPlane: com.vzome.core.construction.Plane;

        /*private*/ perspectivePoint: com.vzome.core.construction.Point;

        public constructor(projectionPlane: com.vzome.core.construction.Plane, perspectivePoint: com.vzome.core.construction.Point) {
            super(projectionPlane.field);
            if (this.projectionPlane === undefined) { this.projectionPlane = null; }
            if (this.perspectivePoint === undefined) { this.perspectivePoint = null; }
            this.projectionPlane = projectionPlane;
            this.perspectivePoint = perspectivePoint;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.projectionPlane.isImpossible())this.setStateVariables(null, null, true);
            const loc: com.vzome.core.algebra.AlgebraicVector = this.getField().origin(3);
            return this.setStateVariables(null, loc, false);
        }

        public transform$com_vzome_core_algebra_AlgebraicVector(arg: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            const segment: com.vzome.core.construction.Segment = new com.vzome.core.construction.SegmentJoiningPoints(this.perspectivePoint, new com.vzome.core.construction.FreePoint(arg));
            if (segment.getOffset().isOrigin())return null;
            const line: com.vzome.core.construction.Line = new com.vzome.core.construction.LineExtensionOfSegment(segment);
            const point: com.vzome.core.construction.Point = new com.vzome.core.construction.LinePlaneIntersectionPoint(this.projectionPlane, line);
            return point.getLocation();
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} arg
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public transform(arg?: any): any {
            if (((arg != null && arg instanceof <any>com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                return <any>this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
            } else if (((arg != null && arg instanceof <any>com.vzome.core.construction.Construction) || arg === null)) {
                return <any>this.transform$com_vzome_core_construction_Construction(arg);
            } else throw new Error('invalid overload');
        }

        public transform$com_vzome_core_construction_Construction(c: com.vzome.core.construction.Construction): com.vzome.core.construction.Construction {
            if (c != null && c instanceof <any>com.vzome.core.construction.Point){
                const result: com.vzome.core.construction.Point = new com.vzome.core.construction.TransformedPoint(this, <com.vzome.core.construction.Point>c);
                if (result.isImpossible())return null;
                return result;
            } else if (c != null && c instanceof <any>com.vzome.core.construction.Segment){
                const result: com.vzome.core.construction.Segment = new com.vzome.core.construction.TransformedSegment(this, <com.vzome.core.construction.Segment>c);
                if (result.isImpossible() || result.getOffset().isOrigin()){
                    return new com.vzome.core.construction.FreePoint((<com.vzome.core.construction.Segment>c).getStart());
                }
                return result;
            } else if (c != null && c instanceof <any>com.vzome.core.construction.Polygon){
                const p: com.vzome.core.construction.Polygon = new com.vzome.core.construction.TransformedPolygon(this, <com.vzome.core.construction.Polygon>c);
                if (p.getNormal().isOrigin()){
                    let min: com.vzome.core.algebra.AlgebraicVector = p.getVertex(0);
                    let max: com.vzome.core.algebra.AlgebraicVector = min;
                    for(let i: number = 1; i < p.getVertexCount(); i++) {{
                        const v: com.vzome.core.algebra.AlgebraicVector = p.getVertex(i);
                        if (v.compareTo(min) === -1){
                            min = v;
                        }
                        if (v.compareTo(max) === 1){
                            max = v;
                        }
                    };}
                    const p1: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(min);
                    const p2: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(max);
                    return new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                }
                return p;
            }
            return super.transform$com_vzome_core_construction_Construction(c);
        }
    }
    PerspectiveProjection["__class"] = "com.vzome.core.construction.PerspectiveProjection";

}
namespace com.vzome.core.construction {
    /**
     * @param prototype
     * @param {com.vzome.core.construction.Point} center
     * @class
     * @extends com.vzome.core.construction.Transformation
     * @author Scott Vorthmann
     */
    export class PointReflection extends com.vzome.core.construction.Transformation {
        /*private*/ mCenter: com.vzome.core.construction.Point;

        public constructor(center: com.vzome.core.construction.Point) {
            super(center.field);
            if (this.mCenter === undefined) { this.mCenter = null; }
            this.mCenter = center;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.mCenter.isImpossible())this.setStateVariables(null, null, true);
            const loc: com.vzome.core.algebra.AlgebraicVector = this.mCenter.getLocation().projectTo3d(true);
            return this.setStateVariables(null, loc, false);
        }

        public transform$com_vzome_core_algebra_AlgebraicVector(arg: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
            arg = arg.minus(this.mOffset);
            arg = this.mOffset.minus(arg);
            return arg;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} arg
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        public transform(arg?: any): any {
            if (((arg != null && arg instanceof <any>com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                return <any>this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
            } else if (((arg != null && arg instanceof <any>com.vzome.core.construction.Construction) || arg === null)) {
                return <any>this.transform$com_vzome_core_construction_Construction(arg);
            } else throw new Error('invalid overload');
        }
    }
    PointReflection["__class"] = "com.vzome.core.construction.PointReflection";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.construction.Line} l3
     * @param {*} len
     * @class
     * @extends com.vzome.core.construction.Segment
     */
    export class SegmentOnLine extends com.vzome.core.construction.Segment {
        /*private*/ mLine: com.vzome.core.construction.Line;

        /*private*/ mLength: com.vzome.core.algebra.AlgebraicNumber;

        public constructor(l3: com.vzome.core.construction.Line, len: com.vzome.core.algebra.AlgebraicNumber) {
            super(l3.field);
            if (this.mLine === undefined) { this.mLine = null; }
            if (this.mLength === undefined) { this.mLength = null; }
            this.mLine = l3;
            this.mLength = len;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.mLine.isImpossible())return this.setStateVariables(null, null, true);
            const offset: com.vzome.core.algebra.AlgebraicVector = this.getOffset().scale(this.mLength);
            return this.setStateVariables(this.mLine.getStart(), offset, false);
        }
    }
    SegmentOnLine["__class"] = "com.vzome.core.construction.SegmentOnLine";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.construction.Transformation} transform
     * @param {com.vzome.core.construction.Segment} prototype
     * @class
     * @extends com.vzome.core.construction.Segment
     */
    export class TransformedSegment extends com.vzome.core.construction.Segment {
        /*private*/ mTransform: com.vzome.core.construction.Transformation;

        /*private*/ mPrototype: com.vzome.core.construction.Segment;

        public constructor(transform: com.vzome.core.construction.Transformation, prototype: com.vzome.core.construction.Segment) {
            super(prototype.field);
            if (this.mTransform === undefined) { this.mTransform = null; }
            if (this.mPrototype === undefined) { this.mPrototype = null; }
            this.mTransform = transform;
            this.mPrototype = prototype;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.mTransform.isImpossible() || this.mPrototype.isImpossible())return this.setStateVariables(null, null, true);
            const loc: com.vzome.core.algebra.AlgebraicVector = this.mTransform.transform$com_vzome_core_algebra_AlgebraicVector(this.mPrototype.getStart().projectTo3d(true));
            const end: com.vzome.core.algebra.AlgebraicVector = this.mTransform.transform$com_vzome_core_algebra_AlgebraicVector(this.mPrototype.getEnd().projectTo3d(true));
            if (end == null || loc == null)return this.setStateVariables(null, null, true);
            return this.setStateVariables(loc, end.minus(loc), false);
        }
    }
    TransformedSegment["__class"] = "com.vzome.core.construction.TransformedSegment";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.construction.Point} p1
     * @param {com.vzome.core.construction.Point} p2
     * @class
     * @extends com.vzome.core.construction.Segment
     */
    export class SegmentJoiningPoints extends com.vzome.core.construction.Segment {
        /*private*/ __com_vzome_core_construction_SegmentJoiningPoints_mStart: com.vzome.core.construction.Point;

        /*private*/ __com_vzome_core_construction_SegmentJoiningPoints_mEnd: com.vzome.core.construction.Point;

        public constructor(p1: com.vzome.core.construction.Point, p2: com.vzome.core.construction.Point) {
            super(p1.field);
            if (this.__com_vzome_core_construction_SegmentJoiningPoints_mStart === undefined) { this.__com_vzome_core_construction_SegmentJoiningPoints_mStart = null; }
            if (this.__com_vzome_core_construction_SegmentJoiningPoints_mEnd === undefined) { this.__com_vzome_core_construction_SegmentJoiningPoints_mEnd = null; }
            this.__com_vzome_core_construction_SegmentJoiningPoints_mStart = p1;
            this.__com_vzome_core_construction_SegmentJoiningPoints_mEnd = p2;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.__com_vzome_core_construction_SegmentJoiningPoints_mStart.isImpossible() || this.__com_vzome_core_construction_SegmentJoiningPoints_mEnd.isImpossible())return this.setStateVariables(null, null, true);
            let startV: com.vzome.core.algebra.AlgebraicVector = this.__com_vzome_core_construction_SegmentJoiningPoints_mStart.getLocation();
            let endV: com.vzome.core.algebra.AlgebraicVector = this.__com_vzome_core_construction_SegmentJoiningPoints_mEnd.getLocation();
            if (startV.dimension() === 3 || endV.dimension() === 3){
                startV = startV.projectTo3d(true);
                endV = endV.projectTo3d(true);
            }
            const offset: com.vzome.core.algebra.AlgebraicVector = endV.minus(startV);
            return this.setStateVariables(startV, offset, false);
        }
    }
    SegmentJoiningPoints["__class"] = "com.vzome.core.construction.SegmentJoiningPoints";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.construction.Segment} s1
     * @param {com.vzome.core.construction.Segment} s2
     * @class
     * @extends com.vzome.core.construction.Segment
     */
    export class SegmentCrossProduct extends com.vzome.core.construction.Segment {
        /*private*/ seg1: com.vzome.core.construction.Segment;

        /*private*/ seg2: com.vzome.core.construction.Segment;

        public constructor(s1: com.vzome.core.construction.Segment, s2: com.vzome.core.construction.Segment) {
            super(s1.field);
            if (this.seg1 === undefined) { this.seg1 = null; }
            if (this.seg2 === undefined) { this.seg2 = null; }
            this.seg1 = s1;
            this.seg2 = s2;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.seg1.isImpossible() || this.seg2.isImpossible()){
                return this.setStateVariables(null, null, true);
            }
            const v2: com.vzome.core.algebra.AlgebraicVector = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(this.seg1.getOffset(), this.seg2.getOffset()).scale(this.field['createPower$int'](-4)).scale(this.field['createRational$long$long'](1, 2));
            return this.setStateVariables(this.seg1.getEnd(), v2, false);
        }
    }
    SegmentCrossProduct["__class"] = "com.vzome.core.construction.SegmentCrossProduct";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.algebra.Quaternion} leftQuaternion
     * @param {com.vzome.core.algebra.Quaternion} rightQuaternion
     * @param {com.vzome.core.construction.Segment} prototype
     * @class
     * @extends com.vzome.core.construction.Segment
     */
    export class SegmentRotated4D extends com.vzome.core.construction.Segment {
        /*private*/ mLeftQuaternion: com.vzome.core.algebra.Quaternion;

        /*private*/ mRightQuaternion: com.vzome.core.algebra.Quaternion;

        /*private*/ mPrototype: com.vzome.core.construction.Segment;

        static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (SegmentRotated4D.logger == null) { SegmentRotated4D.logger = java.util.logging.Logger.getLogger("com.vzome.core.4d"); }  return SegmentRotated4D.logger; }

        public constructor(leftQuaternion: com.vzome.core.algebra.Quaternion, rightQuaternion: com.vzome.core.algebra.Quaternion, prototype: com.vzome.core.construction.Segment) {
            super(prototype.field);
            if (this.mLeftQuaternion === undefined) { this.mLeftQuaternion = null; }
            if (this.mRightQuaternion === undefined) { this.mRightQuaternion = null; }
            if (this.mPrototype === undefined) { this.mPrototype = null; }
            this.mLeftQuaternion = leftQuaternion;
            this.mRightQuaternion = rightQuaternion;
            this.mPrototype = prototype;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.mPrototype.isImpossible())return this.setStateVariables(null, null, true);
            let loc: com.vzome.core.algebra.AlgebraicVector = this.mPrototype.getStart();
            loc = loc.inflateTo4d$boolean(true);
            loc = this.mRightQuaternion.leftMultiply(loc);
            loc = this.mLeftQuaternion.rightMultiply(loc);
            let end: com.vzome.core.algebra.AlgebraicVector = this.mPrototype.getEnd();
            end = end.inflateTo4d$boolean(true);
            end = this.mRightQuaternion.leftMultiply(end);
            end = this.mLeftQuaternion.rightMultiply(end);
            if (SegmentRotated4D.logger_$LI$().isLoggable(java.util.logging.Level.FINER)){
                SegmentRotated4D.logger_$LI$().finer("------------------- SegmentRotated4D");
                SegmentRotated4D.logger_$LI$().finer("left:    " + this.mLeftQuaternion.toString());
                SegmentRotated4D.logger_$LI$().finer("right:   " + this.mRightQuaternion.toString());
                SegmentRotated4D.logger_$LI$().finer("start: " + this.mPrototype.getStart().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.EXPRESSION_FORMAT));
                SegmentRotated4D.logger_$LI$().finer("end:   " + this.mPrototype.getEnd().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.EXPRESSION_FORMAT));
                SegmentRotated4D.logger_$LI$().finer("new start: " + loc.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.EXPRESSION_FORMAT));
                SegmentRotated4D.logger_$LI$().finer("new end:   " + end.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.EXPRESSION_FORMAT));
            }
            return this.setStateVariables(loc, end.minus(loc), false);
        }
    }
    SegmentRotated4D["__class"] = "com.vzome.core.construction.SegmentRotated4D";

}
namespace com.vzome.core.construction {
    export class PolygonPolygonProjectionToSegment extends com.vzome.core.construction.Segment {
        /*private*/ polygons: com.vzome.core.construction.Polygon[];

        public constructor(polygon0: com.vzome.core.construction.Polygon, polygon1: com.vzome.core.construction.Polygon) {
            super(polygon0.getField());
            this.polygons = [null, null];
            this.polygons[0] = polygon0;
            this.polygons[1] = polygon1;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.polygons[0].isImpossible() || this.polygons[1].isImpossible()){
                return this.setStateVariables(null, null, true);
            }
            if (com.vzome.core.algebra.AlgebraicVectors.areParallel(this.polygons[0].getNormal(), this.polygons[1].getNormal())){
                return this.setStateVariables(null, null, true);
            }
            const intersections: java.util.Set<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.HashSet<any>(2));
            for(let poly: number = 0; poly < 2; poly++) {{
                const edgePolygon: com.vzome.core.construction.Polygon = this.polygons[poly];
                const planePolygon: com.vzome.core.construction.Polygon = this.polygons[(poly + 1) % 2];
                const centroid: com.vzome.core.algebra.AlgebraicVector = planePolygon.getCentroid();
                const normal: com.vzome.core.algebra.AlgebraicVector = planePolygon.getNormal();
                const nVertices: number = edgePolygon.getVertexCount();
                for(let i: number = 0; i < nVertices; i++) {{
                    const lineStart: com.vzome.core.algebra.AlgebraicVector = edgePolygon.getVertex(i);
                    const lineDirection: com.vzome.core.algebra.AlgebraicVector = lineStart.minus(edgePolygon.getVertex((i + 1) % nVertices));
                    if (!lineDirection.isOrigin()){
                        const intersection: com.vzome.core.algebra.AlgebraicVector = com.vzome.core.algebra.AlgebraicVectors.getLinePlaneIntersection(lineStart, lineDirection, centroid, normal);
                        if (intersection != null){
                            intersections.add(intersection);
                            if (intersections.size() === 2){
                                break;
                            }
                        }
                    }
                };}
                if (intersections.size() === 2){
                    break;
                }
            };}
            if (intersections.size() !== 2){
                for(let poly: number = 0; poly < 2; poly++) {{
                    const edgePolygon: com.vzome.core.construction.Polygon = this.polygons[poly];
                    const planePolygon: com.vzome.core.construction.Polygon = this.polygons[(poly + 1) % 2];
                    const centroid: com.vzome.core.algebra.AlgebraicVector = planePolygon.getCentroid();
                    const normal: com.vzome.core.algebra.AlgebraicVector = planePolygon.getNormal();
                    const lineStart: com.vzome.core.algebra.AlgebraicVector = edgePolygon.getCentroid();
                    for(let i: number = 0; i < edgePolygon.getVertexCount(); i++) {{
                        const lineDirection: com.vzome.core.algebra.AlgebraicVector = lineStart.minus(edgePolygon.getVertex(i));
                        if (!lineDirection.isOrigin()){
                            const intersection: com.vzome.core.algebra.AlgebraicVector = com.vzome.core.algebra.AlgebraicVectors.getLinePlaneIntersection(lineStart, lineDirection, centroid, normal);
                            if (intersection != null){
                                intersections.add(intersection);
                                if (intersections.size() === 2){
                                    break;
                                }
                            }
                        }
                    };}
                    if (intersections.size() === 2){
                        break;
                    }
                };}
            }
            if (intersections.size() !== 2){
                return this.setStateVariables(null, null, true);
            }
            let v0: com.vzome.core.algebra.AlgebraicVector = null;
            let v1: com.vzome.core.algebra.AlgebraicVector = null;
            for(let index=intersections.iterator();index.hasNext();) {
                let v = index.next();
                {
                    if (v0 == null){
                        v0 = v;
                    } else {
                        v1 = v;
                    }
                }
            }
            const intersectionLine: com.vzome.core.construction.Line = new com.vzome.core.construction.LineExtensionOfSegment(new com.vzome.core.construction.SegmentJoiningPoints(new com.vzome.core.construction.FreePoint(v0), new com.vzome.core.construction.FreePoint(v1)));
            const projections: java.util.Set<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.TreeSet<any>());
            for(let poly: number = 0; poly < 2; poly++) {{
                const polygon: com.vzome.core.construction.Polygon = this.polygons[poly];
                const v2: com.vzome.core.algebra.AlgebraicVector = v0.plus(polygon.getNormal());
                const vProjection: com.vzome.core.algebra.AlgebraicVector = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2);
                for(let i: number = 0; i < polygon.getVertexCount(); i++) {{
                    const vertex: com.vzome.core.algebra.AlgebraicVector = polygon.getVertex(i);
                    if (com.vzome.core.algebra.AlgebraicVectors.areCollinear$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, vertex)){
                        projections.add(vertex);
                    } else {
                        const projectionLine: com.vzome.core.construction.Line = new com.vzome.core.construction.LineFromPointAndVector(vertex, vProjection);
                        const projection: com.vzome.core.construction.Point = new com.vzome.core.construction.LineLineIntersectionPoint(intersectionLine, projectionLine);
                        projections.add(projection.getLocation());
                    }
                };}
            };}
            let start: com.vzome.core.algebra.AlgebraicVector = null;
            let offset: com.vzome.core.algebra.AlgebraicVector = null;
            let n: number = 0;
            for(let index=projections.iterator();index.hasNext();) {
                let v = index.next();
                {
                    if (n === 0){
                        start = v;
                    } else if (n === projections.size() - 1){
                        offset = v.minus(start);
                    }
                    n++;
                }
            }
            return this.setStateVariables(start, offset, (start == null || offset == null));
        }
    }
    PolygonPolygonProjectionToSegment["__class"] = "com.vzome.core.construction.PolygonPolygonProjectionToSegment";

}
namespace com.vzome.core.construction {
    /**
     * @param step
     * @param {com.vzome.core.construction.Point} start
     * @param {com.vzome.core.math.symmetry.Axis} axis
     * @param {*} length
     * @class
     * @extends com.vzome.core.construction.Segment
     * @author Scott Vorthmann
     */
    export class AnchoredSegment extends com.vzome.core.construction.Segment {
        /*private*/ mAnchor: com.vzome.core.construction.Point;

        public mAxis: com.vzome.core.math.symmetry.Axis;

        public mLength: com.vzome.core.algebra.AlgebraicNumber;

        public constructor(axis: com.vzome.core.math.symmetry.Axis, length: com.vzome.core.algebra.AlgebraicNumber, start: com.vzome.core.construction.Point) {
            super(start.field);
            if (this.mAnchor === undefined) { this.mAnchor = null; }
            if (this.mAxis === undefined) { this.mAxis = null; }
            if (this.mLength === undefined) { this.mLength = null; }
            this.mAnchor = start;
            this.mAxis = axis;
            this.mLength = length;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.mAnchor.isImpossible() || this.mLength.isZero())return this.setStateVariables(null, null, true);
            const gv: com.vzome.core.algebra.AlgebraicVector = this.mAnchor.getLocation().projectTo3d(true);
            const offset: com.vzome.core.algebra.AlgebraicVector = this.mAxis.normal().scale(this.mLength);
            return this.setStateVariables(gv, offset, false);
        }

        public getAxis(): com.vzome.core.math.symmetry.Axis {
            return this.mAxis;
        }

        public getLength(): com.vzome.core.algebra.AlgebraicNumber {
            return this.mLength;
        }

        public getUnitVector(): com.vzome.core.algebra.AlgebraicVector {
            return this.mAxis.normal();
        }
    }
    AnchoredSegment["__class"] = "com.vzome.core.construction.AnchoredSegment";

}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @class
     * @extends com.vzome.core.commands.AbstractCommand
     */
    export class CommandLinePlaneIntersect extends com.vzome.core.commands.AbstractCommand {
        static PARAM_SIGNATURE: any[][]; public static PARAM_SIGNATURE_$LI$(): any[][] { if (CommandLinePlaneIntersect.PARAM_SIGNATURE == null) { CommandLinePlaneIntersect.PARAM_SIGNATURE = [["panel", com.vzome.core.construction.Polygon], ["segment", com.vzome.core.construction.Segment]]; }  return CommandLinePlaneIntersect.PARAM_SIGNATURE; }

        static ATTR_SIGNATURE: any[][]; public static ATTR_SIGNATURE_$LI$(): any[][] { if (CommandLinePlaneIntersect.ATTR_SIGNATURE == null) { CommandLinePlaneIntersect.ATTR_SIGNATURE = []; }  return CommandLinePlaneIntersect.ATTR_SIGNATURE; }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getParameterSignature(): any[][] {
            return CommandLinePlaneIntersect.PARAM_SIGNATURE_$LI$();
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return CommandLinePlaneIntersect.ATTR_SIGNATURE_$LI$();
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attrs
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attrs: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const result: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            if (parameters == null || parameters.size() !== 2)throw new Command.Failure("Intersection requires a panel and a strut.");
            try {
                let panel: com.vzome.core.construction.Polygon;
                let segment: com.vzome.core.construction.Segment;
                const first: com.vzome.core.construction.Construction = parameters.get(0);
                if (first != null && first instanceof <any>com.vzome.core.construction.Polygon){
                    panel = <com.vzome.core.construction.Polygon>first;
                    segment = <com.vzome.core.construction.Segment>parameters.get(1);
                } else {
                    segment = <com.vzome.core.construction.Segment>first;
                    panel = <com.vzome.core.construction.Polygon>parameters.get(1);
                }
                const plane: com.vzome.core.construction.Plane = new com.vzome.core.construction.PlaneExtensionOfPolygon(panel);
                const line: com.vzome.core.construction.Line = new com.vzome.core.construction.LineExtensionOfSegment(segment);
                const point: com.vzome.core.construction.Point = new com.vzome.core.construction.LinePlaneIntersectionPoint(plane, line);
                result.addConstruction(point);
                effects['constructionAdded$com_vzome_core_construction_Construction'](point);
            } catch(e) {
                throw new Command.Failure("Intersection requires a panel and a strut.");
            }
            return result;
        }

        constructor() {
            super();
        }
    }
    CommandLinePlaneIntersect["__class"] = "com.vzome.core.commands.CommandLinePlaneIntersect";
    CommandLinePlaneIntersect["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.commands {
    export class CommandObliquePentagon extends com.vzome.core.commands.AbstractCommand {
        static PARAM_SIGNATURE: any[][]; public static PARAM_SIGNATURE_$LI$(): any[][] { if (CommandObliquePentagon.PARAM_SIGNATURE == null) { CommandObliquePentagon.PARAM_SIGNATURE = [["segment1", com.vzome.core.construction.Segment], ["segment2", com.vzome.core.construction.Segment]]; }  return CommandObliquePentagon.PARAM_SIGNATURE; }

        static ATTR_SIGNATURE: any[][]; public static ATTR_SIGNATURE_$LI$(): any[][] { if (CommandObliquePentagon.ATTR_SIGNATURE == null) { CommandObliquePentagon.ATTR_SIGNATURE = []; }  return CommandObliquePentagon.ATTR_SIGNATURE; }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getParameterSignature(): any[][] {
            return CommandObliquePentagon.PARAM_SIGNATURE_$LI$();
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return CommandObliquePentagon.ATTR_SIGNATURE_$LI$();
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attributes: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            throw new Command.Failure("Oblique pentagon should never be called.");
        }

        constructor() {
            super();
        }
    }
    CommandObliquePentagon["__class"] = "com.vzome.core.commands.CommandObliquePentagon";
    CommandObliquePentagon["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @class
     * @extends com.vzome.core.commands.AbstractCommand
     */
    export class CommandMidpoint extends com.vzome.core.commands.AbstractCommand {
        static PARAM_SIGNATURE: any[][]; public static PARAM_SIGNATURE_$LI$(): any[][] { if (CommandMidpoint.PARAM_SIGNATURE == null) { CommandMidpoint.PARAM_SIGNATURE = [["segment", com.vzome.core.construction.Segment]]; }  return CommandMidpoint.PARAM_SIGNATURE; }

        static ATTR_SIGNATURE: any[][]; public static ATTR_SIGNATURE_$LI$(): any[][] { if (CommandMidpoint.ATTR_SIGNATURE == null) { CommandMidpoint.ATTR_SIGNATURE = []; }  return CommandMidpoint.ATTR_SIGNATURE; }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getParameterSignature(): any[][] {
            return CommandMidpoint.PARAM_SIGNATURE_$LI$();
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return CommandMidpoint.ATTR_SIGNATURE_$LI$();
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attrs
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attrs: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const result: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            if (parameters == null || parameters.size() !== 1)throw new Command.Failure("Midpoint can only apply to a single strut.");
            try {
                const segment: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>parameters.get(0);
                const midpoint: com.vzome.core.construction.Point = new com.vzome.core.construction.SegmentMidpoint(segment);
                result.addConstruction(midpoint);
                effects['constructionAdded$com_vzome_core_construction_Construction'](midpoint);
            } catch(e) {
                throw new Command.Failure("Midpoint can only apply to a strut.");
            }
            return result;
        }

        constructor() {
            super();
        }
    }
    CommandMidpoint["__class"] = "com.vzome.core.commands.CommandMidpoint";
    CommandMidpoint["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.algebra.Quaternion} leftQuaternion
     * @param {com.vzome.core.algebra.Quaternion} rightQuaternion
     * @param {com.vzome.core.construction.Point} prototype
     * @class
     * @extends com.vzome.core.construction.Point
     */
    export class PointRotated4D extends com.vzome.core.construction.Point {
        /*private*/ mLeftQuaternion: com.vzome.core.algebra.Quaternion;

        /*private*/ mRightQuaternion: com.vzome.core.algebra.Quaternion;

        /*private*/ mPrototype: com.vzome.core.construction.Point;

        public constructor(leftQuaternion: com.vzome.core.algebra.Quaternion, rightQuaternion: com.vzome.core.algebra.Quaternion, prototype: com.vzome.core.construction.Point) {
            super(prototype.field);
            if (this.mLeftQuaternion === undefined) { this.mLeftQuaternion = null; }
            if (this.mRightQuaternion === undefined) { this.mRightQuaternion = null; }
            if (this.mPrototype === undefined) { this.mPrototype = null; }
            this.mLeftQuaternion = leftQuaternion;
            this.mRightQuaternion = rightQuaternion;
            this.mPrototype = prototype;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.mPrototype.isImpossible())return this.setStateVariable(null, true);
            const field: com.vzome.core.algebra.AlgebraicField = this.mPrototype.getField();
            let loc: com.vzome.core.algebra.AlgebraicVector = field.origin(4);
            const loc3d: com.vzome.core.algebra.AlgebraicVector = this.mPrototype.getLocation();
            loc = loc3d.inflateTo4d$boolean(true);
            loc = this.mRightQuaternion.leftMultiply(loc);
            loc = this.mLeftQuaternion.rightMultiply(loc);
            return this.setStateVariable(loc, false);
        }
    }
    PointRotated4D["__class"] = "com.vzome.core.construction.PointRotated4D";

}
namespace com.vzome.core.construction {
    export class LineLineIntersectionPoint extends com.vzome.core.construction.Point {
        /*private*/ line1: com.vzome.core.construction.Line;

        /*private*/ line2: com.vzome.core.construction.Line;

        public constructor(line1: com.vzome.core.construction.Line, line2: com.vzome.core.construction.Line) {
            super(line1.field);
            if (this.line1 === undefined) { this.line1 = null; }
            if (this.line2 === undefined) { this.line2 = null; }
            this.line1 = line1;
            this.line2 = line2;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            const p1: com.vzome.core.algebra.AlgebraicVector = this.line1.getStart();
            const p21: com.vzome.core.algebra.AlgebraicVector = this.line1.getDirection();
            const p3: com.vzome.core.algebra.AlgebraicVector = this.line2.getStart();
            const p43: com.vzome.core.algebra.AlgebraicVector = this.line2.getDirection();
            if (p1.equals(p3))return this.setStateVariable(p1, false);
            const p2: com.vzome.core.algebra.AlgebraicVector = p1.plus(p21);
            if (p2.equals(p3))return this.setStateVariable(p2, false);
            const p4: com.vzome.core.algebra.AlgebraicVector = p3.plus(p43);
            if (p1.equals(p4))return this.setStateVariable(p1, false);
            if (p2.equals(p4))return this.setStateVariable(p2, false);
            const p13: com.vzome.core.algebra.AlgebraicVector = p1.minus(p3);
            const d1343: com.vzome.core.algebra.AlgebraicNumber = p13.dot(p43);
            const d4321: com.vzome.core.algebra.AlgebraicNumber = p43.dot(p21);
            const d1321: com.vzome.core.algebra.AlgebraicNumber = p13.dot(p21);
            const d4343: com.vzome.core.algebra.AlgebraicNumber = p43.dot(p43);
            const d2121: com.vzome.core.algebra.AlgebraicNumber = p21.dot(p21);
            const denom: com.vzome.core.algebra.AlgebraicNumber = d2121['times$com_vzome_core_algebra_AlgebraicNumber'](d4343)['minus$com_vzome_core_algebra_AlgebraicNumber'](d4321['times$com_vzome_core_algebra_AlgebraicNumber'](d4321));
            if (denom.isZero())return this.setStateVariable(null, true);
            const numer: com.vzome.core.algebra.AlgebraicNumber = d1343['times$com_vzome_core_algebra_AlgebraicNumber'](d4321)['minus$com_vzome_core_algebra_AlgebraicNumber'](d1321['times$com_vzome_core_algebra_AlgebraicNumber'](d4343));
            const mua: com.vzome.core.algebra.AlgebraicNumber = numer.dividedBy(denom);
            const mub: com.vzome.core.algebra.AlgebraicNumber = d1343['plus$com_vzome_core_algebra_AlgebraicNumber'](d4321['times$com_vzome_core_algebra_AlgebraicNumber'](mua)).dividedBy(d4343);
            const pa: com.vzome.core.algebra.AlgebraicVector = p1.plus(p21.scale(mua));
            const pb: com.vzome.core.algebra.AlgebraicVector = p3.plus(p43.scale(mub));
            if (!pa.equals(pb))return this.setStateVariable(null, true);
            return this.setStateVariable(pb, false);
        }
    }
    LineLineIntersectionPoint["__class"] = "com.vzome.core.construction.LineLineIntersectionPoint";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.construction.Transformation} transform
     * @param {com.vzome.core.construction.Point} prototype
     * @class
     * @extends com.vzome.core.construction.Point
     */
    export class TransformedPoint extends com.vzome.core.construction.Point {
        /*private*/ mTransform: com.vzome.core.construction.Transformation;

        /*private*/ mPrototype: com.vzome.core.construction.Point;

        public constructor(transform: com.vzome.core.construction.Transformation, prototype: com.vzome.core.construction.Point) {
            super(prototype.field);
            if (this.mTransform === undefined) { this.mTransform = null; }
            if (this.mPrototype === undefined) { this.mPrototype = null; }
            this.mTransform = transform;
            this.mPrototype = prototype;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.mTransform.isImpossible() || this.mPrototype.isImpossible())return this.setStateVariable(null, true);
            const loc: com.vzome.core.algebra.AlgebraicVector = this.mTransform.transform$com_vzome_core_algebra_AlgebraicVector(this.mPrototype.getLocation());
            return this.setStateVariable(loc, loc == null);
        }
    }
    TransformedPoint["__class"] = "com.vzome.core.construction.TransformedPoint";

}
namespace com.vzome.core.construction {
    /**
     * @param loc
     * @param {com.vzome.core.construction.Segment} seg
     * @class
     * @extends com.vzome.core.construction.Point
     * @author Scott Vorthmann
     */
    export class SegmentMidpoint extends com.vzome.core.construction.Point {
        /*private*/ mSegment: com.vzome.core.construction.Segment;

        public constructor(seg: com.vzome.core.construction.Segment) {
            super(seg.field);
            if (this.mSegment === undefined) { this.mSegment = null; }
            this.mSegment = seg;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.mSegment.isImpossible())return this.setStateVariable(null, true);
            const half: com.vzome.core.algebra.AlgebraicNumber = this.field['createRational$long$long'](1, 2);
            let loc: com.vzome.core.algebra.AlgebraicVector = this.mSegment.getStart();
            loc = loc.plus(this.mSegment.getOffset().scale(half));
            return this.setStateVariable(loc, false);
        }
    }
    SegmentMidpoint["__class"] = "com.vzome.core.construction.SegmentMidpoint";

}
namespace com.vzome.core.construction {
    /**
     * @param {com.vzome.core.algebra.AlgebraicVector} loc
     * @class
     * @extends com.vzome.core.construction.Point
     * @author Scott Vorthmann
     */
    export class FreePoint extends com.vzome.core.construction.Point {
        public constructor(loc: com.vzome.core.algebra.AlgebraicVector) {
            super(loc.getField());
            this.setStateVariable(loc, false);
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            return true;
        }
    }
    FreePoint["__class"] = "com.vzome.core.construction.FreePoint";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.construction.Polygon} polygon
     * @param {number} index
     * @class
     * @extends com.vzome.core.construction.Point
     */
    export class PolygonVertex extends com.vzome.core.construction.Point {
        /*private*/ polygon: com.vzome.core.construction.Polygon;

        /*private*/ index: number;

        public constructor(polygon: com.vzome.core.construction.Polygon, index: number) {
            super(polygon.field);
            if (this.polygon === undefined) { this.polygon = null; }
            if (this.index === undefined) { this.index = 0; }
            this.polygon = polygon;
            this.index = index;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.polygon.isImpossible()){
                return this.setStateVariable(null, true);
            }
            const loc: com.vzome.core.algebra.AlgebraicVector = this.polygon.getVertex(this.index);
            return this.setStateVariable(loc, false);
        }
    }
    PolygonVertex["__class"] = "com.vzome.core.construction.PolygonVertex";

}
namespace com.vzome.core.construction {
    /**
     * @param loc
     * @param {com.vzome.core.construction.Segment} seg
     * @class
     * @extends com.vzome.core.construction.Point
     * @author Scott Vorthmann
     */
    export class SegmentTauDivision extends com.vzome.core.construction.Point {
        /*private*/ mSegment: com.vzome.core.construction.Segment;

        public constructor(seg: com.vzome.core.construction.Segment) {
            super(seg.field);
            if (this.mSegment === undefined) { this.mSegment = null; }
            if (this.shrink === undefined) { this.shrink = null; }
            this.mSegment = seg;
            this.shrink = this.field['createPower$int'](-1);
            this.mapParamsToState();
        }

        shrink: com.vzome.core.algebra.AlgebraicNumber;

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.mSegment.isImpossible())return this.setStateVariable(null, true);
            let loc: com.vzome.core.algebra.AlgebraicVector = this.mSegment.getStart();
            const off: com.vzome.core.algebra.AlgebraicVector = this.mSegment.getOffset().scale(this.shrink);
            loc = loc.plus(off);
            return this.setStateVariable(loc, false);
        }
    }
    SegmentTauDivision["__class"] = "com.vzome.core.construction.SegmentTauDivision";

}
namespace com.vzome.core.construction {
    export class LinePlaneIntersectionPoint extends com.vzome.core.construction.Point {
        /*private*/ mPlane: com.vzome.core.construction.Plane;

        /*private*/ mLine: com.vzome.core.construction.Line;

        public constructor(plane: com.vzome.core.construction.Plane, line: com.vzome.core.construction.Line) {
            super(line.field);
            if (this.mPlane === undefined) { this.mPlane = null; }
            if (this.mLine === undefined) { this.mLine = null; }
            this.mPlane = plane;
            this.mLine = line;
            this.mapParamsToState();
        }

        /**
         * From Vince, GA4CG, p. 196.
         * 
         * @author Scott Vorthmann
         * @return {boolean}
         */
        mapParamsToState_usingGA(): boolean {
            if (this.mPlane.isImpossible() || this.mLine.isImpossible())return this.setStateVariable(null, true);
            const plane: com.vzome.core.algebra.Trivector3dHomogeneous = this.mPlane.getHomogeneous();
            const line: com.vzome.core.algebra.Bivector3dHomogeneous = this.mLine.getHomogeneous();
            const intersection: com.vzome.core.algebra.Vector3dHomogeneous = plane.dual().dot(line);
            if (!intersection.exists())return this.setStateVariable(null, true);
            return this.setStateVariable(intersection.getVector(), false);
        }

        /**
         * from http://astronomy.swin.edu.au/~pbourke/geometry/planeline/:
         * 
         * 
         * The equation of a plane (points P are on the plane with normal N and point P3 on the plane) can be written as
         * 
         * N dot (P - P3) = 0
         * 
         * The equation of the line (points P on the line passing through points P1 and P2) can be written as
         * 
         * P = P1 + u (P2 - P1)
         * 
         * The intersection of these two occurs when
         * 
         * N dot (P1 + u (P2 - P1)) = N dot P3
         * 
         * Solving for u gives
         * 
         * u = ( N dot (P3-P1) ) / ( N dot (P2-P1) )
         * 
         * If the denominator is zero, the line is parallel to the plane.
         * 
         * @author Scott Vorthmann
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.mPlane.isImpossible() || this.mLine.isImpossible())return this.setStateVariable(null, true);
            const p1: com.vzome.core.algebra.AlgebraicVector = this.mLine.getStart();
            const p1p2: com.vzome.core.algebra.AlgebraicVector = this.mLine.getDirection();
            const n: com.vzome.core.algebra.AlgebraicVector = this.mPlane.getNormal();
            const p3: com.vzome.core.algebra.AlgebraicVector = this.mPlane.getBase();
            const p: com.vzome.core.algebra.AlgebraicVector = com.vzome.core.algebra.AlgebraicVectors.getLinePlaneIntersection(p1, p1p2, p3, n);
            if (p == null)return this.setStateVariable(null, true); else return this.setStateVariable(p, false);
        }
    }
    LinePlaneIntersectionPoint["__class"] = "com.vzome.core.construction.LinePlaneIntersectionPoint";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.construction.Point[]} points
     * @class
     * @extends com.vzome.core.construction.Point
     */
    export class CentroidPoint extends com.vzome.core.construction.Point {
        /*private*/ mPoints: com.vzome.core.construction.Point[];

        public constructor(points: com.vzome.core.construction.Point[]) {
            super(points[0].field);
            if (this.mPoints === undefined) { this.mPoints = null; }
            this.mPoints = points;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            let centroid: com.vzome.core.algebra.AlgebraicVector = this.mPoints[0].getLocation();
            let num: number = 1;
            for(let i: number = 1; i < this.mPoints.length; i++) {{
                centroid = centroid.plus(this.mPoints[i].getLocation());
                num++;
            };}
            centroid = centroid.scale(this.field['createRational$long$long'](1, num));
            return this.setStateVariable(centroid, false);
        }
    }
    CentroidPoint["__class"] = "com.vzome.core.construction.CentroidPoint";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.construction.Segment} seg
     * @param {boolean} start
     * @class
     * @extends com.vzome.core.construction.Point
     */
    export class SegmentEndPoint extends com.vzome.core.construction.Point {
        /*private*/ mSegment: com.vzome.core.construction.Segment;

        /*private*/ start: boolean;

        public constructor(seg?: any, start?: any) {
            if (((seg != null && seg instanceof <any>com.vzome.core.construction.Segment) || seg === null) && ((typeof start === 'boolean') || start === null)) {
                let __args = arguments;
                super(seg.field);
                if (this.mSegment === undefined) { this.mSegment = null; } 
                this.start = false;
                this.mSegment = seg;
                this.start = start;
                this.mapParamsToState();
            } else if (((seg != null && seg instanceof <any>com.vzome.core.construction.Segment) || seg === null) && start === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let start: any = false;
                    super(seg.field);
                    if (this.mSegment === undefined) { this.mSegment = null; } 
                    this.start = false;
                    this.mSegment = seg;
                    this.start = start;
                    this.mapParamsToState();
                }
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.mSegment.isImpossible())return this.setStateVariable(null, true);
            const loc: com.vzome.core.algebra.AlgebraicVector = this.start ? this.mSegment.getStart() : this.mSegment.getEnd();
            return this.setStateVariable(loc, false);
        }
    }
    SegmentEndPoint["__class"] = "com.vzome.core.construction.SegmentEndPoint";

}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @class
     * @extends com.vzome.core.commands.AbstractCommand
     */
    export class CommandJoinPoints extends com.vzome.core.commands.AbstractCommand {
        static PARAM_SIGNATURE: any[][]; public static PARAM_SIGNATURE_$LI$(): any[][] { if (CommandJoinPoints.PARAM_SIGNATURE == null) { CommandJoinPoints.PARAM_SIGNATURE = [["start", com.vzome.core.construction.Point], ["end", com.vzome.core.construction.Point]]; }  return CommandJoinPoints.PARAM_SIGNATURE; }

        static ATTR_SIGNATURE: any[][]; public static ATTR_SIGNATURE_$LI$(): any[][] { if (CommandJoinPoints.ATTR_SIGNATURE == null) { CommandJoinPoints.ATTR_SIGNATURE = []; }  return CommandJoinPoints.ATTR_SIGNATURE; }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getParameterSignature(): any[][] {
            return CommandJoinPoints.PARAM_SIGNATURE_$LI$();
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return CommandJoinPoints.ATTR_SIGNATURE_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public ordersSelection(): boolean {
            return true;
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attrs
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attrs: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const result: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            if (parameters == null || parameters.size() !== 2)throw new Command.Failure("parameters must be two points");
            try {
                const pt1: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>parameters.get(0);
                const pt2: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>parameters.get(1);
                const segment: com.vzome.core.construction.Segment = new com.vzome.core.construction.SegmentJoiningPoints(pt1, pt2);
                result.addConstruction(segment);
                effects['constructionAdded$com_vzome_core_construction_Construction'](segment);
            } catch(e) {
                throw new Command.Failure("parameters must be two points");
            }
            return result;
        }

        constructor() {
            super();
        }
    }
    CommandJoinPoints["__class"] = "com.vzome.core.commands.CommandJoinPoints";
    CommandJoinPoints["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @class
     * @extends com.vzome.core.commands.AbstractCommand
     */
    export abstract class CommandTransform extends com.vzome.core.commands.AbstractCommand {
        /**
         * 
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        public setFixedAttributes(attributes: com.vzome.core.commands.AttributeMap, format: com.vzome.core.commands.XmlSaveFormat) {
            if (format.getScale() !== 0)attributes.put(CommandTransform.SCALE_ATTR_NAME, format.getScale());
            super.setFixedAttributes(attributes, format);
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attributes: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            return null;
        }

        public static SYMMETRY_GROUP_ATTR_NAME: string = "symmetry.group";

        public static SYMMETRY_CENTER_ATTR_NAME: string = "symmetry.center";

        public static SYMMETRY_AXIS_ATTR_NAME: string = "symmetry.axis.segment";

        public static SCALE_ATTR_NAME: string = "scale.factor";

        static PARAM_SIGNATURE: any[][]; public static PARAM_SIGNATURE_$LI$(): any[][] { if (CommandTransform.PARAM_SIGNATURE == null) { CommandTransform.PARAM_SIGNATURE = [[com.vzome.core.commands.Command.GENERIC_PARAM_NAME, com.vzome.core.construction.Construction]]; }  return CommandTransform.PARAM_SIGNATURE; }

        static ATTR_SIGNATURE: any[][]; public static ATTR_SIGNATURE_$LI$(): any[][] { if (CommandTransform.ATTR_SIGNATURE == null) { CommandTransform.ATTR_SIGNATURE = [[CommandTransform.SYMMETRY_CENTER_ATTR_NAME, com.vzome.core.construction.Point]]; }  return CommandTransform.ATTR_SIGNATURE; }

        static AXIS_ATTR_SIGNATURE: any[][]; public static AXIS_ATTR_SIGNATURE_$LI$(): any[][] { if (CommandTransform.AXIS_ATTR_SIGNATURE == null) { CommandTransform.AXIS_ATTR_SIGNATURE = [[CommandTransform.SYMMETRY_CENTER_ATTR_NAME, com.vzome.core.construction.Point], [CommandTransform.SYMMETRY_AXIS_ATTR_NAME, com.vzome.core.construction.Segment]]; }  return CommandTransform.AXIS_ATTR_SIGNATURE; }

        static GROUP_ATTR_SIGNATURE: any[][]; public static GROUP_ATTR_SIGNATURE_$LI$(): any[][] { if (CommandTransform.GROUP_ATTR_SIGNATURE == null) { CommandTransform.GROUP_ATTR_SIGNATURE = [[CommandTransform.SYMMETRY_CENTER_ATTR_NAME, com.vzome.core.construction.Point], [CommandTransform.SYMMETRY_GROUP_ATTR_NAME, "com.vzome.core.math.symmetry.Symmetry"]]; }  return CommandTransform.GROUP_ATTR_SIGNATURE; }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getParameterSignature(): any[][] {
            return CommandTransform.PARAM_SIGNATURE_$LI$();
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return CommandTransform.AXIS_ATTR_SIGNATURE_$LI$();
        }

        transform(params: com.vzome.core.construction.Construction[], transform: com.vzome.core.construction.Transformation, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const output: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            effects['constructionAdded$com_vzome_core_construction_Construction'](transform);
            for(let index = 0; index < params.length; index++) {
                let param = params[index];
                {
                    const result: com.vzome.core.construction.Construction = transform.transform$com_vzome_core_construction_Construction(param);
                    if (result == null)continue;
                    effects['constructionAdded$com_vzome_core_construction_Construction'](result);
                    output.addConstruction(result);
                }
            }
            return output;
        }

        constructor() {
            super();
        }
    }
    CommandTransform["__class"] = "com.vzome.core.commands.CommandTransform";
    CommandTransform["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @class
     * @extends com.vzome.core.commands.AbstractCommand
     */
    export class CommandBuildAnchoredSegment extends com.vzome.core.commands.AbstractCommand {
        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.AttributeMap} attributes
         */
        public getXml(xml: org.w3c.dom.Element, attributes: com.vzome.core.commands.AttributeMap) {
            com.vzome.core.commands.XmlSymmetryFormat.serializeAxis(xml, "symm", "dir", "index", "sense", <com.vzome.core.math.symmetry.Axis>attributes.get("axis"));
            com.vzome.core.commands.XmlSaveFormat.serializeNumber(xml, "len", <com.vzome.core.algebra.AlgebraicNumber><any>attributes.get("length"));
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         * @return {com.vzome.core.commands.AttributeMap}
         */
        public setXml(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat): com.vzome.core.commands.AttributeMap {
            const attrs: com.vzome.core.commands.AttributeMap = super.setXml(xml, format);
            if (format.commandEditsCompacted()){
                attrs.put("axis", (<com.vzome.core.commands.XmlSymmetryFormat>format).parseAxis(xml, "symm", "dir", "index", "sense"));
                attrs.put("length", format.parseNumber(xml, "len"));
            }
            return attrs;
        }

        static AXIS_ATTR: string = "axis";

        static LENGTH_ATTR: string = "length";

        static PARAM_SIGNATURE: any[][]; public static PARAM_SIGNATURE_$LI$(): any[][] { if (CommandBuildAnchoredSegment.PARAM_SIGNATURE == null) { CommandBuildAnchoredSegment.PARAM_SIGNATURE = [["start", com.vzome.core.construction.Point]]; }  return CommandBuildAnchoredSegment.PARAM_SIGNATURE; }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getParameterSignature(): any[][] {
            return CommandBuildAnchoredSegment.PARAM_SIGNATURE_$LI$();
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return null;
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attrs
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attrs: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const result: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            if (parameters == null || parameters.size() !== 1)throw new Command.Failure("start parameter must be a single point");
            const c: any = parameters.get(0);
            if (!(c != null && c instanceof <any>com.vzome.core.construction.Point))throw new Command.Failure("start parameter must be a single point");
            const pt1: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>c;
            const axis: com.vzome.core.math.symmetry.Axis = <com.vzome.core.math.symmetry.Axis>attrs.get(CommandBuildAnchoredSegment.AXIS_ATTR);
            const len: com.vzome.core.algebra.AlgebraicNumber = <com.vzome.core.algebra.AlgebraicNumber><any>attrs.get(CommandBuildAnchoredSegment.LENGTH_ATTR);
            const segment: com.vzome.core.construction.Segment = new com.vzome.core.construction.AnchoredSegment(axis, len, pt1);
            effects['constructionAdded$com_vzome_core_construction_Construction'](segment);
            result.addConstruction(segment);
            const pt2: com.vzome.core.construction.Point = new com.vzome.core.construction.SegmentEndPoint(segment);
            effects['constructionAdded$com_vzome_core_construction_Construction'](pt2);
            result.addConstruction(pt2);
            return result;
        }

        constructor() {
            super();
        }
    }
    CommandBuildAnchoredSegment["__class"] = "com.vzome.core.commands.CommandBuildAnchoredSegment";
    CommandBuildAnchoredSegment["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.math.symmetry.IcosahedralSymmetry} symmetry
     * @class
     * @extends com.vzome.core.commands.AbstractCommand
     */
    export class CommandExecuteZomicScript extends com.vzome.core.commands.AbstractCommand {
        /**
         * 
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        public setFixedAttributes(attributes: com.vzome.core.commands.AttributeMap, format: com.vzome.core.commands.XmlSaveFormat) {
            super.setFixedAttributes(attributes, format);
            this.symmetry = <com.vzome.core.math.symmetry.IcosahedralSymmetry>attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME);
            if (this.symmetry == null)this.symmetry = <com.vzome.core.math.symmetry.IcosahedralSymmetry><any>(<com.vzome.core.commands.XmlSymmetryFormat>format).parseSymmetry("icosahedral");
        }

        public constructor(symmetry?: any) {
            if (((symmetry != null && symmetry instanceof <any>com.vzome.core.math.symmetry.IcosahedralSymmetry) || symmetry === null)) {
                let __args = arguments;
                super();
                if (this.symmetry === undefined) { this.symmetry = null; } 
                this.symmetry = symmetry;
            } else if (symmetry === undefined) {
                let __args = arguments;
                super();
                if (this.symmetry === undefined) { this.symmetry = null; } 
                this.symmetry = null;
            } else throw new Error('invalid overload');
        }

        /*private*/ symmetry: com.vzome.core.math.symmetry.IcosahedralSymmetry;

        public static SCRIPT_ATTR: string = "script";

        static PARAM_SIGNATURE: any[][]; public static PARAM_SIGNATURE_$LI$(): any[][] { if (CommandExecuteZomicScript.PARAM_SIGNATURE == null) { CommandExecuteZomicScript.PARAM_SIGNATURE = [["start", com.vzome.core.construction.Point]]; }  return CommandExecuteZomicScript.PARAM_SIGNATURE; }

        static ATTR_SIGNATURE: any[][]; public static ATTR_SIGNATURE_$LI$(): any[][] { if (CommandExecuteZomicScript.ATTR_SIGNATURE == null) { CommandExecuteZomicScript.ATTR_SIGNATURE = [[CommandExecuteZomicScript.SCRIPT_ATTR, com.vzome.core.zomic.program.ZomicStatement]]; }  return CommandExecuteZomicScript.ATTR_SIGNATURE; }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getParameterSignature(): any[][] {
            return CommandExecuteZomicScript.PARAM_SIGNATURE_$LI$();
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return CommandExecuteZomicScript.ATTR_SIGNATURE_$LI$();
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attrs
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attrs: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const script: string = <string>attrs.get(CommandExecuteZomicScript.SCRIPT_ATTR);
            const result: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            if (parameters.size() !== 1)throw new Command.Failure("start parameter must be a single connector");
            const c: com.vzome.core.construction.Construction = parameters.get(0);
            if (!(c != null && c instanceof <any>com.vzome.core.construction.Point))throw new Command.Failure("start parameter must be a connector");
            const pt1: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>c;
            try {
                this.symmetry.interpretScript(script, "zomic", pt1, this.symmetry, effects);
            } catch(e) {
                throw new Command.Failure(e.message, e);
            }
            return result;
        }
    }
    CommandExecuteZomicScript["__class"] = "com.vzome.core.commands.CommandExecuteZomicScript";
    CommandExecuteZomicScript["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @class
     * @extends com.vzome.core.commands.AbstractCommand
     */
    export class CommandTauDivision extends com.vzome.core.commands.AbstractCommand {
        static PARAM_SIGNATURE: any[][]; public static PARAM_SIGNATURE_$LI$(): any[][] { if (CommandTauDivision.PARAM_SIGNATURE == null) { CommandTauDivision.PARAM_SIGNATURE = [["start", com.vzome.core.construction.Point], ["end", com.vzome.core.construction.Point]]; }  return CommandTauDivision.PARAM_SIGNATURE; }

        static ATTR_SIGNATURE: any[][]; public static ATTR_SIGNATURE_$LI$(): any[][] { if (CommandTauDivision.ATTR_SIGNATURE == null) { CommandTauDivision.ATTR_SIGNATURE = []; }  return CommandTauDivision.ATTR_SIGNATURE; }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getParameterSignature(): any[][] {
            return CommandTauDivision.PARAM_SIGNATURE_$LI$();
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return CommandTauDivision.ATTR_SIGNATURE_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public ordersSelection(): boolean {
            return true;
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attrs
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attrs: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const result: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            if (parameters == null || parameters.size() !== 2)throw new Command.Failure("Tau division applies to two balls.");
            try {
                const start: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>parameters.get(0);
                const end: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>parameters.get(1);
                const join: com.vzome.core.construction.Segment = new com.vzome.core.construction.SegmentJoiningPoints(start, end);
                const midpoint: com.vzome.core.construction.Point = new com.vzome.core.construction.SegmentTauDivision(join);
                result.addConstruction(midpoint);
                effects['constructionAdded$com_vzome_core_construction_Construction'](midpoint);
            } catch(e) {
                throw new Command.Failure("Tau division applies to two balls.");
            }
            return result;
        }

        constructor() {
            super();
        }
    }
    CommandTauDivision["__class"] = "com.vzome.core.commands.CommandTauDivision";
    CommandTauDivision["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.commands {
    export class CommandPolygon extends com.vzome.core.commands.AbstractCommand {
        static PARAM_SIGNATURE: any[][]; public static PARAM_SIGNATURE_$LI$(): any[][] { if (CommandPolygon.PARAM_SIGNATURE == null) { CommandPolygon.PARAM_SIGNATURE = [[com.vzome.core.commands.Command.GENERIC_PARAM_NAME, com.vzome.core.construction.Point]]; }  return CommandPolygon.PARAM_SIGNATURE; }

        static ATTR_SIGNATURE: any[][]; public static ATTR_SIGNATURE_$LI$(): any[][] { if (CommandPolygon.ATTR_SIGNATURE == null) { CommandPolygon.ATTR_SIGNATURE = []; }  return CommandPolygon.ATTR_SIGNATURE; }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getParameterSignature(): any[][] {
            return CommandPolygon.PARAM_SIGNATURE_$LI$();
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return CommandPolygon.ATTR_SIGNATURE_$LI$();
        }

        /**
         * 
         * @return {boolean}
         */
        public ordersSelection(): boolean {
            return true;
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attrs
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attrs: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const points: java.util.List<com.vzome.core.construction.Point> = <any>(new java.util.ArrayList<any>());
            {
                let array = parameters.getConstructions();
                for(let index = 0; index < array.length; index++) {
                    let param = array[index];
                    {
                        if (param != null && param instanceof <any>com.vzome.core.construction.Point){
                            points.add(<com.vzome.core.construction.Point>param);
                        }
                    }
                }
            }
            let errorMsg: string = null;
            if (points.size() < 3){
                errorMsg = "A polygon requires at least three vertices.";
            } else if (points.get(0).is3d() && points.get(1).is3d() && points.get(1).is3d()){
                const normal: com.vzome.core.algebra.AlgebraicVector = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(points.get(0).getLocation(), points.get(1).getLocation(), points.get(2).getLocation());
                if (normal.isOrigin()){
                    errorMsg = "First 3 points cannot be collinear.";
                } else {
                    let base: com.vzome.core.algebra.AlgebraicVector = null;
                    for(let index=points.iterator();index.hasNext();) {
                        let point = index.next();
                        {
                            if (base == null){
                                base = point.getLocation();
                            } else {
                                if (!point.getLocation().minus(base).dot(normal).isZero()){
                                    errorMsg = "Points are not coplanar.";
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            if (errorMsg != null && attrs.get(com.vzome.core.commands.Command.LOADING_FROM_FILE) == null){
                throw new Command.Failure(errorMsg);
            }
            const poly: com.vzome.core.construction.PolygonFromVertices = new com.vzome.core.construction.PolygonFromVertices(points);
            if (errorMsg != null){
                poly.setFailed();
            } else {
                effects['constructionAdded$com_vzome_core_construction_Construction'](poly);
            }
            const result: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            result.addConstruction(poly);
            return result;
        }

        constructor() {
            super();
        }
    }
    CommandPolygon["__class"] = "com.vzome.core.commands.CommandPolygon";
    CommandPolygon["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @class
     * @extends com.vzome.core.commands.AbstractCommand
     */
    export class CommandCentroid extends com.vzome.core.commands.AbstractCommand {
        static PARAM_SIGNATURE: any[][]; public static PARAM_SIGNATURE_$LI$(): any[][] { if (CommandCentroid.PARAM_SIGNATURE == null) { CommandCentroid.PARAM_SIGNATURE = [[com.vzome.core.commands.Command.GENERIC_PARAM_NAME, com.vzome.core.construction.Point]]; }  return CommandCentroid.PARAM_SIGNATURE; }

        static ATTR_SIGNATURE: any[][]; public static ATTR_SIGNATURE_$LI$(): any[][] { if (CommandCentroid.ATTR_SIGNATURE == null) { CommandCentroid.ATTR_SIGNATURE = []; }  return CommandCentroid.ATTR_SIGNATURE; }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getParameterSignature(): any[][] {
            return CommandCentroid.PARAM_SIGNATURE_$LI$();
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return CommandCentroid.ATTR_SIGNATURE_$LI$();
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attrs
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attrs: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const result: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            if (parameters == null || parameters.size() === 0)throw new Command.Failure("Select two or more balls to compute their centroid.");
            const params: com.vzome.core.construction.Construction[] = parameters.getConstructions();
            const verticesList: java.util.List<com.vzome.core.construction.Point> = <any>(new java.util.ArrayList<any>());
            for(let index = 0; index < params.length; index++) {
                let param = params[index];
                {
                    if (param != null && param instanceof <any>com.vzome.core.construction.Point){
                        verticesList.add(<com.vzome.core.construction.Point>param);
                    }
                }
            }
            if (verticesList.isEmpty())throw new Command.Failure("Select two or more balls to compute their centroid.");
            const points: com.vzome.core.construction.Point[] = [];
            const centroid: com.vzome.core.construction.CentroidPoint = new com.vzome.core.construction.CentroidPoint(verticesList.toArray<any>(points));
            effects['constructionAdded$com_vzome_core_construction_Construction'](centroid);
            result.addConstruction(centroid);
            return result;
        }

        constructor() {
            super();
        }
    }
    CommandCentroid["__class"] = "com.vzome.core.commands.CommandCentroid";
    CommandCentroid["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.construction.Point} intersection
     * @param {com.vzome.core.construction.Segment} normal
     * @class
     * @extends com.vzome.core.construction.Plane
     */
    export class PlaneFromNormalSegment extends com.vzome.core.construction.Plane {
        /*private*/ __com_vzome_core_construction_PlaneFromNormalSegment_mNormal: com.vzome.core.construction.Segment;

        /*private*/ mIntersection: com.vzome.core.construction.Point;

        public constructor(intersection: com.vzome.core.construction.Point, normal: com.vzome.core.construction.Segment) {
            super(intersection.field);
            if (this.__com_vzome_core_construction_PlaneFromNormalSegment_mNormal === undefined) { this.__com_vzome_core_construction_PlaneFromNormalSegment_mNormal = null; }
            if (this.mIntersection === undefined) { this.mIntersection = null; }
            this.__com_vzome_core_construction_PlaneFromNormalSegment_mNormal = normal;
            this.mIntersection = intersection;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.__com_vzome_core_construction_PlaneFromNormalSegment_mNormal.isImpossible() || this.mIntersection.isImpossible())return this.setStateVariables(null, null, true);
            return this.setStateVariables(this.mIntersection.getLocation(), this.__com_vzome_core_construction_PlaneFromNormalSegment_mNormal.getOffset(), false);
        }
    }
    PlaneFromNormalSegment["__class"] = "com.vzome.core.construction.PlaneFromNormalSegment";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.construction.Polygon} polygon
     * @class
     * @extends com.vzome.core.construction.Plane
     */
    export class PlaneExtensionOfPolygon extends com.vzome.core.construction.Plane {
        /*private*/ mPolygon: com.vzome.core.construction.Polygon;

        public constructor(polygon: com.vzome.core.construction.Polygon) {
            super(polygon.field);
            if (this.mPolygon === undefined) { this.mPolygon = null; }
            this.mPolygon = polygon;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.mPolygon.isImpossible()){
                return this.setStateVariables(null, null, true);
            }
            return this.setStateVariables(this.mPolygon.getVertex(0), this.mPolygon.getNormal(), false);
        }

        /**
         * 
         * @return {com.vzome.core.algebra.Trivector3dHomogeneous}
         */
        public getHomogeneous(): com.vzome.core.algebra.Trivector3dHomogeneous {
            const v1: com.vzome.core.algebra.Vector3dHomogeneous = new com.vzome.core.algebra.Vector3dHomogeneous(this.mPolygon.getVertex(0), this.getField());
            const v2: com.vzome.core.algebra.Vector3dHomogeneous = new com.vzome.core.algebra.Vector3dHomogeneous(this.mPolygon.getVertex(1), this.getField());
            const v3: com.vzome.core.algebra.Vector3dHomogeneous = new com.vzome.core.algebra.Vector3dHomogeneous(this.mPolygon.getVertex(2), this.getField());
            return v1.outer(v2).outer(v3);
        }
    }
    PlaneExtensionOfPolygon["__class"] = "com.vzome.core.construction.PlaneExtensionOfPolygon";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.algebra.AlgebraicVector} point
     * @param {com.vzome.core.algebra.AlgebraicVector} normal
     * @class
     * @extends com.vzome.core.construction.Plane
     */
    export class PlaneFromPointAndNormal extends com.vzome.core.construction.Plane {
        /*private*/ normal: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ point: com.vzome.core.algebra.AlgebraicVector;

        public constructor(point: com.vzome.core.algebra.AlgebraicVector, normal: com.vzome.core.algebra.AlgebraicVector) {
            super(point.getField());
            if (this.normal === undefined) { this.normal = null; }
            if (this.point === undefined) { this.point = null; }
            this.point = point;
            this.normal = normal;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.normal.isOrigin())return this.setStateVariables(null, null, true);
            return this.setStateVariables(this.point, this.normal, false);
        }
    }
    PlaneFromPointAndNormal["__class"] = "com.vzome.core.construction.PlaneFromPointAndNormal";

}
namespace com.vzome.core.construction {
    /**
     * @param step
     * @param start
     * @param end
     * @param {com.vzome.core.construction.Line} l1
     * @param {com.vzome.core.construction.Line} l2
     * @param {com.vzome.core.construction.Point} p
     * @class
     * @extends com.vzome.core.construction.Line
     * @author Scott Vorthmann
     */
    export class PerpendicularLine extends com.vzome.core.construction.Line {
        /*private*/ mLine1: com.vzome.core.construction.Line;

        /*private*/ mLine2: com.vzome.core.construction.Line;

        /*private*/ mPoint: com.vzome.core.construction.Point;

        public constructor(l1: com.vzome.core.construction.Line, l2: com.vzome.core.construction.Line, p: com.vzome.core.construction.Point) {
            super(l1.field);
            if (this.mLine1 === undefined) { this.mLine1 = null; }
            if (this.mLine2 === undefined) { this.mLine2 = null; }
            if (this.mPoint === undefined) { this.mPoint = null; }
            this.mLine1 = l1;
            this.mLine2 = l2;
            this.mPoint = p;
            this.mapParamsToState();
        }

        /**
         * returns true if something changed.
         * @return
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.mLine1.isImpossible() || this.mLine2.isImpossible() || this.mPoint.isImpossible()){
                return this.setStateVariables(null, null, true);
            }
            const normal: com.vzome.core.algebra.AlgebraicVector = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(this.mLine1.getDirection(), this.mLine2.getDirection());
            return this.setStateVariables(this.mPoint.getLocation(), normal, normal.isOrigin());
        }
    }
    PerpendicularLine["__class"] = "com.vzome.core.construction.PerpendicularLine";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.construction.Segment} seg
     * @class
     * @extends com.vzome.core.construction.Line
     */
    export class LineExtensionOfSegment extends com.vzome.core.construction.Line {
        /*private*/ mSegment: com.vzome.core.construction.Segment;

        public constructor(seg: com.vzome.core.construction.Segment) {
            super(seg.field);
            if (this.mSegment === undefined) { this.mSegment = null; }
            this.mSegment = seg;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.mSegment.isImpossible())return this.setStateVariables(null, null, true);
            return this.setStateVariables(this.mSegment.getStart(), this.mSegment.getOffset(), false);
        }

        /**
         * 
         * @return {com.vzome.core.algebra.Bivector3dHomogeneous}
         */
        public getHomogeneous(): com.vzome.core.algebra.Bivector3dHomogeneous {
            const v1: com.vzome.core.algebra.Vector3dHomogeneous = new com.vzome.core.algebra.Vector3dHomogeneous(this.mSegment.getStart(), this.getField());
            const v2: com.vzome.core.algebra.Vector3dHomogeneous = new com.vzome.core.algebra.Vector3dHomogeneous(this.mSegment.getEnd(), this.getField());
            return v1.outer(v2);
        }
    }
    LineExtensionOfSegment["__class"] = "com.vzome.core.construction.LineExtensionOfSegment";

}
namespace com.vzome.core.construction {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.algebra.AlgebraicVector} point
     * @param {com.vzome.core.algebra.AlgebraicVector} direction
     * @class
     * @extends com.vzome.core.construction.Line
     */
    export class LineFromPointAndVector extends com.vzome.core.construction.Line {
        /*private*/ point: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ direction: com.vzome.core.algebra.AlgebraicVector;

        public constructor(point: com.vzome.core.algebra.AlgebraicVector, direction: com.vzome.core.algebra.AlgebraicVector) {
            super(point.getField());
            if (this.point === undefined) { this.point = null; }
            if (this.direction === undefined) { this.direction = null; }
            this.point = point;
            this.direction = direction;
            this.mapParamsToState();
        }

        /**
         * 
         * @return {boolean}
         */
        mapParamsToState(): boolean {
            if (this.direction.isOrigin())return this.setStateVariables(null, null, true);
            return this.setStateVariables(this.point, this.direction, false);
        }
    }
    LineFromPointAndVector["__class"] = "com.vzome.core.construction.LineFromPointAndVector";

}
namespace com.vzome.core.editor.api {
    export abstract class ChangeSelection extends com.vzome.core.editor.api.SideEffects {
        mSelection: com.vzome.core.editor.api.Selection;

        /*private*/ groupingDoneInSelection: boolean;

        /*private*/ orderedSelection: boolean;

        /*private*/ selectionEffects: java.util.Deque<com.vzome.core.editor.api.SideEffect>;

        static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (ChangeSelection.logger == null) { ChangeSelection.logger = java.util.logging.Logger.getLogger("com.vzome.core.editor.ChangeSelection"); }  return ChangeSelection.logger; }

        public constructor(selection: com.vzome.core.editor.api.Selection) {
            super();
            if (this.mSelection === undefined) { this.mSelection = null; }
            if (this.groupingDoneInSelection === undefined) { this.groupingDoneInSelection = false; }
            this.orderedSelection = false;
            this.selectionEffects = null;
            this.mSelection = selection;
            this.groupingDoneInSelection = false;
        }

        public setOrderedSelection(orderedSelection: boolean) {
            this.orderedSelection = orderedSelection;
        }

        /**
         * 
         */
        public undo() {
            if (this.orderedSelection){
                const stack: java.util.Deque<com.vzome.core.editor.api.SideEffect> = <any>(new java.util.ArrayDeque<com.vzome.core.editor.api.SideEffect>());
                this.selectionEffects = stack;
                super.undo();
                this.selectionEffects = null;
                while((!stack.isEmpty())) {{
                    const se: com.vzome.core.editor.api.SideEffect = stack.pop();
                    se.undo();
                }};
            } else super.undo();
        }

        getXmlAttributes(element: org.w3c.dom.Element) {
        }

        setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
        }

        abstract getXmlElementName(): string;

        /**
         * 
         * @param {*} doc
         * @return {*}
         */
        public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
            const result: org.w3c.dom.Element = doc.createElement(this.getXmlElementName());
            if (this.groupingDoneInSelection)com.vzome.xml.DomUtils.addAttribute(result, "grouping", "2.1.1");
            this.getXmlAttributes(result);
            return result;
        }

        adjustSelection(man: com.vzome.core.model.Manifestation, action: com.vzome.core.editor.api.ActionEnum) {
            switch((action)) {
            case com.vzome.core.editor.api.ActionEnum.SELECT:
                this.select$com_vzome_core_model_Manifestation(man);
                break;
            case com.vzome.core.editor.api.ActionEnum.DESELECT:
                this.unselect$com_vzome_core_model_Manifestation(man);
                break;
            case com.vzome.core.editor.api.ActionEnum.IGNORE:
                break;
            default:
                ChangeSelection.logger_$LI$().warning("unexpected action: " + /* Enum.name */com.vzome.core.editor.api.ActionEnum[action]);
                break;
            }
        }

        /**
         * Any subclass can override to alter loading, or migrate (insert other edits), etc.
         * ALWAYS DO SOME INSERT, or all trace of the command will disappear!
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         * @param {*} context
         */
        public loadAndPerform(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat, context: com.vzome.core.editor.api.Context) {
            const grouping: string = xml.getAttribute("grouping");
            if (this.groupingAware() && (format.groupingDoneInSelection() || ("2.1.1" === grouping)))this.groupingDoneInSelection = true;
            this.setXmlAttributes(xml, format);
            context.performAndRecord(this);
        }

        groupingAware(): boolean {
            return false;
        }

        public unselect$com_vzome_core_model_Manifestation(man: com.vzome.core.model.Manifestation) {
            this.unselect$com_vzome_core_model_Manifestation$boolean(man, false);
        }

        public unselect$com_vzome_core_model_Manifestation$boolean(man: com.vzome.core.model.Manifestation, ignoreGroups: boolean) {
            if (this.groupingDoneInSelection){
                this.plan(new ChangeSelection.SelectManifestation(this, man, false));
                return;
            }
            if (man == null){
                SideEffects.logBugAccommodation("null manifestation");
                return;
            }
            if (!this.mSelection.manifestationSelected(man))return;
            const group: com.vzome.core.model.Group = ignoreGroups ? null : com.vzome.core.editor.api.Selection.biggestGroup(man);
            if (group == null)this.plan(new ChangeSelection.SelectManifestation(this, man, false)); else this.unselectGroup(group);
        }

        public unselect(man?: any, ignoreGroups?: any) {
            if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ((typeof ignoreGroups === 'boolean') || ignoreGroups === null)) {
                return <any>this.unselect$com_vzome_core_model_Manifestation$boolean(man, ignoreGroups);
            } else if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ignoreGroups === undefined) {
                return <any>this.unselect$com_vzome_core_model_Manifestation(man);
            } else throw new Error('invalid overload');
        }

        public select$com_vzome_core_model_Manifestation(man: com.vzome.core.model.Manifestation) {
            this.select$com_vzome_core_model_Manifestation$boolean(man, false);
        }

        public recordSelected(man: com.vzome.core.model.Manifestation) {
            if (!this.mSelection.manifestationSelected(man))return;
            this.plan(new ChangeSelection.RecordSelectedManifestation(this, man));
        }

        public select$com_vzome_core_model_Manifestation$boolean(man: com.vzome.core.model.Manifestation, ignoreGroups: boolean) {
            if (this.groupingDoneInSelection){
                this.plan(new ChangeSelection.SelectManifestation(this, man, true));
                return;
            }
            if (man == null){
                SideEffects.logBugAccommodation("null manifestation");
                return;
            }
            if (this.mSelection.manifestationSelected(man))return;
            const group: com.vzome.core.model.Group = ignoreGroups ? null : com.vzome.core.editor.api.Selection.biggestGroup(man);
            if (group == null)this.plan(new ChangeSelection.SelectManifestation(this, man, true)); else this.selectGroup(group);
        }

        public select(man?: any, ignoreGroups?: any) {
            if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ((typeof ignoreGroups === 'boolean') || ignoreGroups === null)) {
                return <any>this.select$com_vzome_core_model_Manifestation$boolean(man, ignoreGroups);
            } else if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ignoreGroups === undefined) {
                return <any>this.select$com_vzome_core_model_Manifestation(man);
            } else throw new Error('invalid overload');
        }

        selectGroup(group: com.vzome.core.model.Group) {
            for(let index=group.iterator();index.hasNext();) {
                let next = index.next();
                {
                    if (next != null && next instanceof <any>com.vzome.core.model.Group)this.selectGroup(<com.vzome.core.model.Group><any>next); else this.plan(new ChangeSelection.SelectManifestation(this, <com.vzome.core.model.Manifestation><any>next, true));
                }
            }
        }

        unselectGroup(group: com.vzome.core.model.Group) {
            for(let index=group.iterator();index.hasNext();) {
                let next = index.next();
                {
                    if (next != null && next instanceof <any>com.vzome.core.model.Group)this.unselectGroup(<com.vzome.core.model.Group><any>next); else this.plan(new ChangeSelection.SelectManifestation(this, <com.vzome.core.model.Manifestation><any>next, false));
                }
            }
        }

        getSelectedConnectors(): com.vzome.core.editor.api.Manifestations.ConnectorIterator {
            return com.vzome.core.editor.api.Manifestations.getConnectors$java_lang_Iterable(this.mSelection);
        }

        getSelectedStruts(): com.vzome.core.editor.api.Manifestations.StrutIterator {
            return com.vzome.core.editor.api.Manifestations.getStruts$java_lang_Iterable(this.mSelection);
        }

        getSelectedPanels(): com.vzome.core.editor.api.Manifestations.PanelIterator {
            return com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable(this.mSelection);
        }

        public getLastSelectedManifestation(): com.vzome.core.model.Manifestation {
            let last: com.vzome.core.model.Manifestation = null;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    last = man;
                }
            }
            return last;
        }

        public getLastSelectedConnector(): com.vzome.core.model.Connector {
            let last: com.vzome.core.model.Connector = null;
            for(let index=this.getSelectedConnectors().iterator();index.hasNext();) {
                let connector = index.next();
                {
                    last = connector;
                }
            }
            return last;
        }

        public getLastSelectedStrut(): com.vzome.core.model.Strut {
            let last: com.vzome.core.model.Strut = null;
            for(let index=this.getSelectedStruts().iterator();index.hasNext();) {
                let strut = index.next();
                {
                    last = strut;
                }
            }
            return last;
        }

        public getLastSelectedPanel(): com.vzome.core.model.Panel {
            let last: com.vzome.core.model.Panel = null;
            for(let index=this.getSelectedPanels().iterator();index.hasNext();) {
                let panel = index.next();
                {
                    last = panel;
                }
            }
            return last;
        }

        public unselectAll(): boolean {
            let anySelected: boolean = false;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    anySelected = true;
                    this.unselect$com_vzome_core_model_Manifestation(man);
                }
            }
            if (anySelected){
                this.redo();
            }
            return anySelected;
        }

        public unselectConnectors(): boolean {
            let anySelected: boolean = false;
            for(let index=this.getSelectedConnectors().iterator();index.hasNext();) {
                let connector = index.next();
                {
                    anySelected = true;
                    this.unselect$com_vzome_core_model_Manifestation(connector);
                }
            }
            if (anySelected){
                this.redo();
            }
            return anySelected;
        }

        public unselectStruts(): boolean {
            let anySelected: boolean = false;
            for(let index=this.getSelectedStruts().iterator();index.hasNext();) {
                let strut = index.next();
                {
                    anySelected = true;
                    this.unselect$com_vzome_core_model_Manifestation(strut);
                }
            }
            if (anySelected){
                this.redo();
            }
            return anySelected;
        }

        public unselectPanels(): boolean {
            let anySelected: boolean = false;
            for(let index=this.getSelectedPanels().iterator();index.hasNext();) {
                let panel = index.next();
                {
                    anySelected = true;
                    this.unselect$com_vzome_core_model_Manifestation(panel);
                }
            }
            if (anySelected){
                this.redo();
            }
            return anySelected;
        }
    }
    ChangeSelection["__class"] = "com.vzome.core.editor.api.ChangeSelection";


    export namespace ChangeSelection {

        export class SelectManifestation implements com.vzome.core.editor.api.SideEffect {
            public __parent: any;
            mMan: com.vzome.core.model.Manifestation;

            mOn: boolean;

            public constructor(__parent: any, man: com.vzome.core.model.Manifestation, value: boolean) {
                this.__parent = __parent;
                if (this.mMan === undefined) { this.mMan = null; }
                if (this.mOn === undefined) { this.mOn = false; }
                this.mMan = man;
                this.mOn = value;
                com.vzome.core.editor.api.ChangeSelection.logger_$LI$().finest("constructing SelectManifestation");
            }

            /**
             * 
             */
            public redo() {
                if (this.__parent.groupingDoneInSelection){
                    if (this.mOn)this.__parent.mSelection.selectWithGrouping(this.mMan); else this.__parent.mSelection.unselectWithGrouping(this.mMan);
                } else if (this.mOn)this.__parent.mSelection.select(this.mMan); else this.__parent.mSelection.unselect(this.mMan);
            }

            /**
             * 
             */
            public undo() {
                if (this.__parent.groupingDoneInSelection){
                    if (this.mOn)this.__parent.mSelection.unselectWithGrouping(this.mMan); else this.__parent.mSelection.selectWithGrouping(this.mMan);
                } else if (this.mOn)this.__parent.mSelection.unselect(this.mMan); else if (this.__parent.selectionEffects != null){
                    this.__parent.selectionEffects.push(this);
                } else this.__parent.mSelection.select(this.mMan);
            }

            /**
             * 
             * @param {*} doc
             * @return {*}
             */
            public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
                const result: org.w3c.dom.Element = this.mOn ? doc.createElement("select") : doc.createElement("deselect");
                if (this.mMan != null){
                    const man: org.w3c.dom.Element = this.mMan.getXml(doc);
                    result.appendChild(man);
                }
                return result;
            }
        }
        SelectManifestation["__class"] = "com.vzome.core.editor.api.ChangeSelection.SelectManifestation";
        SelectManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffect"];



        export class RecordSelectedManifestation implements com.vzome.core.editor.api.SideEffect {
            public __parent: any;
            mMan: com.vzome.core.model.Manifestation;

            public constructor(__parent: any, man: com.vzome.core.model.Manifestation) {
                this.__parent = __parent;
                if (this.mMan === undefined) { this.mMan = null; }
                this.mMan = man;
                com.vzome.core.editor.api.ChangeSelection.logger_$LI$().finest("constructing RecordSelectedManifestation");
            }

            /**
             * 
             */
            public redo() {
                com.vzome.core.editor.api.ChangeSelection.logger_$LI$().finest("redoing RecordSelectedManifestation");
            }

            /**
             * 
             */
            public undo() {
                com.vzome.core.editor.api.ChangeSelection.logger_$LI$().finest("undoing RecordSelectedManifestation");
                if (this.__parent.selectionEffects == null)this.__parent.mSelection.select(this.mMan); else this.__parent.selectionEffects.push(this);
            }

            /**
             * 
             * @param {*} doc
             * @return {*}
             */
            public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
                return doc.createElement("recordSelected");
            }
        }
        RecordSelectedManifestation["__class"] = "com.vzome.core.editor.api.ChangeSelection.RecordSelectedManifestation";
        RecordSelectedManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffect"];


    }

}
namespace com.vzome.core.tools {
    export class TetrahedralToolFactory extends com.vzome.core.tools.OctahedralToolFactory {
        static __com_vzome_core_tools_TetrahedralToolFactory_ID: string = "tetrahedral";

        static __com_vzome_core_tools_TetrahedralToolFactory_LABEL: string = "Create a tetrahedral symmetry tool";

        static TOOLTIP1: string = "<p>Each tool produces up to 11 copies of the input<br>selection, using the rotation symmetries of a<br>tetrahedron.  To create a tool, select a ball<br>that defines the center of symmetry, and a single<br>blue or green strut, defining one of five<br>possible orientations for the symmetry.<br><br>Combine with a point reflection tool to achieve<br>all 24 symmetries of the tetrahedron, including<br>reflections.<br></p>";

        static __com_vzome_core_tools_TetrahedralToolFactory_TOOLTIP2: string = "<p>Each tool produces up to 11 copies of the input<br>selection, using the rotation symmetries of a<br>tetrahedron.  To create a tool, select a ball<br>that defines the center of symmetry.<br><br>Combine with a point reflection tool to achieve<br>all 24 symmetries of the tetrahedron, including<br>reflections.<br></p>";

        public constructor(tools: com.vzome.core.editor.ToolsModel, symmetry: com.vzome.core.math.symmetry.Symmetry) {
            super(tools, symmetry, TetrahedralToolFactory.__com_vzome_core_tools_TetrahedralToolFactory_ID, TetrahedralToolFactory.__com_vzome_core_tools_TetrahedralToolFactory_LABEL, "icosahedral" === symmetry.getName() ? TetrahedralToolFactory.TOOLTIP1 : TetrahedralToolFactory.__com_vzome_core_tools_TetrahedralToolFactory_TOOLTIP2);
        }

        /**
         * 
         * @param {string} id
         * @return {com.vzome.core.editor.Tool}
         */
        public createToolInternal(id: string): com.vzome.core.editor.Tool {
            if (!/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(id, "tetrahedral"))id = "tetrahedral." + id;
            return new com.vzome.core.tools.SymmetryTool(id, this.getSymmetry(), this.getToolsModel());
        }
    }
    TetrahedralToolFactory["__class"] = "com.vzome.core.tools.TetrahedralToolFactory";
    TetrahedralToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


}
namespace com.vzome.core.tools {
    /**
     * Used for the throwaway factories used to create predefined tools.
     * Using the symmetry name in the factory ID prevents collisions across
     * symmetries for common tools.
     * @param {com.vzome.core.editor.ToolsModel} tools
     * @param {*} symmetry
     * @param {boolean} useSymmetryName
     * @class
     * @extends com.vzome.core.tools.RotationToolFactory
     */
    export class AxialSymmetryToolFactory extends com.vzome.core.tools.RotationToolFactory {
        static ID: string = "axial symmetry";

        static __com_vzome_core_tools_AxialSymmetryToolFactory_LABEL: string = "Create a rotational symmetry tool";

        static __com_vzome_core_tools_AxialSymmetryToolFactory_TOOLTIP: string = "<p>Each tool creates enough copies of the selected objects to<br>create rotational symmetry around an axis.  To create a tool,<br>select a strut that defines that axis,  You can also define<br>the direction and center independently, by selecting a ball<br>for the center and a strut for the axis.  Note: not all struts<br>correspond to rotational symmetries!<br><br>Combine with a point reflection or mirror reflection tool to<br>achieve more symmetries.<br></p>";

        public constructor(tools: com.vzome.core.editor.ToolsModel, symmetry: com.vzome.core.math.symmetry.Symmetry, useSymmetryName: boolean = false) {
            super(tools, symmetry, (useSymmetryName ? symmetry.getName() + ' ' : "") + AxialSymmetryToolFactory.ID, AxialSymmetryToolFactory.__com_vzome_core_tools_AxialSymmetryToolFactory_LABEL, AxialSymmetryToolFactory.__com_vzome_core_tools_AxialSymmetryToolFactory_TOOLTIP);
        }

        /**
         * 
         * @param {string} id
         * @return {com.vzome.core.editor.Tool}
         */
        public createToolInternal(id: string): com.vzome.core.editor.Tool {
            return new com.vzome.core.tools.RotationTool(id, this.getSymmetry(), this.getToolsModel(), true);
        }
    }
    AxialSymmetryToolFactory["__class"] = "com.vzome.core.tools.AxialSymmetryToolFactory";
    AxialSymmetryToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


}
namespace com.vzome.core.algebra {
    /**
     * @author David Hall
     * @param {number} polygonSides
     * @param {*} factory
     * @class
     * @extends com.vzome.core.algebra.ParameterizedField
     */
    export class PolygonField extends com.vzome.core.algebra.ParameterizedField {
        static PI: number = 3.141592653589793;

        /**
         * 
         * @param {number} nSides
         * @return {double[]} the coefficients of a PolygonField given the same parameter.
         * This can be used to determine when two fields have compatible coefficients
         * without having to generate an instance of the class.
         */
        public static getFieldCoefficients(nSides: number): number[] {
            const order: number = PolygonField.getOrder(nSides);
            const coefficients: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(order);
            const diagLengths: number[] = PolygonField.getDiagonalLengths(nSides);
            for(let i: number = 0; i < order; i++) {{
                coefficients[i] = diagLengths[i];
            };}
            return coefficients;
        }

        /**
         * 
         * @param {number} nSides
         * @return {double[]} an array with the unique lengths in increasing order
         * of the diagonals of a regular N-gon having a unit edge length.
         */
        public static getDiagonalLengths(nSides: number): number[] {
            const count: number = PolygonField.diagonalCount(nSides);
            const diagLengths: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(count);
            const unitLength: number = Math.sin(PolygonField.PI / nSides);
            diagLengths[0] = 1.0;
            for(let i: number = 1; i < count; i++) {{
                diagLengths[i] = Math.sin((i + 1) * PolygonField.PI / nSides) / unitLength;
            };}
            switch((nSides)) {
            case 6:
                diagLengths[2] = 2.0;
                diagLengths[1] = Math.sqrt(3);
                break;
            case 5:
                diagLengths[1] = (1.0 + Math.sqrt(5.0)) / 2.0;
                break;
            }
            return diagLengths;
        }

        public static FIELD_PREFIX: string = "polygon";

        public static getOrder(nSides: number): number {
            return PolygonField.primaryDiagonalCount(nSides);
        }

        public static diagonalCount(nSides: number): number {
            return (nSides / 2|0);
        }

        public static primaryDiagonalCount(nSides: number): number {
            return (<number>((n => n<0?Math.ceil(n):Math.floor(n))(PolygonField.eulerTotient(2 * nSides) / 2))|0);
        }

        public static secondaryDiagonalCount(nSides: number): number {
            return PolygonField.diagonalCount(nSides) - PolygonField.primaryDiagonalCount(nSides);
        }

        public static eulerTotient(n: number): number {
            let result: number = n;
            for(let i: number = 2; i * i <= n; i++) {{
                if (n % i === 0)result -= (n => n<0?Math.ceil(n):Math.floor(n))(result / i);
                while((n % i === 0)) {{
                    n = (n => n<0?Math.ceil(n):Math.floor(n))(n / i);
                }};
            };}
            if (n > 1){
                result -= (n => n<0?Math.ceil(n):Math.floor(n))(result / n);
            }
            return result;
        }

        public static isPowerOfTwo(n: number): boolean {
            return (n !== 0) && ((n & -n) === n);
        }

        public isPrime(n: number): boolean {
            return this.numberFactory.isPrime(n);
        }

        /*private*/ distinctPrimeFactors(n: number): java.util.List<number> {
            const factors: java.util.List<number> = <any>(new java.util.ArrayList<any>());
            for(let prime: number = 2; prime <= n; prime = this.numberFactory.nextPrime(prime)) {{
                if (n % prime === 0){
                    factors.add(prime);
                }
                while((n % prime === 0)) {{
                    n = (n => n<0?Math.ceil(n):Math.floor(n))(n / prime);
                }};
            };}
            return factors;
        }

        public getNormalizedMultiplicationTensor(nSides: number): number[][][] {
            const tensor: number[][][] = PolygonField.getExtendedMultiplicationTensor(nSides);
            if (this.isPrime(nSides) || PolygonField.isPowerOfTwo(nSides)){
                return tensor;
            }
            const length: number = PolygonField.primaryDiagonalCount(nSides);
            const result: number[][][] = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return 0; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([length, length, length]);
            for(let i: number = 0; i < length; i++) {{
                for(let j: number = 0; j < length; j++) {{
                    for(let k: number = 0; k < length; k++) {{
                        result[i][j][k] = tensor[i][j][k];
                    };}
                };}
            };}
            const normalizerMatrix: number[][] = this.getNormalizerMatrix(nSides);
            let n: number = 0;
            for(let term: number = length; term < PolygonField.diagonalCount(nSides); term++) {{
                for(let r: number = 0; r < length; r++) {{
                    for(let c: number = 0; c < length; c++) {{
                        const omit: number = tensor[term][r][c];
                        if (omit !== 0){
                            for(let t: number = 0; t < length; t++) {{
                                const alt: number = normalizerMatrix[n][t];
                                if (alt !== 0){
                                    const adjust: number = omit * alt;
                                    result[t][r][c] = (<number>(result[t][r][c] + adjust)|0);
                                }
                            };}
                        }
                    };}
                };}
                n++;
            };}
            return result;
        }

        public getNormalizerMatrix(nSides: number): number[][] {
            if (nSides < PolygonField.MIN_SIDES){
                throw new java.lang.IllegalArgumentException("nSides = " + nSides + " but must be greater than or equal to " + PolygonField.MIN_SIDES);
            }
            const nSecondaryDiags: number = PolygonField.secondaryDiagonalCount(nSides);
            if (nSecondaryDiags === 0){
                return null;
            }
            const nPrimaryDiags: number = PolygonField.primaryDiagonalCount(nSides);
            const nDiags: number = nPrimaryDiags + nSecondaryDiags;
            const primeFactors: java.util.List<number> = this.distinctPrimeFactors(nSides);
            if (primeFactors.get(0) === 2){
                primeFactors.remove(0);
            }
            let nEquations: number = 0;
            for(let index=primeFactors.iterator();index.hasNext();) {
                let prime = index.next();
                {
                    nEquations += (nDiags / /* intValue */(prime|0)|0);
                }
            }
            const primaryDiags: com.vzome.core.algebra.BigRational[][] = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([nEquations, nPrimaryDiags]);
            const secondaryDiags: com.vzome.core.algebra.BigRational[][] = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([nEquations, nSecondaryDiags]);
            let equationRow: number = 0;
            for(let index=primeFactors.iterator();index.hasNext();) {
                let factor = index.next();
                {
                    const period: number = (nSides / factor|0);
                    const steps: number = (period / 2|0);
                    const parity: number = period % 2;
                    for(let step: number = 0; step < steps; step++) {{
                        let n: number = (step === 0 && parity === 0) ? 2 : 1;
                        if (nSides % 2 === parity){
                            n *= -1;
                        }
                        const terms: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(nDiags);
                        terms[step] = 1;
                        for(let mid: number = period - parity; mid < nDiags; mid += period) {{
                            terms[mid + step + parity] = terms[mid - step] = n;
                            n *= -1;
                        };}
                        primaryDiags[equationRow] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(nPrimaryDiags);
                        secondaryDiags[equationRow] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(nSecondaryDiags);
                        for(let t: number = 0; t < terms.length; t++) {{
                            let term: number = terms[t];
                            if (t < nSecondaryDiags){
                                secondaryDiags[equationRow][t] = this.numberFactory.createBigRational(term, 1);
                            } else {
                                term *= -1;
                                primaryDiags[equationRow][t - nSecondaryDiags] = this.numberFactory.createBigRational(term, 1);
                            }
                        };}
                        equationRow++;
                    };}
                }
            }
            const rank: number = com.vzome.core.algebra.Fields.gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A$com_vzome_core_algebra_Fields_Element_A_A(secondaryDiags, primaryDiags);
            if (rank !== nSecondaryDiags){
                throw new java.lang.IllegalStateException("System of equations has unexpected rank: " + rank);
            }
            for(let r: number = rank; r < primaryDiags.length; r++) {{
                for(let c: number = 0; c < primaryDiags[0].length; c++) {{
                    if (!primaryDiags[r][c].isZero()){
                        throw new java.lang.IllegalStateException("System of equations is inconsistent. Rank = " + rank);
                    }
                };}
            };}
            const results: number[][] = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return 0; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([rank, nPrimaryDiags]);
            for(let r: number = 0; r < rank; r++) {{
                for(let c: number = nPrimaryDiags - 1; c >= 0; c--) {{
                    const bigTerm: com.vzome.core.algebra.BigRational = primaryDiags[rank - 1 - r][nPrimaryDiags - 1 - c];
                    results[r][c] = /* shortValue */(javaemul.internal.DoubleHelper.valueOf(bigTerm.evaluate())|0);
                };}
            };}
            return results;
        }

        public static getExtendedMultiplicationTensor(nSides: number): number[][][] {
            const nDiags: number = PolygonField.diagonalCount(nSides);
            const tensor: number[][][] = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return 0; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([nDiags, nDiags, nDiags]);
            for(let i: number = 0; i < nDiags; i++) {{
                for(let j: number = 0; j < nDiags; j++) {{
                    for(let k: number = 0; k < nDiags; k++) {{
                        tensor[i][j][k] = 0;
                    };}
                };}
            };}
            for(let layer: number = 0; layer < nDiags; layer++) {{
                const midWay: number = (layer / 2|0);
                for(let bx: number = layer, by: number = 0; bx > midWay || bx === by; bx--, by++) {{
                    for(let x: number = bx, y: number = by; x < nDiags && y < nDiags; x++, y++) {{
                        tensor[layer][y][x] += 1;
                        if (x !== y){
                            tensor[layer][x][y] += 1;
                        }
                    };}
                };}
            };}
            const box: number = nSides - 2;
            const parity: number = (nSides + 1) % 2;
            for(let layer: number = 0; layer < nDiags - parity; layer++) {{
                const base: number = box - layer;
                for(let xb: number = base, yb: number = 0; xb >= 0; xb--, yb++) {{
                    let x: number = xb;
                    let y: number = yb;
                    while((x < nDiags && y < nDiags)) {{
                        tensor[layer][y][x] += 1;
                        x++;
                        y++;
                    }};
                };}
            };}
            return tensor;
        }

        public static subscriptString(i: number): string {
            return /* replace *//* replace *//* replace *//* replace *//* replace *//* replace *//* replace *//* replace *//* replace *//* replace *//* replace *//* replace *//* toString */(''+(i)).split("0").join("\u2080").split("1").join("\u2081").split("2").join("\u2082").split("3").join("\u2083").split("4").join("\u2084").split("5").join("\u2085").split("6").join("\u2086").split("7").join("\u2087").split("8").join("\u2088").split("9").join("\u2089").split("+").join("\u208a").split("-").join("\u208b");
        }

        public static MIN_SIDES: number = 4;

        /*private*/ __isEven: boolean;

        /*private*/ goldenRatio: com.vzome.core.algebra.AlgebraicNumber;

        /*private*/ __polygonSides: number;

        public constructor(name?: any, polygonSides?: any, factory?: any) {
            if (((typeof name === 'string') || name === null) && ((typeof polygonSides === 'number') || polygonSides === null) && ((factory != null && (factory.constructor != null && factory.constructor["__interfaces"] != null && factory.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumberFactory") >= 0)) || factory === null)) {
                let __args = arguments;
                super(name, PolygonField.getOrder(polygonSides), factory);
                if (this.__isEven === undefined) { this.__isEven = false; } 
                if (this.goldenRatio === undefined) { this.goldenRatio = null; } 
                if (this.__polygonSides === undefined) { this.__polygonSides = 0; } 
                if (this.normalizerMatrix === undefined) { this.normalizerMatrix = null; } 
                this.__polygonSides = polygonSides;
                this.validate();
                this.initialize();
                this.__isEven = polygonSides % 2 === 0;
                this.goldenRatio = this.getDiagonalRatio$int(5);
            } else if (((typeof name === 'number') || name === null) && ((polygonSides != null && (polygonSides.constructor != null && polygonSides.constructor["__interfaces"] != null && polygonSides.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumberFactory") >= 0)) || polygonSides === null) && factory === undefined) {
                let __args = arguments;
                let polygonSides: any = __args[0];
                let factory: any = __args[1];
                {
                    let __args = arguments;
                    let name: any = PolygonField.FIELD_PREFIX + __args[1];
                    super(name, PolygonField.getOrder(polygonSides), factory);
                    if (this.__isEven === undefined) { this.__isEven = false; } 
                    if (this.goldenRatio === undefined) { this.goldenRatio = null; } 
                    if (this.__polygonSides === undefined) { this.__polygonSides = 0; } 
                    if (this.normalizerMatrix === undefined) { this.normalizerMatrix = null; } 
                    this.__polygonSides = polygonSides;
                    this.validate();
                    this.initialize();
                    this.__isEven = polygonSides % 2 === 0;
                    this.goldenRatio = this.getDiagonalRatio$int(5);
                }
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * u = units numerator
         * U = units denominator
         * p = phis numerator
         * P = phis denominator
         * ____ = 0,1
         * COMBO ... see comments inline below
         * Remapping the 4 element pairs array [u,U, p,P]
         * looks like this based on polygonSides:
         * 5  [  u, U,   p, P] // unchanged
         * 10  [ COMBO,  ____,   p, P    ... // the two units elements combine all of the input pairs
         * 15  [  u, U,  -p,-P,   ____,   p, P    ...
         * 20  [  u, U,   ____,  -p,-P,   ____,   p, P    ...
         * 25  [  u, U,   ____,   ____,  -p,-P,   ____,   p, P    ...
         * 30  [  u, U,   ____,   ____,   ____,  -p,-P,   ____,   p, P    ...
         * 35  [  u, U,   ____,   ____,   ____,   ____,  -p,-P,   ____,   p, P    ...
         * 40  [  u, U,   ____,   ____,   ____,   ____,   ____,  -p,-P,   ____,   p, P    ...
         * 45  [  u, U,   ____,   ____,   ____,   ____,   ____,   ____,  -p,-P,   ____,   p, P    ...
         * index   0  1    2  3    4  5    6  7    8  9   10 11   12 13   14 15   16 17   18 19
         * @param {long[]} pairs
         * @return {long[]}
         */
        convertGoldenNumberPairs(pairs: number[]): number[] {
            if (this.__polygonSides % 5 === 0 && pairs.length === 4 && this.getOrder() > 2){
                const u: number = pairs[0];
                const U: number = pairs[1];
                const p: number = pairs[2];
                const P: number = pairs[3];
                const remapped: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(2 * this.getOrder());
                for(let den: number = 1; den < remapped.length; den += 2) {{
                    remapped[den] = 1;
                };}
                const i: number = ((this.__polygonSides / 5|0)) * 2;
                remapped[i - 4] = -p;
                remapped[i - 3] = P;
                remapped[i + 0] = p;
                remapped[i + 1] = P;
                if (this.__polygonSides === 10){
                    remapped[0] = PolygonField.safeSubtract((u * P), (U * p));
                    remapped[1] = U * P;
                } else {
                    remapped[0] = u;
                    remapped[1] = U;
                }
                return remapped;
            }
            return pairs;
        }

        /**
         * @param {number} j
         * @param {number} k
         * @return {number} a long that equals j - k
         * @throws ArithmeticException if the subtraction causes an integer overflow
         */
        static safeSubtract(j: number, k: number): number {
            const result: number = j - k;
            if ((k > 0 && result >= j) || (k < 0 && result <= j)){
                throw new java.lang.ArithmeticException("Arithmetic Overflow: " + j + " - " + k + " = " + result + ". Result exceeds the size of a long.");
            }
            return result;
        }

        public diagonalCount(): number {
            return PolygonField.diagonalCount(this.polygonSides());
        }

        /**
         * 
         * @return {double[]}
         */
        public getCoefficients(): number[] {
            return PolygonField.getFieldCoefficients(this.polygonSides());
        }

        /**
         * 
         * @return {*}
         */
        public getAffineScalar(): com.vzome.core.algebra.AlgebraicNumber {
            return this.getUnitDiagonal(2);
        }

        validate() {
            if (this.polygonSides() < PolygonField.MIN_SIDES){
                const msg: string = "polygon sides = " + this.polygonSides() + ". It must be at least " + PolygonField.MIN_SIDES + ".";
                throw new java.lang.IllegalArgumentException(msg);
            }
        }

        /**
         * 
         */
        initializeLabels() {
            const nSides: number = this.polygonSides();
            if (this.irrationalLabels.length !== PolygonField.diagonalCount(nSides)){
                const unitLabels: string[] = this.irrationalLabels[0];
                this.irrationalLabels = <any> (function(dims) { let allocate = function(dims) { if (dims.length === 0) { return null; } else { let array = []; for(let i = 0; i < dims[0]; i++) { array.push(allocate(dims.slice(1))); } return array; }}; return allocate(dims);})([PolygonField.diagonalCount(nSides), unitLabels.length]);
                this.irrationalLabels[0] = unitLabels;
            }
            switch((this.polygonSides())) {
            case 4:
                this.irrationalLabels[1] = ["\u221a2", "sqrtTwo"];
                break;
            case 5:
                this.irrationalLabels[1] = ["\u03c6", "phi"];
                break;
            case 6:
                this.irrationalLabels[1] = ["\u221a3", "sqrtThree"];
                this.irrationalLabels[2] = ["\u03b2", "beta"];
                break;
            case 7:
                this.irrationalLabels[1] = ["\u03c1", "rho"];
                this.irrationalLabels[2] = ["\u03c3", "sigma"];
                break;
            case 9:
                this.irrationalLabels[1] = ["\u03b1", "alpha"];
                this.irrationalLabels[2] = ["\u03b2", "beta"];
                this.irrationalLabels[3] = ["\u03b3", "gamma"];
                break;
            case 11:
                this.irrationalLabels[1] = ["\u03b8", "theta"];
                this.irrationalLabels[2] = ["\u03ba", "kappa"];
                this.irrationalLabels[3] = ["\u03bb", "lambda"];
                this.irrationalLabels[4] = ["\u03bc", "mu"];
                break;
            case 13:
                this.irrationalLabels[1] = ["\u03b1", "alpha"];
                this.irrationalLabels[2] = ["\u03b2", "beta"];
                this.irrationalLabels[3] = ["\u03b3", "gamma"];
                this.irrationalLabels[4] = ["\u03b4", "delta"];
                this.irrationalLabels[5] = ["\u03b5", "epsilon"];
                break;
            default:
                const alphabet: string = "abcdefghijklmnopqrstuvwxyz";
                const length: number = this.irrationalLabels.length;
                if (length - 1 <= alphabet.length){
                    for(let i: number = 1; i < length; i++) {{
                        const name: string = alphabet.substring(i - 1, i);
                        this.irrationalLabels[i] = [name, "d[" + i + "]"];
                    };}
                } else {
                    for(let i: number = 1; i < this.irrationalLabels.length; i++) {{
                        this.irrationalLabels[i] = ["d" + PolygonField.subscriptString(i), "d[" + i + "]"];
                    };}
                }
                break;
            }
        }

        /**
         * getUnitTerm(n) expects n < getOrder().
         * This method handles normalized diagonal lengths
         * where getOrder() <= n < diagonalCount()
         * In these cases, the resulting AlgebraicNumber will not have just the nth term set to 1,
         * but rather, will have the normalized equivalent.
         * For example, since a normalized PolygonField(6) is of order 2, but diagonalCount() == 3,
         * PolygonField(6).getUnitTerm(2) would return an AlgebraicNumber with terms of {2,0} rather than {0,0,1}.
         * @param {number} n
         * @return {*}
         */
        public getUnitDiagonal(n: number): com.vzome.core.algebra.AlgebraicNumber {
            if (n >= this.getOrder() && n < this.diagonalCount()){
                const terms: number[] = this.zero().toTrailingDivisor();
                const row: number = n - this.getOrder();
                for(let i: number = 0; i < this.getOrder(); i++) {{
                    const term: number = this.normalizerMatrix[row][i];
                    if (term !== 0){
                        terms[i] = term;
                    }
                };}
                return this.createAlgebraicNumberFromTD(terms);
            }
            return super.getUnitTerm(n);
        }

        /**
         * 
         * @return {*}
         */
        public getGoldenRatio(): com.vzome.core.algebra.AlgebraicNumber {
            return this.goldenRatio;
        }

        /**
         * 
         * @param {string} name
         * @return {*}
         */
        public getNumberByName(name: string): com.vzome.core.algebra.AlgebraicNumber {
            switch((name)) {
            case "\u221a2":
            case "root2":
            case "sqrt2":
                return this.getRoot2();
            case "\u221a3":
            case "root3":
            case "sqrt3":
                return this.getRoot3();
            case "\u221a5":
            case "root5":
            case "sqrt5":
                return super.getNumberByName("root5");
            case "\u221a6":
            case "root6":
            case "sqrt6":
                return this.getRoot6();
            case "\u221a7":
            case "root7":
            case "sqrt7":
                return this.getRoot7();
            case "\u221a8":
            case "root8":
            case "sqrt8":
                return super.getNumberByName("root8");
            case "\u221a10":
            case "root10":
            case "sqrt10":
                return this.getRoot10();
            case "rho":
                return this.getDiagonalRatio$int(7);
            case "sigma":
                return this.getDiagonalRatio$int$int(7, 3);
            case "alpha":
                return this.getDiagonalRatio$int$int((this.__polygonSides % 9 === 0 ? 9 : 13), 2);
            case "beta":
                return this.getDiagonalRatio$int$int((this.__polygonSides % 9 === 0 ? 9 : 13), 3);
            case "gamma":
                return this.getDiagonalRatio$int$int((this.__polygonSides % 9 === 0 ? 9 : 13), 4);
            case "delta":
                return this.getDiagonalRatio$int$int(13, 5);
            case "epsilon":
                return this.getDiagonalRatio$int$int(13, 6);
            case "theta":
                return this.getDiagonalRatio$int$int(11, 2);
            case "kappa":
                return this.getDiagonalRatio$int$int(11, 3);
            case "lambda":
                return this.getDiagonalRatio$int$int(11, 4);
            case "mu":
                return this.getDiagonalRatio$int$int(11, 5);
            }
            return super.getNumberByName(name);
        }

        /*private*/ getRoot2(): com.vzome.core.algebra.AlgebraicNumber {
            return this.getDiagonalRatio$int(4);
        }

        /*private*/ getRoot3(): com.vzome.core.algebra.AlgebraicNumber {
            return this.getDiagonalRatio$int(6);
        }

        /*private*/ getRoot6(): com.vzome.core.algebra.AlgebraicNumber {
            const r3: com.vzome.core.algebra.AlgebraicNumber = this.getNumberByName("root3");
            if (r3 != null){
                const r2: com.vzome.core.algebra.AlgebraicNumber = this.getNumberByName("root2");
                return r2 == null ? null : r2['times$com_vzome_core_algebra_AlgebraicNumber'](r3);
            }
            return null;
        }

        /*private*/ getRoot7(): com.vzome.core.algebra.AlgebraicNumber {
            if (this.__polygonSides % 14 === 0){
                const n: number = (this.__polygonSides / 14|0);
                const d0: com.vzome.core.algebra.AlgebraicNumber = this.getUnitDiagonal((1 * n) - 1).negate();
                const d1: com.vzome.core.algebra.AlgebraicNumber = this.getUnitDiagonal((2 * n) - 1);
                const d2: com.vzome.core.algebra.AlgebraicNumber = this.getUnitDiagonal((3 * n) - 1);
                const d3: com.vzome.core.algebra.AlgebraicNumber = this.getUnitDiagonal((4 * n) - 1);
                const d4: com.vzome.core.algebra.AlgebraicNumber = this.getUnitDiagonal((5 * n) - 1);
                const d5: com.vzome.core.algebra.AlgebraicNumber = this.getUnitDiagonal((6 * n) - 1);
                const cotA: com.vzome.core.algebra.AlgebraicNumber = d4.dividedBy(d1);
                const cotB: com.vzome.core.algebra.AlgebraicNumber = d2.dividedBy(d3);
                const cotC: com.vzome.core.algebra.AlgebraicNumber = d0.dividedBy(d5);
                return cotA['plus$com_vzome_core_algebra_AlgebraicNumber'](cotB)['plus$com_vzome_core_algebra_AlgebraicNumber'](cotC);
            }
            return null;
        }

        /*private*/ getRoot10(): com.vzome.core.algebra.AlgebraicNumber {
            const r5: com.vzome.core.algebra.AlgebraicNumber = this.getNumberByName("root5");
            if (r5 != null){
                const r2: com.vzome.core.algebra.AlgebraicNumber = this.getNumberByName("root2");
                return r2 == null ? null : r2['times$com_vzome_core_algebra_AlgebraicNumber'](r5);
            }
            return null;
        }

        /*private*/ getDiagonalRatio$int(divisor: number): com.vzome.core.algebra.AlgebraicNumber {
            return this.getDiagonalRatio$int$int(divisor, 2);
        }

        public getDiagonalRatio$int$int(divisor: number, step: number): com.vzome.core.algebra.AlgebraicNumber {
            if (this.__polygonSides % divisor === 0 && step > 1 && step * 2 <= this.__polygonSides){
                const n: number = (this.__polygonSides / divisor|0);
                const denominator: com.vzome.core.algebra.AlgebraicNumber = this.getUnitDiagonal(n - 1);
                const numerator: com.vzome.core.algebra.AlgebraicNumber = this.getUnitDiagonal((step * n) - 1);
                return numerator.dividedBy(denominator);
            }
            return null;
        }

        public getDiagonalRatio(divisor?: any, step?: any): com.vzome.core.algebra.AlgebraicNumber {
            if (((typeof divisor === 'number') || divisor === null) && ((typeof step === 'number') || step === null)) {
                return <any>this.getDiagonalRatio$int$int(divisor, step);
            } else if (((typeof divisor === 'number') || divisor === null) && step === undefined) {
                return <any>this.getDiagonalRatio$int(divisor);
            } else throw new Error('invalid overload');
        }

        /**
         * 
         */
        initializeCoefficients() {
            const temp: number[] = this.getCoefficients();
            for(let i: number = 0; i < this.coefficients.length; i++) {{
                this.coefficients[i] = temp[i];
            };}
        }

        /**
         * 
         */
        initializeMultiplicationTensor() {
            this.multiplicationTensor = this.getNormalizedMultiplicationTensor(this.polygonSides());
        }

        normalizerMatrix: number[][];

        /**
         * 
         */
        initializeNormalizer() {
            this.normalizerMatrix = this.getNormalizerMatrix(this.polygonSides());
        }

        public polygonSides(): number {
            return this.__polygonSides;
        }

        public isEven(): boolean {
            return this.__isEven;
        }

        public isOdd(): boolean {
            return !this.__isEven;
        }
    }
    PolygonField["__class"] = "com.vzome.core.algebra.PolygonField";
    PolygonField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];


}
namespace com.vzome.core.algebra {
    /**
     * @author David Hall
     * @param {*} factory
     * @class
     * @extends com.vzome.core.algebra.ParameterizedField
     */
    export class SnubDodecahedronField extends com.vzome.core.algebra.ParameterizedField {
        public static FIELD_NAME: string = "snubDodecahedron";

        /**
         * 
         * @return {double[]} the coefficients of this AlgebraicField class.
         * This can be used to determine when two fields have compatible coefficients
         * without having to generate an instance of the class.
         */
        public static getFieldCoefficients(): number[] {
            const PHI_VALUE: number = (1.0 + Math.sqrt(5.0)) / 2.0;
            const XI_VALUE: number = 1.7155614996973678;
            return [1.0, PHI_VALUE, XI_VALUE, PHI_VALUE * XI_VALUE, XI_VALUE * XI_VALUE, PHI_VALUE * XI_VALUE * XI_VALUE];
        }

        /**
         * 
         * @return {double[]}
         */
        public getCoefficients(): number[] {
            return SnubDodecahedronField.getFieldCoefficients();
        }

        public constructor(factory: com.vzome.core.algebra.AlgebraicNumberFactory) {
            super(SnubDodecahedronField.FIELD_NAME, 6, factory);
            this.initialize();
        }

        /**
         * 
         */
        initializeCoefficients() {
            const temp: number[] = this.getCoefficients();
            let i: number = 0;
            for(let index = 0; index < temp.length; index++) {
                let coefficient = temp[index];
                {
                    this.coefficients[i++] = coefficient;
                }
            }
        }

        /**
         * 
         */
        initializeMultiplicationTensor() {
            const mm: number[][][] = [[[1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0]], [[0, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 2], [0, 0, 1, 1, 0, 0], [0, 0, 1, 2, 0, 0]], [[0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 2, 0], [0, 1, 0, 0, 0, 2], [0, 0, 2, 0, 0, 1], [0, 0, 0, 2, 1, 1]], [[0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 0, 2], [1, 1, 0, 0, 2, 2], [0, 0, 0, 2, 1, 1], [0, 0, 2, 2, 1, 2]], [[0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 2, 0], [0, 1, 0, 0, 0, 2]], [[0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 0, 2], [1, 1, 0, 0, 2, 2]]];
            this.multiplicationTensor = mm;
        }

        /**
         * 
         */
        initializeLabels() {
            this.irrationalLabels[1] = ["\u03c6", "phi"];
            this.irrationalLabels[2] = ["\u03be", "xi"];
            this.irrationalLabels[3] = ["\u03c6\u03be", "phi*xi"];
            this.irrationalLabels[4] = ["\u03be\u00b2", "xi^2"];
            this.irrationalLabels[5] = ["\u03c6\u03be\u00b2", "phi*xi^2"];
        }

        /**
         * 
         * @return {number}
         */
        public getNumMultipliers(): number {
            return 2;
        }

        /**
         * scalar for an affine pentagon
         * @return {*}
         */
        public getAffineScalar(): com.vzome.core.algebra.AlgebraicNumber {
            return this.getGoldenRatio();
        }

        /**
         * 
         * @return {*}
         */
        public getGoldenRatio(): com.vzome.core.algebra.AlgebraicNumber {
            return this.getUnitTerm(1);
        }
    }
    SnubDodecahedronField["__class"] = "com.vzome.core.algebra.SnubDodecahedronField";
    SnubDodecahedronField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];


}
namespace com.vzome.core.algebra {
    /**
     * @author David Hall
     * @param {*} factory
     * @class
     * @extends com.vzome.core.algebra.ParameterizedField
     */
    export class SnubCubeField extends com.vzome.core.algebra.ParameterizedField {
        public static FIELD_NAME: string = "snubCube";

        /**
         * 
         * @param radicand
         * @return {double[]} the coefficients of a SnubCubeField.
         * This can be used to determine when two fields have compatible coefficients
         * without having to generate an instance of the class.
         */
        public static getFieldCoefficients(): number[] {
            const tribonacciConstant: number = (1.0 + /* cbrt */Math.pow(19.0 - (3.0 * Math.sqrt(33)), 1/3) + /* cbrt */Math.pow(19.0 + (3.0 * Math.sqrt(33)), 1/3)) / 3.0;
            return [1.0, tribonacciConstant, tribonacciConstant * tribonacciConstant];
        }

        /**
         * 
         * @return {double[]}
         */
        public getCoefficients(): number[] {
            return SnubCubeField.getFieldCoefficients();
        }

        public constructor(factory: com.vzome.core.algebra.AlgebraicNumberFactory) {
            super(SnubCubeField.FIELD_NAME, 3, factory);
            this.initialize();
        }

        /**
         * 
         */
        initializeCoefficients() {
            const temp: number[] = this.getCoefficients();
            let i: number = 0;
            for(let index = 0; index < temp.length; index++) {
                let coefficient = temp[index];
                {
                    this.coefficients[i++] = coefficient;
                }
            }
        }

        /**
         * 
         */
        initializeMultiplicationTensor() {
            const mm: number[][][] = [[[1, 0, 0], [0, 0, 1], [0, 1, 1]], [[0, 1, 0], [1, 0, 1], [0, 1, 2]], [[0, 0, 1], [0, 1, 1], [1, 1, 2]]];
            this.multiplicationTensor = mm;
        }

        /**
         * 
         */
        initializeLabels() {
            this.irrationalLabels[1] = ["\u03c8", "psi"];
            this.irrationalLabels[2] = ["\u03c8\u00b2", "psi^2"];
        }

        /**
         * 
         * @return {number}
         */
        public getNumMultipliers(): number {
            return 1;
        }
    }
    SnubCubeField["__class"] = "com.vzome.core.algebra.SnubCubeField";
    SnubCubeField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];


}
namespace com.vzome.core.algebra {
    export class PlasticPhiField extends com.vzome.core.algebra.ParameterizedField {
        public static FIELD_NAME: string = "plasticPhi";

        /**
         * @return {double[]} the coefficients of a PlasticPhiField.
         * This can be used to determine when two fields have compatible coefficients
         * without having to generate an instance of the class.
         */
        public static getFieldCoefficients(): number[] {
            const plasticNumber: number = 1.32471795724475;
            const phi: number = (1.0 + Math.sqrt(5)) / 2.0;
            return [1.0, phi, plasticNumber, plasticNumber * phi, plasticNumber * plasticNumber, plasticNumber * plasticNumber * phi];
        }

        /**
         * 
         * @return {number}
         */
        public getNumMultipliers(): number {
            return 2;
        }

        /**
         * 
         * @return {double[]}
         */
        public getCoefficients(): number[] {
            return PlasticPhiField.getFieldCoefficients();
        }

        public constructor(factory: com.vzome.core.algebra.AlgebraicNumberFactory) {
            super(PlasticPhiField.FIELD_NAME, 6, factory);
            this.initialize();
        }

        /**
         * 
         */
        initializeCoefficients() {
            const temp: number[] = this.getCoefficients();
            let i: number = 0;
            for(let index = 0; index < temp.length; index++) {
                let coefficient = temp[index];
                {
                    this.coefficients[i++] = coefficient;
                }
            }
        }

        /**
         * 
         */
        initializeMultiplicationTensor() {
            const tensor: number[][][] = [[[1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0]], [[0, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0]], [[0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 1], [0, 0, 1, 0, 1, 0], [0, 0, 0, 1, 0, 1]], [[0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 0, 1], [1, 1, 0, 0, 1, 1], [0, 0, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1]], [[0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 1]], [[0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 0, 1], [1, 1, 0, 0, 1, 1]]];
            this.multiplicationTensor = tensor;
        }

        /**
         * 
         */
        initializeLabels() {
            const upperRho: string = "\u03a1";
            const lowerPhi: string = "\u03c6";
            this.irrationalLabels[1] = [lowerPhi, "phi"];
            this.irrationalLabels[2] = [upperRho, "P"];
            this.irrationalLabels[3] = [upperRho + "\u03c6", "Pphi"];
            this.irrationalLabels[4] = [upperRho + "\u00b2", "P^2"];
            this.irrationalLabels[5] = [upperRho + "\u00b2\u03c6", "P^2phi"];
        }

        /**
         * 
         * @return {*}
         */
        public getGoldenRatio(): com.vzome.core.algebra.AlgebraicNumber {
            return this.getUnitTerm(1);
        }
    }
    PlasticPhiField["__class"] = "com.vzome.core.algebra.PlasticPhiField";
    PlasticPhiField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];


}
namespace com.vzome.core.algebra {
    export class EdPeggField extends com.vzome.core.algebra.ParameterizedField {
        public static FIELD_NAME: string = "edPegg";

        /**
         * 
         * @return {double[]} the coefficients of an EdPeggField.
         * This can be used to determine when two fields have compatible coefficients
         * without having to generate an instance of the class.
         */
        public static getFieldCoefficients(): number[] {
            const a: number = 1.76929235423863;
            return [1.0, a, a * a];
        }

        /**
         * 
         * @return {number}
         */
        public getNumMultipliers(): number {
            return 1;
        }

        /**
         * 
         * @return {double[]}
         */
        public getCoefficients(): number[] {
            return EdPeggField.getFieldCoefficients();
        }

        public constructor(factory: com.vzome.core.algebra.AlgebraicNumberFactory) {
            super(EdPeggField.FIELD_NAME, 3, factory);
            this.initialize();
        }

        /**
         * 
         */
        initializeCoefficients() {
            const temp: number[] = this.getCoefficients();
            let i: number = 0;
            for(let index = 0; index < temp.length; index++) {
                let coefficient = temp[index];
                {
                    this.coefficients[i++] = coefficient;
                }
            }
        }

        /**
         * 
         */
        initializeMultiplicationTensor() {
            const mt: number[][][] = [[[1, 0, 0], [0, 0, 2], [0, 2, 0]], [[0, 1, 0], [1, 0, 2], [0, 2, 2]], [[0, 0, 1], [0, 1, 0], [1, 0, 2]]];
            this.multiplicationTensor = mt;
        }

        /**
         * 
         */
        initializeLabels() {
            this.irrationalLabels[1] = ["\u03b5", "epsilon"];
            this.irrationalLabels[2] = ["\u03b5\u00b2", "epsilon^2"];
        }
    }
    EdPeggField["__class"] = "com.vzome.core.algebra.EdPeggField";
    EdPeggField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];


}
namespace com.vzome.core.algebra {
    export class SuperGoldenField extends com.vzome.core.algebra.ParameterizedField {
        public static FIELD_NAME: string = "superGolden";

        /**
         * 
         * @return {double[]} the coefficients of a SuperGoldenField.
         * This can be used to determine when two fields have compatible coefficients
         * without having to generate an instance of the class.
         */
        public static getFieldCoefficients(): number[] {
            const narayanaCowNumber: number = 1.465571231876768;
            return [1.0, narayanaCowNumber, narayanaCowNumber * narayanaCowNumber];
        }

        /**
         * 
         * @return {number}
         */
        public getNumMultipliers(): number {
            return 1;
        }

        /**
         * 
         * @return {double[]}
         */
        public getCoefficients(): number[] {
            return SuperGoldenField.getFieldCoefficients();
        }

        public constructor(factory: com.vzome.core.algebra.AlgebraicNumberFactory) {
            super(SuperGoldenField.FIELD_NAME, 3, factory);
            this.initialize();
        }

        /**
         * 
         */
        initializeCoefficients() {
            const temp: number[] = this.getCoefficients();
            let i: number = 0;
            for(let index = 0; index < temp.length; index++) {
                let coefficient = temp[index];
                {
                    this.coefficients[i++] = coefficient;
                }
            }
        }

        /**
         * 
         */
        initializeMultiplicationTensor() {
            const mt: number[][][] = [[[1, 0, 0], [0, 0, 1], [0, 1, 1]], [[0, 1, 0], [1, 0, 0], [0, 0, 1]], [[0, 0, 1], [0, 1, 1], [1, 1, 1]]];
            this.multiplicationTensor = mt;
        }

        /**
         * 
         */
        initializeLabels() {
            this.irrationalLabels[1] = ["\u03c8", "psi"];
            this.irrationalLabels[2] = ["\u03c8\u00b2", "psi^2"];
        }
    }
    SuperGoldenField["__class"] = "com.vzome.core.algebra.SuperGoldenField";
    SuperGoldenField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];


}
namespace com.vzome.core.algebra {
    /**
     * @author David Hall
     * @param {*} factory
     * @class
     * @extends com.vzome.core.algebra.ParameterizedField
     */
    export class PlasticNumberField extends com.vzome.core.algebra.ParameterizedField {
        public static FIELD_NAME: string = "plasticNumber";

        /**
         * 
         * @return {double[]} the coefficients of a PlasticNumberField.
         * This can be used to determine when two fields have compatible coefficients
         * without having to generate an instance of the class.
         */
        public static getFieldCoefficients(): number[] {
            const plasticNumber: number = 1.32471795724475;
            return [1.0, plasticNumber, plasticNumber * plasticNumber];
        }

        /**
         * 
         * @return {number}
         */
        public getNumMultipliers(): number {
            return 1;
        }

        /**
         * 
         * @return {double[]}
         */
        public getCoefficients(): number[] {
            return PlasticNumberField.getFieldCoefficients();
        }

        public constructor(factory: com.vzome.core.algebra.AlgebraicNumberFactory) {
            super(PlasticNumberField.FIELD_NAME, 3, factory);
            this.initialize();
        }

        /**
         * 
         */
        initializeCoefficients() {
            const temp: number[] = this.getCoefficients();
            let i: number = 0;
            for(let index = 0; index < temp.length; index++) {
                let coefficient = temp[index];
                {
                    this.coefficients[i++] = coefficient;
                }
            }
        }

        /**
         * 
         */
        initializeMultiplicationTensor() {
            const tensor: number[][][] = [[[1, 0, 0], [0, 0, 1], [0, 1, 0]], [[0, 1, 0], [1, 0, 1], [0, 1, 1]], [[0, 0, 1], [0, 1, 0], [1, 0, 1]]];
            this.multiplicationTensor = tensor;
        }

        /**
         * 
         */
        initializeLabels() {
            const upperRho: string = "\u03a1";
            this.irrationalLabels[1] = [upperRho, "P"];
            this.irrationalLabels[2] = [upperRho + "\u00b2", "P^2"];
        }
    }
    PlasticNumberField["__class"] = "com.vzome.core.algebra.PlasticNumberField";
    PlasticNumberField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];


}
namespace com.vzome.fields.sqrtphi {
    /**
     * @author David Hall
     * @param {*} factory
     * @class
     * @extends com.vzome.core.algebra.ParameterizedField
     */
    export class SqrtPhiField extends com.vzome.core.algebra.ParameterizedField {
        public static FIELD_NAME: string = "sqrtPhi";

        public static PHI_VALUE: number; public static PHI_VALUE_$LI$(): number { if (SqrtPhiField.PHI_VALUE == null) { SqrtPhiField.PHI_VALUE = (1.0 + Math.sqrt(5.0)) / 2.0; }  return SqrtPhiField.PHI_VALUE; }

        public static SQRT_PHI_VALUE: number; public static SQRT_PHI_VALUE_$LI$(): number { if (SqrtPhiField.SQRT_PHI_VALUE == null) { SqrtPhiField.SQRT_PHI_VALUE = Math.sqrt(SqrtPhiField.PHI_VALUE_$LI$()); }  return SqrtPhiField.SQRT_PHI_VALUE; }

        /**
         * 
         * @return {double[]} the coefficients of a SqrtPhiField.
         * This can be used to determine when two fields have compatible coefficients
         * without having to generate an instance of the class.
         */
        public static getFieldCoefficients(): number[] {
            return [1.0, SqrtPhiField.SQRT_PHI_VALUE_$LI$(), SqrtPhiField.PHI_VALUE_$LI$(), SqrtPhiField.PHI_VALUE_$LI$() * SqrtPhiField.SQRT_PHI_VALUE_$LI$()];
        }

        /**
         * 
         * @return {number}
         */
        public getNumMultipliers(): number {
            return 1;
        }

        /**
         * 
         * @return {double[]}
         */
        public getCoefficients(): number[] {
            return SqrtPhiField.getFieldCoefficients();
        }

        public constructor(factory: com.vzome.core.algebra.AlgebraicNumberFactory) {
            super(SqrtPhiField.FIELD_NAME, 4, factory);
            this.initialize();
        }

        /**
         * 
         */
        initializeCoefficients() {
            const temp: number[] = this.getCoefficients();
            let i: number = 0;
            for(let index = 0; index < temp.length; index++) {
                let coefficient = temp[index];
                {
                    this.coefficients[i++] = coefficient;
                }
            }
        }

        /**
         * 
         */
        initializeMultiplicationTensor() {
            const tensor: number[][][] = [[[1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 1]], [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], [[0, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 2]], [[0, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]];
            this.multiplicationTensor = tensor;
        }

        /**
         * 
         */
        initializeLabels() {
            this.irrationalLabels[1] = ["\u221a\u03c6", "sqrt(phi)"];
            this.irrationalLabels[2] = ["\u03c6", "phi"];
            this.irrationalLabels[3] = ["\u03c6\u221a\u03c6", "phi*sqrt(phi)"];
        }

        /**
         * 
         * @param {long[]} pairs
         * @return {long[]}
         */
        convertGoldenNumberPairs(pairs: number[]): number[] {
            return (pairs.length === 4) ? [pairs[0], pairs[1], 0, 1, pairs[2], pairs[3], 0, 1] : pairs;
        }

        /**
         * 
         * @return {*}
         */
        public getGoldenRatio(): com.vzome.core.algebra.AlgebraicNumber {
            return this.getUnitTerm(2);
        }
    }
    SqrtPhiField["__class"] = "com.vzome.fields.sqrtphi.SqrtPhiField";
    SqrtPhiField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];


}
namespace com.vzome.core.commands {
    export class CommandVanOss600Cell extends com.vzome.core.commands.CommandImportVEFData {
        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attributes: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            try {
                const input: java.io.InputStream = (<any>this.constructor).getClassLoader().getResourceAsStream("com/vzome/core/commands/600cell.vef");
                const out: java.io.ByteArrayOutputStream = new java.io.ByteArrayOutputStream();
                const buf: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(1024);
                let num: number;
                while(((num = input.read(buf, 0, 1024)) > 0)) {out.write(buf, 0, num)};
                const vefData: string = <string>new String(out.toByteArray());
                const result: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
                let field: com.vzome.core.algebra.AlgebraicField = <com.vzome.core.algebra.AlgebraicField><any>attributes.get(com.vzome.core.commands.CommandImportVEFData.FIELD_ATTR_NAME);
                if (field == null)field = <com.vzome.core.algebra.AlgebraicField><any>attributes.get(com.vzome.core.commands.Command.FIELD_ATTR_NAME);
                new CommandVanOss600Cell.VefToModel(this, null, effects).parseVEF(vefData, field);
                return result;
            } catch(exc) {
                throw new com.vzome.core.commands.Command.Failure(exc);
            }
        }

        constructor() {
            super();
        }
    }
    CommandVanOss600Cell["__class"] = "com.vzome.core.commands.CommandVanOss600Cell";
    CommandVanOss600Cell["__interfaces"] = ["com.vzome.core.commands.Command"];



    export namespace CommandVanOss600Cell {

        export class VefToModel extends com.vzome.core.math.VefParser {
            public __parent: any;
            mProjection: com.vzome.core.math.QuaternionProjection;

            mVertices: com.vzome.core.construction.Point[];

            mEffects: com.vzome.core.construction.ConstructionChanges;

            mLocations: com.vzome.core.algebra.AlgebraicVector[];

            public constructor(__parent: any, quaternion: com.vzome.core.algebra.Quaternion, effects: com.vzome.core.construction.ConstructionChanges) {
                super();
                this.__parent = __parent;
                if (this.mProjection === undefined) { this.mProjection = null; }
                if (this.mVertices === undefined) { this.mVertices = null; }
                if (this.mEffects === undefined) { this.mEffects = null; }
                if (this.mLocations === undefined) { this.mLocations = null; }
                this.mEffects = effects;
            }

            /**
             * 
             * @param {number} numVertices
             */
            startVertices(numVertices: number) {
                this.mVertices = (s => { let a=[]; while(s-->0) a.push(null); return a; })(numVertices);
                this.mLocations = (s => { let a=[]; while(s-->0) a.push(null); return a; })(numVertices);
                this.mProjection = null;
            }

            /**
             * 
             * @param {number} index
             * @param {com.vzome.core.algebra.AlgebraicVector} location
             */
            addVertex(index: number, location: com.vzome.core.algebra.AlgebraicVector) {
                this.mLocations[index] = location;
            }

            /**
             * 
             */
            endVertices() {
                const field: com.vzome.core.algebra.AlgebraicField = this.getField();
                const half: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long$long'](1, 2);
                const quarter: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long$long'](1, 4);
                const centroid: com.vzome.core.algebra.AlgebraicVector = this.mLocations[0].plus(this.mLocations[48]).plus(this.mLocations[50]).plus(this.mLocations[64]).scale(quarter);
                const edgeCenter: com.vzome.core.algebra.AlgebraicVector = this.mLocations[0].plus(this.mLocations[48]).scale(half);
                const vertex: com.vzome.core.algebra.AlgebraicVector = this.mLocations[50];
                const edgeToVertex: com.vzome.core.algebra.AlgebraicVector = vertex.minus(edgeCenter);
                const edgeToCenter: com.vzome.core.algebra.AlgebraicVector = centroid.minus(edgeCenter);
                const symmCenter1: com.vzome.core.algebra.AlgebraicVector = edgeCenter.plus(edgeToCenter.scale(field['createAlgebraicNumber$int$int$int$int'](0, 3, 5, 0)));
                const symmCenter2: com.vzome.core.algebra.AlgebraicVector = edgeCenter.plus(edgeToVertex.scale(field['createAlgebraicNumber$int$int$int$int'](0, 2, 5, 0)));
                const direction: com.vzome.core.algebra.AlgebraicVector = symmCenter2.minus(symmCenter1);
                const target: com.vzome.core.algebra.AlgebraicVector = symmCenter1.plus(direction.scale(field['createAlgebraicNumber$int$int$int$int'](0, 1, 1, 0)));
                this.mProjection = new com.vzome.core.math.QuaternionProjection(field, null, target);
                const power5: com.vzome.core.algebra.AlgebraicNumber = field['createPower$int'](5);
                for(let i: number = 0; i < this.mLocations.length; i++) {{
                    let location: com.vzome.core.algebra.AlgebraicVector = this.mLocations[i].scale(power5);
                    location = this.mProjection.projectImage(location, this.wFirst());
                    this.mVertices[i] = new com.vzome.core.construction.FreePoint(location);
                    this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](this.mVertices[i]);
                };}
            }

            /**
             * 
             * @param {number} index
             * @param {number} v1
             * @param {number} v2
             */
            addEdge(index: number, v1: number, v2: number) {
                const p1: com.vzome.core.construction.Point = this.mVertices[v1];
                const p2: com.vzome.core.construction.Point = this.mVertices[v2];
                if (p1 == null || p2 == null){
                    console.info("skipping " + v1 + " " + v2);
                    return;
                }
                const seg: com.vzome.core.construction.Segment = new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](seg);
            }

            /**
             * 
             * @param {number} numEdges
             */
            startEdges(numEdges: number) {
            }

            /**
             * 
             * @param {number} numFaces
             */
            startFaces(numFaces: number) {
            }

            /**
             * 
             * @param {number} index
             * @param {int[]} verts
             */
            addFace(index: number, verts: number[]) {
            }

            /**
             * 
             * @param {number} index
             * @param {number} vertex
             */
            addBall(index: number, vertex: number) {
            }

            /**
             * 
             * @param {number} numVertices
             */
            startBalls(numVertices: number) {
            }
        }
        VefToModel["__class"] = "com.vzome.core.commands.CommandVanOss600Cell.VefToModel";

    }

}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @param {*} field
     * @param {com.vzome.core.math.symmetry.QuaternionicSymmetry} qsymm
     * @param {number} index
     * @class
     * @extends com.vzome.core.commands.CommandTransform
     */
    export class CommandUniformH4Polytope extends com.vzome.core.commands.CommandTransform {
        /**
         * 
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        public setFixedAttributes(attributes: com.vzome.core.commands.AttributeMap, format: com.vzome.core.commands.XmlSaveFormat) {
            super.setFixedAttributes(attributes, format);
            this.field = format.getField();
            this.symm = this.h4Symms.get(this.field.getName());
            if (this.symm == null){
                this.symm = new CommandUniformH4Polytope.H4Symmetry(this.field);
                this.h4Symms.put(this.field.getName(), this.symm);
            }
            this.mRoots = (<com.vzome.core.commands.XmlSymmetryFormat>format).getQuaternionicSymmetry("H_4").getRoots();
        }

        /*private*/ h4Symms: java.util.Map<string, CommandUniformH4Polytope.H4Symmetry>;

        public static POLYTOPE_INDEX_ATTR_NAME: string = "polytope.index";

        /*private*/ mRoots: com.vzome.core.algebra.Quaternion[];

        /*private*/ mPolytopeIndex: number;

        static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (CommandUniformH4Polytope.logger == null) { CommandUniformH4Polytope.logger = java.util.logging.Logger.getLogger("com.vzome.core.commands.h4polytope"); }  return CommandUniformH4Polytope.logger; }

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        /*private*/ symm: CommandUniformH4Polytope.H4Symmetry;

        public constructor(field?: any, qsymm?: any, index?: any) {
            if (((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((qsymm != null && qsymm instanceof <any>com.vzome.core.math.symmetry.QuaternionicSymmetry) || qsymm === null) && ((typeof index === 'number') || index === null)) {
                let __args = arguments;
                super();
                if (this.mRoots === undefined) { this.mRoots = null; } 
                if (this.field === undefined) { this.field = null; } 
                if (this.symm === undefined) { this.symm = null; } 
                this.h4Symms = <any>(new java.util.HashMap<any, any>());
                this.mPolytopeIndex = -1;
                this.quaternionVector = null;
                this.mPolytopeIndex = index;
                this.field = field;
                this.symm = new CommandUniformH4Polytope.H4Symmetry(field);
                this.mRoots = qsymm.getRoots();
            } else if (field === undefined && qsymm === undefined && index === undefined) {
                let __args = arguments;
                super();
                if (this.mRoots === undefined) { this.mRoots = null; } 
                if (this.field === undefined) { this.field = null; } 
                if (this.symm === undefined) { this.symm = null; } 
                this.h4Symms = <any>(new java.util.HashMap<any, any>());
                this.mPolytopeIndex = -1;
                this.quaternionVector = null;
            } else throw new Error('invalid overload');
        }

        /*private*/ quaternionVector: com.vzome.core.algebra.AlgebraicVector;

        /**
         * Only called when migrating a 2.0 model file.
         * @param {com.vzome.core.algebra.AlgebraicVector} offset
         */
        public setQuaternion(offset: com.vzome.core.algebra.AlgebraicVector) {
            this.quaternionVector = offset;
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         * @return {com.vzome.core.commands.AttributeMap}
         */
        public setXml(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat): com.vzome.core.commands.AttributeMap {
            const attrs: com.vzome.core.commands.AttributeMap = super.setXml(xml, format);
            this.quaternionVector = format.parseRationalVector(xml, "quaternion");
            return attrs;
        }

        /**
         * 
         * @param {*} result
         * @param {com.vzome.core.commands.AttributeMap} attributes
         */
        public getXml(result: org.w3c.dom.Element, attributes: com.vzome.core.commands.AttributeMap) {
            if (this.quaternionVector != null)com.vzome.xml.DomUtils.addAttribute(result, "quaternion", this.quaternionVector.toParsableString());
            super.getXml(result, attributes);
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return com.vzome.core.commands.CommandTransform.GROUP_ATTR_SIGNATURE_$LI$();
        }

        /**
         * 
         * @param {string} attrName
         * @return {boolean}
         */
        public attributeIs3D(attrName: string): boolean {
            if ("symmetry.axis.segment" === attrName)return false; else return true;
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attributes: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const SCALE_DOWN_5: com.vzome.core.algebra.AlgebraicNumber = this.field['createPower$int'](-5);
            let proj: com.vzome.core.math.Projection = new com.vzome.core.math.Projection.Default(this.field);
            let leftQuat: com.vzome.core.algebra.AlgebraicVector = null;
            let rightQuat: com.vzome.core.algebra.AlgebraicVector = null;
            if (parameters.size() === 0){
                rightQuat = this.quaternionVector;
                const symmAxis: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME);
                if (rightQuat == null)rightQuat = (symmAxis == null) ? null : symmAxis.getOffset();
                if (rightQuat != null)rightQuat = rightQuat.scale(SCALE_DOWN_5);
            } else {
                let numSegs: number = 0;
                for(let index=parameters.iterator();index.hasNext();) {
                    let cons = index.next();
                    {
                        if (cons != null && cons instanceof <any>com.vzome.core.construction.Segment){
                            const seg: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>cons;
                            if (++numSegs === 1)rightQuat = seg.getOffset().scale(SCALE_DOWN_5); else if (numSegs === 2)leftQuat = seg.getOffset().scale(SCALE_DOWN_5); else throw new com.vzome.core.commands.Command.Failure("Too many struts to specify quaternion multiplication.");
                        }
                    }
                }
            }
            if (rightQuat != null)proj = new com.vzome.core.math.QuaternionProjection(this.field, leftQuat, rightQuat);
            if (this.mPolytopeIndex < 0){
                const indexObj: number = <number>attributes.get(CommandUniformH4Polytope.POLYTOPE_INDEX_ATTR_NAME);
                this.mPolytopeIndex = indexObj;
            } else attributes.put(CommandUniformH4Polytope.POLYTOPE_INDEX_ATTR_NAME, this.mPolytopeIndex);
            this.generate(this.mPolytopeIndex, this.mPolytopeIndex, null, new CommandUniformH4Polytope.ConstructionChangesAdapter(effects, proj, this.field['createPower$int'](5)));
            return new com.vzome.core.construction.ConstructionList();
        }

        public generate(index: number, renderEdges: number, edgeScales: com.vzome.core.algebra.AlgebraicNumber[], listener: com.vzome.core.math.symmetry.WythoffConstruction.Listener) {
            const reflections: com.vzome.core.algebra.AlgebraicVector[] = [null, null, null, null];
            let prototype: com.vzome.core.algebra.AlgebraicVector = this.symm.getPrototype(index);
            if (edgeScales != null){
                prototype = this.field.origin(4);
                for(let b: number = 0; b < 4; b++) {{
                    const mask: number = 1 << b;
                    const test: number = index & mask;
                    if (test !== 0){
                        const contribution: com.vzome.core.algebra.AlgebraicVector = this.symm.getCoRoot(b).scale(edgeScales[b]);
                        prototype = prototype.plus(contribution);
                    }
                };}
            }
            for(let mirror: number = 0; mirror < 4; mirror++) {if ((renderEdges & (1 << mirror)) !== 0)reflections[mirror] = this.symm.reflect(mirror, prototype);;}
            for(let index1 = 0; index1 < this.mRoots.length; index1++) {
                let outerRoot = this.mRoots[index1];
                {
                    for(let index2 = 0; index2 < this.mRoots.length; index2++) {
                        let innerRoot = this.mRoots[index2];
                        {
                            let vertex: com.vzome.core.algebra.AlgebraicVector = outerRoot.rightMultiply(prototype);
                            vertex = innerRoot.leftMultiply(vertex);
                            const p1: any = listener.addVertex(vertex);
                            for(let mirror: number = 0; mirror < 4; mirror++) {{
                                if (reflections[mirror] != null){
                                    let other: com.vzome.core.algebra.AlgebraicVector = outerRoot.rightMultiply(reflections[mirror]);
                                    other = innerRoot.leftMultiply(other);
                                    if (!other.equals(vertex)){
                                        const p2: any = listener.addVertex(other);
                                        listener.addEdge(p1, p2);
                                    }
                                }
                            };}
                        }
                    }
                }
            }
        }
    }
    CommandUniformH4Polytope["__class"] = "com.vzome.core.commands.CommandUniformH4Polytope";
    CommandUniformH4Polytope["__interfaces"] = ["com.vzome.core.commands.Command"];



    export namespace CommandUniformH4Polytope {

        export class H4Symmetry {
            mPrototypes: com.vzome.core.algebra.AlgebraicVector[];

            mMirrors: com.vzome.core.algebra.Quaternion[];

            coRoots: com.vzome.core.algebra.AlgebraicVector[];

            public constructor(field: com.vzome.core.algebra.AlgebraicField) {
                this.mPrototypes = (s => { let a=[]; while(s-->0) a.push(null); return a; })(15);
                this.mMirrors = [null, null, null, null];
                this.coRoots = [null, null, null, null];
                const ONE: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long'](1);
                const NEG_ONE: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long'](-1);
                const TWO: com.vzome.core.algebra.AlgebraicNumber = field['createRational$long'](2);
                const A: com.vzome.core.algebra.AlgebraicNumber = field['createAlgebraicNumber$int$int$int$int'](1, -1, 1, 0);
                const B: com.vzome.core.algebra.AlgebraicNumber = field['createAlgebraicNumber$int$int$int$int'](0, 1, 1, 0);
                let temp: com.vzome.core.algebra.AlgebraicVector = field.origin(4);
                temp.setComponent(1, A.dividedBy(TWO));
                temp.setComponent(2, ONE.dividedBy(TWO));
                temp.setComponent(3, B.dividedBy(TWO));
                this.mMirrors[3] = new com.vzome.core.algebra.Quaternion(field, temp);
                temp = field.origin(4);
                temp.setComponent(3, NEG_ONE);
                this.mMirrors[2] = new com.vzome.core.algebra.Quaternion(field, temp);
                temp = field.origin(4);
                temp.setComponent(1, ONE.dividedBy(TWO));
                temp.setComponent(2, NEG_ONE.dividedBy(TWO));
                temp.setComponent(3, ONE.dividedBy(TWO));
                temp.setComponent(0, NEG_ONE.dividedBy(TWO));
                this.mMirrors[1] = new com.vzome.core.algebra.Quaternion(field, temp);
                temp = field.origin(4);
                temp.setComponent(0, ONE);
                this.mMirrors[0] = new com.vzome.core.algebra.Quaternion(field, temp);
                const B2: com.vzome.core.algebra.AlgebraicNumber = field['createAlgebraicNumber$int$int$int$int'](0, 2, 1, 0);
                this.coRoots[3] = field.origin(4);
                this.coRoots[3].setComponent(1, B2);
                this.coRoots[3].setComponent(2, B2);
                this.coRoots[2] = field.origin(4);
                this.coRoots[2].setComponent(1, B2['plus$com_vzome_core_algebra_AlgebraicNumber'](ONE));
                this.coRoots[2].setComponent(2, B['plus$com_vzome_core_algebra_AlgebraicNumber'](TWO));
                this.coRoots[2].setComponent(3, A);
                this.coRoots[1] = field.origin(4);
                this.coRoots[1].setComponent(1, B2);
                this.coRoots[1].setComponent(2, TWO);
                this.coRoots[0] = field.origin(4);
                this.coRoots[0].setComponent(1, B);
                this.coRoots[0].setComponent(2, ONE);
                this.coRoots[0].setComponent(0, A.negate());
                if (com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().isLoggable(java.util.logging.Level.FINE))for(let i: number = 0; i < 4; i++) {{
                    const buf: java.lang.StringBuffer = new java.lang.StringBuffer();
                    this.coRoots[i].getVectorExpression$java_lang_StringBuffer$int(buf, com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT);
                    com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().fine(buf.toString());
                };}
                const origin: com.vzome.core.algebra.AlgebraicVector = field.origin(4);
                for(let index: number = 1; index <= 15; index++) {{
                    let vertex: com.vzome.core.algebra.AlgebraicVector = origin;
                    for(let b: number = 0; b < 4; b++) {{
                        const mask: number = 1 << b;
                        const test: number = index & mask;
                        if (test !== 0){
                            vertex = vertex.plus(this.coRoots[b]);
                        }
                    };}
                    this.mPrototypes[index - 1] = vertex;
                };}
            }

            public getPrototype(index: number): com.vzome.core.algebra.AlgebraicVector {
                return this.mPrototypes[index - 1];
            }

            public reflect(mirror: number, prototype: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.algebra.AlgebraicVector {
                return this.mMirrors[mirror].reflect(prototype);
            }

            public getCoRoot(i: number): com.vzome.core.algebra.AlgebraicVector {
                return this.coRoots[i];
            }
        }
        H4Symmetry["__class"] = "com.vzome.core.commands.CommandUniformH4Polytope.H4Symmetry";


        export class ConstructionChangesAdapter implements com.vzome.core.math.symmetry.WythoffConstruction.Listener {
            vertices: java.util.Map<com.vzome.core.algebra.AlgebraicVector, com.vzome.core.construction.Point>;

            effects: com.vzome.core.construction.ConstructionChanges;

            proj: com.vzome.core.math.Projection;

            scale: com.vzome.core.algebra.AlgebraicNumber;

            edges: java.util.Set<CommandUniformH4Polytope.Edge>;

            constructor(effects: com.vzome.core.construction.ConstructionChanges, proj: com.vzome.core.math.Projection, scale: com.vzome.core.algebra.AlgebraicNumber) {
                this.vertices = <any>(new java.util.HashMap<any, any>());
                if (this.effects === undefined) { this.effects = null; }
                if (this.proj === undefined) { this.proj = null; }
                if (this.scale === undefined) { this.scale = null; }
                this.edges = <any>(new java.util.HashSet<any>());
                this.effects = effects;
                this.proj = proj;
                this.scale = scale;
            }

            /**
             * 
             * @param {*} v1
             * @param {*} v2
             * @return {*}
             */
            public addEdge(v1: any, v2: any): any {
                const p1: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>v1;
                const p2: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>v2;
                const edge: CommandUniformH4Polytope.Edge = new CommandUniformH4Polytope.Edge(p1.getIndex(), p2.getIndex());
                if (this.edges.contains(edge))return null;
                this.edges.add(edge);
                this.effects['constructionAdded$com_vzome_core_construction_Construction'](new com.vzome.core.construction.SegmentJoiningPoints(p1, p2));
                return edge;
            }

            /**
             * 
             * @param {java.lang.Object[]} vertices
             * @return {*}
             */
            public addFace(vertices: any[]): any {
                return null;
            }

            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} vertex
             * @return {*}
             */
            public addVertex(vertex: com.vzome.core.algebra.AlgebraicVector): any {
                let p: com.vzome.core.construction.Point = this.vertices.get(vertex);
                if (p == null){
                    let projected: com.vzome.core.algebra.AlgebraicVector = vertex;
                    com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().finer("before   : ");
                    this.printGoldenVector(projected);
                    if (this.proj != null)projected = this.proj.projectImage(projected, true);
                    com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().finer("projected: ");
                    this.printGoldenVector(projected);
                    projected = projected.scale(this.scale);
                    com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().finer("scaled   : ");
                    this.printGoldenVector(projected);
                    p = new com.vzome.core.construction.FreePoint(projected);
                    p.setIndex(this.vertices.size());
                    this.effects['constructionAdded$com_vzome_core_construction_Construction'](p);
                    this.vertices.put(vertex, p);
                }
                return p;
            }

            printGoldenVector(gv: com.vzome.core.algebra.AlgebraicVector) {
                if (com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().isLoggable(java.util.logging.Level.FINER)){
                    const buf: java.lang.StringBuffer = new java.lang.StringBuffer();
                    gv.getVectorExpression$java_lang_StringBuffer$int(buf, com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT);
                    com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().finer(buf.toString());
                }
            }
        }
        ConstructionChangesAdapter["__class"] = "com.vzome.core.commands.CommandUniformH4Polytope.ConstructionChangesAdapter";
        ConstructionChangesAdapter["__interfaces"] = ["com.vzome.core.math.symmetry.WythoffConstruction.Listener"];



        export class Edge {
            p1: number;

            p2: number;

            public constructor(p1: number, p2: number) {
                if (this.p1 === undefined) { this.p1 = 0; }
                if (this.p2 === undefined) { this.p2 = 0; }
                this.p1 = p1;
                this.p2 = p2;
            }

            /**
             * 
             * @param {*} obj
             * @return {boolean}
             */
            public equals(obj: any): boolean {
                if (!(obj != null && obj instanceof <any>com.vzome.core.commands.CommandUniformH4Polytope.Edge))return false;
                const that: CommandUniformH4Polytope.Edge = <CommandUniformH4Polytope.Edge>obj;
                if (this.p1 === that.p1 && this.p2 === that.p2)return true;
                if (this.p1 === that.p2 && this.p2 === that.p1)return true;
                return false;
            }

            /**
             * 
             * @return {number}
             */
            public hashCode(): number {
                return this.p1 ^ this.p2;
            }
        }
        Edge["__class"] = "com.vzome.core.commands.CommandUniformH4Polytope.Edge";

    }

}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @param {*} symmetry
     * @class
     * @extends com.vzome.core.commands.CommandTransform
     */
    export class CommandSymmetry extends com.vzome.core.commands.CommandTransform {
        mSymmetry: com.vzome.core.math.symmetry.Symmetry;

        public constructor(symmetry?: any) {
            if (((symmetry != null && (symmetry.constructor != null && symmetry.constructor["__interfaces"] != null && symmetry.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symmetry === null)) {
                let __args = arguments;
                super();
                if (this.mSymmetry === undefined) { this.mSymmetry = null; } 
                this.mSymmetry = symmetry;
            } else if (symmetry === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let symmetry: any = null;
                    super();
                    if (this.mSymmetry === undefined) { this.mSymmetry = null; } 
                    this.mSymmetry = symmetry;
                }
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return com.vzome.core.commands.CommandTransform.GROUP_ATTR_SIGNATURE_$LI$();
        }

        setSymmetry(attributes: com.vzome.core.commands.AttributeMap): com.vzome.core.construction.Point {
            if (this.mSymmetry == null)this.mSymmetry = <com.vzome.core.math.symmetry.Symmetry><any>attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME); else if (!attributes.containsKey(com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME))attributes.put(com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME, this.mSymmetry);
            if (this.mSymmetry == null)throw new java.lang.IllegalStateException("null symmetry no longer supported");
            const center: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME);
            return center;
        }

        /**
         * 
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        public setFixedAttributes(attributes: com.vzome.core.commands.AttributeMap, format: com.vzome.core.commands.XmlSaveFormat) {
            if (!attributes.containsKey(com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME)){
                const icosahedralSymmetry: com.vzome.core.math.symmetry.Symmetry = (<com.vzome.core.commands.XmlSymmetryFormat>format).parseSymmetry("icosahedral");
                attributes.put(com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME, icosahedralSymmetry);
            }
            super.setFixedAttributes(attributes, format);
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attributes: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const center: com.vzome.core.construction.Point = this.setSymmetry(attributes);
            const params: com.vzome.core.construction.Construction[] = parameters.getConstructions();
            const output: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            for(let index = 0; index < params.length; index++) {
                let param = params[index];
                {
                    output.addConstruction(param);
                }
            }
            for(let i: number = 1; i < this.mSymmetry.getChiralOrder(); i++) {{
                const transform: com.vzome.core.construction.Transformation = new com.vzome.core.construction.SymmetryTransformation(this.mSymmetry, i, center);
                output.addAll(this.transform(params, transform, effects));
            };}
            return output;
        }
    }
    CommandSymmetry["__class"] = "com.vzome.core.commands.CommandSymmetry";
    CommandSymmetry["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @param {com.vzome.core.math.symmetry.QuaternionicSymmetry} left
     * @param {com.vzome.core.math.symmetry.QuaternionicSymmetry} right
     * @class
     * @extends com.vzome.core.commands.CommandTransform
     */
    export class CommandQuaternionSymmetry extends com.vzome.core.commands.CommandTransform {
        /**
         * 
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        public setFixedAttributes(attributes: com.vzome.core.commands.AttributeMap, format: com.vzome.core.commands.XmlSaveFormat) {
            super.setFixedAttributes(attributes, format);
            if (!attributes.containsKey(CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$())){
                this.mLeft = (<com.vzome.core.commands.XmlSymmetryFormat>format).getQuaternionicSymmetry("H_4");
                attributes.put(CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$(), this.mLeft);
            }
            if (!attributes.containsKey(CommandQuaternionSymmetry.RIGHT_SYMMETRY_GROUP_ATTR_NAME)){
                this.mRight = (<com.vzome.core.commands.XmlSymmetryFormat>format).getQuaternionicSymmetry("H_4");
                attributes.put(CommandQuaternionSymmetry.RIGHT_SYMMETRY_GROUP_ATTR_NAME, this.mRight);
            }
        }

        public static LEFT_SYMMETRY_GROUP_ATTR_NAME: string; public static LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$(): string { if (CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME == null) { CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME = com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME; }  return CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME; }

        public static RIGHT_SYMMETRY_GROUP_ATTR_NAME: string = "right.symmetry.group";

        /*private*/ mLeft: com.vzome.core.math.symmetry.QuaternionicSymmetry;

        /*private*/ mRight: com.vzome.core.math.symmetry.QuaternionicSymmetry;

        public constructor(left?: any, right?: any) {
            if (((left != null && left instanceof <any>com.vzome.core.math.symmetry.QuaternionicSymmetry) || left === null) && ((right != null && right instanceof <any>com.vzome.core.math.symmetry.QuaternionicSymmetry) || right === null)) {
                let __args = arguments;
                super();
                if (this.mLeft === undefined) { this.mLeft = null; } 
                if (this.mRight === undefined) { this.mRight = null; } 
                this.mLeft = left;
                this.mRight = right;
            } else if (left === undefined && right === undefined) {
                let __args = arguments;
                super();
                if (this.mLeft === undefined) { this.mLeft = null; } 
                if (this.mRight === undefined) { this.mRight = null; } 
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return com.vzome.core.commands.CommandTransform.GROUP_ATTR_SIGNATURE_$LI$();
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attributes: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            if (this.mLeft == null)this.mLeft = <com.vzome.core.math.symmetry.QuaternionicSymmetry>attributes.get(CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$()); else if (!attributes.containsKey(CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$()))attributes.put(CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$(), this.mLeft);
            if (this.mRight == null)this.mRight = <com.vzome.core.math.symmetry.QuaternionicSymmetry>attributes.get(CommandQuaternionSymmetry.RIGHT_SYMMETRY_GROUP_ATTR_NAME); else if (!attributes.containsKey(CommandQuaternionSymmetry.RIGHT_SYMMETRY_GROUP_ATTR_NAME))attributes.put(CommandQuaternionSymmetry.RIGHT_SYMMETRY_GROUP_ATTR_NAME, this.mRight);
            const leftRoots: com.vzome.core.algebra.Quaternion[] = this.mLeft.getRoots();
            const rightRoots: com.vzome.core.algebra.Quaternion[] = this.mRight.getRoots();
            const params: com.vzome.core.construction.Construction[] = parameters.getConstructions();
            const output: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            for(let index = 0; index < params.length; index++) {
                let param = params[index];
                {
                    output.addConstruction(param);
                }
            }
            for(let index = 0; index < leftRoots.length; index++) {
                let leftRoot = leftRoots[index];
                {
                    for(let index1 = 0; index1 < rightRoots.length; index1++) {
                        let rightRoot = rightRoots[index1];
                        {
                            for(let index2 = 0; index2 < params.length; index2++) {
                                let param = params[index2];
                                {
                                    let result: com.vzome.core.construction.Construction = null;
                                    if (param != null && param instanceof <any>com.vzome.core.construction.Point){
                                        result = new com.vzome.core.construction.PointRotated4D(leftRoot, rightRoot, <com.vzome.core.construction.Point>param);
                                    } else if (param != null && param instanceof <any>com.vzome.core.construction.Segment){
                                        result = new com.vzome.core.construction.SegmentRotated4D(leftRoot, rightRoot, <com.vzome.core.construction.Segment>param);
                                    } else if (param != null && param instanceof <any>com.vzome.core.construction.Polygon){
                                        result = new com.vzome.core.construction.PolygonRotated4D(leftRoot, rightRoot, <com.vzome.core.construction.Polygon>param);
                                    } else {
                                    }
                                    if (result == null)continue;
                                    effects['constructionAdded$com_vzome_core_construction_Construction'](result);
                                    output.addConstruction(result);
                                }
                            }
                        }
                    }
                }
            }
            return output;
        }
    }
    CommandQuaternionSymmetry["__class"] = "com.vzome.core.commands.CommandQuaternionSymmetry";
    CommandQuaternionSymmetry["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @class
     * @extends com.vzome.core.commands.CommandTransform
     */
    export class CommandTranslate extends com.vzome.core.commands.CommandTransform {
        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attributes: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const norm: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME);
            if (norm == null){
                throw new com.vzome.core.commands.Command.Failure("no symmetry axis provided");
            }
            const params: com.vzome.core.construction.Construction[] = parameters.getConstructions();
            const field: com.vzome.core.algebra.AlgebraicField = norm.getField();
            const offset: com.vzome.core.algebra.AlgebraicVector = field.projectTo3d(norm.getOffset(), true);
            const transform: com.vzome.core.construction.Transformation = new com.vzome.core.construction.Translation(offset);
            return this.transform(params, transform, effects);
        }

        constructor() {
            super();
        }
    }
    CommandTranslate["__class"] = "com.vzome.core.commands.CommandTranslate";
    CommandTranslate["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @class
     * @extends com.vzome.core.commands.CommandTransform
     */
    export class CommandCentralSymmetry extends com.vzome.core.commands.CommandTransform {
        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return com.vzome.core.commands.CommandTransform.ATTR_SIGNATURE_$LI$();
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attributes: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const output: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            const center: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME);
            const params: com.vzome.core.construction.Construction[] = parameters.getConstructions();
            for(let index = 0; index < params.length; index++) {
                let param = params[index];
                {
                    output.addConstruction(param);
                }
            }
            const transform: com.vzome.core.construction.Transformation = new com.vzome.core.construction.PointReflection(center);
            effects['constructionAdded$com_vzome_core_construction_Construction'](transform);
            return this.transform(params, transform, effects);
        }

        constructor() {
            super();
        }
    }
    CommandCentralSymmetry["__class"] = "com.vzome.core.commands.CommandCentralSymmetry";
    CommandCentralSymmetry["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @class
     * @extends com.vzome.core.commands.CommandTransform
     */
    export class CommandMirrorSymmetry extends com.vzome.core.commands.CommandTransform {
        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attributes: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const center: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME);
            const norm: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME);
            if (norm == null){
                throw new com.vzome.core.commands.Command.Failure("no symmetry axis provided");
            }
            const params: com.vzome.core.construction.Construction[] = parameters.getConstructions();
            const mirror: com.vzome.core.construction.Plane = new com.vzome.core.construction.PlaneFromNormalSegment(center, norm);
            effects['constructionAdded$com_vzome_core_construction_Construction'](mirror);
            const transform: com.vzome.core.construction.Transformation = new com.vzome.core.construction.PlaneReflection(mirror);
            return this.transform(params, transform, effects);
        }

        constructor() {
            super();
        }
    }
    CommandMirrorSymmetry["__class"] = "com.vzome.core.commands.CommandMirrorSymmetry";
    CommandMirrorSymmetry["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.edits {
    export class ValidateSelection extends com.vzome.core.editor.api.ChangeSelection {
        /**
         * 
         */
        public perform() {
            if (this.mSelection.size() === 0)throw new com.vzome.core.commands.Command.Failure("selection is empty");
        }

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor.getSelection());
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "ValidateSelection";
        }
    }
    ValidateSelection["__class"] = "com.vzome.core.edits.ValidateSelection";

}
namespace com.vzome.core.edits {
    export class InvertSelection extends com.vzome.core.editor.api.ChangeSelection {
        mManifestations: com.vzome.core.model.RealizedModel;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor.getSelection());
            if (this.mManifestations === undefined) { this.mManifestations = null; }
            this.mManifestations = editor.getRealizedModel();
        }

        /**
         * 
         */
        public perform() {
            for(let index=this.mManifestations.iterator();index.hasNext();) {
                let m = index.next();
                {
                    if (m.isRendered()){
                        if (this.mSelection.manifestationSelected(m))this.unselect$com_vzome_core_model_Manifestation(m); else this.select$com_vzome_core_model_Manifestation(m);
                    }
                }
            }
            this.redo();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "InvertSelection";
        }
    }
    InvertSelection["__class"] = "com.vzome.core.edits.InvertSelection";

}
namespace com.vzome.core.edits {
    /**
     * Used by CommandEdit.
     * @param {*} editor
     * @param {*} m
     * @class
     * @extends com.vzome.core.editor.api.ChangeSelection
     */
    export class SelectManifestation extends com.vzome.core.editor.api.ChangeSelection {
        /*private*/ mManifestation: com.vzome.core.model.Manifestation;

        /*private*/ construction: com.vzome.core.construction.Construction;

        /*private*/ mRealized: com.vzome.core.model.RealizedModel;

        /*private*/ mReplace: boolean;

        /**
         * 
         * @return {boolean}
         */
        groupingAware(): boolean {
            return true;
        }

        public constructor(editor?: any, m?: any) {
            if (((editor != null && (editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editor === null) && ((m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || m === null)) {
                let __args = arguments;
                {
                    let __args = arguments;
                    super(editor.getSelection());
                    if (this.mManifestation === undefined) { this.mManifestation = null; } 
                    if (this.construction === undefined) { this.construction = null; } 
                    if (this.mRealized === undefined) { this.mRealized = null; } 
                    if (this.mReplace === undefined) { this.mReplace = false; } 
                    this.mRealized = editor.getRealizedModel();
                }
                (() => {
                    this.mManifestation = m;
                    if (this.mManifestation != null){
                        this.construction = this.mManifestation.toConstruction();
                    }
                })();
            } else if (((editor != null && (editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editor === null) && m === undefined) {
                let __args = arguments;
                super(editor.getSelection());
                if (this.mManifestation === undefined) { this.mManifestation = null; } 
                if (this.construction === undefined) { this.construction = null; } 
                if (this.mRealized === undefined) { this.mRealized = null; } 
                if (this.mReplace === undefined) { this.mReplace = false; } 
                this.mRealized = editor.getRealizedModel();
            } else throw new Error('invalid overload');
        }

        public configure(props: java.util.Map<string, any>) {
            const mode: string = <string>props.get("mode");
            this.mReplace = "replace" === mode;
            this.mManifestation = <com.vzome.core.model.Manifestation><any>props.get("picked");
            if (this.mManifestation != null){
                this.construction = this.mManifestation.toConstruction();
            }
        }

        /**
         * 
         */
        public perform() {
            if (this.mReplace){
                for(let index=this.mSelection.iterator();index.hasNext();) {
                    let man = index.next();
                    {
                        this.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                    }
                }
                this.select$com_vzome_core_model_Manifestation(this.mManifestation);
            } else if (this.mSelection.manifestationSelected(this.mManifestation))this.unselect$com_vzome_core_model_Manifestation(this.mManifestation); else this.select$com_vzome_core_model_Manifestation(this.mManifestation);
            this.redo();
        }

        /**
         * 
         * @param {*} result
         */
        getXmlAttributes(result: org.w3c.dom.Element) {
            if (this.construction != null && this.construction instanceof <any>com.vzome.core.construction.Point)com.vzome.core.commands.XmlSaveFormat.serializePoint(result, "point", <com.vzome.core.construction.Point>this.construction); else if (this.construction != null && this.construction instanceof <any>com.vzome.core.construction.Segment)com.vzome.core.commands.XmlSaveFormat.serializeSegment(result, "startSegment", "endSegment", <com.vzome.core.construction.Segment>this.construction); else if (this.construction != null && this.construction instanceof <any>com.vzome.core.construction.Polygon)com.vzome.core.commands.XmlSaveFormat.serializePolygon(result, "polygonVertex", <com.vzome.core.construction.Polygon>this.construction);
            if (this.mReplace)com.vzome.xml.DomUtils.addAttribute(result, "replace", "true");
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        public setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            if (format.rationalVectors()){
                this.construction = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "point");
                if (this.construction == null)this.construction = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "startSegment", "endSegment");
                if (this.construction == null){
                    const kid: org.w3c.dom.Element = com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element$java_lang_String(xml, "polygon");
                    if (kid != null)this.construction = format.parsePolygon$org_w3c_dom_Element$java_lang_String(kid, "vertex"); else this.construction = format.parsePolygon$org_w3c_dom_Element$java_lang_String(xml, "polygonVertex");
                }
            } else {
                const attrs: com.vzome.core.commands.AttributeMap = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                this.construction = <com.vzome.core.construction.Construction>attrs.get("manifestation");
                const replaceVal: boolean = <boolean>attrs.get("replace");
                if (replaceVal != null && replaceVal)this.mReplace = true;
            }
            this.mManifestation = this.mRealized.getManifestation(this.construction);
            if (this.mManifestation == null && format.rationalVectors() && (this.construction != null && this.construction instanceof <any>com.vzome.core.construction.Polygon)){
                this.construction = format.parsePolygonReversed(xml, "polygonVertex");
                this.mManifestation = this.mRealized.getManifestation(this.construction);
                if (this.mManifestation != null)com.vzome.core.editor.api.SideEffects.logBugAccommodation("reverse-oriented polygon");
            }
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "SelectManifestation";
        }
    }
    SelectManifestation["__class"] = "com.vzome.core.edits.SelectManifestation";

}
namespace com.vzome.core.edits {
    /**
     * This constructor is only used during deserialization, so it prepares for setXmlAttributes().
     * @param {*} editor
     * @class
     * @extends com.vzome.core.editor.api.ChangeSelection
     * @author David Hall
     */
    export class AdjustSelectionByOrbitLength extends com.vzome.core.editor.api.ChangeSelection {
        /*private*/ orbit: com.vzome.core.math.symmetry.Direction;

        /*private*/ length: com.vzome.core.algebra.AlgebraicNumber;

        /*private*/ symmetry: com.vzome.core.editor.api.OrbitSource;

        /*private*/ strutAction: com.vzome.core.editor.api.ActionEnum;

        /*private*/ panelAction: com.vzome.core.editor.api.ActionEnum;

        /*private*/ editor: com.vzome.core.editor.api.EditorModel;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor.getSelection());
            if (this.orbit === undefined) { this.orbit = null; }
            if (this.length === undefined) { this.length = null; }
            if (this.symmetry === undefined) { this.symmetry = null; }
            this.strutAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
            this.panelAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
            if (this.editor === undefined) { this.editor = null; }
            this.symmetry = (<com.vzome.core.editor.api.SymmetryAware><any>editor)['getSymmetrySystem$']();
            this.editor = editor;
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
            const mode: string = <string>props.get("mode");
            const strut: com.vzome.core.model.Strut = <com.vzome.core.model.Strut><any>props.get("picked");
            this.orbit = <com.vzome.core.math.symmetry.Direction>props.get("orbit");
            this.length = <com.vzome.core.algebra.AlgebraicNumber><any>props.get("length");
            if (mode != null)switch((mode)) {
            case "selectSimilarStruts":
                this.strutAction = com.vzome.core.editor.api.ActionEnum.SELECT;
                break;
            case "selectSimilarPanels":
                this.panelAction = com.vzome.core.editor.api.ActionEnum.SELECT;
                break;
            case "deselectSimilarStruts":
                this.strutAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                break;
            case "deselectSimilarPanels":
                this.panelAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                break;
            }
            if (strut != null){
                const offset: com.vzome.core.algebra.AlgebraicVector = strut.getOffset();
                const zone: com.vzome.core.math.symmetry.Axis = this.symmetry.getAxis(offset);
                this.orbit = zone.getOrbit();
                this.length = zone.getLength(offset);
            }
        }

        /**
         * 
         */
        public perform() {
            const whichManifestationSet: java.lang.Iterable<com.vzome.core.model.Manifestation> = (this.strutAction === com.vzome.core.editor.api.ActionEnum.SELECT || this.panelAction === com.vzome.core.editor.api.ActionEnum.SELECT) ? this.editor.getRealizedModel() : this.mSelection;
            for(let index=whichManifestationSet.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (man.isRendered()){
                        if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                            const offset: com.vzome.core.algebra.AlgebraicVector = (<com.vzome.core.model.Strut><any>man).getOffset();
                            const zone: com.vzome.core.math.symmetry.Axis = this.symmetry.getAxis(offset);
                            if (zone.getOrbit() === this.orbit){
                                if (this.length == null || /* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(this.length,zone.getLength(offset)))){
                                    this.adjustSelection(man, this.strutAction);
                                }
                            }
                        } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                            const zone: com.vzome.core.math.symmetry.Axis = this.symmetry.getAxis((<com.vzome.core.model.Panel><any>man)['getNormal$']());
                            if (zone.getOrbit() === this.orbit){
                                this.adjustSelection(man, this.panelAction);
                            }
                        }
                    }
                }
            }
            this.redo();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "AdjustSelectionByOrbitLength";
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            if (this.symmetry != null){
                com.vzome.xml.DomUtils.addAttribute(element, "symmetry", this.symmetry.getName());
            }
            if (this.orbit != null){
                com.vzome.xml.DomUtils.addAttribute(element, "orbit", this.orbit.getName());
            }
            if (this.length != null){
                com.vzome.core.commands.XmlSaveFormat.serializeNumber(element, "length", this.length);
            }
            element.setAttribute("struts", /* Enum.name */com.vzome.core.editor.api.ActionEnum[this.strutAction]);
            element.setAttribute("panels", /* Enum.name */com.vzome.core.editor.api.ActionEnum[this.panelAction]);
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            this.symmetry = (<com.vzome.core.editor.api.SymmetryAware><any>this.editor)['getSymmetrySystem$java_lang_String'](xml.getAttribute("symmetry"));
            this.length = format.parseNumber(xml, "length");
            this.orbit = this.symmetry.getOrbits().getDirection(xml.getAttribute("orbit"));
            if (xml.getLocalName() === ("SelectSimilarSize")){
                this.strutAction = com.vzome.core.editor.api.ActionEnum.SELECT;
                this.panelAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
            } else {
                this.strutAction = /* Enum.valueOf */<any>com.vzome.core.editor.api.ActionEnum[xml.getAttribute("struts")];
                this.panelAction = /* Enum.valueOf */<any>com.vzome.core.editor.api.ActionEnum[xml.getAttribute("panels")];
            }
        }
    }
    AdjustSelectionByOrbitLength["__class"] = "com.vzome.core.edits.AdjustSelectionByOrbitLength";

}
namespace com.vzome.core.edits {
    /**
     * @author David Hall
     * This class is designed to be a generalized replacement for the legacy DeselectByClass
     * It allows balls, struts and/or panels to be selected, deselected or ignored by class
     * It can be used in place of DeselectByClass including the ability to parse the legacy XML.
     * DeselectByClass has been renamed as AdjustSelectionByClass and modified with the additional functionality.
     * @param {*} editor
     * @class
     * @extends com.vzome.core.editor.api.ChangeSelection
     */
    export class AdjustSelectionByClass extends com.vzome.core.editor.api.ChangeSelection {
        /*private*/ ballAction: com.vzome.core.editor.api.ActionEnum;

        /*private*/ strutAction: com.vzome.core.editor.api.ActionEnum;

        /*private*/ panelAction: com.vzome.core.editor.api.ActionEnum;

        /*private*/ editor: com.vzome.core.editor.api.EditorModel;

        /*private*/ originLast: boolean;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor.getSelection());
            this.ballAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
            this.strutAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
            this.panelAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
            if (this.editor === undefined) { this.editor = null; }
            this.originLast = true;
            this.editor = editor;
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
            const mode: string = <string>props.get("mode");
            if (mode != null)switch((mode)) {
            case "selectBalls":
                this.ballAction = com.vzome.core.editor.api.ActionEnum.SELECT;
                break;
            case "selectStruts":
                this.strutAction = com.vzome.core.editor.api.ActionEnum.SELECT;
                break;
            case "selectPanels":
                this.panelAction = com.vzome.core.editor.api.ActionEnum.SELECT;
                break;
            case "deselectBalls":
            case "unselectBalls":
                this.ballAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                break;
            case "deselectStruts":
                this.strutAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                break;
            case "deselectPanels":
                this.panelAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                break;
            case "unselectStruts":
            case "unselectStrutsAndPanels":
                this.strutAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                this.panelAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                break;
            }
        }

        /**
         * 
         */
        public perform() {
            const whichManifestationSet: java.lang.Iterable<com.vzome.core.model.Manifestation> = (this.ballAction === com.vzome.core.editor.api.ActionEnum.SELECT || this.strutAction === com.vzome.core.editor.api.ActionEnum.SELECT || this.panelAction === com.vzome.core.editor.api.ActionEnum.SELECT) ? this.editor.getRealizedModel() : this.mSelection;
            let originBall: com.vzome.core.model.Connector = null;
            for(let index=whichManifestationSet.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (man.isRendered()){
                        if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                            if (this.originLast && originBall == null && this.ballAction === com.vzome.core.editor.api.ActionEnum.SELECT && man.getLocation().isOrigin()){
                                originBall = <com.vzome.core.model.Connector><any>man;
                            } else {
                                this.adjustSelection(man, this.ballAction);
                            }
                        } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                            this.adjustSelection(man, this.strutAction);
                        } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                            this.adjustSelection(man, this.panelAction);
                        }
                    }
                }
            }
            if (originBall != null){
                const ignoreGroups: boolean = true;
                if (this.mSelection.manifestationSelected(originBall)){
                    this.unselect$com_vzome_core_model_Manifestation$boolean(originBall, ignoreGroups);
                    this.redo();
                }
                this.select$com_vzome_core_model_Manifestation$boolean(originBall, ignoreGroups);
            }
            this.redo();
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            element.setAttribute("balls", /* Enum.name */com.vzome.core.editor.api.ActionEnum[this.ballAction]);
            element.setAttribute("struts", /* Enum.name */com.vzome.core.editor.api.ActionEnum[this.strutAction]);
            element.setAttribute("panels", /* Enum.name */com.vzome.core.editor.api.ActionEnum[this.panelAction]);
            if (this.originLast){
                element.setAttribute("originLast", "true");
            }
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            if (xml.getLocalName() === ("DeselectByClass")){
                if (xml.getAttribute("class") === ("balls")){
                    this.ballAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                    this.strutAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
                    this.panelAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
                } else {
                    this.ballAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
                    this.strutAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                    this.panelAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                }
            } else {
                this.ballAction = /* Enum.valueOf */<any>com.vzome.core.editor.api.ActionEnum[xml.getAttribute("balls")];
                this.strutAction = /* Enum.valueOf */<any>com.vzome.core.editor.api.ActionEnum[xml.getAttribute("struts")];
                this.panelAction = /* Enum.valueOf */<any>com.vzome.core.editor.api.ActionEnum[xml.getAttribute("panels")];
            }
            const mode: string = xml.getAttribute("originLast");
            this.originLast = "true" === mode;
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "AdjustSelectionByClass";
        }
    }
    AdjustSelectionByClass["__class"] = "com.vzome.core.edits.AdjustSelectionByClass";

}
namespace com.vzome.core.edits {
    export class SelectAll extends com.vzome.core.editor.api.ChangeSelection {
        /*private*/ realizedModel: com.vzome.core.model.RealizedModel;

        /*private*/ originLast: boolean;

        /**
         * 
         */
        public perform() {
            if (this.originLast){
                let originBall: com.vzome.core.model.Connector = null;
                const ignoreGroups: boolean = true;
                for(let index=this.realizedModel.iterator();index.hasNext();) {
                    let m = index.next();
                    {
                        if (m.isRendered()){
                            if (originBall == null && (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) && m.getLocation().isOrigin()){
                                originBall = <com.vzome.core.model.Connector><any>m;
                            } else if (!this.mSelection.manifestationSelected(m)){
                                this.select$com_vzome_core_model_Manifestation$boolean(m, ignoreGroups);
                            }
                        }
                    }
                }
                if (originBall != null){
                    if (this.mSelection.manifestationSelected(originBall)){
                        this.unselect$com_vzome_core_model_Manifestation$boolean(originBall, ignoreGroups);
                        this.redo();
                    }
                    this.select$com_vzome_core_model_Manifestation$boolean(originBall, ignoreGroups);
                }
            } else {
                for(let index=this.realizedModel.iterator();index.hasNext();) {
                    let m = index.next();
                    {
                        if (m.isRendered()){
                            if (!this.mSelection.manifestationSelected(m))this.select$com_vzome_core_model_Manifestation$boolean(m, true);
                        }
                    }
                }
            }
            super.perform();
        }

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor.getSelection());
            if (this.realizedModel === undefined) { this.realizedModel = null; }
            this.originLast = true;
            this.realizedModel = editor.getRealizedModel();
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            const mode: string = xml.getAttribute("originLast");
            this.originLast = "true" === mode;
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            if (this.originLast)element.setAttribute("originLast", "true");
        }

        /**
         * 
         * @return {boolean}
         */
        groupingAware(): boolean {
            return true;
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "SelectAll";
        }
    }
    SelectAll["__class"] = "com.vzome.core.edits.SelectAll";

}
namespace com.vzome.core.edits {
    export class SelectNeighbors extends com.vzome.core.editor.api.ChangeSelection {
        /*private*/ editor: com.vzome.core.editor.api.EditorModel;

        /*private*/ withPanels: boolean;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor.getSelection());
            if (this.editor === undefined) { this.editor = null; }
            this.withPanels = false;
            this.editor = editor;
        }

        public perform() {
            const model: com.vzome.core.model.RealizedModel = this.editor.getRealizedModel();
            const panels: java.util.Set<com.vzome.core.model.Panel> = <any>(new java.util.LinkedHashSet<any>());
            const struts: java.util.Set<com.vzome.core.model.Strut> = <any>(new java.util.LinkedHashSet<any>());
            const balls: java.util.Set<com.vzome.core.model.Connector> = <any>(new java.util.LinkedHashSet<any>());
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))struts.add(<com.vzome.core.model.Strut><any>man); else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))balls.add(<com.vzome.core.model.Connector><any>man); else if (this.withPanels && (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)))panels.add(<com.vzome.core.model.Panel><any>man);
                }
            }
            for(let index=balls.iterator();index.hasNext();) {
                let ball = index.next();
                {
                    const loc: com.vzome.core.algebra.AlgebraicVector = ball.getLocation();
                    for(let index=model.iterator();index.hasNext();) {
                        let man = index.next();
                        {
                            if (!man.isRendered())continue;
                            if ((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) && !struts.contains(man)){
                                const strut: com.vzome.core.model.Strut = <com.vzome.core.model.Strut><any>man;
                                if (loc.equals(strut.getLocation()) || loc.equals(strut.getEnd()))this.select$com_vzome_core_model_Manifestation(strut);
                            } else if (this.withPanels && (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) && !panels.contains(man)){
                                const panel: com.vzome.core.model.Panel = <com.vzome.core.model.Panel><any>man;
                                for(let index=panel.iterator();index.hasNext();) {
                                    let vertex = index.next();
                                    {
                                        if (loc.equals(vertex)){
                                            this.select$com_vzome_core_model_Manifestation(panel);
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            for(let index=struts.iterator();index.hasNext();) {
                let strut = index.next();
                {
                    const loc: com.vzome.core.algebra.AlgebraicVector = strut.getLocation();
                    const end: com.vzome.core.algebra.AlgebraicVector = strut.getEnd();
                    for(let index=model.iterator();index.hasNext();) {
                        let man = index.next();
                        {
                            if (!man.isRendered())continue;
                            if ((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) && !balls.contains(man)){
                                const bloc: com.vzome.core.algebra.AlgebraicVector = man.getLocation();
                                if (bloc.equals(loc) || bloc.equals(end))this.select$com_vzome_core_model_Manifestation(man);
                            }
                        }
                    }
                }
            }
            if (this.withPanels){
                for(let index=panels.iterator();index.hasNext();) {
                    let panel = index.next();
                    {
                        for(let index=panel.iterator();index.hasNext();) {
                            let loc = index.next();
                            {
                                for(let index=model.iterator();index.hasNext();) {
                                    let man = index.next();
                                    {
                                        if (man.isRendered()){
                                            if ((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) && !balls.contains(man)){
                                                const bloc: com.vzome.core.algebra.AlgebraicVector = man.getLocation();
                                                if (bloc.equals(loc)){
                                                    this.select$com_vzome_core_model_Manifestation(man);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            super.perform();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "SelectNeighbors";
        }
    }
    SelectNeighbors["__class"] = "com.vzome.core.edits.SelectNeighbors";

}
namespace com.vzome.core.edits {
    export class DeselectAll extends com.vzome.core.editor.api.ChangeSelection {
        /**
         * 
         */
        public perform() {
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                }
            }
            super.perform();
        }

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor.getSelection());
        }

        /**
         * 
         * @return {boolean}
         */
        groupingAware(): boolean {
            return true;
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "DeselectAll";
        }
    }
    DeselectAll["__class"] = "com.vzome.core.edits.DeselectAll";

}
namespace com.vzome.core.editor.api {
    export abstract class ChangeManifestations extends com.vzome.core.editor.api.ChangeSelection {
        mManifestations: com.vzome.core.model.RealizedModel;

        public constructor(editorModel: com.vzome.core.editor.api.EditorModel) {
            super(editorModel.getSelection());
            if (this.mManifestations === undefined) { this.mManifestations = null; }
            this.mManifestations = editorModel.getRealizedModel();
            this.mManifestations.clearPerEditManifestations();
        }

        /**
         * 
         */
        public redo() {
            this.mManifestations.clearPerEditManifestations();
            super.redo();
        }

        /**
         * 
         */
        public undo() {
            this.mManifestations.clearPerEditManifestations();
            super.undo();
        }

        getManifestation(c: com.vzome.core.construction.Construction): com.vzome.core.model.Manifestation {
            return this.mManifestations.getManifestation(c);
        }

        public manifestConstruction(c: com.vzome.core.construction.Construction): com.vzome.core.model.Manifestation {
            const sig: string = c.getSignature();
            const m: com.vzome.core.model.Manifestation = this.mManifestations.findConstruction(c);
            if (m == null)return null;
            const made: com.vzome.core.model.Manifestation = this.mManifestations.findPerEditManifestation(sig);
            if (made != null)return made;
            if (m.isUnnecessary()){
                this.mManifestations.addPerEditManifestation(sig, m);
                this.plan(new ChangeManifestations.ManifestConstruction(this, c, m, true));
            } else {
                if (!m.isRendered())this.plan(new ChangeManifestations.RenderManifestation(this, m, true));
            }
            return m;
        }

        unmanifestConstruction(c: com.vzome.core.construction.Construction): com.vzome.core.model.Manifestation {
            const m: com.vzome.core.model.Manifestation = this.mManifestations.removeConstruction(c);
            if (m == null)return null;
            this.plan(new ChangeManifestations.ManifestConstruction(this, c, m, false));
            return m;
        }

        deleteManifestation(man: com.vzome.core.model.Manifestation) {
            this.plan(new ChangeManifestations.DeleteManifestation(this, man));
        }

        showManifestation(m: com.vzome.core.model.Manifestation) {
            this.plan(new ChangeManifestations.RenderManifestation(this, m, true));
        }

        hideManifestation(m: com.vzome.core.model.Manifestation) {
            this.plan(new ChangeManifestations.RenderManifestation(this, m, false));
        }

        public colorManifestation(m: com.vzome.core.model.Manifestation, color: com.vzome.core.construction.Color) {
            this.plan(new ChangeManifestations.ColorManifestation(this, m, color));
        }

        public labelManifestation(m: com.vzome.core.model.Manifestation, label: string) {
            this.plan(new ChangeManifestations.LabelManifestation(this, m, label));
        }

        hideConnectors() {
            for(let index=com.vzome.core.editor.api.Manifestations.getVisibleConnectors(this.mManifestations).iterator();index.hasNext();) {
                let connector = index.next();
                this.hideManifestation(connector)
            }
        }

        showConnectors() {
            for(let index=com.vzome.core.editor.api.Manifestations.getHiddenConnectors(this.mManifestations).iterator();index.hasNext();) {
                let connector = index.next();
                this.showManifestation(connector)
            }
        }

        hideStruts() {
            for(let index=com.vzome.core.editor.api.Manifestations.getVisibleStruts(this.mManifestations).iterator();index.hasNext();) {
                let strut = index.next();
                this.hideManifestation(strut)
            }
        }

        showStruts() {
            for(let index=com.vzome.core.editor.api.Manifestations.getHiddenStruts(this.mManifestations).iterator();index.hasNext();) {
                let strut = index.next();
                this.showManifestation(strut)
            }
        }

        hidePanels() {
            for(let index=com.vzome.core.editor.api.Manifestations.getVisiblePanels(this.mManifestations).iterator();index.hasNext();) {
                let panel = index.next();
                this.hideManifestation(panel)
            }
        }

        showPanels() {
            for(let index=com.vzome.core.editor.api.Manifestations.getHiddenPanels(this.mManifestations).iterator();index.hasNext();) {
                let panel = index.next();
                this.showManifestation(panel)
            }
        }

        public showsManifestation(man: com.vzome.core.model.Manifestation): boolean {
            for(const iterator: java.util.Iterator<com.vzome.core.editor.api.SideEffect> = this.getEffects(); iterator.hasNext(); ) {{
                const effect: com.vzome.core.editor.api.SideEffect = iterator.next();
                if (effect != null && effect instanceof <any>com.vzome.core.editor.api.ChangeManifestations.ManifestConstruction){
                    const show: ChangeManifestations.ManifestConstruction = <ChangeManifestations.ManifestConstruction><any>effect;
                    if (show.showsManifestation(man))return true;
                } else if (effect != null && effect instanceof <any>com.vzome.core.editor.api.ChangeManifestations.RenderManifestation){
                    const show: ChangeManifestations.RenderManifestation = <ChangeManifestations.RenderManifestation><any>effect;
                    if (show.showsManifestation(man))return true;
                }
            };}
            return false;
        }

        getRenderedSelection(): com.vzome.core.editor.api.Manifestations.ManifestationIterator {
            return com.vzome.core.editor.api.Manifestations.visibleManifestations$java_lang_Iterable$java_util_function_Predicate(this.mSelection, (man) => { return com.vzome.core.editor.api.Manifestations.Filters.isRendered(man) });
        }

        getConnectors(): com.vzome.core.editor.api.Manifestations.ConnectorIterator {
            return com.vzome.core.editor.api.Manifestations.getConnectors$java_lang_Iterable(this.mManifestations);
        }

        getStruts(): com.vzome.core.editor.api.Manifestations.StrutIterator {
            return com.vzome.core.editor.api.Manifestations.getStruts$java_lang_Iterable(this.mManifestations);
        }

        getPanels(): com.vzome.core.editor.api.Manifestations.PanelIterator {
            return com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable(this.mManifestations);
        }

        getVisibleConnectors$(): com.vzome.core.editor.api.Manifestations.ConnectorIterator {
            return com.vzome.core.editor.api.Manifestations.getVisibleConnectors(this.mManifestations);
        }

        getVisibleStruts$(): com.vzome.core.editor.api.Manifestations.StrutIterator {
            return com.vzome.core.editor.api.Manifestations.getVisibleStruts(this.mManifestations);
        }

        getVisiblePanels$(): com.vzome.core.editor.api.Manifestations.PanelIterator {
            return com.vzome.core.editor.api.Manifestations.getVisiblePanels(this.mManifestations);
        }

        public getVisibleConnectors$java_util_function_Predicate(postFilter: (p1: com.vzome.core.model.Connector) => boolean): com.vzome.core.editor.api.Manifestations.ConnectorIterator {
            return com.vzome.core.editor.api.Manifestations.getVisibleConnectors(this.mManifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postFilter)));
        }

        public getVisibleConnectors(postFilter?: any): com.vzome.core.editor.api.Manifestations.ConnectorIterator {
            if (((typeof postFilter === 'function' && (<any>postFilter).length === 1) || postFilter === null)) {
                return <any>this.getVisibleConnectors$java_util_function_Predicate(postFilter);
            } else if (postFilter === undefined) {
                return <any>this.getVisibleConnectors$();
            } else throw new Error('invalid overload');
        }

        public getVisibleStruts$java_util_function_Predicate(postFilter: (p1: com.vzome.core.model.Strut) => boolean): com.vzome.core.editor.api.Manifestations.StrutIterator {
            return com.vzome.core.editor.api.Manifestations.getVisibleStruts(this.mManifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postFilter)));
        }

        public getVisibleStruts(postFilter?: any): com.vzome.core.editor.api.Manifestations.StrutIterator {
            if (((typeof postFilter === 'function' && (<any>postFilter).length === 1) || postFilter === null)) {
                return <any>this.getVisibleStruts$java_util_function_Predicate(postFilter);
            } else if (postFilter === undefined) {
                return <any>this.getVisibleStruts$();
            } else throw new Error('invalid overload');
        }

        public getVisiblePanels$java_util_function_Predicate(postFilter: (p1: com.vzome.core.model.Panel) => boolean): com.vzome.core.editor.api.Manifestations.PanelIterator {
            return com.vzome.core.editor.api.Manifestations.getVisiblePanels(this.mManifestations, <any>(((funcInst: any) => { if (funcInst == null || typeof funcInst == 'function') { return funcInst } return (arg0) =>  (funcInst['test'] ? funcInst['test'] : funcInst) .call(funcInst, arg0)})(postFilter)));
        }

        public getVisiblePanels(postFilter?: any): com.vzome.core.editor.api.Manifestations.PanelIterator {
            if (((typeof postFilter === 'function' && (<any>postFilter).length === 1) || postFilter === null)) {
                return <any>this.getVisiblePanels$java_util_function_Predicate(postFilter);
            } else if (postFilter === undefined) {
                return <any>this.getVisiblePanels$();
            } else throw new Error('invalid overload');
        }
    }
    ChangeManifestations["__class"] = "com.vzome.core.editor.api.ChangeManifestations";


    export namespace ChangeManifestations {

        export class ManifestConstruction implements com.vzome.core.editor.api.SideEffect {
            public __parent: any;
            mManifestation: com.vzome.core.model.Manifestation;

            mConstruction: com.vzome.core.construction.Construction;

            mShowing: boolean;

            public constructor(__parent: any, construction: com.vzome.core.construction.Construction, manifestation: com.vzome.core.model.Manifestation, showing: boolean) {
                this.__parent = __parent;
                if (this.mManifestation === undefined) { this.mManifestation = null; }
                if (this.mConstruction === undefined) { this.mConstruction = null; }
                if (this.mShowing === undefined) { this.mShowing = false; }
                this.mConstruction = construction;
                this.mManifestation = manifestation;
                this.mShowing = showing;
            }

            /**
             * 
             */
            public redo() {
                if (this.mShowing){
                    if (this.mManifestation.isUnnecessary()){
                        this.mManifestation.addConstruction(this.mConstruction);
                        this.__parent.mManifestations.add(this.mManifestation);
                    }
                    this.__parent.mManifestations.show(this.mManifestation);
                } else {
                    this.mManifestation.removeConstruction(this.mConstruction);
                    if (this.mManifestation.isUnnecessary()){
                        this.__parent.mManifestations.hide(this.mManifestation);
                        this.__parent.mManifestations.remove(this.mManifestation);
                    }
                }
            }

            /**
             * 
             */
            public undo() {
                if (this.mShowing){
                    this.mManifestation.removeConstruction(this.mConstruction);
                    if (this.mManifestation.isUnnecessary()){
                        this.__parent.mManifestations.hide(this.mManifestation);
                        this.__parent.mManifestations.remove(this.mManifestation);
                    }
                } else {
                    if (this.mManifestation.isUnnecessary())this.__parent.mManifestations.add(this.mManifestation);
                    this.__parent.mManifestations.show(this.mManifestation);
                    this.mManifestation.addConstruction(this.mConstruction);
                }
            }

            /**
             * 
             * @param {*} doc
             * @return {*}
             */
            public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
                const result: org.w3c.dom.Element = this.mShowing ? doc.createElement("mshow") : doc.createElement("mhide");
                const man: org.w3c.dom.Element = this.mConstruction.getXml(doc);
                result.appendChild(man);
                return result;
            }

            public showsManifestation(man: com.vzome.core.model.Manifestation): boolean {
                return this.mShowing && /* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(this.mManifestation,man));
            }
        }
        ManifestConstruction["__class"] = "com.vzome.core.editor.api.ChangeManifestations.ManifestConstruction";
        ManifestConstruction["__interfaces"] = ["com.vzome.core.editor.api.SideEffect"];



        export class RenderManifestation implements com.vzome.core.editor.api.SideEffect {
            public __parent: any;
            mManifestation: com.vzome.core.model.Manifestation;

            mShowing: boolean;

            public constructor(__parent: any, manifestation: com.vzome.core.model.Manifestation, showing: boolean) {
                this.__parent = __parent;
                if (this.mManifestation === undefined) { this.mManifestation = null; }
                if (this.mShowing === undefined) { this.mShowing = false; }
                this.mManifestation = manifestation;
                this.mShowing = showing;
            }

            /**
             * 
             */
            public redo() {
                this.mManifestation.setHidden(!this.mShowing);
                if (this.mShowing)this.__parent.mManifestations.show(this.mManifestation); else this.__parent.mManifestations.hide(this.mManifestation);
            }

            /**
             * 
             */
            public undo() {
                this.mManifestation.setHidden(this.mShowing);
                if (this.mShowing)this.__parent.mManifestations.hide(this.mManifestation); else this.__parent.mManifestations.show(this.mManifestation);
            }

            /**
             * 
             * @param {*} doc
             * @return {*}
             */
            public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
                const result: org.w3c.dom.Element = this.mShowing ? doc.createElement("show") : doc.createElement("hide");
                const man: org.w3c.dom.Element = this.mManifestation.getXml(doc);
                result.appendChild(man);
                return result;
            }

            public showsManifestation(man: com.vzome.core.model.Manifestation): boolean {
                return this.mShowing && /* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(this.mManifestation,man));
            }
        }
        RenderManifestation["__class"] = "com.vzome.core.editor.api.ChangeManifestations.RenderManifestation";
        RenderManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffect"];



        export class DeleteManifestation implements com.vzome.core.editor.api.SideEffect {
            public __parent: any;
            mManifestation: com.vzome.core.model.Manifestation;

            public constructor(__parent: any, manifestation: com.vzome.core.model.Manifestation) {
                this.__parent = __parent;
                if (this.mManifestation === undefined) { this.mManifestation = null; }
                this.mManifestation = manifestation;
            }

            /**
             * 
             */
            public redo() {
                this.mManifestation.setHidden(true);
                this.__parent.mManifestations.hide(this.mManifestation);
                this.__parent.mManifestations.remove(this.mManifestation);
            }

            /**
             * 
             */
            public undo() {
                this.__parent.mManifestations.add(this.mManifestation);
                this.__parent.mManifestations.show(this.mManifestation);
                this.mManifestation.setHidden(false);
            }

            /**
             * 
             * @param {*} doc
             * @return {*}
             */
            public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
                const result: org.w3c.dom.Element = doc.createElement("delete");
                const man: org.w3c.dom.Element = this.mManifestation.getXml(doc);
                result.appendChild(man);
                return result;
            }
        }
        DeleteManifestation["__class"] = "com.vzome.core.editor.api.ChangeManifestations.DeleteManifestation";
        DeleteManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffect"];



        export class ColorManifestation implements com.vzome.core.editor.api.SideEffect {
            public __parent: any;
            mManifestation: com.vzome.core.model.Manifestation;

            oldColor: com.vzome.core.construction.Color;

            newColor: com.vzome.core.construction.Color;

            public constructor(__parent: any, manifestation: com.vzome.core.model.Manifestation, color: com.vzome.core.construction.Color) {
                this.__parent = __parent;
                if (this.mManifestation === undefined) { this.mManifestation = null; }
                if (this.oldColor === undefined) { this.oldColor = null; }
                if (this.newColor === undefined) { this.newColor = null; }
                this.mManifestation = manifestation;
                this.newColor = color;
                this.oldColor = manifestation.getColor();
            }

            /**
             * 
             */
            public redo() {
                this.__parent.mManifestations.setColor(this.mManifestation, this.newColor);
            }

            /**
             * 
             */
            public undo() {
                this.__parent.mManifestations.setColor(this.mManifestation, this.oldColor);
            }

            /**
             * 
             * @param {*} doc
             * @return {*}
             */
            public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
                const result: org.w3c.dom.Element = doc.createElement("color");
                com.vzome.xml.DomUtils.addAttribute(result, "rgb", this.newColor.toString());
                const man: org.w3c.dom.Element = this.mManifestation.getXml(doc);
                result.appendChild(man);
                return result;
            }
        }
        ColorManifestation["__class"] = "com.vzome.core.editor.api.ChangeManifestations.ColorManifestation";
        ColorManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffect"];



        export class LabelManifestation implements com.vzome.core.editor.api.SideEffect {
            public __parent: any;
            mManifestation: com.vzome.core.model.Manifestation;

            oldLabel: string;

            newLabel: string;

            public constructor(__parent: any, m: com.vzome.core.model.Manifestation, label: string) {
                this.__parent = __parent;
                if (this.mManifestation === undefined) { this.mManifestation = null; }
                if (this.oldLabel === undefined) { this.oldLabel = null; }
                if (this.newLabel === undefined) { this.newLabel = null; }
                this.mManifestation = m;
                this.newLabel = label;
                this.oldLabel = m.getLabel();
            }

            /**
             * 
             */
            public undo() {
                this.__parent.mManifestations.setLabel(this.mManifestation, this.oldLabel);
            }

            /**
             * 
             * @param {*} doc
             * @return {*}
             */
            public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
                const result: org.w3c.dom.Element = doc.createElement("label");
                com.vzome.xml.DomUtils.addAttribute(result, "text", this.newLabel);
                const man: org.w3c.dom.Element = this.mManifestation.getXml(doc);
                result.appendChild(man);
                return result;
            }

            /**
             * 
             */
            public redo() {
                this.__parent.mManifestations.setLabel(this.mManifestation, this.newLabel);
            }
        }
        LabelManifestation["__class"] = "com.vzome.core.editor.api.ChangeManifestations.LabelManifestation";
        LabelManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffect"];


    }

}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @param {*} symmetry
     * @class
     * @extends com.vzome.core.commands.CommandSymmetry
     */
    export class CommandTetrahedralSymmetry extends com.vzome.core.commands.CommandSymmetry {
        public static SUBGROUP_ATTR_NAME: string = "symmetry.permutations";

        static ATTR_SIGNATURE: any[][]; public static ATTR_SIGNATURE_$LI$(): any[][] { if (CommandTetrahedralSymmetry.ATTR_SIGNATURE == null) { CommandTetrahedralSymmetry.ATTR_SIGNATURE = [[com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME, com.vzome.core.construction.Point], [com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME, "com.vzome.core.math.symmetry.Symmetry"], [CommandTetrahedralSymmetry.SUBGROUP_ATTR_NAME, (<any>[].constructor)]]; }  return CommandTetrahedralSymmetry.ATTR_SIGNATURE; }

        public constructor(symmetry: com.vzome.core.math.symmetry.Symmetry = null) {
            super(symmetry);
        }

        /**
         * 
         * @return {java.lang.Object[][]}
         */
        public getAttributeSignature(): any[][] {
            return CommandTetrahedralSymmetry.ATTR_SIGNATURE_$LI$();
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attributes: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const center: com.vzome.core.construction.Point = this.setSymmetry(attributes);
            const closure: number[] = this.mSymmetry.subgroup(com.vzome.core.math.symmetry.Symmetry.TETRAHEDRAL);
            const params: com.vzome.core.construction.Construction[] = parameters.getConstructions();
            const output: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            for(let index = 0; index < params.length; index++) {
                let param = params[index];
                {
                    output.addConstruction(param);
                }
            }
            for(let i: number = 1; i < closure.length; i++) {{
                const transform: com.vzome.core.construction.Transformation = new com.vzome.core.construction.SymmetryTransformation(this.mSymmetry, closure[i], center);
                output.addAll(this.transform(params, transform, effects));
            };}
            return output;
        }
    }
    CommandTetrahedralSymmetry["__class"] = "com.vzome.core.commands.CommandTetrahedralSymmetry";
    CommandTetrahedralSymmetry["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @class
     * @extends com.vzome.core.commands.CommandSymmetry
     */
    export class CommandRotate extends com.vzome.core.commands.CommandSymmetry {
        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attributes: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            const center: com.vzome.core.construction.Point = this.setSymmetry(attributes);
            const norm: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME);
            if (norm == null){
                throw new com.vzome.core.commands.Command.Failure("no symmetry axis provided");
            }
            const params: com.vzome.core.construction.Construction[] = parameters.getConstructions();
            const output: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            let vector: com.vzome.core.algebra.AlgebraicVector = norm.getOffset();
            vector = norm.getField().projectTo3d(vector, true);
            const axis: com.vzome.core.math.symmetry.Axis = this.mSymmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](vector);
            const rotation: number = axis.getRotation();
            const transform: com.vzome.core.construction.Transformation = new com.vzome.core.construction.SymmetryTransformation(this.mSymmetry, rotation, center);
            effects['constructionAdded$com_vzome_core_construction_Construction'](transform);
            output.addAll(this.transform(params, transform, effects));
            return output;
        }

        constructor() {
            super();
        }
    }
    CommandRotate["__class"] = "com.vzome.core.commands.CommandRotate";
    CommandRotate["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.commands {
    /**
     * @author Scott Vorthmann
     * @param {*} symmetry
     * @class
     * @extends com.vzome.core.commands.CommandSymmetry
     */
    export class CommandAxialSymmetry extends com.vzome.core.commands.CommandSymmetry {
        public constructor(symmetry: com.vzome.core.math.symmetry.Symmetry = null) {
            super(symmetry);
        }

        /**
         * 
         * @param {com.vzome.core.construction.ConstructionList} parameters
         * @param {com.vzome.core.commands.AttributeMap} attributes
         * @param {*} effects
         * @return {com.vzome.core.construction.ConstructionList}
         */
        public apply(parameters: com.vzome.core.construction.ConstructionList, attributes: com.vzome.core.commands.AttributeMap, effects: com.vzome.core.construction.ConstructionChanges): com.vzome.core.construction.ConstructionList {
            this.setSymmetry(attributes);
            const norm: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME);
            if (norm == null){
                throw new com.vzome.core.commands.Command.Failure("no symmetry axis provided");
            }
            const output: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            let vector: com.vzome.core.algebra.AlgebraicVector = norm.getOffset();
            vector = norm.getField().projectTo3d(vector, true);
            const axis: com.vzome.core.math.symmetry.Axis = this.mSymmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](vector);
            const rotation: com.vzome.core.math.symmetry.Permutation = axis.getRotationPermutation();
            if (rotation == null){
                throw new com.vzome.core.commands.Command.Failure("symmetry axis does not support axial symmetry");
            }
            const order: number = rotation.getOrder();
            const rotate: com.vzome.core.commands.CommandRotate = new com.vzome.core.commands.CommandRotate();
            for(let i: number = 1; i < order; i++) {{
                for(let index=parameters.iterator();index.hasNext();) {
                    let param = index.next();
                    {
                        output.addConstruction(param);
                    }
                }
                parameters = rotate.apply(parameters, attributes, effects);
            };}
            for(let index=parameters.iterator();index.hasNext();) {
                let param = index.next();
                {
                    output.addConstruction(param);
                }
            }
            return output;
        }
    }
    CommandAxialSymmetry["__class"] = "com.vzome.core.commands.CommandAxialSymmetry";
    CommandAxialSymmetry["__interfaces"] = ["com.vzome.core.commands.Command"];


}
namespace com.vzome.core.edits {
    /**
     * @author David Hall
     * @param {*} editor
     * @class
     * @extends com.vzome.core.editor.api.ChangeManifestations
     */
    export class PanelPanelIntersection extends com.vzome.core.editor.api.ChangeManifestations {
        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
        }

        /**
         * 
         */
        public perform() {
            let panel0: com.vzome.core.model.Panel = null;
            let panel1: com.vzome.core.model.Panel = null;
            let nPanels: number = 0;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                        switch((nPanels++)) {
                        case 0:
                            panel0 = <com.vzome.core.model.Panel><any>man;
                            break;
                        case 1:
                            panel1 = <com.vzome.core.model.Panel><any>man;
                            break;
                        default:
                            break;
                        }
                    }
                }
            }
            if (nPanels !== 2){
                let msg: string;
                switch((nPanels)) {
                case 0:
                    msg = "No panels are selected.";
                    break;
                case 1:
                    msg = "One panel is selected.";
                    break;
                default:
                    msg = nPanels + " panels are selected.";
                    break;
                }
                this.fail(msg + " Two are required.");
            }
            if (com.vzome.core.algebra.AlgebraicVectors.areParallel(panel0['getNormal$'](), panel1['getNormal$']())){
                const vertices: java.util.List<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>());
                {
                    let array = [panel0, panel1];
                    for(let index = 0; index < array.length; index++) {
                        let panel = array[index];
                        {
                            for(let index1=panel.iterator();index1.hasNext();) {
                                let v = index1.next();
                                {
                                    vertices.add(v);
                                }
                            }
                        }
                    }
                }
                this.fail("Panels are " + (com.vzome.core.algebra.AlgebraicVectors.areCoplanar(vertices) ? "coplanar" : "parallel") + ".");
            }
            this.redo();
            const segment: com.vzome.core.construction.Segment = new com.vzome.core.construction.PolygonPolygonProjectionToSegment(PanelPanelIntersection.polygonFromPanel(panel0), PanelPanelIntersection.polygonFromPanel(panel1));
            const start: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(segment.getStart());
            const end: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(segment.getEnd());
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(segment));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(start));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(end));
            this.redo();
        }

        /*private*/ static polygonFromPanel(panel: com.vzome.core.model.Panel): com.vzome.core.construction.Polygon {
            const vertices: java.util.List<com.vzome.core.construction.Point> = <any>(new java.util.ArrayList<any>(panel.getVertexCount()));
            for(let index=panel.iterator();index.hasNext();) {
                let vector = index.next();
                {
                    vertices.add(new com.vzome.core.construction.FreePoint(vector));
                }
            }
            return new com.vzome.core.construction.PolygonFromVertices(vertices);
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return /* getSimpleName */(c => typeof c === 'string' ? (<any>c).substring((<any>c).lastIndexOf('.')+1) : c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.')+1) : c["name"].substring(c["name"].lastIndexOf('.')+1))((<any>this.constructor));
        }
    }
    PanelPanelIntersection["__class"] = "com.vzome.core.edits.PanelPanelIntersection";

}
namespace com.vzome.core.edits {
    export class GhostSymmetry24Cell extends com.vzome.core.editor.api.ChangeManifestations {
        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        /*private*/ proj: com.vzome.core.math.Projection;

        /*private*/ symmAxis: com.vzome.core.construction.Segment;

        /*private*/ symm: com.vzome.core.math.symmetry.Symmetry;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            if (this.field === undefined) { this.field = null; }
            if (this.proj === undefined) { this.proj = null; }
            if (this.symmAxis === undefined) { this.symmAxis = null; }
            if (this.symm === undefined) { this.symm = null; }
            this.symm = (<com.vzome.core.editor.api.SymmetryAware><any>editor)['getSymmetrySystem$']().getSymmetry();
            this.field = this.symm.getField();
            this.symmAxis = (<com.vzome.core.editor.api.ImplicitSymmetryParameters><any>editor).getSymmetrySegment();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "GhostSymmetry24Cell";
        }

        /**
         * 
         * @param {*} result
         */
        public getXmlAttributes(result: org.w3c.dom.Element) {
            if (this.symmAxis != null)com.vzome.core.commands.XmlSaveFormat.serializeSegment(result, "start", "end", this.symmAxis);
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        public setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            this.symmAxis = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "start", "end");
        }

        /**
         * 
         */
        public perform() {
            if (this.symmAxis == null)this.proj = new com.vzome.core.math.Projection.Default(this.field); else this.proj = new com.vzome.core.math.QuaternionProjection(this.field, null, this.symmAxis.getOffset().scale(this.field['createPower$int'](-5)));
            const blue: com.vzome.core.math.symmetry.Direction = this.symm.getDirection("blue");
            const green: com.vzome.core.math.symmetry.Direction = this.symm.getDirection("green");
            for(let k: number = 0; k < 12; k++) {{
                const A1: com.vzome.core.algebra.AlgebraicVector = blue.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, (k + 2) % 12).normal();
                const A2: com.vzome.core.algebra.AlgebraicVector = green.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, (5 * k + 2) % 12).normal();
                const B1: com.vzome.core.algebra.AlgebraicVector = green.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, (k + 2) % 12).normal();
                const B2: com.vzome.core.algebra.AlgebraicVector = blue.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, (5 * k + 5) % 12).normal();
                let projected: com.vzome.core.algebra.AlgebraicVector = this.symm.getField().origin(4);
                projected.setComponent(0, A2.getComponent(0));
                projected.setComponent(1, A2.getComponent(1));
                projected.setComponent(2, A1.getComponent(0));
                projected.setComponent(3, A1.getComponent(1));
                if (this.proj != null)projected = this.proj.projectImage(projected, true);
                let p: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(projected.scale(this.field['createPower$int'](5)));
                p.setIndex(k);
                this.manifestConstruction(p);
                projected = this.symm.getField().origin(4);
                projected.setComponent(0, B2.getComponent(0));
                projected.setComponent(1, B2.getComponent(1));
                projected.setComponent(2, B1.getComponent(0));
                projected.setComponent(3, B1.getComponent(1));
                if (this.proj != null)projected = this.proj.projectImage(projected, true);
                p = new com.vzome.core.construction.FreePoint(projected.scale(this.field['createPower$int'](5)));
                p.setIndex(12 + k);
                this.manifestConstruction(p);
            };}
            this.redo();
        }
    }
    GhostSymmetry24Cell["__class"] = "com.vzome.core.edits.GhostSymmetry24Cell";

}
namespace com.vzome.core.edits {
    export class JoinPoints extends com.vzome.core.editor.api.ChangeManifestations {
        joinMode: JoinPoints.JoinModeEnum;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            this.joinMode = JoinPoints.JoinModeEnum.CLOSED_LOOP;
        }

        /**
         * 
         * @return {boolean}
         */
        groupingAware(): boolean {
            return true;
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
            const mode: string = <string>props.get("mode");
            if (mode != null)this.joinMode = /* Enum.valueOf */<any>JoinPoints.JoinModeEnum[mode];
        }

        public static ATTRNAME_CLOSEDLOOP: string = "closedLoop";

        public static ATTRNAME_JOINMODE: string = "joinMode";

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            if (this.joinMode === JoinPoints.JoinModeEnum.CLOSED_LOOP){
            } else {
                element.setAttribute(JoinPoints.ATTRNAME_CLOSEDLOOP, "false");
                if (this.joinMode !== JoinPoints.JoinModeEnum.CHAIN_BALLS)element.setAttribute(JoinPoints.ATTRNAME_JOINMODE, /* Enum.name */com.vzome.core.edits.JoinPoints.JoinModeEnum[this.joinMode]);
            }
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            let attr: string = xml.getAttribute(JoinPoints.ATTRNAME_JOINMODE);
            if (attr != null && !/* isEmpty */(attr.length === 0)){
                this.joinMode = /* Enum.valueOf */<any>JoinPoints.JoinModeEnum[attr];
            } else {
                attr = xml.getAttribute(JoinPoints.ATTRNAME_CLOSEDLOOP);
                if (attr != null && !/* isEmpty */(attr.length === 0)){
                    this.joinMode = javaemul.internal.BooleanHelper.parseBoolean(attr) ? JoinPoints.JoinModeEnum.CLOSED_LOOP : JoinPoints.JoinModeEnum.CHAIN_BALLS;
                } else {
                    this.joinMode = JoinPoints.JoinModeEnum.CLOSED_LOOP;
                }
            }
        }

        /**
         * 
         */
        public perform() {
            const inputs: java.util.ArrayList<com.vzome.core.construction.Point> = <any>(new java.util.ArrayList<any>());
            if (this.joinMode !== JoinPoints.JoinModeEnum.ALL_POSSIBLE)this.setOrderedSelection(true);
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        inputs.add(<com.vzome.core.construction.Point>(<com.vzome.core.model.Connector><any>man).getFirstConstruction());
                    }
                    this.unselect$com_vzome_core_model_Manifestation(man);
                }
            }
            this.redo();
            const last: number = inputs.size() - 1;
            if (last > 0){
                const points: com.vzome.core.construction.Point[] = inputs.toArray<any>([]);
                switch((this.joinMode)) {
                case com.vzome.core.edits.JoinPoints.JoinModeEnum.CHAIN_BALLS:
                    for(let i: number = 0; i < last; i++) {{
                        this.addSegment(points, i, i + 1);
                    };}
                    break;
                case com.vzome.core.edits.JoinPoints.JoinModeEnum.CLOSED_LOOP:
                    for(let i: number = 0; i < last; i++) {{
                        this.addSegment(points, i, i + 1);
                    };}
                    if (last > 1){
                        this.addSegment(points, last, 0);
                    }
                    break;
                case com.vzome.core.edits.JoinPoints.JoinModeEnum.ALL_TO_FIRST:
                    for(let i: number = 1; i <= last; i++) {{
                        this.addSegment(points, 0, i);
                    };}
                    break;
                case com.vzome.core.edits.JoinPoints.JoinModeEnum.ALL_TO_LAST:
                    for(let i: number = 0; i < last; i++) {{
                        this.addSegment(points, i, last);
                    };}
                    break;
                case com.vzome.core.edits.JoinPoints.JoinModeEnum.ALL_POSSIBLE:
                    for(let start: number = 0; start < last; start++) {{
                        for(let end: number = start + 1; end <= last; end++) {{
                            this.addSegment(points, start, end);
                        };}
                    };}
                    break;
                default:
                    throw new com.vzome.core.commands.Command.Failure("Unsupported JoinModeEnum: " + /* Enum.name */com.vzome.core.edits.JoinPoints.JoinModeEnum[this.joinMode]);
                }
                this.redo();
            }
        }

        addSegment(points: com.vzome.core.construction.Point[], start: number, end: number) {
            if ((start !== end) && !(points[start].getLocation().equals(points[end].getLocation()))){
                const segment: com.vzome.core.construction.Segment = new com.vzome.core.construction.SegmentJoiningPoints(points[start], points[end]);
                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(segment));
            }
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "JoinPoints";
        }
    }
    JoinPoints["__class"] = "com.vzome.core.edits.JoinPoints";


    export namespace JoinPoints {

        export enum JoinModeEnum {
            CHAIN_BALLS, CLOSED_LOOP, ALL_TO_FIRST, ALL_TO_LAST, ALL_POSSIBLE
        }
    }

}
namespace com.vzome.core.edits {
    export class ShowNormals extends com.vzome.core.editor.api.ChangeManifestations {
        public static NAME: string = "ShowNormals";

        /**
         * 
         */
        public perform() {
            const SCALE_DOWN: com.vzome.core.algebra.AlgebraicNumber = this.mManifestations.getField()['createAlgebraicNumber$int$int$int$int'](1, 0, 2, -3);
            this.unselectConnectors();
            this.unselectStruts();
            for(let index=com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable(this.mSelection).iterator();index.hasNext();) {
                let panel = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation(panel);
                    const centroid: com.vzome.core.algebra.AlgebraicVector = panel.getCentroid();
                    const tip: com.vzome.core.algebra.AlgebraicVector = centroid.plus(panel['getNormal$']().scale(SCALE_DOWN));
                    const p1: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(centroid);
                    const p2: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(tip);
                    const s: com.vzome.core.construction.Segment = new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p1));
                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p2));
                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(s));
                }
            }
            this.redo();
        }

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return ShowNormals.NAME;
        }
    }
    ShowNormals["__class"] = "com.vzome.core.edits.ShowNormals";

}
namespace com.vzome.core.edits {
    export class JoinPointPair extends com.vzome.core.editor.api.ChangeManifestations {
        /*private*/ start: com.vzome.core.construction.Point;

        /*private*/ end: com.vzome.core.construction.Point;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            if (this.start === undefined) { this.start = null; }
            if (this.end === undefined) { this.end = null; }
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
            this.start = <com.vzome.core.construction.Point>props.get("start");
            this.end = <com.vzome.core.construction.Point>props.get("end");
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            com.vzome.core.commands.XmlSaveFormat.serializePoint(element, "start", this.start);
            com.vzome.core.commands.XmlSaveFormat.serializePoint(element, "end", this.end);
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            this.start = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "start");
            this.end = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "end");
        }

        /**
         * 
         */
        public perform() {
            if ((this.start !== this.end) && !(this.start.getLocation().equals(this.end.getLocation()))){
                const segment: com.vzome.core.construction.Segment = new com.vzome.core.construction.SegmentJoiningPoints(this.start, this.end);
                this.manifestConstruction(segment);
            }
            this.redo();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "JoinPointPair";
        }
    }
    JoinPointPair["__class"] = "com.vzome.core.edits.JoinPointPair";

}
namespace com.vzome.core.edits {
    export class Label extends com.vzome.core.editor.api.ChangeManifestations {
        /*private*/ target: com.vzome.core.model.Manifestation;

        /*private*/ label: string;

        public constructor(editorModel: com.vzome.core.editor.api.EditorModel) {
            super(editorModel);
            if (this.target === undefined) { this.target = null; }
            if (this.label === undefined) { this.label = null; }
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
            this.target = <com.vzome.core.model.Manifestation><any>props.get("picked");
            this.label = <string>props.get("text");
        }

        /**
         * 
         */
        public perform() {
            this.labelManifestation(this.target, this.label);
            super.perform();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "Label";
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            const construction: com.vzome.core.construction.Construction = this.target.getFirstConstruction();
            if (construction != null && construction instanceof <any>com.vzome.core.construction.Point)com.vzome.core.commands.XmlSaveFormat.serializePoint(element, "point", <com.vzome.core.construction.Point>construction); else if (construction != null && construction instanceof <any>com.vzome.core.construction.Segment)com.vzome.core.commands.XmlSaveFormat.serializeSegment(element, "startSegment", "endSegment", <com.vzome.core.construction.Segment>construction); else if (construction != null && construction instanceof <any>com.vzome.core.construction.Polygon)com.vzome.core.commands.XmlSaveFormat.serializePolygon(element, "polygonVertex", <com.vzome.core.construction.Polygon>construction);
            element.setAttribute("text", this.label);
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            this.label = xml.getAttribute("text");
            let construction: com.vzome.core.construction.Construction = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "point");
            if (construction == null)construction = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "startSegment", "endSegment");
            if (construction == null)construction = format.parsePolygon$org_w3c_dom_Element$java_lang_String(xml, "polygonVertex");
            if (construction != null)this.target = this.getManifestation(construction);
        }
    }
    Label["__class"] = "com.vzome.core.edits.Label";

}
namespace com.vzome.core.edits {
    export class ShowPoint extends com.vzome.core.editor.api.ChangeManifestations {
        /*private*/ point: com.vzome.core.construction.Point;

        /*private*/ parameters: com.vzome.core.editor.api.ImplicitSymmetryParameters;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            if (this.point === undefined) { this.point = null; }
            if (this.parameters === undefined) { this.parameters = null; }
            this.parameters = <com.vzome.core.editor.api.ImplicitSymmetryParameters><any>editor;
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
            switch((<string>props.get("mode"))) {
            case "origin":
                const origin: com.vzome.core.algebra.AlgebraicVector = this.mManifestations.getField().origin(3);
                this.point = new com.vzome.core.construction.FreePoint(origin);
                break;
            case "symmCenter":
                this.point = this.parameters.getCenterPoint();
                break;
            }
        }

        /**
         * 
         */
        public perform() {
            this.manifestConstruction(this.point);
            this.redo();
        }

        /**
         * 
         * @param {*} xml
         */
        public getXmlAttributes(xml: org.w3c.dom.Element) {
            com.vzome.core.commands.XmlSaveFormat.serializePoint(xml, "point", this.point);
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        public setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            if (format.commandEditsCompacted())this.point = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "point"); else {
                const attrs: com.vzome.core.commands.AttributeMap = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                this.point = <com.vzome.core.construction.Point>attrs.get("point");
            }
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "ShowPoint";
        }
    }
    ShowPoint["__class"] = "com.vzome.core.edits.ShowPoint";

}
namespace com.vzome.core.edits {
    /**
     * This is only used when opening legacy files.  The UI and controllers now use the generic Polytope4d.
     * @author Scott Vorthmann
     * @param {*} editorModel
     * @param {com.vzome.core.construction.Segment} symmAxis
     * @param {number} index
     * @class
     * @extends com.vzome.core.editor.api.ChangeManifestations
     */
    export class B4Polytope extends com.vzome.core.editor.api.ChangeManifestations {
        /*private*/ index: number;

        /*private*/ proj: com.vzome.core.math.Projection;

        /*private*/ symmAxis: com.vzome.core.construction.Segment;

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        public constructor(editorModel?: any, symmAxis?: any, index?: any) {
            if (((editorModel != null && (editorModel.constructor != null && editorModel.constructor["__interfaces"] != null && editorModel.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editorModel === null) && ((symmAxis != null && symmAxis instanceof <any>com.vzome.core.construction.Segment) || symmAxis === null) && ((typeof index === 'number') || index === null)) {
                let __args = arguments;
                super(editorModel);
                if (this.index === undefined) { this.index = 0; } 
                if (this.proj === undefined) { this.proj = null; } 
                if (this.symmAxis === undefined) { this.symmAxis = null; } 
                if (this.field === undefined) { this.field = null; } 
                this.field = this.mManifestations.getField();
                this.index = index;
                this.symmAxis = symmAxis;
            } else if (((editorModel != null && (editorModel.constructor != null && editorModel.constructor["__interfaces"] != null && editorModel.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editorModel === null) && symmAxis === undefined && index === undefined) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let symmAxis: any = null;
                    let index: any = 0;
                    super(editorModel);
                    if (this.index === undefined) { this.index = 0; } 
                    if (this.proj === undefined) { this.proj = null; } 
                    if (this.symmAxis === undefined) { this.symmAxis = null; } 
                    if (this.field === undefined) { this.field = null; } 
                    this.field = this.mManifestations.getField();
                    this.index = index;
                    this.symmAxis = symmAxis;
                }
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "B4Polytope";
        }

        /**
         * 
         * @param {*} result
         */
        public getXmlAttributes(result: org.w3c.dom.Element) {
            com.vzome.xml.DomUtils.addAttribute(result, "dynkin", com.vzome.xml.DomUtils.byteToBinary(this.index));
            if (this.symmAxis != null)com.vzome.core.commands.XmlSaveFormat.serializeSegment(result, "start", "end", this.symmAxis);
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        public setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            const binary: string = xml.getAttribute("dynkin");
            this.index = javaemul.internal.IntegerHelper.parseInt(binary, 2);
            if (format.commandEditsCompacted())this.symmAxis = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "start", "end"); else {
                const attrs: com.vzome.core.commands.AttributeMap = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                this.symmAxis = <com.vzome.core.construction.Segment>attrs.get("rotation");
            }
        }

        /**
         * 
         */
        public perform() {
            if (this.symmAxis == null)this.proj = new com.vzome.core.math.Projection.Default(this.field); else {
                const scale: com.vzome.core.algebra.AlgebraicNumber = this.field['createPower$int'](-5);
                this.proj = new com.vzome.core.math.QuaternionProjection(this.field, null, this.symmAxis.getOffset().scale(scale));
            }
            const edgeScales: com.vzome.core.algebra.AlgebraicNumber[] = [null, null, null, null];
            for(let i: number = 0; i < edgeScales.length; i++) {{
                edgeScales[i] = this.field.one();
            };}
            const group: com.vzome.core.math.symmetry.CoxeterGroup = new com.vzome.core.math.symmetry.B4Group(this.field);
            com.vzome.core.math.symmetry.WythoffConstruction.constructPolytope(group, this.index, this.index, edgeScales, group, new B4Polytope.WythoffListener(this, this.field));
            this.redo();
        }
    }
    B4Polytope["__class"] = "com.vzome.core.edits.B4Polytope";


    export namespace B4Polytope {

        export class WythoffListener implements com.vzome.core.math.symmetry.WythoffConstruction.Listener {
            public __parent: any;
            numVertices: number;

            scale: com.vzome.core.algebra.AlgebraicNumber;

            public constructor(__parent: any, field: com.vzome.core.algebra.AlgebraicField) {
                this.__parent = __parent;
                this.numVertices = 0;
                if (this.scale === undefined) { this.scale = null; }
                this.scale = field['createPower$int'](5);
            }

            /**
             * 
             * @param {*} p1
             * @param {*} p2
             * @return {*}
             */
            public addEdge(p1: any, p2: any): any {
                const edge: com.vzome.core.construction.Segment = new com.vzome.core.construction.SegmentJoiningPoints(<com.vzome.core.construction.Point>p1, <com.vzome.core.construction.Point>p2);
                this.__parent.manifestConstruction(edge);
                return edge;
            }

            /**
             * 
             * @param {java.lang.Object[]} vertices
             * @return {*}
             */
            public addFace(vertices: any[]): any {
                return null;
            }

            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} vertex
             * @return {*}
             */
            public addVertex(vertex: com.vzome.core.algebra.AlgebraicVector): any {
                let projected: com.vzome.core.algebra.AlgebraicVector = vertex;
                if (this.__parent.proj != null)projected = this.__parent.proj.projectImage(vertex, true);
                const p: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(projected.scale(this.scale));
                p.setIndex(this.numVertices++);
                this.__parent.manifestConstruction(p);
                return p;
            }
        }
        WythoffListener["__class"] = "com.vzome.core.edits.B4Polytope.WythoffListener";
        WythoffListener["__interfaces"] = ["com.vzome.core.math.symmetry.WythoffConstruction.Listener"];


    }

}
namespace com.vzome.core.edits {
    export class CrossProduct extends com.vzome.core.editor.api.ChangeManifestations {
        /**
         * 
         */
        public perform() {
            let p1: com.vzome.core.construction.Point = null;
            let p2: com.vzome.core.construction.Point = null;
            let s1: com.vzome.core.construction.Segment = null;
            let success: boolean = false;
            this.setOrderedSelection(true);
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (success){
                        this.recordSelected(man);
                    } else {
                        this.unselect$com_vzome_core_model_Manifestation(man);
                        if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                            const nextPoint: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>(<com.vzome.core.model.Connector><any>man).getFirstConstruction();
                            if (p1 == null){
                                p1 = nextPoint;
                            } else if (s1 == null){
                                p2 = nextPoint;
                                s1 = new com.vzome.core.construction.SegmentJoiningPoints(p1, nextPoint);
                            } else if (!success){
                                let segment: com.vzome.core.construction.Segment = new com.vzome.core.construction.SegmentJoiningPoints(p2, nextPoint);
                                segment = new com.vzome.core.construction.SegmentCrossProduct(s1, segment);
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(segment));
                                const endpt: com.vzome.core.construction.Point = new com.vzome.core.construction.SegmentEndPoint(segment);
                                this.manifestConstruction(endpt);
                                success = true;
                            } else this.recordSelected(man);
                        }
                    }
                }
            }
            if (!success)throw new com.vzome.core.commands.Command.Failure("cross-product requires three selected vertices");
            this.redo();
        }

        public constructor(editorModel: com.vzome.core.editor.api.EditorModel) {
            super(editorModel);
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "CrossProduct";
        }
    }
    CrossProduct["__class"] = "com.vzome.core.edits.CrossProduct";

}
namespace com.vzome.core.edits {
    export class ShowHidden extends com.vzome.core.editor.api.ChangeManifestations {
        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
        }

        /**
         * 
         */
        public perform() {
            for(let index=this.mManifestations.iterator();index.hasNext();) {
                let m = index.next();
                {
                    if (m.isHidden()){
                        this.showManifestation(m);
                        this.select$com_vzome_core_model_Manifestation(m);
                    } else if (this.mSelection.manifestationSelected(m))this.unselect$com_vzome_core_model_Manifestation(m);
                }
            }
            this.redo();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "ShowHidden";
        }
    }
    ShowHidden["__class"] = "com.vzome.core.edits.ShowHidden";

}
namespace com.vzome.core.edits {
    export class HeptagonSubdivision extends com.vzome.core.editor.api.ChangeManifestations {
        /**
         * 
         */
        public perform() {
            let p1: com.vzome.core.construction.Point = null;
            this.setOrderedSelection(true);
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        const nextPoint: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>(<com.vzome.core.model.Connector><any>man).getFirstConstruction();
                        if (p1 == null)p1 = nextPoint; else {
                            const segment: com.vzome.core.construction.Segment = new com.vzome.core.construction.SegmentJoiningPoints(p1, nextPoint);
                            const field: com.vzome.core.algebra.AlgebraicField = segment.getField();
                            const scaleFactor: com.vzome.core.algebra.AlgebraicNumber = field.getAffineScalar().reciprocal();
                            const offset: com.vzome.core.algebra.AlgebraicVector = segment.getOffset();
                            const off2: com.vzome.core.algebra.AlgebraicVector = offset.scale(scaleFactor);
                            const off1: com.vzome.core.algebra.AlgebraicVector = off2.scale(scaleFactor);
                            const v1: com.vzome.core.algebra.AlgebraicVector = p1.getLocation().plus(off1);
                            const firstPoint: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(v1);
                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(firstPoint));
                            const v2: com.vzome.core.algebra.AlgebraicVector = v1.plus(off2);
                            const secondPoint: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(v2);
                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(secondPoint));
                            break;
                        }
                    }
                }
            }
            this.redo();
        }

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "HeptagonSubdivision";
        }
    }
    HeptagonSubdivision["__class"] = "com.vzome.core.edits.HeptagonSubdivision";

}
namespace com.vzome.core.edits {
    export class PolarZonohedron extends com.vzome.core.editor.api.ChangeManifestations {
        /*private*/ symmetry: com.vzome.core.editor.api.OrbitSource;

        /*private*/ editor: com.vzome.core.editor.api.EditorModel;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            if (this.symmetry === undefined) { this.symmetry = null; }
            if (this.editor === undefined) { this.editor = null; }
            this.editor = editor;
            this.symmetry = (<com.vzome.core.editor.api.SymmetryAware><any>editor)['getSymmetrySystem$']();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "PolarZonohedron";
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            if (this.symmetry != null){
                com.vzome.xml.DomUtils.addAttribute(element, "symmetry", this.symmetry.getName());
            }
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            this.symmetry = (<com.vzome.core.editor.api.SymmetryAware><any>this.editor)['getSymmetrySystem$java_lang_String'](xml.getAttribute("symmetry"));
        }

        /**
         * 
         */
        public perform() {
            const errorMsg: java.lang.StringBuilder = new java.lang.StringBuilder();
            errorMsg.append("The Polar Zonohedron command requires either of the following selections:\n\n1) Two non-collinear struts with a common end point.\n   The first strut must have more than 2-fold rotational symmetry.\n   The second strut will be rotated around the first.\n\n2) Any three or more struts having a common end point.\n");
            const struts: java.util.List<com.vzome.core.model.Strut> = <any>(new java.util.ArrayList<any>());
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        struts.add(<com.vzome.core.model.Strut><any>man);
                    }
                    this.unselect$com_vzome_core_model_Manifestation(man);
                }
            }
            if (struts.size() < 2){
                errorMsg.append(struts.size() === 1 ? "\nonly one strut is selected." : "\nno struts are selected.");
                this.fail(errorMsg.toString());
            }
            const common: com.vzome.core.algebra.AlgebraicVector = struts.size() === 2 ? this.useRotationalSymmetry(struts, errorMsg) : this.useRadialSelection(struts);
            if (common == null){
                this.fail(errorMsg.append("\nselected struts do not have a common end point").toString());
            }
            const L1: number = 0;
            const L2: number = 1;
            const layers: number = struts.size();
            const offsets: java.util.List<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>(layers));
            const vertices: com.vzome.core.algebra.AlgebraicVector[][] = [null, null];
            vertices[L1] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(layers);
            for(let i: number = 0; i < layers; i++) {{
                const strut: com.vzome.core.model.Strut = struts.get(i);
                const start: com.vzome.core.algebra.AlgebraicVector = strut.getLocation();
                const end: com.vzome.core.algebra.AlgebraicVector = strut.getEnd();
                const offset: com.vzome.core.algebra.AlgebraicVector = strut.getOffset();
                if (start.equals(common)){
                    vertices[L1][i] = end;
                    offsets.add(offset);
                } else {
                    vertices[L1][i] = start;
                    offsets.add(offset.negate());
                }
            };}
            for(let layer: number = 1; layer < layers; layer++) {{
                vertices[L2] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(layers);
                for(let i: number = 0; i < layers; i++) {{
                    const off: number = (i + layer) % layers;
                    const offset: com.vzome.core.algebra.AlgebraicVector = offsets.get(off);
                    const v1: com.vzome.core.algebra.AlgebraicVector = vertices[L1][i];
                    const v2: com.vzome.core.algebra.AlgebraicVector = v1.plus(offset);
                    const v3: com.vzome.core.algebra.AlgebraicVector = vertices[L1][(i + 1) % layers];
                    const v0: com.vzome.core.algebra.AlgebraicVector = v3.minus(offset);
                    vertices[L2][i] = v2;
                    const p0: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(v0);
                    const p1: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(v1);
                    const p2: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(v2);
                    const p3: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(v3);
                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p0));
                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p1));
                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p2));
                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p3));
                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p1, p2)));
                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p2, p3)));
                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p0, p1, p2, p3])));
                };}
                vertices[L1] = vertices[L2];
            };}
            this.redo();
        }

        public static getCommonEndpoint(strut1: com.vzome.core.model.Strut, strut2: com.vzome.core.model.Strut): com.vzome.core.algebra.AlgebraicVector {
            if (/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(strut1,strut2))){
                throw new java.lang.IllegalArgumentException("Identical struts have both end points in common.");
            }
            const start1: com.vzome.core.algebra.AlgebraicVector = strut1.getLocation();
            const end1: com.vzome.core.algebra.AlgebraicVector = strut1.getEnd();
            const start2: com.vzome.core.algebra.AlgebraicVector = strut2.getLocation();
            const end2: com.vzome.core.algebra.AlgebraicVector = strut2.getEnd();
            if (start1.equals(start2) || start1.equals(end2))return start1;
            if (end1.equals(start2) || end1.equals(end2))return end1;
            return null;
        }

        /*private*/ useRotationalSymmetry(struts: java.util.List<com.vzome.core.model.Strut>, errorMsg: java.lang.StringBuilder): com.vzome.core.algebra.AlgebraicVector {
            const axisStrut: com.vzome.core.model.Strut = struts.get(0);
            const axisSegment: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>axisStrut.getFirstConstruction();
            let v1: com.vzome.core.algebra.AlgebraicVector = axisSegment.getOffset();
            v1 = axisSegment.getField().projectTo3d(v1, true);
            const axis1: com.vzome.core.math.symmetry.Axis = this.symmetry.getAxis(v1);
            if (axis1 == null){
                this.fail(errorMsg.append("\nfirst selected strut is not an axis of rotational symmetry").toString());
            }
            const perm: com.vzome.core.math.symmetry.Permutation = axis1.getRotationPermutation();
            if (perm == null){
                this.fail(errorMsg.append("\nfirst selected strut is not an axis of rotation").toString());
            }
            let rotation: number = perm.mapIndex(0);
            const order: number = perm.getOrder();
            if (order <= 2){
                this.fail(errorMsg.append("\nfirst selected strut has " + order + "-fold symmetry").toString());
            }
            const spokeStrut: com.vzome.core.model.Strut = struts.get(1);
            const spokeSegment: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>spokeStrut.getFirstConstruction();
            let v2: com.vzome.core.algebra.AlgebraicVector = spokeSegment.getOffset();
            if (v1.equals(v2) || v1.equals(v2.negate())){
                this.fail(errorMsg.append("\nselected struts are collinear").toString());
            }
            const common: com.vzome.core.algebra.AlgebraicVector = PolarZonohedron.getCommonEndpoint(axisStrut, spokeStrut);
            if (common == null){
                this.fail(errorMsg.append("\nselected struts do not have a common end point").toString());
            }
            let s1: com.vzome.core.algebra.AlgebraicVector = axisSegment.getStart();
            let e1: com.vzome.core.algebra.AlgebraicVector = axisSegment.getEnd();
            const center: com.vzome.core.construction.Point = new com.vzome.core.construction.SegmentEndPoint(axisSegment, common.equals(e1));
            let s2: com.vzome.core.algebra.AlgebraicVector = spokeSegment.getStart();
            let e2: com.vzome.core.algebra.AlgebraicVector = spokeSegment.getEnd();
            if (common.equals(s1)){
                if (common.equals(e2)){
                    v2 = v2.negate();
                    e2 = s2;
                    s2 = common;
                }
            } else {
                v1 = v1.negate();
                e1 = s1;
                s1 = common;
                if (common.equals(e2)){
                    v2 = v2.negate();
                    e2 = s2;
                    s2 = common;
                }
            }
            this.redo();
            struts.remove(axisStrut);
            this.select$com_vzome_core_model_Manifestation(spokeStrut);
            const p0: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(s2);
            const p1: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(e2);
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p0));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p1));
            for(let i: number = 0; i < order - 1; i++) {{
                const transform: com.vzome.core.construction.Transformation = new com.vzome.core.construction.SymmetryTransformation(this.symmetry.getSymmetry(), rotation, center);
                rotation = perm.mapIndex(rotation);
                const ball: com.vzome.core.model.Connector = <com.vzome.core.model.Connector><any>this.manifestConstruction(new com.vzome.core.construction.TransformedPoint(transform, p1));
                const strut: com.vzome.core.model.Strut = <com.vzome.core.model.Strut><any>this.manifestConstruction(new com.vzome.core.construction.TransformedSegment(transform, spokeSegment));
                struts.add(strut);
                this.select$com_vzome_core_model_Manifestation(ball);
                this.select$com_vzome_core_model_Manifestation(strut);
            };}
            this.redo();
            return common;
        }

        /*private*/ useRadialSelection(struts: java.util.List<com.vzome.core.model.Strut>): com.vzome.core.algebra.AlgebraicVector {
            const first: com.vzome.core.model.Strut = struts.get(0);
            const common: com.vzome.core.algebra.AlgebraicVector = PolarZonohedron.getCommonEndpoint(first, struts.get(1));
            if (common == null){
                return null;
            }
            for(let i: number = 1; i < struts.size(); i++) {{
                if (!common.equals(PolarZonohedron.getCommonEndpoint(first, struts.get(i)))){
                    return null;
                }
            };}
            this.redo();
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.FreePoint(common)));
            for(let index=struts.iterator();index.hasNext();) {
                let strut = index.next();
                {
                    this.select$com_vzome_core_model_Manifestation(strut);
                    const start: com.vzome.core.algebra.AlgebraicVector = strut.getLocation();
                    if (common.equals(start)){
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.FreePoint(strut.getEnd())));
                    } else {
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.FreePoint(start)));
                    }
                }
            }
            this.redo();
            return common;
        }
    }
    PolarZonohedron["__class"] = "com.vzome.core.edits.PolarZonohedron";

}
namespace com.vzome.core.edits {
    export class TransformSelection extends com.vzome.core.editor.api.ChangeManifestations {
        transform: com.vzome.core.construction.Transformation;

        public constructor(editor: com.vzome.core.editor.api.EditorModel, transform: com.vzome.core.construction.Transformation) {
            super(editor);
            if (this.transform === undefined) { this.transform = null; }
            this.transform = transform;
        }

        /**
         * 
         */
        public perform() {
            const inputs: java.util.List<com.vzome.core.model.Manifestation> = <any>(new java.util.ArrayList<any>());
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation(man);
                    inputs.add(man);
                }
            }
            this.redo();
            for(let index=inputs.iterator();index.hasNext();) {
                let m = index.next();
                {
                    if (!m.isRendered())continue;
                    const c: com.vzome.core.construction.Construction = m.getFirstConstruction();
                    const result: com.vzome.core.construction.Construction = this.transform.transform$com_vzome_core_construction_Construction(c);
                    this.select$com_vzome_core_model_Manifestation$boolean(this.manifestConstruction(result), true);
                }
            }
            this.redo();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "TransformSelection";
        }
    }
    TransformSelection["__class"] = "com.vzome.core.edits.TransformSelection";

}
namespace com.vzome.core.edits {
    /**
     * This is a modern replacement for CommandQuaternionSymmetry, which is a legacy command.
     * It duplicates the math from that command, but one key change: only parameter objects that lie
     * in the W=0 plane are transformed.  This makes it safe and predictable to use
     * on objects produced by Polytope4d, which retain their 4D coordinates.
     * 
     * As with CommandQuaternionSymmetry, all transformed vertices are projected to the W=0 plane
     * before being added to the model.
     * 
     * @author vorth
     * @param {*} editor
     * @param {com.vzome.core.math.symmetry.QuaternionicSymmetry} left
     * @param {com.vzome.core.math.symmetry.QuaternionicSymmetry} right
     * @class
     * @extends com.vzome.core.editor.api.ChangeManifestations
     */
    export class Symmetry4d extends com.vzome.core.editor.api.ChangeManifestations {
        /*private*/ left: com.vzome.core.math.symmetry.QuaternionicSymmetry;

        /*private*/ right: com.vzome.core.math.symmetry.QuaternionicSymmetry;

        public constructor(editor?: any, left?: any, right?: any) {
            if (((editor != null && (editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editor === null) && ((left != null && left instanceof <any>com.vzome.core.math.symmetry.QuaternionicSymmetry) || left === null) && ((right != null && right instanceof <any>com.vzome.core.math.symmetry.QuaternionicSymmetry) || right === null)) {
                let __args = arguments;
                super(editor);
                if (this.left === undefined) { this.left = null; } 
                if (this.right === undefined) { this.right = null; } 
                this.left = left;
                this.right = right;
            } else if (((editor != null && (editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editor === null) && left === undefined && right === undefined) {
                let __args = arguments;
                super(editor);
                if (this.left === undefined) { this.left = null; } 
                if (this.right === undefined) { this.right = null; } 
                this.left = (<com.vzome.core.editor.api.SymmetryAware><any>editor).get4dSymmetries().getQuaternionSymmetry("H_4");
                this.right = this.left;
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {*} parameters
         */
        public configure(parameters: java.util.Map<string, any>) {
            this.left = <com.vzome.core.math.symmetry.QuaternionicSymmetry>parameters.get("left");
            this.right = <com.vzome.core.math.symmetry.QuaternionicSymmetry>parameters.get("right");
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "Symmetry4d";
        }

        /*private*/ static inW0hyperplane(v: com.vzome.core.algebra.AlgebraicVector): boolean {
            if (v.dimension() > 3)return v.getComponent(com.vzome.core.algebra.AlgebraicVector.W4).isZero(); else return true;
        }

        /**
         * 
         */
        public perform() {
            const params: java.util.List<com.vzome.core.construction.Construction> = <any>(new java.util.ArrayList<any>());
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation(man);
                    const cs: java.util.Iterator<com.vzome.core.construction.Construction> = man.getConstructions();
                    let useThis: com.vzome.core.construction.Construction = null;
                    if (!cs.hasNext())throw new com.vzome.core.commands.Command.Failure("No construction for this manifestation");
                    for(const iterator: java.util.Iterator<com.vzome.core.construction.Construction> = man.getConstructions(); iterator.hasNext(); ) {{
                        const construction: com.vzome.core.construction.Construction = iterator.next();
                        if (construction != null && construction instanceof <any>com.vzome.core.construction.Point){
                            const p: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>construction;
                            if (!Symmetry4d.inW0hyperplane(p.getLocation()))throw new com.vzome.core.commands.Command.Failure("Some ball is not in the W=0 hyperplane.");
                        } else if (construction != null && construction instanceof <any>com.vzome.core.construction.Segment){
                            const s: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>construction;
                            if (!Symmetry4d.inW0hyperplane(s.getStart()))throw new com.vzome.core.commands.Command.Failure("Some strut end is not in the W=0 hyperplane.");
                            if (!Symmetry4d.inW0hyperplane(s.getEnd()))throw new com.vzome.core.commands.Command.Failure("Some strut end is not in the W=0 hyperplane.");
                        } else if (construction != null && construction instanceof <any>com.vzome.core.construction.Polygon){
                            const p: com.vzome.core.construction.Polygon = <com.vzome.core.construction.Polygon>construction;
                            for(let i: number = 0; i < p.getVertexCount(); i++) {{
                                if (!Symmetry4d.inW0hyperplane(p.getVertex(i))){
                                    throw new com.vzome.core.commands.Command.Failure("Some panel vertex is not in the W=0 hyperplane.");
                                }
                            };}
                        } else {
                            throw new com.vzome.core.commands.Command.Failure("Unknown construction type.");
                        }
                        useThis = construction;
                    };}
                    if (useThis != null)params.add(useThis);
                }
            }
            this.redo();
            const leftRoots: com.vzome.core.algebra.Quaternion[] = this.left.getRoots();
            const rightRoots: com.vzome.core.algebra.Quaternion[] = this.right.getRoots();
            for(let index = 0; index < leftRoots.length; index++) {
                let leftRoot = leftRoots[index];
                {
                    for(let index1 = 0; index1 < rightRoots.length; index1++) {
                        let rightRoot = rightRoots[index1];
                        {
                            for(let index2=params.iterator();index2.hasNext();) {
                                let construction = index2.next();
                                {
                                    let result: com.vzome.core.construction.Construction = null;
                                    if (construction != null && construction instanceof <any>com.vzome.core.construction.Point){
                                        result = new com.vzome.core.construction.PointRotated4D(leftRoot, rightRoot, <com.vzome.core.construction.Point>construction);
                                    } else if (construction != null && construction instanceof <any>com.vzome.core.construction.Segment){
                                        result = new com.vzome.core.construction.SegmentRotated4D(leftRoot, rightRoot, <com.vzome.core.construction.Segment>construction);
                                    } else if (construction != null && construction instanceof <any>com.vzome.core.construction.Polygon){
                                        result = new com.vzome.core.construction.PolygonRotated4D(leftRoot, rightRoot, <com.vzome.core.construction.Polygon>construction);
                                    } else {
                                    }
                                    if (result == null)continue;
                                    this.manifestConstruction(result);
                                }
                            }
                        }
                    }
                }
            }
            this.redo();
        }

        rotateAndProject(loc3d: com.vzome.core.algebra.AlgebraicVector, leftQuaternion: com.vzome.core.algebra.Quaternion, rightQuaternion: com.vzome.core.algebra.Quaternion): com.vzome.core.construction.FreePoint {
            let loc: com.vzome.core.algebra.AlgebraicVector = loc3d.inflateTo4d$boolean(true);
            loc = rightQuaternion.leftMultiply(loc);
            loc = leftQuaternion.rightMultiply(loc);
            loc = loc.projectTo3d(true);
            return new com.vzome.core.construction.FreePoint(loc);
        }
    }
    Symmetry4d["__class"] = "com.vzome.core.edits.Symmetry4d";

}
namespace com.vzome.core.edits {
    /**
     * @author David Hall
     * @param {*} editorModel
     * @class
     * @extends com.vzome.core.editor.api.ChangeManifestations
     */
    export class AffineHeptagon extends com.vzome.core.editor.api.ChangeManifestations {
        /**
         * 
         */
        public perform() {
            const errorMsg: string = "Affine heptagon command requires two selected struts with a common vertex.";
            let strut1: com.vzome.core.model.Strut = null;
            let strut2: com.vzome.core.model.Strut = null;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        if (strut1 == null){
                            strut1 = <com.vzome.core.model.Strut><any>man;
                        } else if (strut2 == null){
                            strut2 = <com.vzome.core.model.Strut><any>man;
                        } else {
                            this.fail(errorMsg);
                        }
                    }
                }
            }
            if (strut1 == null || strut2 == null){
                this.fail(errorMsg);
            }
            const field: com.vzome.core.algebra.AlgebraicField = strut1.getLocation().getField();
            this.redo();
            const s1: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>strut1.getFirstConstruction();
            const s2: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>strut2.getFirstConstruction();
            this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s1, true));
            this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s1, false));
            this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s2, true));
            this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s2, false));
            this.redo();
            let offset1: com.vzome.core.algebra.AlgebraicVector = s1.getOffset();
            let offset2: com.vzome.core.algebra.AlgebraicVector = s2.getOffset();
            let v0: com.vzome.core.algebra.AlgebraicVector = null;
            let v1: com.vzome.core.algebra.AlgebraicVector = null;
            let v2: com.vzome.core.algebra.AlgebraicVector = null;
            {
                const s1s: com.vzome.core.algebra.AlgebraicVector = s1.getStart();
                const s1e: com.vzome.core.algebra.AlgebraicVector = s1.getEnd();
                const s2s: com.vzome.core.algebra.AlgebraicVector = s2.getStart();
                const s2e: com.vzome.core.algebra.AlgebraicVector = s2.getEnd();
                if (s1s.equals(s2s)){
                    v0 = s1s;
                    v1 = s1e;
                    v2 = s2e;
                } else if (s1e.equals(s2s)){
                    v0 = s1e;
                    v1 = s1s;
                    v2 = s2e;
                    offset1 = offset1.negate();
                } else if (s1e.equals(s2e)){
                    v0 = s1e;
                    v1 = s1s;
                    v2 = s2s;
                    offset2 = offset2.negate();
                    offset1 = offset1.negate();
                } else if (s1s.equals(s2e)){
                    v0 = s1s;
                    v1 = s1e;
                    v2 = s2s;
                    offset2 = offset2.negate();
                } else {
                    this.fail(errorMsg);
                }
            };
            let c0: com.vzome.core.model.Connector = null;
            let c1: com.vzome.core.model.Connector = null;
            let c2: com.vzome.core.model.Connector = null;
            let p1: com.vzome.core.construction.Point = null;
            let p2: com.vzome.core.construction.Point = null;
            for(let index=this.mManifestations.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        const loc: com.vzome.core.algebra.AlgebraicVector = man.getLocation();
                        if (loc.equals(v0)){
                            c0 = <com.vzome.core.model.Connector><any>man;
                        } else if (loc.equals(v1)){
                            c1 = <com.vzome.core.model.Connector><any>man;
                            p1 = <com.vzome.core.construction.Point>man.getFirstConstruction();
                        } else if (loc.equals(v2)){
                            c2 = <com.vzome.core.model.Connector><any>man;
                            p2 = <com.vzome.core.construction.Point>man.getFirstConstruction();
                        }
                    }
                }
            }
            const sigma: com.vzome.core.algebra.AlgebraicNumber = field['createAlgebraicNumber$int_A']([0, 0, 1]);
            const rho: com.vzome.core.algebra.AlgebraicNumber = field['createAlgebraicNumber$int_A']([0, 1, 0]);
            const p3: com.vzome.core.construction.Point = new com.vzome.core.construction.TransformedPoint(new com.vzome.core.construction.Translation(offset1.scale(sigma)), p2);
            const p4: com.vzome.core.construction.Point = new com.vzome.core.construction.TransformedPoint(new com.vzome.core.construction.Translation(offset2.scale(sigma)), p1);
            const p5: com.vzome.core.construction.Point = new com.vzome.core.construction.TransformedPoint(new com.vzome.core.construction.Translation(offset1.scale(rho)), p4);
            const p6: com.vzome.core.construction.Point = new com.vzome.core.construction.TransformedPoint(new com.vzome.core.construction.Translation(offset2.scale(rho)), p3);
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p1, p3)));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p3, p5)));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p5, p6)));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p6, p4)));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p4, p2)));
            this.select$com_vzome_core_model_Manifestation(c0);
            this.select$com_vzome_core_model_Manifestation(c1);
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p3));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p5));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p6));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p4));
            this.select$com_vzome_core_model_Manifestation(c2);
            this.redo();
        }

        public constructor(editorModel: com.vzome.core.editor.api.EditorModel) {
            super(editorModel);
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "AffineHeptagon";
        }
    }
    AffineHeptagon["__class"] = "com.vzome.core.edits.AffineHeptagon";

}
namespace com.vzome.core.edits {
    export class Polytope4d extends com.vzome.core.editor.api.ChangeManifestations {
        /*private*/ index: number;

        /*private*/ field: com.vzome.core.algebra.AlgebraicField;

        /*private*/ proj: com.vzome.core.math.Projection;

        /*private*/ quaternion: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ groupName: string;

        /*private*/ edgesToRender: number;

        /*private*/ edgeScales: com.vzome.core.algebra.AlgebraicNumber[];

        /*private*/ renderGroupName: string;

        /*private*/ symmetries: com.vzome.core.math.symmetry.Symmetries4D;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            if (this.index === undefined) { this.index = 0; }
            if (this.field === undefined) { this.field = null; }
            if (this.proj === undefined) { this.proj = null; }
            if (this.quaternion === undefined) { this.quaternion = null; }
            if (this.groupName === undefined) { this.groupName = null; }
            this.edgesToRender = 15;
            this.edgeScales = [null, null, null, null];
            if (this.renderGroupName === undefined) { this.renderGroupName = null; }
            if (this.symmetries === undefined) { this.symmetries = null; }
            this.symmetries = (<com.vzome.core.editor.api.SymmetryAware><any>editor).get4dSymmetries();
            this.field = editor.getRealizedModel().getField();
            for(let i: number = 0; i < this.edgeScales.length; i++) {{
                this.edgeScales[i] = this.field.one();
            };}
        }

        /**
         * 
         * @param {*} params
         */
        public configure(params: java.util.Map<string, any>) {
            this.groupName = <string>params.get("groupName");
            this.renderGroupName = <string>params.get("renderGroupName");
            this.index = (<number>params.get("index")|0);
            this.edgesToRender = (<number>params.get("edgesToRender")|0);
            this.edgeScales = <com.vzome.core.algebra.AlgebraicNumber[]>params.get("edgeScales");
            this.quaternion = <com.vzome.core.algebra.AlgebraicVector>params.get("quaternion");
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "Polytope4d";
        }

        /**
         * 
         * @param {*} xml
         */
        public getXmlAttributes(xml: org.w3c.dom.Element) {
            if (this.quaternion != null)com.vzome.xml.DomUtils.addAttribute(xml, "quaternion", this.quaternion.toParsableString());
            com.vzome.xml.DomUtils.addAttribute(xml, "group", this.groupName);
            com.vzome.xml.DomUtils.addAttribute(xml, "wythoff", com.vzome.xml.DomUtils.byteToBinary(this.index));
            if (this.edgesToRender !== 15)com.vzome.xml.DomUtils.addAttribute(xml, "renderEdges", com.vzome.xml.DomUtils.byteToBinary(this.edgesToRender));
            if (!(this.renderGroupName === this.groupName))com.vzome.xml.DomUtils.addAttribute(xml, "renderGroup", this.renderGroupName);
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        public setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            const binary: string = xml.getAttribute("wythoff");
            this.index = javaemul.internal.IntegerHelper.parseInt(binary, 2);
            const renderString: string = xml.getAttribute("renderEdges");
            this.edgesToRender = (renderString == null || /* isEmpty */(renderString.length === 0)) ? this.index : javaemul.internal.IntegerHelper.parseInt(renderString, 2);
            this.groupName = xml.getAttribute("group");
            const rgString: string = xml.getAttribute("renderGroup");
            this.renderGroupName = (rgString == null || /* isEmpty */(rgString.length === 0)) ? this.groupName : rgString;
            let quatString: string = xml.getAttribute("quaternion");
            if (quatString != null && !("" === quatString)){
                if (/* contains */(quatString.indexOf("+") != -1)){
                    quatString = /* replace */quatString.split(',').join(' ');
                    quatString = /* replace */quatString.split('(').join(' ');
                    quatString = /* replace */quatString.split(')').join(' ');
                    quatString = /* replace */quatString.split('+').join(' ');
                    const irrat: string = this.field['getIrrational$int'](0).charAt(0);
                    quatString = /* replace */quatString.split(irrat).join(' ');
                    quatString = quatString + " 0 0 0";
                }
                this.quaternion = this.field.parseVector(quatString);
            } else {
                let segment: com.vzome.core.construction.Segment = null;
                if (format.commandEditsCompacted())segment = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "start", "end"); else {
                    const attrs: com.vzome.core.commands.AttributeMap = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                    segment = <com.vzome.core.construction.Segment>attrs.get("rotation");
                }
                if (segment != null)this.quaternion = segment.getOffset().inflateTo4d$();
            }
        }

        /**
         * 
         */
        public perform() {
            if (this.quaternion == null)this.proj = new com.vzome.core.math.Projection.Default(this.field); else this.proj = new com.vzome.core.math.QuaternionProjection(this.field, null, this.quaternion.scale(this.field['createPower$int'](-5)));
            this.symmetries.constructPolytope(this.groupName, this.index, this.edgesToRender, this.edgeScales, new Polytope4d.WythoffListener(this));
            this.redo();
        }

        public static getSupportedGroups(): string[] {
            return ["A4", "B4/C4", "D4", "F4", "H4"];
        }
    }
    Polytope4d["__class"] = "com.vzome.core.edits.Polytope4d";


    export namespace Polytope4d {

        export class WythoffListener implements com.vzome.core.math.symmetry.WythoffConstruction.Listener {
            public __parent: any;
            numVertices: number;

            vertices: java.util.Map<string, com.vzome.core.construction.Point>;

            /**
             * 
             * @param {*} p1
             * @param {*} p2
             * @return {*}
             */
            public addEdge(p1: any, p2: any): any {
                const edge: com.vzome.core.construction.Segment = new com.vzome.core.construction.SegmentJoiningPoints(<com.vzome.core.construction.Point>p1, <com.vzome.core.construction.Point>p2);
                this.__parent.manifestConstruction(edge);
                return edge;
            }

            /**
             * 
             * @param {java.lang.Object[]} vertices
             * @return {*}
             */
            public addFace(vertices: any[]): any {
                return null;
            }

            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} vertex
             * @return {*}
             */
            public addVertex(vertex: com.vzome.core.algebra.AlgebraicVector): any {
                let p: com.vzome.core.construction.Point = this.vertices.get(vertex.toString());
                if (p == null){
                    let projected: com.vzome.core.algebra.AlgebraicVector = vertex;
                    if (this.__parent.proj != null)projected = this.__parent.proj.projectImage(vertex, true);
                    projected = projected.scale(this.__parent.field['createPower$int'](5));
                    p = new com.vzome.core.construction.FreePoint(projected);
                    p.setIndex(this.numVertices++);
                    this.__parent.manifestConstruction(p);
                    this.vertices.put(vertex.toString(), p);
                }
                return p;
            }

            constructor(__parent: any) {
                this.__parent = __parent;
                this.numVertices = 0;
                this.vertices = <any>(new java.util.HashMap<any, any>());
            }
        }
        WythoffListener["__class"] = "com.vzome.core.edits.Polytope4d.WythoffListener";
        WythoffListener["__interfaces"] = ["com.vzome.core.math.symmetry.WythoffConstruction.Listener"];


    }

}
namespace com.vzome.core.edits {
    export class ShowVertices extends com.vzome.core.editor.api.ChangeManifestations {
        public static NAME: string = "ShowVertices";

        /**
         * 
         */
        public perform() {
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        const s: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>man.getFirstConstruction();
                        const start: com.vzome.core.construction.SegmentEndPoint = new com.vzome.core.construction.SegmentEndPoint(s, true);
                        this.manifestConstruction(start);
                        const end: com.vzome.core.construction.SegmentEndPoint = new com.vzome.core.construction.SegmentEndPoint(s, false);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(end));
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                        const polygon: com.vzome.core.construction.Polygon = <com.vzome.core.construction.Polygon>(<com.vzome.core.model.Panel><any>man).getFirstConstruction();
                        for(let i: number = 0; i < polygon.getVertexCount(); i++) {{
                            const v: com.vzome.core.construction.PolygonVertex = new com.vzome.core.construction.PolygonVertex(polygon, i);
                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(v));
                        };}
                    }
                }
            }
            this.redo();
        }

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return ShowVertices.NAME;
        }
    }
    ShowVertices["__class"] = "com.vzome.core.edits.ShowVertices";

}
namespace com.vzome.core.edits {
    export class JoinSkewLines extends com.vzome.core.editor.api.ChangeManifestations {
        public static NAME: string = "JoinSkewLines";

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
        }

        /**
         * 
         */
        public perform() {
            const errorMsg: java.lang.StringBuilder = new java.lang.StringBuilder();
            errorMsg.append("This command requires two non-parallel struts.\n");
            let s0: com.vzome.core.model.Strut = null;
            let s1: com.vzome.core.model.Strut = null;
            let qty: number = 0;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        switch((qty)) {
                        case 0:
                            s0 = <com.vzome.core.model.Strut><any>man;
                            break;
                        case 1:
                            s1 = <com.vzome.core.model.Strut><any>man;
                            break;
                        default:
                            errorMsg.append("\ntoo many struts are selected.");
                            this.fail(errorMsg.toString());
                        }
                        qty++;
                    }
                    this.unselect$com_vzome_core_model_Manifestation(man);
                }
            }
            if (qty < 2){
                errorMsg.append(qty === 1 ? "\nonly one strut is selected." : "\nno struts are selected.");
                this.fail(errorMsg.toString());
            }
            const u: com.vzome.core.algebra.AlgebraicVector = s0.getOffset();
            const v: com.vzome.core.algebra.AlgebraicVector = s1.getOffset();
            const p0: com.vzome.core.algebra.AlgebraicVector = s0.getLocation();
            const q0: com.vzome.core.algebra.AlgebraicVector = s1.getLocation();
            const uuA: com.vzome.core.algebra.AlgebraicNumber = u.dot(u);
            const uvB: com.vzome.core.algebra.AlgebraicNumber = u.dot(v);
            const vvC: com.vzome.core.algebra.AlgebraicNumber = v.dot(v);
            const denD: com.vzome.core.algebra.AlgebraicNumber = uuA['times$com_vzome_core_algebra_AlgebraicNumber'](vvC)['minus$com_vzome_core_algebra_AlgebraicNumber'](uvB['times$com_vzome_core_algebra_AlgebraicNumber'](uvB));
            if (denD.isZero()){
                errorMsg.append("\nstruts are parallel.");
                this.fail(errorMsg.toString());
            }
            this.redo();
            const w: com.vzome.core.algebra.AlgebraicVector = p0.minus(q0);
            const uwD: com.vzome.core.algebra.AlgebraicNumber = u.dot(w);
            const vwE: com.vzome.core.algebra.AlgebraicNumber = v.dot(w);
            const sc: com.vzome.core.algebra.AlgebraicNumber = (uvB['times$com_vzome_core_algebra_AlgebraicNumber'](vwE)['minus$com_vzome_core_algebra_AlgebraicNumber'](vvC['times$com_vzome_core_algebra_AlgebraicNumber'](uwD))).dividedBy(denD);
            const tc: com.vzome.core.algebra.AlgebraicNumber = (uuA['times$com_vzome_core_algebra_AlgebraicNumber'](vwE)['minus$com_vzome_core_algebra_AlgebraicNumber'](uvB['times$com_vzome_core_algebra_AlgebraicNumber'](uwD))).dividedBy(denD);
            const w0: com.vzome.core.algebra.AlgebraicVector = p0.plus(u.scale(sc));
            const pw0: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(w0);
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(pw0));
            const w1: com.vzome.core.algebra.AlgebraicVector = q0.plus(v.scale(tc));
            if (!w1.equals(w0)){
                const pw1: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(w1);
                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(pw1));
                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(pw0, pw1)));
            }
            this.redo();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return JoinSkewLines.NAME;
        }
    }
    JoinSkewLines["__class"] = "com.vzome.core.edits.JoinSkewLines";

}
namespace com.vzome.core.edits {
    export class NewCentroid extends com.vzome.core.editor.api.ChangeManifestations {
        /**
         * 
         */
        public perform() {
            const verticesList: java.util.List<com.vzome.core.construction.Point> = <any>(new java.util.ArrayList<any>());
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation(man);
                    const construction: com.vzome.core.construction.Construction = man.toConstruction();
                    if (construction != null && construction instanceof <any>com.vzome.core.construction.Point){
                        const nextPoint: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>construction;
                        verticesList.add(nextPoint);
                    }
                }
            }
            if (verticesList.size() < 2)throw new com.vzome.core.commands.Command.Failure("Select at least two balls to compute the centroid.");
            const points: com.vzome.core.construction.Point[] = [];
            const centroid: com.vzome.core.construction.CentroidPoint = new com.vzome.core.construction.CentroidPoint(verticesList.toArray<any>(points));
            this.manifestConstruction(centroid);
            this.redo();
        }

        public constructor(editorModel: com.vzome.core.editor.api.EditorModel) {
            super(editorModel);
        }

        /**
         * 
         * @return {boolean}
         */
        groupingAware(): boolean {
            return true;
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "NewCentroid";
        }
    }
    NewCentroid["__class"] = "com.vzome.core.edits.NewCentroid";

}
namespace com.vzome.core.edits {
    export class LinePlaneIntersect extends com.vzome.core.editor.api.ChangeManifestations {
        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
        }

        /**
         * 
         * @return {boolean}
         */
        groupingAware(): boolean {
            return true;
        }

        /**
         * 
         */
        public perform() {
            let panel: com.vzome.core.model.Panel = null;
            let strut: com.vzome.core.model.Strut = null;
            let p0: com.vzome.core.construction.Point = null;
            let p1: com.vzome.core.construction.Point = null;
            let p2: com.vzome.core.construction.Point = null;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation(man);
                    if ((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) && (p2 == null)){
                        const nextPoint: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>(<com.vzome.core.model.Connector><any>man).getFirstConstruction();
                        if (p0 == null)p0 = nextPoint; else if (p1 == null)p1 = nextPoint; else if (p2 == null)p2 = nextPoint;
                    } else if ((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) && (strut == null)){
                        strut = (<com.vzome.core.model.Strut><any>man);
                    } else if ((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) && panel == null){
                        panel = (<com.vzome.core.model.Panel><any>man);
                    }
                }
            }
            if (strut == null){
                return;
            }
            let point: com.vzome.core.construction.Point = null;
            let plane: com.vzome.core.construction.Plane = null;
            const line: com.vzome.core.construction.Line = new com.vzome.core.construction.LineFromPointAndVector(strut.getLocation(), strut.getZoneVector());
            if (p2 != null && panel == null){
                const points: com.vzome.core.construction.Point[] = [p0, p1, p2];
                const polygon: com.vzome.core.construction.Polygon = new com.vzome.core.construction.PolygonFromVertices(points);
                plane = new com.vzome.core.construction.PlaneExtensionOfPolygon(polygon);
            } else if (strut != null && panel != null){
                plane = new com.vzome.core.construction.PlaneFromPointAndNormal(panel.getFirstVertex(), panel.getZoneVector());
            }
            if (plane != null && !plane.isImpossible()){
                point = new com.vzome.core.construction.LinePlaneIntersectionPoint(plane, line);
                if (!point.isImpossible())this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(point));
            }
            this.redo();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "LinePlaneIntersect";
        }
    }
    LinePlaneIntersect["__class"] = "com.vzome.core.edits.LinePlaneIntersect";

}
namespace com.vzome.core.edits {
    export abstract class SelectByBoundary extends com.vzome.core.editor.api.ChangeManifestations {
        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
        }

        public abstract usage(): string;

        /**
         * 
         * @param {string} message
         */
        fail(message: string) {
            const errorMsg: java.lang.StringBuilder = new java.lang.StringBuilder();
            const usage: string = this.usage();
            if (usage != null){
                errorMsg.append(usage);
            }
            if (message != null){
                if (errorMsg.length() > 0){
                    errorMsg.append("\n");
                }
                errorMsg.append(message);
            }
            super.fail(errorMsg.toString());
        }

        /**
         * Sets the boundary criteria based on the selection
         * @return {string} null if successful, otherwise a string describing the error.
         */
        abstract setBoundary(): string;

        /**
         * 
         */
        public perform() {
            const errMsg: string = this.setBoundary();
            if (errMsg != null){
                this.fail(errMsg);
            }
            this.unselectAll();
            this.selectBoundedManifestations();
            this.redo();
        }

        selectBoundedManifestations() {
            for(let index=this.getConnectors().iterator();index.hasNext();) {
                let connector = index.next();
                {
                    if (this.boundaryContains$com_vzome_core_model_Connector(connector)){
                        this.select$com_vzome_core_model_Manifestation(connector);
                    }
                }
            }
            for(let index=this.getStruts().iterator();index.hasNext();) {
                let strut = index.next();
                {
                    if (this.boundaryContains$com_vzome_core_model_Strut(strut)){
                        this.select$com_vzome_core_model_Manifestation(strut);
                    }
                }
            }
            for(let index=this.getPanels().iterator();index.hasNext();) {
                let panel = index.next();
                {
                    if (this.boundaryContains$com_vzome_core_model_Panel(panel)){
                        this.select$com_vzome_core_model_Manifestation(panel);
                    }
                }
            }
        }

        public boundaryContains$com_vzome_core_model_Connector(connector: com.vzome.core.model.Connector): boolean {
            return this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(connector.getLocation());
        }

        public boundaryContains(connector?: any): boolean {
            if (((connector != null && (connector.constructor != null && connector.constructor["__interfaces"] != null && connector.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || connector === null)) {
                return <any>this.boundaryContains$com_vzome_core_model_Connector(connector);
            } else if (((connector != null && (connector.constructor != null && connector.constructor["__interfaces"] != null && connector.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || connector === null)) {
                return <any>this.boundaryContains$com_vzome_core_model_Strut(connector);
            } else if (((connector != null && (connector.constructor != null && connector.constructor["__interfaces"] != null && connector.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) || connector === null)) {
                return <any>this.boundaryContains$com_vzome_core_model_Panel(connector);
            } else if (((connector != null && connector instanceof <any>com.vzome.core.algebra.AlgebraicVector) || connector === null)) {
                return <any>this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(connector);
            } else throw new Error('invalid overload');
        }

        /*private*/ boundaryContains$com_vzome_core_model_Strut(strut: com.vzome.core.model.Strut): boolean {
            return this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(strut.getLocation()) && this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(strut.getEnd());
        }

        /*private*/ boundaryContains$com_vzome_core_model_Panel(panel: com.vzome.core.model.Panel): boolean {
            for(let index=panel.iterator();index.hasNext();) {
                let vertex = index.next();
                {
                    if (!this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(vertex)){
                        return false;
                    }
                }
            }
            return true;
        }

        boundaryContains$com_vzome_core_algebra_AlgebraicVector(v: com.vzome.core.algebra.AlgebraicVector): boolean { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }
    }
    SelectByBoundary["__class"] = "com.vzome.core.edits.SelectByBoundary";

}
namespace com.vzome.core.edits {
    export class RealizeMetaParts extends com.vzome.core.editor.api.ChangeManifestations {
        public static NAME: string = "realizeMetaParts";

        /**
         * 
         */
        public perform() {
            let scale: com.vzome.core.algebra.AlgebraicNumber = null;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation(man);
                    const rm: com.vzome.core.model.RenderedObject = (<com.vzome.core.model.HasRenderedObject><any>man).getRenderedObject();
                    if (rm != null){
                        const shape: com.vzome.core.math.Polyhedron = rm.getShape();
                        if (scale == null){
                            const field: com.vzome.core.algebra.AlgebraicField = shape.getField();
                            scale = field['createPower$int'](5);
                        }
                        const orientation: com.vzome.core.algebra.AlgebraicMatrix = rm.getOrientation();
                        const vertexList: java.util.List<com.vzome.core.algebra.AlgebraicVector> = shape.getVertexList();
                        for(let index=shape.getVertexList().iterator();index.hasNext();) {
                            let vertex = index.next();
                            {
                                const vertexPt: com.vzome.core.construction.Point = this.transformVertex(vertex, man.getLocation(), scale, orientation);
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(vertexPt));
                            }
                        }
                        for(let index=shape.getFaceSet().iterator();index.hasNext();) {
                            let face = index.next();
                            {
                                const vertices: com.vzome.core.construction.Point[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(face.size());
                                for(let i: number = 0; i < vertices.length; i++) {{
                                    const vertexIndex: number = face.getVertex(i);
                                    const vertex: com.vzome.core.algebra.AlgebraicVector = vertexList.get(vertexIndex);
                                    vertices[i] = this.transformVertex(vertex, man.getLocation(), scale, orientation);
                                };}
                                const polygon: com.vzome.core.construction.Polygon = new com.vzome.core.construction.PolygonFromVertices(vertices);
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(polygon));
                            }
                        }
                    }
                }
            }
            this.redo();
        }

        /*private*/ transformVertex(vertex: com.vzome.core.algebra.AlgebraicVector, offset: com.vzome.core.algebra.AlgebraicVector, scale: com.vzome.core.algebra.AlgebraicNumber, orientation: com.vzome.core.algebra.AlgebraicMatrix): com.vzome.core.construction.Point {
            if (orientation != null)vertex = orientation.timesColumn(vertex);
            if (offset != null)vertex = vertex.plus(offset);
            return new com.vzome.core.construction.FreePoint(vertex.scale(scale));
        }

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return RealizeMetaParts.NAME;
        }
    }
    RealizeMetaParts["__class"] = "com.vzome.core.edits.RealizeMetaParts";

}
namespace com.vzome.core.edits {
    /**
     * called from the main menu and when opening a file
     * @param symmetry
     * @param selection
     * @param model
     * @param {*} editor
     * @class
     * @extends com.vzome.core.editor.api.ChangeManifestations
     * @author David Hall
     */
    export class SelectParallelStruts extends com.vzome.core.editor.api.ChangeManifestations {
        /*private*/ symmetry: com.vzome.core.editor.api.OrbitSource;

        /*private*/ orbit: com.vzome.core.math.symmetry.Direction;

        /*private*/ axis: com.vzome.core.math.symmetry.Axis;

        /*private*/ editor: com.vzome.core.editor.api.EditorModel;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            if (this.symmetry === undefined) { this.symmetry = null; }
            if (this.orbit === undefined) { this.orbit = null; }
            if (this.axis === undefined) { this.axis = null; }
            if (this.editor === undefined) { this.editor = null; }
            this.editor = editor;
            this.symmetry = (<com.vzome.core.editor.api.SymmetryAware><any>editor)['getSymmetrySystem$']();
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
            const strut: com.vzome.core.model.Strut = <com.vzome.core.model.Strut><any>props.get("picked");
            if (strut != null){
                this.axis = this.symmetry.getAxis(strut.getOffset());
                this.orbit = this.axis.getOrbit();
            }
        }

        /**
         * 
         */
        public perform() {
            if (this.orbit == null || this.axis == null){
                const lastStrut: com.vzome.core.model.Strut = this.getLastSelectedStrut();
                if (lastStrut != null){
                    const offset: com.vzome.core.algebra.AlgebraicVector = lastStrut.getOffset();
                    this.orbit = this.symmetry.getAxis(offset).getOrbit();
                    this.axis = this.orbit.getAxis$com_vzome_core_algebra_AlgebraicVector(offset);
                }
            }
            if (this.orbit == null || this.axis == null){
                throw new com.vzome.core.commands.Command.Failure("select a reference strut.");
            }
            this.unselectAll();
            const oppositeAxis: com.vzome.core.math.symmetry.Axis = this.symmetry.getSymmetry().getPrincipalReflection() == null ? this.orbit.getAxis$int$int(((this.axis.getSense() + 1) % 2), this.axis.getOrientation()) : this.orbit.getAxis$int$int$boolean(this.axis.getSense(), this.axis.getOrientation(), !this.axis.isOutbound());
            for(let index=this.getStruts().iterator();index.hasNext();) {
                let strut = index.next();
                {
                    const strutAxis: com.vzome.core.math.symmetry.Axis = this.symmetry.getAxis(strut.getOffset());
                    if (strutAxis != null && strutAxis.getOrbit().equals(this.orbit)){
                        if (strutAxis.equals(this.axis) || strutAxis.equals(oppositeAxis)){
                            this.select$com_vzome_core_model_Manifestation(strut);
                        }
                    }
                }
            }
            super.perform();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "SelectParallelStruts";
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            if (this.symmetry != null)com.vzome.xml.DomUtils.addAttribute(element, "symmetry", this.symmetry.getName());
            if (this.orbit != null)com.vzome.xml.DomUtils.addAttribute(element, "orbit", this.orbit.getName());
            if (this.axis != null)com.vzome.core.commands.XmlSymmetryFormat.serializeAxis(element, "symm", "dir", "index", "sense", this.axis);
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            this.symmetry = (<com.vzome.core.editor.api.SymmetryAware><any>this.editor)['getSymmetrySystem$java_lang_String'](xml.getAttribute("symmetry"));
            this.orbit = this.symmetry.getOrbits().getDirection(xml.getAttribute("orbit"));
            this.axis = (<com.vzome.core.commands.XmlSymmetryFormat>format).parseAxis(xml, "symm", "dir", "index", "sense");
        }
    }
    SelectParallelStruts["__class"] = "com.vzome.core.edits.SelectParallelStruts";

}
namespace com.vzome.core.edits {
    export abstract class ConvexHull extends com.vzome.core.editor.api.ChangeManifestations {
        public constructor(editorModel: com.vzome.core.editor.api.EditorModel) {
            super(editorModel);
        }

        getSelectedVertexSet(unselectAll: boolean): java.util.Set<com.vzome.core.algebra.AlgebraicVector> {
            const vertexSet: java.util.Set<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.HashSet<any>());
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        vertexSet.add(man.getLocation());
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        vertexSet.add(man.getLocation());
                        vertexSet.add((<com.vzome.core.model.Strut><any>man).getEnd());
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                        for(let index=(<com.vzome.core.model.Panel><any>man).iterator();index.hasNext();) {
                            let vertex = index.next();
                            {
                                vertexSet.add(vertex);
                            }
                        }
                    }
                    if (unselectAll){
                        this.unselect$com_vzome_core_model_Manifestation(man);
                    }
                }
            }
            return vertexSet;
        }
    }
    ConvexHull["__class"] = "com.vzome.core.edits.ConvexHull";

}
namespace com.vzome.core.edits {
    export class ReplaceWithShape extends com.vzome.core.editor.api.ChangeManifestations {
        public static NAME: string = "ReplaceWithShape";

        /*private*/ vef: string;

        /*private*/ shape: com.vzome.core.math.Polyhedron;

        /*private*/ ballOrStrut: com.vzome.core.model.Manifestation;

        /*private*/ symmetryShapes: string;

        /*private*/ editor: com.vzome.core.editor.api.EditorModel;

        /*private*/ replace(man: com.vzome.core.model.Manifestation, renderedObject: com.vzome.core.model.RenderedObject, shape: com.vzome.core.math.Polyhedron) {
            if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0))return;
            if (renderedObject != null){
                const orientation: com.vzome.core.algebra.AlgebraicMatrix = renderedObject.getOrientation();
                const vertexList: java.util.List<com.vzome.core.algebra.AlgebraicVector> = shape.getVertexList();
                for(let index=shape.getFaceSet().iterator();index.hasNext();) {
                    let face = index.next();
                    {
                        const vertices: com.vzome.core.construction.Point[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(face.size());
                        for(let i: number = 0; i < vertices.length; i++) {{
                            const vertexIndex: number = face.getVertex(i);
                            const vertex: com.vzome.core.algebra.AlgebraicVector = vertexList.get(vertexIndex);
                            vertices[i] = ReplaceWithShape.transformVertex(vertex, renderedObject.getLocationAV(), orientation);
                        };}
                        const polygon: com.vzome.core.construction.Polygon = new com.vzome.core.construction.PolygonFromVertices(vertices);
                        const panel: com.vzome.core.model.Manifestation = this.manifestConstruction(polygon);
                        this.select$com_vzome_core_model_Manifestation(panel);
                    }
                }
            }
            this.deleteManifestation(man);
        }

        /**
         * 
         */
        public perform() {
            if (this.symmetryShapes != null){
                const tokens: string[] = this.symmetryShapes.split(":");
                const symmetrySystem: com.vzome.core.editor.api.OrbitSource = (<com.vzome.core.editor.api.SymmetryAware><any>this.editor)['getSymmetrySystem$java_lang_String'](tokens[0]);
                const shapes: com.vzome.core.editor.api.Shapes = (<com.vzome.core.editor.SymmetrySystem><any>symmetrySystem).getStyle$java_lang_String(tokens[1]);
                const model: com.vzome.core.render.RenderedModel = new com.vzome.core.render.RenderedModel(symmetrySystem.getSymmetry().getField(), new ReplaceWithShape.ReplaceWithShape$0(this, symmetrySystem, shapes));
                if (this.ballOrStrut != null){
                    for(let index=this.mSelection.iterator();index.hasNext();) {
                        let man = index.next();
                        {
                            this.unselect$com_vzome_core_model_Manifestation(man);
                        }
                    }
                    this.redo();
                    const rm: com.vzome.core.render.RenderedManifestation = model.render(this.ballOrStrut);
                    this.replace(this.ballOrStrut, rm, rm.getShape());
                } else for(let index=this.mSelection.iterator();index.hasNext();) {
                    let man = index.next();
                    {
                        this.unselect$com_vzome_core_model_Manifestation(man);
                        const rm: com.vzome.core.render.RenderedManifestation = model.render(man);
                        this.replace(man, rm, rm.getShape());
                    }
                }
            } else {
                for(let index=this.mSelection.iterator();index.hasNext();) {
                    let man = index.next();
                    {
                        this.unselect$com_vzome_core_model_Manifestation(man);
                    }
                }
                this.redo();
                this.replace(this.ballOrStrut, (<com.vzome.core.model.HasRenderedObject><any>this.ballOrStrut).getRenderedObject(), this.shape);
            }
            super.perform();
        }

        /*private*/ static transformVertex(vertex: com.vzome.core.algebra.AlgebraicVector, offset: com.vzome.core.algebra.AlgebraicVector, orientation: com.vzome.core.algebra.AlgebraicMatrix): com.vzome.core.construction.Point {
            if (orientation != null)vertex = orientation.timesColumn(vertex);
            if (offset != null)vertex = vertex.plus(offset);
            return new com.vzome.core.construction.FreePoint(vertex);
        }

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            if (this.vef === undefined) { this.vef = null; }
            if (this.shape === undefined) { this.shape = null; }
            if (this.ballOrStrut === undefined) { this.ballOrStrut = null; }
            if (this.symmetryShapes === undefined) { this.symmetryShapes = null; }
            if (this.editor === undefined) { this.editor = null; }
            this.editor = editor;
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
            const m: com.vzome.core.model.Manifestation = <com.vzome.core.model.Manifestation><any>props.get("picked");
            if (m != null){
                this.symmetryShapes = (<com.vzome.core.model.HasRenderedObject><any>m).getRenderedObject().getSymmetryShapes();
                this.ballOrStrut = m;
            } else this.symmetryShapes = <string>props.get("mode");
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            if (this.ballOrStrut != null){
                const construction: com.vzome.core.construction.Construction = this.ballOrStrut.getFirstConstruction();
                if (construction != null && construction instanceof <any>com.vzome.core.construction.Point)com.vzome.core.commands.XmlSaveFormat.serializePoint(element, "point", <com.vzome.core.construction.Point>construction); else com.vzome.core.commands.XmlSaveFormat.serializeSegment(element, "startSegment", "endSegment", <com.vzome.core.construction.Segment>construction);
            }
            if (this.shape != null){
                if (this.vef == null){
                    this.vef = com.vzome.core.algebra.VefVectorExporter.exportPolyhedron(this.shape);
                }
                const textNode: org.w3c.dom.Node = element.getOwnerDocument().createTextNode(com.vzome.core.commands.XmlSaveFormat.escapeNewlines(this.vef));
                element.appendChild(textNode);
            } else {
                element.setAttribute("shapes", this.symmetryShapes);
            }
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            const attr: string = xml.getAttribute("shapes");
            if (attr != null && !/* isEmpty */(attr.length === 0)){
                this.symmetryShapes = attr;
            } else {
                this.vef = xml.getTextContent();
                this.shape = com.vzome.core.math.VefToPolyhedron.importPolyhedron(format.getField(), this.vef);
            }
            let construction: com.vzome.core.construction.Construction = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "point");
            if (construction == null)construction = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "startSegment", "endSegment");
            if (construction != null)this.ballOrStrut = this.getManifestation(construction);
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return ReplaceWithShape.NAME;
        }
    }
    ReplaceWithShape["__class"] = "com.vzome.core.edits.ReplaceWithShape";


    export namespace ReplaceWithShape {

        export class ReplaceWithShape$0 implements com.vzome.core.editor.api.OrbitSource {
            public __parent: any;
            /* Default method injected from com.vzome.core.editor.api.OrbitSource */
            getOrientations$(): number[][] {
                return this.getOrientations(false);
            }
            /* Default method injected from com.vzome.core.editor.api.OrbitSource */
            getEmbedding(): number[] {
                const symmetry: com.vzome.core.math.symmetry.Symmetry = this.getSymmetry();
                const field: com.vzome.core.algebra.AlgebraicField = symmetry.getField();
                const embedding: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(16);
                for(let i: number = 0; i < 3; i++) {{
                    const columnSelect: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, i);
                    const colRV: com.vzome.core.math.RealVector = symmetry.embedInR3(columnSelect);
                    embedding[i * 4 + 0] = colRV.x;
                    embedding[i * 4 + 1] = colRV.y;
                    embedding[i * 4 + 2] = colRV.z;
                    embedding[i * 4 + 3] = 0.0;
                };}
                embedding[12] = 0.0;
                embedding[13] = 0.0;
                embedding[14] = 0.0;
                embedding[15] = 1.0;
                return embedding;
            }
            /* Default method injected from com.vzome.core.editor.api.OrbitSource */
            getZone(orbit: string, orientation: number): com.vzome.core.math.symmetry.Axis {
                return this.getSymmetry().getDirection(orbit).getAxis(com.vzome.core.math.symmetry.Symmetry.PLUS, orientation);
            }
            /* Default method injected from com.vzome.core.editor.api.OrbitSource */
            public getOrientations(rowMajor?: any): number[][] {
                if (((typeof rowMajor === 'boolean') || rowMajor === null)) {
                    let __args = arguments;
                    return <any>(() => {
                        const symmetry: com.vzome.core.math.symmetry.Symmetry = this.getSymmetry();
                        const field: com.vzome.core.algebra.AlgebraicField = symmetry.getField();
                        const order: number = symmetry.getChiralOrder();
                        const orientations: number[][] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(order);
                        for(let orientation: number = 0; orientation < order; orientation++) {{
                            if (rowMajor){
                                orientations[orientation] = symmetry.getMatrix(orientation).getRowMajorRealElements();
                                continue;
                            }
                            const asFloats: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(16);
                            const transform: com.vzome.core.algebra.AlgebraicMatrix = symmetry.getMatrix(orientation);
                            for(let i: number = 0; i < 3; i++) {{
                                const columnSelect: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, i);
                                const columnI: com.vzome.core.algebra.AlgebraicVector = transform.timesColumn(columnSelect);
                                const colRV: com.vzome.core.math.RealVector = columnI.toRealVector();
                                asFloats[i * 4 + 0] = colRV.x;
                                asFloats[i * 4 + 1] = colRV.y;
                                asFloats[i * 4 + 2] = colRV.z;
                                asFloats[i * 4 + 3] = 0.0;
                            };}
                            asFloats[12] = 0.0;
                            asFloats[13] = 0.0;
                            asFloats[14] = 0.0;
                            asFloats[15] = 1.0;
                            orientations[orientation] = asFloats;
                        };}
                        return orientations;
                    })();
                } else if (rowMajor === undefined) {
                    return <any>this.getOrientations$();
                } else throw new Error('invalid overload');
            }
            /**
             * 
             * @return {*}
             */
            public getSymmetry(): com.vzome.core.math.symmetry.Symmetry {
                return this.symmetrySystem.getSymmetry();
            }

            /**
             * 
             * @return {*}
             */
            public getShapes(): com.vzome.core.editor.api.Shapes {
                return this.shapes;
            }

            /**
             * 
             * @return {com.vzome.core.math.symmetry.OrbitSet}
             */
            public getOrbits(): com.vzome.core.math.symmetry.OrbitSet {
                return this.symmetrySystem.getOrbits();
            }

            /**
             * 
             * @param {com.vzome.core.math.symmetry.Direction} orbit
             * @return {com.vzome.core.construction.Color}
             */
            public getColor(orbit: com.vzome.core.math.symmetry.Direction): com.vzome.core.construction.Color {
                return this.symmetrySystem.getColor(orbit);
            }

            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} vector
             * @return {com.vzome.core.math.symmetry.Axis}
             */
            public getAxis(vector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.math.symmetry.Axis {
                return this.symmetrySystem.getAxis(vector);
            }

            /**
             * 
             * @return {string}
             */
            public getName(): string {
                return this.symmetrySystem.getName();
            }

            /**
             * 
             * @param {com.vzome.core.algebra.AlgebraicVector} vector
             * @return {com.vzome.core.construction.Color}
             */
            public getVectorColor(vector: com.vzome.core.algebra.AlgebraicVector): com.vzome.core.construction.Color {
                return this.symmetrySystem.getVectorColor(vector);
            }

            constructor(__parent: any, private symmetrySystem: any, private shapes: any) {
                this.__parent = __parent;
            }
        }
        ReplaceWithShape$0["__interfaces"] = ["com.vzome.core.editor.api.OrbitSource"];


    }

}
namespace com.vzome.core.edits {
    export class AffinePentagon extends com.vzome.core.editor.api.ChangeManifestations {
        /**
         * 
         */
        public perform() {
            const errorMsg: string = "Affine pentagon command requires two selected struts with a common vertex.";
            let strut1: com.vzome.core.model.Strut = null;
            let strut2: com.vzome.core.model.Strut = null;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        if (strut1 == null){
                            strut1 = <com.vzome.core.model.Strut><any>man;
                        } else if (strut2 == null){
                            strut2 = <com.vzome.core.model.Strut><any>man;
                        }
                    }
                }
            }
            this.redo();
            if (strut1 == null || strut2 == null){
                this.fail(errorMsg);
            }
            const field: com.vzome.core.algebra.AlgebraicField = strut1.getLocation().getField();
            const s1: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>strut1.getFirstConstruction();
            const s2: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>strut2.getFirstConstruction();
            this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s1, true));
            this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s1, false));
            this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s2, true));
            this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s2, false));
            this.redo();
            let offset1: com.vzome.core.algebra.AlgebraicVector = s1.getOffset();
            let offset2: com.vzome.core.algebra.AlgebraicVector = s2.getOffset();
            let v1: com.vzome.core.algebra.AlgebraicVector = null;
            let v2: com.vzome.core.algebra.AlgebraicVector = null;
            {
                const s1s: com.vzome.core.algebra.AlgebraicVector = s1.getStart();
                const s1e: com.vzome.core.algebra.AlgebraicVector = s1.getEnd();
                const s2s: com.vzome.core.algebra.AlgebraicVector = s2.getStart();
                const s2e: com.vzome.core.algebra.AlgebraicVector = s2.getEnd();
                if (s1s.equals(s2s)){
                    v1 = s1e;
                    v2 = s2e;
                } else if (s1e.equals(s2s)){
                    v1 = s1s;
                    v2 = s2e;
                    offset1 = offset1.negate();
                } else if (s1e.equals(s2e)){
                    v1 = s1s;
                    v2 = s2s;
                    offset2 = offset2.negate();
                    offset1 = offset1.negate();
                } else if (s1s.equals(s2e)){
                    v1 = s1e;
                    v2 = s2s;
                    offset2 = offset2.negate();
                } else {
                    this.fail(errorMsg);
                }
            };
            let p1: com.vzome.core.construction.Point = null;
            let p2: com.vzome.core.construction.Point = null;
            for(let index=this.mManifestations.iterator();index.hasNext();) {
                let m = index.next();
                {
                    if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        const loc: com.vzome.core.algebra.AlgebraicVector = m.getLocation();
                        if (loc.equals(v1))p1 = <com.vzome.core.construction.Point>m.getFirstConstruction(); else if (loc.equals(v2))p2 = <com.vzome.core.construction.Point>m.getFirstConstruction();
                    }
                }
            }
            const phi: com.vzome.core.algebra.AlgebraicNumber = field['createPower$int'](1);
            let transform: com.vzome.core.construction.Transformation = new com.vzome.core.construction.Translation(offset1.scale(phi));
            const p3: com.vzome.core.construction.Point = new com.vzome.core.construction.TransformedPoint(transform, p2);
            this.manifestConstruction(p3);
            transform = new com.vzome.core.construction.Translation(offset2.scale(phi));
            const p4: com.vzome.core.construction.Point = new com.vzome.core.construction.TransformedPoint(transform, p1);
            this.manifestConstruction(p4);
            let segment: com.vzome.core.construction.Segment = new com.vzome.core.construction.SegmentJoiningPoints(p1, p3);
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(segment));
            segment = new com.vzome.core.construction.SegmentJoiningPoints(p2, p4);
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(segment));
            segment = new com.vzome.core.construction.SegmentJoiningPoints(p3, p4);
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(segment));
            this.redo();
        }

        public constructor(editorModel: com.vzome.core.editor.api.EditorModel) {
            super(editorModel);
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "AffinePentagon";
        }
    }
    AffinePentagon["__class"] = "com.vzome.core.edits.AffinePentagon";

}
namespace com.vzome.core.edits {
    export class Validate2Manifold extends com.vzome.core.editor.api.ChangeManifestations {
        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
        }

        showStrut(strut: com.vzome.core.model.Strut) {
            const a: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(strut.getLocation());
            this.manifestConstruction(a);
            const b: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(strut.getEnd());
            this.manifestConstruction(b);
            const segment: com.vzome.core.construction.Segment = new com.vzome.core.construction.SegmentJoiningPoints(a, b);
            this.manifestConstruction(segment);
        }

        /**
         * 
         */
        public perform() {
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                super.unselect$com_vzome_core_model_Manifestation$boolean(man, true)
            }
            this.hideConnectors();
            this.hideStruts();
            this.redo();
            const edges: Validate2Manifold.Edges = new Validate2Manifold.Edges();
            for(let index=com.vzome.core.editor.api.Manifestations.getVisiblePanels(this.mManifestations).iterator();index.hasNext();) {
                let panel = index.next();
                {
                    let v0: com.vzome.core.algebra.AlgebraicVector = null;
                    let prev: com.vzome.core.algebra.AlgebraicVector = null;
                    for(let index=panel.iterator();index.hasNext();) {
                        let vertex = index.next();
                        {
                            if (v0 == null){
                                v0 = vertex;
                                prev = vertex;
                            } else {
                                const strut: com.vzome.core.model.Strut = new com.vzome.core.model.StrutImpl(prev, vertex);
                                edges.addStrut(strut, panel);
                                prev = vertex;
                            }
                        }
                    }
                    const strut: com.vzome.core.model.Strut = new com.vzome.core.model.StrutImpl(prev, v0);
                    edges.addStrut(strut, panel);
                }
            }
            let invalid: boolean = false;
            for(let index=edges.entrySet().iterator();index.hasNext();) {
                let entry = index.next();
                {
                    if (entry.getValue().size() !== 2){
                        this.showStrut(entry.getKey());
                        invalid = true;
                    }
                }
            }
            if (invalid){
                this.hidePanels();
                this.redo();
                return;
            }
            for(let index=edges.entrySet().iterator();index.hasNext();) {
                let entry = index.next();
                {
                    const strut: com.vzome.core.model.Strut = entry.getKey();
                    const v1: com.vzome.core.algebra.AlgebraicVector = strut.getLocation();
                    const v2: com.vzome.core.algebra.AlgebraicVector = strut.getEnd();
                    const oriented: (p1: com.vzome.core.model.Panel) => boolean = ((v1,v2) => {
                        return (p) => {
                            let prev: com.vzome.core.algebra.AlgebraicVector = null;
                            for(let index=p.iterator();index.hasNext();) {
                                let v = index.next();
                                {
                                    if (v.equals(v2) && prev != null)return v1.equals(prev);
                                    prev = v;
                                }
                            }
                            return v1.equals(prev);
                        }
                    })(v1,v2);
                    const panels: com.vzome.core.model.Panel[] = [null, null];
                    entry.getValue().toArray<any>(panels);
                    const c1: boolean = (target => (typeof target === 'function') ? target(panels[0]) : (<any>target).apply(panels[0]))(oriented);
                    const c2: boolean = (target => (typeof target === 'function') ? target(panels[1]) : (<any>target).apply(panels[1]))(oriented);
                    if (c1 === c2){
                        invalid = true;
                        this.showStrut(strut);
                    }
                }
            }
            if (invalid){
                this.redo();
                return;
            }
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "Validate2Manifold";
        }
    }
    Validate2Manifold["__class"] = "com.vzome.core.edits.Validate2Manifold";


    export namespace Validate2Manifold {

        export class Edges extends java.util.HashMap<com.vzome.core.model.Strut, java.util.Collection<com.vzome.core.model.Panel>> {
            addStrut(strut: com.vzome.core.model.Strut, panel: com.vzome.core.model.Panel) {
                let existing: java.util.Collection<com.vzome.core.model.Panel> = this.get(strut);
                if (existing == null){
                    existing = <any>(new java.util.HashSet<com.vzome.core.model.Panel>());
                    this.put(strut, existing);
                }
                existing.add(panel);
            }

            constructor() {
                super();
            }
        }
        Edges["__class"] = "com.vzome.core.edits.Validate2Manifold.Edges";
        Edges["__interfaces"] = ["java.lang.Cloneable","java.util.Map","java.io.Serializable"];


    }

}
namespace com.vzome.core.edits {
    export class PanelCentroids extends com.vzome.core.editor.api.ChangeManifestations {
        public constructor(editorModel: com.vzome.core.editor.api.EditorModel) {
            super(editorModel);
        }

        /**
         * 
         */
        public perform() {
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                        const panel: com.vzome.core.model.Panel = <com.vzome.core.model.Panel><any>man;
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.FreePoint(panel.getCentroid())));
                    }
                }
            }
            this.redo();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "PanelCentroids";
        }
    }
    PanelCentroids["__class"] = "com.vzome.core.edits.PanelCentroids";

}
namespace com.vzome.core.edits {
    export class StrutCreation extends com.vzome.core.editor.api.ChangeManifestations {
        mAnchor: com.vzome.core.construction.Point;

        /*private*/ mAxis: com.vzome.core.math.symmetry.Axis;

        /*private*/ mLength: com.vzome.core.algebra.AlgebraicNumber;

        /**
         * 
         * @param {*} params
         */
        public configure(params: java.util.Map<string, any>) {
            this.mAnchor = <com.vzome.core.construction.Point>params.get("anchor");
            this.mAxis = <com.vzome.core.math.symmetry.Axis>params.get("zone");
            this.mLength = <com.vzome.core.algebra.AlgebraicNumber><any>params.get("length");
        }

        public constructor(anchor?: any, axis?: any, len?: any, editor?: any) {
            if (((anchor != null && anchor instanceof <any>com.vzome.core.construction.Point) || anchor === null) && ((axis != null && axis instanceof <any>com.vzome.core.math.symmetry.Axis) || axis === null) && ((len != null && (len.constructor != null && len.constructor["__interfaces"] != null && len.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || len === null) && ((editor != null && (editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editor === null)) {
                let __args = arguments;
                super(editor);
                if (this.mAnchor === undefined) { this.mAnchor = null; } 
                if (this.mAxis === undefined) { this.mAxis = null; } 
                if (this.mLength === undefined) { this.mLength = null; } 
                this.mAnchor = anchor;
                this.mAxis = axis;
                this.mLength = len;
            } else if (((anchor != null && (anchor.constructor != null && anchor.constructor["__interfaces"] != null && anchor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || anchor === null) && axis === undefined && len === undefined && editor === undefined) {
                let __args = arguments;
                let editor: any = __args[0];
                {
                    let __args = arguments;
                    let anchor: any = null;
                    let axis: any = null;
                    let len: any = null;
                    super(editor);
                    if (this.mAnchor === undefined) { this.mAnchor = null; } 
                    if (this.mAxis === undefined) { this.mAxis = null; } 
                    if (this.mLength === undefined) { this.mLength = null; } 
                    this.mAnchor = anchor;
                    this.mAxis = axis;
                    this.mLength = len;
                }
            } else throw new Error('invalid overload');
        }

        /**
         * 
         */
        public perform() {
            const segment: com.vzome.core.construction.Segment = new com.vzome.core.construction.AnchoredSegment(this.mAxis, this.mLength, this.mAnchor);
            this.manifestConstruction(segment);
            const point: com.vzome.core.construction.Point = new com.vzome.core.construction.SegmentEndPoint(segment);
            this.manifestConstruction(point);
            this.redo();
        }

        /**
         * 
         * @param {*} xml
         */
        getXmlAttributes(xml: org.w3c.dom.Element) {
            com.vzome.core.commands.XmlSaveFormat.serializePoint(xml, "anchor", this.mAnchor);
            com.vzome.core.commands.XmlSymmetryFormat.serializeAxis(xml, "symm", "dir", "index", "sense", this.mAxis);
            com.vzome.core.commands.XmlSaveFormat.serializeNumber(xml, "len", this.mLength);
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        public setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            if (format.rationalVectors()){
                this.mAnchor = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "anchor");
                this.mAxis = (<com.vzome.core.commands.XmlSymmetryFormat>format).parseAxis(xml, "symm", "dir", "index", "sense");
                this.mLength = format.parseNumber(xml, "len");
            } else {
                const attrs: com.vzome.core.commands.AttributeMap = format.loadCommandAttributes$org_w3c_dom_Element$boolean(xml, true);
                this.mAnchor = <com.vzome.core.construction.Point>attrs.get("anchor");
                this.mAxis = <com.vzome.core.math.symmetry.Axis>attrs.get("axis");
                this.mLength = <com.vzome.core.algebra.AlgebraicNumber><any>attrs.get("len");
            }
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "StrutCreation";
        }
    }
    StrutCreation["__class"] = "com.vzome.core.edits.StrutCreation";

}
namespace com.vzome.core.edits {
    export class StrutIntersection extends com.vzome.core.editor.api.ChangeManifestations {
        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
        }

        /**
         * 
         */
        public perform() {
            let s1: com.vzome.core.model.Strut = null;
            let s2: com.vzome.core.model.Strut = null;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))if (s1 == null)s1 = <com.vzome.core.model.Strut><any>man; else if (s2 == null)s2 = <com.vzome.core.model.Strut><any>man; else throw new com.vzome.core.commands.Command.Failure("only two struts are allowed");
                }
            }
            if (s1 == null || s2 == null)throw new com.vzome.core.commands.Command.Failure("two struts are required");
            const l1: com.vzome.core.construction.Line = new com.vzome.core.construction.LineFromPointAndVector(s1.getLocation(), s1.getZoneVector());
            const l2: com.vzome.core.construction.Line = new com.vzome.core.construction.LineFromPointAndVector(s2.getLocation(), s2.getZoneVector());
            const point: com.vzome.core.construction.Point = new com.vzome.core.construction.LineLineIntersectionPoint(l1, l2);
            if (point.isImpossible())throw new com.vzome.core.commands.Command.Failure("lines are parallel or non-intersecting");
            const ball: com.vzome.core.model.Manifestation = this.manifestConstruction(point);
            this.select$com_vzome_core_model_Manifestation(ball);
            this.redo();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "StrutIntersection";
        }
    }
    StrutIntersection["__class"] = "com.vzome.core.edits.StrutIntersection";

}
namespace com.vzome.core.edits {
    /**
     * Work in progress, to help someone create correctly oriented surfaces for vZome part export,
     * or for StL 3D printing export.
     * 
     * @author Scott Vorthmann
     * @param {*} singlePanel
     * @param {*} editor
     * @class
     * @extends com.vzome.core.editor.api.ChangeManifestations
     */
    export class ReversePanel extends com.vzome.core.editor.api.ChangeManifestations {
        /**
         * 
         */
        public perform() {
            if (this.panel != null){
                if (this.mSelection.manifestationSelected(this.panel))this.unselect$com_vzome_core_model_Manifestation(this.panel);
                const polygon: com.vzome.core.construction.Polygon = <com.vzome.core.construction.Polygon>this.panel.getFirstConstruction();
                this.unmanifestConstruction(polygon);
            }
            this.redo();
        }

        /*private*/ panel: com.vzome.core.model.Panel;

        public constructor(singlePanel: com.vzome.core.model.Manifestation, editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            if (this.panel === undefined) { this.panel = null; }
            if (singlePanel != null)this.panel = <com.vzome.core.model.Panel><any>singlePanel; else this.panel = null;
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "ReversePanel";
        }
    }
    ReversePanel["__class"] = "com.vzome.core.edits.ReversePanel";

}
namespace com.vzome.core.edits {
    export class DodecagonSymmetry extends com.vzome.core.editor.api.ChangeManifestations {
        /*private*/ center: com.vzome.core.construction.Point;

        /*private*/ symmetry: com.vzome.core.math.symmetry.Symmetry;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            if (this.center === undefined) { this.center = null; }
            if (this.symmetry === undefined) { this.symmetry = null; }
            this.center = (<com.vzome.core.editor.api.ImplicitSymmetryParameters><any>editor).getCenterPoint();
            this.symmetry = (<com.vzome.core.editor.api.SymmetryAware><any>editor)['getSymmetrySystem$']().getSymmetry();
        }

        /**
         * 
         */
        public perform() {
            const transform: com.vzome.core.construction.Transformation = new com.vzome.core.construction.SymmetryTransformation(this.symmetry, 1, this.center);
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    let c: com.vzome.core.construction.Construction = man.getFirstConstruction();
                    for(let i: number = 0; i < 11; i++) {{
                        c = transform.transform$com_vzome_core_construction_Construction(c);
                        if (c == null)continue;
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(c));
                    };}
                }
            }
            this.redo();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "DodecagonSymmetry";
        }
    }
    DodecagonSymmetry["__class"] = "com.vzome.core.edits.DodecagonSymmetry";

}
namespace com.vzome.core.edits {
    export class RunZomicScript extends com.vzome.core.editor.api.ChangeManifestations {
        /*private*/ programText: string;

        /*private*/ origin: com.vzome.core.construction.Point;

        /*private*/ symm: com.vzome.core.math.symmetry.IcosahedralSymmetry;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            if (this.programText === undefined) { this.programText = null; }
            if (this.origin === undefined) { this.origin = null; }
            if (this.symm === undefined) { this.symm = null; }
            this.origin = (<com.vzome.core.editor.api.ImplicitSymmetryParameters><any>editor).getCenterPoint();
            this.symm = <com.vzome.core.math.symmetry.IcosahedralSymmetry><any>(<com.vzome.core.editor.api.SymmetryAware><any>editor)['getSymmetrySystem$']().getSymmetry();
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
            this.programText = <string>props.get("script");
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "RunZomicScript";
        }

        getScriptDialect(): string {
            return "zomic";
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            element.setTextContent(com.vzome.core.commands.XmlSaveFormat.escapeNewlines(this.programText));
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            this.programText = xml.getTextContent();
            this.symm = <com.vzome.core.math.symmetry.IcosahedralSymmetry><any>(<com.vzome.core.commands.XmlSymmetryFormat>format).parseSymmetry("icosahedral");
        }

        /**
         * 
         */
        public perform() {
            let offset: com.vzome.core.construction.Point = null;
            let pointFound: boolean = false;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        const nextPoint: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>(<com.vzome.core.model.Connector><any>man).getFirstConstruction();
                        if (!pointFound){
                            pointFound = true;
                            offset = nextPoint;
                        } else {
                            offset = null;
                        }
                    }
                }
            }
            if (offset == null)offset = this.origin;
            try {
                this.symm.interpretScript(this.programText, this.getScriptDialect(), offset, this.symm, new com.vzome.core.editor.api.ManifestConstructions(this));
            } catch(e) {
                throw new com.vzome.core.commands.Command.Failure(e.message, e);
            }
            this.redo();
        }
    }
    RunZomicScript["__class"] = "com.vzome.core.edits.RunZomicScript";

}
namespace com.vzome.core.edits {
    export class PanelPerimeters extends com.vzome.core.editor.api.ChangeManifestations {
        public constructor(editorModel: com.vzome.core.editor.api.EditorModel) {
            super(editorModel);
        }

        /**
         * 
         */
        public perform() {
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (!(man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0))){
                        this.unselect$com_vzome_core_model_Manifestation(man);
                    }
                }
            }
            this.redo();
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                        this.unselect$com_vzome_core_model_Manifestation(man);
                        const panel: com.vzome.core.model.Panel = <com.vzome.core.model.Panel><any>man;
                        const polygon: com.vzome.core.construction.Polygon = <com.vzome.core.construction.Polygon>panel.getFirstConstruction();
                        const vertices: com.vzome.core.algebra.AlgebraicVector[] = polygon.getVertices();
                        const first: com.vzome.core.construction.FreePoint = new com.vzome.core.construction.FreePoint(vertices[0]);
                        let start: com.vzome.core.construction.FreePoint = first;
                        for(let i: number = 1; i < vertices.length; i++) {{
                            const end: com.vzome.core.construction.FreePoint = new com.vzome.core.construction.FreePoint(vertices[i]);
                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(start));
                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(start, end)));
                            start = end;
                        };}
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(start));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(start, first)));
                    }
                }
            }
            this.redo();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "PanelPerimeters";
        }
    }
    PanelPerimeters["__class"] = "com.vzome.core.edits.PanelPerimeters";

}
namespace com.vzome.core.edits {
    /**
     * @author David Hall
     * @param {*} editor
     * @class
     * @extends com.vzome.core.editor.api.ChangeManifestations
     */
    export class MapToColor extends com.vzome.core.editor.api.ChangeManifestations {
        /*private*/ colorMapper: com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper;

        /*private*/ editor: com.vzome.core.editor.api.EditorModel;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            if (this.colorMapper === undefined) { this.colorMapper = null; }
            if (this.editor === undefined) { this.editor = null; }
            this.editor = editor;
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
            const colorMapperName: string = <string>props.get("mode");
            const symmetry: com.vzome.core.editor.api.OrbitSource = (<com.vzome.core.editor.api.SymmetryAware><any>this.editor)['getSymmetrySystem$']();
            if (colorMapperName != null)this.colorMapper = com.vzome.core.edits.ManifestationColorMappers.getColorMapper$java_lang_String$com_vzome_core_editor_api_OrbitSource(colorMapperName, symmetry);
        }

        /**
         * Either configure() or setXmlAttributes() is always called before perform()
         */
        public perform() {
            if (this.colorMapper.requiresOrderedSelection()){
                this.setOrderedSelection(true);
            }
            this.colorMapper.initialize(this.getRenderedSelection());
            for(let index=this.getRenderedSelection().iterator();index.hasNext();) {
                let man = index.next();
                {
                    const newColor: com.vzome.core.construction.Color = this.colorMapper.apply$com_vzome_core_model_Manifestation(man);
                    this.plan(new MapToColor.ColorMapManifestation(this, man, newColor));
                    this.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                }
            }
            this.redo();
        }

        static COLORMAPPER_ATTR_NAME: string = "colorMapper";

        /**
         * 
         * @param {*} result
         */
        public getXmlAttributes(result: org.w3c.dom.Element) {
            result.setAttribute(MapToColor.COLORMAPPER_ATTR_NAME, this.colorMapper.getName());
            this.colorMapper.getXmlAttributes(result);
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        public setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            const symmetry: com.vzome.core.editor.api.OrbitSource = (<com.vzome.core.editor.api.SymmetryAware><any>this.editor)['getSymmetrySystem$java_lang_String'](xml.getAttribute("symmetry"));
            const colorMapperName: string = xml.getAttribute(MapToColor.COLORMAPPER_ATTR_NAME);
            this.colorMapper = com.vzome.core.edits.ManifestationColorMappers.getColorMapper$java_lang_String$com_vzome_core_editor_api_OrbitSource(colorMapperName, symmetry);
            this.colorMapper.setXmlAttributes(xml);
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "MapToColor";
        }
    }
    MapToColor["__class"] = "com.vzome.core.edits.MapToColor";


    export namespace MapToColor {

        export class ColorMapManifestation implements com.vzome.core.editor.api.SideEffect {
            public __parent: any;
            mManifestation: com.vzome.core.model.Manifestation;

            oldColor: com.vzome.core.construction.Color;

            newColor: com.vzome.core.construction.Color;

            public constructor(__parent: any, manifestation: com.vzome.core.model.Manifestation, color: com.vzome.core.construction.Color) {
                this.__parent = __parent;
                if (this.mManifestation === undefined) { this.mManifestation = null; }
                if (this.oldColor === undefined) { this.oldColor = null; }
                if (this.newColor === undefined) { this.newColor = null; }
                this.mManifestation = manifestation;
                this.newColor = color;
                this.oldColor = manifestation.getColor();
            }

            /**
             * 
             */
            public redo() {
                this.__parent.mManifestations.setColor(this.mManifestation, this.newColor);
            }

            /**
             * 
             */
            public undo() {
                this.__parent.mManifestations.setColor(this.mManifestation, this.oldColor);
            }

            /**
             * 
             * @param {*} doc
             * @return {*}
             */
            public getXml(doc: org.w3c.dom.Document): org.w3c.dom.Element {
                const result: org.w3c.dom.Element = doc.createElement("color");
                com.vzome.xml.DomUtils.addAttribute(result, "rgb", this.newColor.toString());
                const man: org.w3c.dom.Element = this.mManifestation.getXml(doc);
                result.appendChild(man);
                return result;
            }
        }
        ColorMapManifestation["__class"] = "com.vzome.core.edits.MapToColor.ColorMapManifestation";
        ColorMapManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffect"];


    }

}
namespace com.vzome.core.edits {
    export class ColorManifestations extends com.vzome.core.editor.api.ChangeManifestations {
        /*private*/ color: com.vzome.core.construction.Color;

        public constructor(editorModel: com.vzome.core.editor.api.EditorModel) {
            super(editorModel);
            if (this.color === undefined) { this.color = null; }
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
            const mode: string = <string>props.get("mode");
            if (mode != null)this.initialize(new com.vzome.core.construction.Color(mode));
        }

        /*private*/ initialize(color: com.vzome.core.construction.Color) {
            this.color = color;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let m = index.next();
                {
                    if (m.isRendered())this.colorManifestation(m, color);
                    this.unselect$com_vzome_core_model_Manifestation$boolean(m, true);
                }
            }
        }

        /**
         * 
         * @param {*} result
         */
        public getXmlAttributes(result: org.w3c.dom.Element) {
            result.setAttribute("red", "" + this.color.getRed());
            result.setAttribute("green", "" + this.color.getGreen());
            result.setAttribute("blue", "" + this.color.getBlue());
            const alpha: number = this.color.getAlpha();
            if (alpha < 255)result.setAttribute("alpha", "" + alpha);
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        public setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            if (format.loadToRender()){
                const red: string = xml.getAttribute("red");
                const green: string = xml.getAttribute("green");
                const blue: string = xml.getAttribute("blue");
                const alphaStr: string = xml.getAttribute("alpha");
                const alpha: number = (alphaStr == null || /* isEmpty */(alphaStr.length === 0)) ? 255 : javaemul.internal.IntegerHelper.parseInt(alphaStr);
                this.initialize(new com.vzome.core.construction.Color(javaemul.internal.IntegerHelper.parseInt(red), javaemul.internal.IntegerHelper.parseInt(green), javaemul.internal.IntegerHelper.parseInt(blue), alpha));
            } else this.initialize(null);
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "setItemColor";
        }
    }
    ColorManifestations["__class"] = "com.vzome.core.edits.ColorManifestations";

}
namespace com.vzome.core.edits {
    export abstract class ImportMesh extends com.vzome.core.editor.api.ChangeManifestations {
        meshData: string;

        scale: com.vzome.core.algebra.AlgebraicNumber;

        projection: com.vzome.core.math.Projection;

        editor: com.vzome.core.editor.api.EditorModel;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            if (this.meshData === undefined) { this.meshData = null; }
            if (this.scale === undefined) { this.scale = null; }
            if (this.projection === undefined) { this.projection = null; }
            if (this.editor === undefined) { this.editor = null; }
            this.editor = editor;
        }

        /**
         * 
         * @param {*} params
         */
        public configure(params: java.util.Map<string, any>) {
            const field: com.vzome.core.algebra.AlgebraicField = this.mManifestations.getField();
            this.meshData = <string>params.get("vef");
            this.projection = <com.vzome.core.math.Projection><any>params.get("projection");
            this.scale = <com.vzome.core.algebra.AlgebraicNumber><any>params.get("scale");
            if (this.scale == null){
                this.scale = field.one();
            }
            const mode: string = <string>params.getOrDefault("mode", "");
            switch((mode)) {
            case "":
                break;
            case "clipboard":
                if (this.meshData != null && !/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(this.meshData, "vZome VEF") && !/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(this.meshData, "{"))this.meshData = null;
                break;
            case "Quaternion":
                break;
            default:
                this.setProjection(mode, field);
                break;
            }
        }

        /**
         * 
         * @return {boolean}
         */
        public isNoOp(): boolean {
            return this.meshData == null;
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            if (this.scale != null)com.vzome.xml.DomUtils.addAttribute(element, "scale", this.scale.toString(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
            if (this.projection != null){
                const name: string = this.projection.getProjectionName();
                if (!("" === name)){
                    com.vzome.xml.DomUtils.addAttribute(element, "projection", this.projection.getProjectionName());
                    this.projection.getXmlAttributes(element);
                }
            }
            const textNode: org.w3c.dom.Node = element.getOwnerDocument().createTextNode(com.vzome.core.commands.XmlSaveFormat.escapeNewlines(this.meshData));
            element.appendChild(textNode);
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            const field: com.vzome.core.algebra.AlgebraicField = format.getField();
            this.scale = format.parseRationalNumber(xml, "scale");
            if (this.scale == null){
                this.scale = field.one();
            }
            this.meshData = xml.getTextContent();
            const projectionName: string = xml.getAttribute("projection");
            if ("" === projectionName){
                const quaternion: com.vzome.core.algebra.AlgebraicVector = format.parseRationalVector(xml, "quaternion");
                this.projection = quaternion == null ? null : new com.vzome.core.math.QuaternionProjection(field, null, quaternion);
            } else {
                this.setProjection(projectionName, field);
            }
            if (this.projection != null){
                this.projection.setXmlAttributes(xml);
            }
        }

        setProjection(projectionName: string, field: com.vzome.core.algebra.AlgebraicField) {
            switch((projectionName)) {
            case "Quaternion":
                this.projection = new com.vzome.core.math.QuaternionProjection(field, null, null);
                break;
            case "SixCube":
                this.projection = new com.vzome.core.math.SixCubeProjection(field);
                break;
            case "Tetrahedral":
                this.projection = new com.vzome.core.math.TetrahedralProjection(field);
                break;
            case "Perspective":
                this.projection = new com.vzome.core.math.PerspectiveProjection(field, null);
                break;
            }
        }

        /**
         * 
         */
        public perform() {
            if (this.meshData == null)return;
            let offset: com.vzome.core.algebra.AlgebraicVector = null;
            let pointFound: boolean = false;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        const nextPoint: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>(<com.vzome.core.model.Connector><any>man).getFirstConstruction();
                        if (!pointFound){
                            pointFound = true;
                            offset = nextPoint.getLocation();
                        } else {
                            offset = null;
                            break;
                        }
                    }
                    if (this.deselectInputs())this.unselect$com_vzome_core_model_Manifestation(man);
                }
            }
            const field: com.vzome.core.algebra.AlgebraicField = this.mManifestations.getField();
            const events: com.vzome.core.editor.api.ManifestConstructions = new com.vzome.core.editor.api.ManifestConstructions(this);
            const registry: com.vzome.core.algebra.AlgebraicField.Registry = new ImportMesh.ImportMesh$0(this, field);
            if (this.projection == null)this.projection = new com.vzome.core.math.Projection.Default(field);
            try {
                this.parseMeshData(offset, events, registry);
            } catch(e) {
                throw new com.vzome.core.commands.Command.Failure("Incorrect content for this import:\n" + e.message);
            }
            this.redo();
        }

        abstract parseMeshData(offset: com.vzome.core.algebra.AlgebraicVector, events: com.vzome.core.editor.api.ManifestConstructions, registry: com.vzome.core.algebra.AlgebraicField.Registry);

        deselectInputs(): boolean {
            return true;
        }
    }
    ImportMesh["__class"] = "com.vzome.core.edits.ImportMesh";


    export namespace ImportMesh {

        export class ImportMesh$0 implements com.vzome.core.algebra.AlgebraicField.Registry {
            public __parent: any;
            /**
             * 
             * @param {string} name
             * @return {*}
             */
            public getField(name: string): com.vzome.core.algebra.AlgebraicField {
                if (this.field.supportsSubfield(name))return this.field; else {
                    return null;
                }
            }

            constructor(__parent: any, private field: any) {
                this.__parent = __parent;
            }
        }
        ImportMesh$0["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField.Registry"];


    }

}
namespace com.vzome.core.edits {
    export class Delete extends com.vzome.core.editor.api.ChangeManifestations {
        /**
         * 
         */
        public perform() {
            const inputs: java.util.ArrayList<com.vzome.core.model.Manifestation> = <any>(new java.util.ArrayList<any>());
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    inputs.add(man);
                    this.unselect$com_vzome_core_model_Manifestation(man);
                }
            }
            this.redo();
            for(let index=inputs.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.deleteManifestation(man);
                }
            }
            super.perform();
        }

        public constructor(editorModel: com.vzome.core.editor.api.EditorModel) {
            super(editorModel);
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "Delete";
        }
    }
    Delete["__class"] = "com.vzome.core.edits.Delete";

}
namespace com.vzome.core.edits {
    export class AffineTransformAll extends com.vzome.core.editor.api.ChangeManifestations {
        /*private*/ center: com.vzome.core.construction.Point;

        public constructor(editorModel: com.vzome.core.editor.api.EditorModel) {
            super(editorModel);
            if (this.center === undefined) { this.center = null; }
            this.center = (<com.vzome.core.editor.api.ImplicitSymmetryParameters><any>editorModel).getCenterPoint();
        }

        /**
         * 
         */
        public perform() {
            let s1: com.vzome.core.construction.Segment = null;
            let s2: com.vzome.core.construction.Segment = null;
            let s3: com.vzome.core.construction.Segment = null;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        if (s1 == null)s1 = <com.vzome.core.construction.Segment>man.getFirstConstruction(); else if (s2 == null)s2 = <com.vzome.core.construction.Segment>man.getFirstConstruction(); else if (s3 == null)s3 = <com.vzome.core.construction.Segment>man.getFirstConstruction();
                    }
                }
            }
            if (s3 == null || s2 == null || s1 == null)throw new com.vzome.core.commands.Command.Failure("three struts required");
            this.redo();
            const transform: com.vzome.core.construction.Transformation = new com.vzome.core.construction.ChangeOfBasis(s1, s2, s3, this.center, true);
            for(let index=this.mManifestations.iterator();index.hasNext();) {
                let m = index.next();
                {
                    if (!m.isRendered())continue;
                    const c: com.vzome.core.construction.Construction = m.getFirstConstruction();
                    const result: com.vzome.core.construction.Construction = transform.transform$com_vzome_core_construction_Construction(c);
                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(result));
                }
            }
            this.redo();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "AffineTransformAll";
        }
    }
    AffineTransformAll["__class"] = "com.vzome.core.edits.AffineTransformAll";

}
namespace com.vzome.core.edits {
    export class Parallelepiped extends com.vzome.core.editor.api.ChangeManifestations {
        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "Parallelepiped";
        }

        /**
         * 
         */
        public perform() {
            const errorMsg: string = "Parallelepiped command requires three selected struts with a common vertex.";
            let strut1: com.vzome.core.model.Strut = null;
            let strut2: com.vzome.core.model.Strut = null;
            let strut3: com.vzome.core.model.Strut = null;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        if (strut1 == null){
                            strut1 = <com.vzome.core.model.Strut><any>(man);
                        } else if (strut2 == null){
                            strut2 = <com.vzome.core.model.Strut><any>(man);
                        } else if (strut3 == null){
                            strut3 = <com.vzome.core.model.Strut><any>(man);
                        } else this.fail(errorMsg);
                    } else this.fail(errorMsg);
                }
            }
            if (strut1 == null || strut2 == null || strut3 == null){
                this.fail(errorMsg);
            }
            const s1: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>(strut1.getFirstConstruction());
            const s2: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>(strut2.getFirstConstruction());
            const s3: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>(strut3.getFirstConstruction());
            let offset1: com.vzome.core.algebra.AlgebraicVector = s1.getOffset();
            let offset2: com.vzome.core.algebra.AlgebraicVector = s2.getOffset();
            let offset3: com.vzome.core.algebra.AlgebraicVector = s3.getOffset();
            let v0: com.vzome.core.algebra.AlgebraicVector = null;
            let v1: com.vzome.core.algebra.AlgebraicVector = null;
            let v2: com.vzome.core.algebra.AlgebraicVector = null;
            let v3: com.vzome.core.algebra.AlgebraicVector = null;
            {
                const s1s: com.vzome.core.algebra.AlgebraicVector = s1.getStart();
                const s1e: com.vzome.core.algebra.AlgebraicVector = s1.getEnd();
                const s2s: com.vzome.core.algebra.AlgebraicVector = s2.getStart();
                const s2e: com.vzome.core.algebra.AlgebraicVector = s2.getEnd();
                if (s1s.equals(s2s)){
                    v1 = s1e;
                    v2 = s2e;
                    v0 = s2s;
                } else if (s1e.equals(s2s)){
                    v1 = s1s;
                    v2 = s2e;
                    v0 = s2s;
                    offset1 = offset1.negate();
                } else if (s1e.equals(s2e)){
                    v1 = s1s;
                    v2 = s2s;
                    v0 = s2e;
                    offset2 = offset2.negate();
                    offset1 = offset1.negate();
                } else if (s1s.equals(s2e)){
                    v1 = s1e;
                    v2 = s2s;
                    v0 = s2e;
                    offset2 = offset2.negate();
                } else {
                    this.fail(errorMsg);
                }
                const s3s: com.vzome.core.algebra.AlgebraicVector = s3.getStart();
                const s3e: com.vzome.core.algebra.AlgebraicVector = s3.getEnd();
                if (s3s.equals(v0)){
                    v3 = s3e;
                } else if (s3e.equals(v0)){
                    v3 = s3s;
                    offset3 = offset3.negate();
                } else {
                    this.fail(errorMsg);
                }
            };
            this.redo();
            const p0: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(v0);
            const p1: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(v1);
            const p2: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(v2);
            const p3: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(v3);
            this.manifestConstruction(p0);
            this.manifestConstruction(p1);
            this.manifestConstruction(p2);
            this.manifestConstruction(p3);
            this.redo();
            const v4: com.vzome.core.algebra.AlgebraicVector = v2.plus(offset3);
            const p4: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(v4);
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p4));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p2, p4)));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p3, p4)));
            const v5: com.vzome.core.algebra.AlgebraicVector = v3.plus(offset1);
            const p5: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(v5);
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p5));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p1, p5)));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p3, p5)));
            const v6: com.vzome.core.algebra.AlgebraicVector = v1.plus(offset2);
            const p6: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(v6);
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p6));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p1, p6)));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p2, p6)));
            const v7: com.vzome.core.algebra.AlgebraicVector = v4.plus(offset1);
            const p7: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(v7);
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p7));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p4, p7)));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p5, p7)));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p6, p7)));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p0, p3, p4, p2])));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p0, p1, p5, p3])));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p0, p2, p6, p1])));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p7, p4, p3, p5])));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p7, p6, p2, p4])));
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p7, p5, p1, p6])));
            this.redo();
        }
    }
    Parallelepiped["__class"] = "com.vzome.core.edits.Parallelepiped";

}
namespace com.vzome.core.edits {
    /**
     * @author David Hall
     * @param {*} editor
     * @class
     * @extends com.vzome.core.editor.api.ChangeManifestations
     */
    export class SelectAutomaticStruts extends com.vzome.core.editor.api.ChangeManifestations {
        symmetry: com.vzome.core.editor.api.OrbitSource;

        /*private*/ editor: com.vzome.core.editor.api.EditorModel;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            if (this.symmetry === undefined) { this.symmetry = null; }
            if (this.editor === undefined) { this.editor = null; }
            this.editor = editor;
            this.symmetry = (<com.vzome.core.editor.api.SymmetryAware><any>editor)['getSymmetrySystem$']();
        }

        /**
         * 
         */
        public perform() {
            this.unselectAll();
            for(let index=this.getVisibleStruts$java_util_function_Predicate((strut) => { return this.isAutomaticStrut(strut) }).iterator();index.hasNext();) {
                let strut = index.next();
                {
                    this.select$com_vzome_core_model_Manifestation(strut);
                }
            }
            super.perform();
        }

        /*private*/ isAutomaticStrut(strut: com.vzome.core.model.Strut): boolean {
            return this.symmetry.getAxis(strut.getOffset()).getOrbit().isAutomatic();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "SelectAutomaticStruts";
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            if (this.symmetry != null){
                com.vzome.xml.DomUtils.addAttribute(element, "symmetry", this.symmetry.getName());
            }
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            this.symmetry = (<com.vzome.core.editor.api.SymmetryAware><any>this.editor)['getSymmetrySystem$java_lang_String'](xml.getAttribute("symmetry"));
        }
    }
    SelectAutomaticStruts["__class"] = "com.vzome.core.edits.SelectAutomaticStruts";

}
namespace com.vzome.core.edits {
    /**
     * @author David Hall
     * @param {*} editor
     * @class
     * @extends com.vzome.core.editor.api.ChangeManifestations
     */
    export class SelectCollinear extends com.vzome.core.editor.api.ChangeManifestations {
        /*private*/ vector1: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ vector2: com.vzome.core.algebra.AlgebraicVector;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            this.vector1 = null;
            this.vector2 = null;
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
            const strut: com.vzome.core.model.Strut = <com.vzome.core.model.Strut><any>props.get("picked");
            if (strut != null){
                this.vector1 = strut.getLocation();
                this.vector2 = strut.getEnd();
            }
        }

        /**
         * 
         */
        public perform() {
            if (this.vector1 == null || this.vector2 == null){
                const lastStrut: com.vzome.core.model.Strut = this.getLastSelectedStrut();
                if (lastStrut != null){
                    this.vector1 = lastStrut.getLocation();
                    this.vector2 = lastStrut.getEnd();
                } else {
                    for(let index=this.getSelectedConnectors().iterator();index.hasNext();) {
                        let ball = index.next();
                        {
                            this.vector1 = this.vector2;
                            this.vector2 = ball.getLocation();
                        }
                    }
                }
            }
            if (this.vector1 == null || this.vector2 == null){
                throw new com.vzome.core.commands.Command.Failure("select a strut or two balls as a reference.");
            }
            this.unselectAll();
            const balls: java.util.Set<com.vzome.core.model.Connector> = <any>(new java.util.TreeSet<any>());
            for(let index=this.getVisibleConnectors$java_util_function_Predicate((ball) => { return this.isCollinearWith(ball) }).iterator();index.hasNext();) {
                let ball = index.next();
                {
                    balls.add(ball);
                }
            }
            const struts: java.util.Set<com.vzome.core.model.Strut> = <any>(new java.util.TreeSet<any>());
            for(let index=this.getVisibleStruts$().iterator();index.hasNext();) {
                let strut = index.next();
                {
                    if (this.isCollinearWith$com_vzome_core_model_Strut(strut)){
                        struts.add(strut);
                    }
                }
            }
            for(let index=struts.iterator();index.hasNext();) {
                let strut = index.next();
                {
                    this.select$com_vzome_core_model_Manifestation(strut);
                }
            }
            for(let index=balls.iterator();index.hasNext();) {
                let ball = index.next();
                {
                    this.select$com_vzome_core_model_Manifestation(ball);
                }
            }
            const level: java.util.logging.Level = java.util.logging.Level.FINER;
            if (com.vzome.core.editor.api.ChangeSelection.logger_$LI$().isLoggable(level)){
                const sb: java.lang.StringBuilder = new java.lang.StringBuilder("Selected:\n");
                const indent: string = "  ";
                for(let index=struts.iterator();index.hasNext();) {
                    let strut = index.next();
                    {
                        sb.append(indent).append(strut.toString()).append("\n");
                    }
                }
                for(let index=balls.iterator();index.hasNext();) {
                    let ball = index.next();
                    {
                        sb.append(indent).append(ball.toString()).append("\n");
                    }
                }
                com.vzome.core.editor.api.ChangeSelection.logger_$LI$().log(level, sb.toString());
            }
            super.perform();
        }

        public isCollinearWith$com_vzome_core_model_Connector(ball: com.vzome.core.model.Connector): boolean {
            return this.isCollinear(ball.getLocation());
        }

        public isCollinearWith(ball?: any): boolean {
            if (((ball != null && (ball.constructor != null && ball.constructor["__interfaces"] != null && ball.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || ball === null)) {
                return <any>this.isCollinearWith$com_vzome_core_model_Connector(ball);
            } else if (((ball != null && (ball.constructor != null && ball.constructor["__interfaces"] != null && ball.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || ball === null)) {
                return <any>this.isCollinearWith$com_vzome_core_model_Strut(ball);
            } else throw new Error('invalid overload');
        }

        /*private*/ isCollinearWith$com_vzome_core_model_Strut(strut: com.vzome.core.model.Strut): boolean {
            return this.isCollinear(strut.getLocation()) && this.isCollinear(strut.getEnd());
        }

        /*private*/ isCollinear(vec: com.vzome.core.algebra.AlgebraicVector): boolean {
            return com.vzome.core.algebra.AlgebraicVectors.areCollinear$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(vec, this.vector1, this.vector2);
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "SelectCollinear";
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            com.vzome.xml.DomUtils.addAttribute(element, "vector1", this.vector1.toParsableString());
            com.vzome.xml.DomUtils.addAttribute(element, "vector2", this.vector2.toParsableString());
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            this.vector1 = format.parseRationalVector(xml, "vector1");
            this.vector2 = format.parseRationalVector(xml, "vector2");
        }
    }
    SelectCollinear["__class"] = "com.vzome.core.edits.SelectCollinear";

}
namespace com.vzome.core.editor {
    /**
     * Just a mechanism to incorporate the legacy edit mechanism into the new undo/redo.
     * 
     * @author Scott Vorthmann 2006
     * @param {com.vzome.core.commands.AbstractCommand} cmd
     * @param {*} editor
     * @class
     * @extends com.vzome.core.editor.api.ChangeManifestations
     */
    export class CommandEdit extends com.vzome.core.editor.api.ChangeManifestations {
        /*private*/ mEditorModel: com.vzome.core.editor.api.EditorModel;

        /*private*/ mCommand: com.vzome.core.commands.AbstractCommand;

        /*private*/ mAttrs: com.vzome.core.commands.AttributeMap;

        static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (CommandEdit.logger == null) { CommandEdit.logger = java.util.logging.Logger.getLogger("com.vzome.core.editor.CommandEdit"); }  return CommandEdit.logger; }

        static loadAndPerformLgger: java.util.logging.Logger; public static loadAndPerformLgger_$LI$(): java.util.logging.Logger { if (CommandEdit.loadAndPerformLgger == null) { CommandEdit.loadAndPerformLgger = java.util.logging.Logger.getLogger("com.vzome.core.editor.CommandEdit.loadAndPerform"); }  return CommandEdit.loadAndPerformLgger; }

        public constructor(cmd: com.vzome.core.commands.AbstractCommand, editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            if (this.mEditorModel === undefined) { this.mEditorModel = null; }
            if (this.mCommand === undefined) { this.mCommand = null; }
            if (this.mAttrs === undefined) { this.mAttrs = null; }
            this.mEditorModel = editor;
            this.mCommand = cmd;
        }

        /**
         * 
         * @return {boolean}
         */
        groupingAware(): boolean {
            return true;
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            const cmdName: string = /* getName */(c => typeof c === 'string' ? c : c["__class"] ? c["__class"] : c["name"])((<any>this.mCommand.constructor));
            const lastDot: number = cmdName.lastIndexOf('.');
            return cmdName.substring(lastDot + 1 + "Command".length);
        }

        /**
         * 
         * @param {*} result
         */
        public getXmlAttributes(result: org.w3c.dom.Element) {
            this.mCommand.getXml(result, this.mAttrs);
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        public setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            this.mAttrs = this.mCommand.setXml(xml, format);
            this.mAttrs.put(com.vzome.core.commands.Command.LOADING_FROM_FILE, javaemul.internal.BooleanHelper.TRUE);
        }

        /**
         * 
         */
        public perform() {
            const isHide: boolean = (this.mCommand != null && this.mCommand instanceof <any>com.vzome.core.commands.CommandHide);
            if (CommandEdit.logger_$LI$().isLoggable(java.util.logging.Level.FINER)){
                CommandEdit.logger_$LI$().finer("------------------- CommandEdit");
            }
            if (this.mCommand.ordersSelection())this.setOrderedSelection(true);
            const constrsBefore: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (CommandEdit.logger_$LI$().isLoggable(java.util.logging.Level.FINER)){
                        CommandEdit.logger_$LI$().finer("----------- manifestation: " + man.toString());
                        for(const iterator: java.util.Iterator<com.vzome.core.construction.Construction> = man.getConstructions(); iterator.hasNext(); ) {{
                            const c: com.vzome.core.construction.Construction = iterator.next();
                            CommandEdit.logger_$LI$().finer("   " + c.toString());
                        };}
                    }
                    this.unselect$com_vzome_core_model_Manifestation(man);
                    if (isHide)this.hideManifestation(man); else {
                        const construction: com.vzome.core.construction.Construction = man.getFirstConstruction();
                        constrsBefore.add(construction);
                    }
                }
            }
            this.redo();
            if (isHide)return;
            if (this.mAttrs == null)this.mAttrs = new com.vzome.core.commands.AttributeMap();
            const symmAxis: com.vzome.core.construction.Segment = (<com.vzome.core.editor.api.LegacyEditorModel><any>this.mEditorModel).getSymmetrySegment();
            if (symmAxis != null)this.mAttrs.put(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME, symmAxis);
            this.mAttrs.put(com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME, (<com.vzome.core.editor.api.LegacyEditorModel><any>this.mEditorModel).getCenterPoint());
            this.mAttrs.put(com.vzome.core.commands.Command.FIELD_ATTR_NAME, this.mManifestations.getField());
            const news: CommandEdit.NewConstructions = new CommandEdit.NewConstructions();
            let selectionAfter: com.vzome.core.construction.ConstructionList = null;
            const signature: any[][] = this.mCommand.getParameterSignature();
            const actualsLen: number = constrsBefore.size();
            if ((signature.length === actualsLen) || (signature.length === 1 && /* equals */(<any>((o1: any, o2: any) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)(signature[0][0],com.vzome.core.commands.Command.GENERIC_PARAM_NAME)))){
                try {
                    selectionAfter = this.mCommand.apply(constrsBefore, this.mAttrs, news);
                } catch(f) {
                    this.undo();
                    throw f;
                }
            } else if (signature.length > actualsLen){
                this.fail("Too few objects in the selection.");
            } else if (signature.length === 1){
                let partial: com.vzome.core.construction.ConstructionList;
                selectionAfter = new com.vzome.core.construction.ConstructionList();
                for(let i: number = 0; i < actualsLen; i++) {{
                    const param: com.vzome.core.construction.Construction = constrsBefore.get(i);
                    const formalClass: any = (<any>signature[0][1]);
                    if ((formalClass === com.vzome.core.construction.Point && (param != null && param instanceof <any>com.vzome.core.construction.Point)) || (formalClass === com.vzome.core.construction.Segment && (param != null && param instanceof <any>com.vzome.core.construction.Segment))){
                        const single: com.vzome.core.construction.ConstructionList = new com.vzome.core.construction.ConstructionList();
                        single.addConstruction(param);
                        partial = this.mCommand.apply(single, this.mAttrs, news);
                        selectionAfter.addAll(partial);
                    } else selectionAfter.add(param);
                };}
            } else this.fail("Too many objects in the selection.");
            for(let index=news.iterator();index.hasNext();) {
                let c = index.next();
                {
                    this.manifestConstruction(c);
                }
            }
            for(let index=selectionAfter.iterator();index.hasNext();) {
                let cons = index.next();
                {
                    if (cons.failed()){
                        CommandEdit.logBugAccommodation("failed construction");
                        (<com.vzome.core.editor.api.LegacyEditorModel><any>this.mEditorModel).addFailedConstruction(cons);
                        continue;
                    }
                    const man: com.vzome.core.model.Manifestation = this.manifestConstruction(cons);
                    if (man != null)this.select$com_vzome_core_model_Manifestation(man);
                }
            }
            this.redo();
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         * @param {*} context
         */
        public loadAndPerform(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat, context: com.vzome.core.editor.api.Context) {
            let cmdName: string = null;
            if (format.selectionsNotSaved())cmdName = xml.getLocalName(); else if (format.commandEditsCompacted())cmdName = "Command" + xml.getLocalName(); else cmdName = xml.getAttribute("command");
            if (cmdName === ("CommandIcosahedralSymmetry"))cmdName = "CommandSymmetry";
            this.mCommand = <com.vzome.core.commands.AbstractCommand><any>context.createLegacyCommand(cmdName);
            if (format.selectionsNotSaved()){
                const selectedBefore: java.util.Set<com.vzome.core.model.Manifestation> = <any>(new java.util.LinkedHashSet<any>());
                context.performAndRecord(new com.vzome.core.editor.BeginBlock(null));
                this.mAttrs = new com.vzome.core.commands.AttributeMap();
                const nodes: org.w3c.dom.NodeList = xml.getChildNodes();
                for(let j: number = 0; j < nodes.getLength(); j++) {{
                    const kid2: org.w3c.dom.Node = nodes.item(j);
                    if (kid2 != null && (kid2.constructor != null && kid2.constructor["__interfaces"] != null && kid2.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)){
                        const attrOrParam: org.w3c.dom.Element = <org.w3c.dom.Element><any>kid2;
                        const apName: string = attrOrParam.getLocalName();
                        if (apName === ("attr")){
                            let attrName: string = attrOrParam.getAttribute("name");
                            if (/* endsWith */((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(attrName, ".symmetry.center"))attrName = com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME; else if (attrName === ("reflection.mirror.normal.segment"))attrName = com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME;
                            const val: org.w3c.dom.Element = com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element(attrOrParam);
                            let valName: string = val.getLocalName();
                            if (valName === ("FreePoint"))valName = "point";
                            let value: any = format.parseAlgebraicObject(valName, val);
                            if (value === com.vzome.core.commands.XmlSaveFormat.NOT_AN_ATTRIBUTE_$LI$())value = format.parseConstruction$java_lang_String$org_w3c_dom_Element(valName, val);
                            if (attrName === com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME){
                                const c: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint((<com.vzome.core.construction.Point>value).getLocation().projectTo3d(true));
                                context.performAndRecord(new com.vzome.core.edits.SymmetryCenterChange(<com.vzome.core.editor.api.LegacyEditorModel><any>this.mEditorModel, c));
                            } else if (attrName === com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME){
                                context.performAndRecord(new com.vzome.core.edits.SymmetryAxisChange(<com.vzome.core.editor.api.LegacyEditorModel><any>this.mEditorModel, <com.vzome.core.construction.Segment>value));
                                if (!this.mCommand.attributeIs3D(attrName)){
                                    const vector: com.vzome.core.algebra.AlgebraicVector = (<com.vzome.core.construction.Segment>value).getOffset();
                                    this.mCommand.setQuaternion(vector);
                                }
                            } else this.mAttrs.put(attrName, value);
                        } else {
                            const c: com.vzome.core.construction.Construction = format.parseConstruction$java_lang_String$org_w3c_dom_Element(apName, attrOrParam);
                            if (c != null){
                                if ((<com.vzome.core.editor.api.LegacyEditorModel><any>this.mEditorModel).hasFailedConstruction(c)){
                                    CommandEdit.logBugAccommodation("skip selecting a failed construction");
                                    continue;
                                }
                                const m: com.vzome.core.model.Manifestation = this.getManifestation(c);
                                if (m == null || m.isUnnecessary()){
                                    CommandEdit.loadAndPerformLgger_$LI$().severe("CommandEdit parameter: " + attrOrParam.toString());
                                    throw new com.vzome.core.commands.Command.Failure("no manifestation to be selected.");
                                }
                                if (!selectedBefore.contains(m))selectedBefore.add(m);
                            }
                        }
                    }
                };}
                if (selectedBefore.size() > (this.mManifestations.size() / 2|0)){
                    const toUnselect: java.util.Collection<com.vzome.core.model.Manifestation> = <any>(new java.util.ArrayList<any>());
                    for(let index=this.mManifestations.iterator();index.hasNext();) {
                        let m = index.next();
                        {
                            if (!selectedBefore.contains(m))toUnselect.add(m);
                        }
                    }
                    let edit: com.vzome.core.editor.api.ChangeSelection = new com.vzome.core.edits.SelectAll(this.mEditorModel);
                    context.performAndRecord(edit);
                    for(let index=toUnselect.iterator();index.hasNext();) {
                        let m = index.next();
                        {
                            edit = new com.vzome.core.edits.SelectManifestation(this.mEditorModel, m);
                            context.performAndRecord(edit);
                        }
                    }
                } else {
                    let edit: com.vzome.core.editor.api.ChangeSelection = new com.vzome.core.edits.DeselectAll(this.mEditorModel);
                    context.performAndRecord(edit);
                    for(let index=selectedBefore.iterator();index.hasNext();) {
                        let m = index.next();
                        {
                            edit = new com.vzome.core.edits.SelectManifestation(this.mEditorModel, m);
                            context.performAndRecord(edit);
                        }
                    }
                }
                context.performAndRecord(new com.vzome.core.editor.EndBlock(null));
                this.redo();
                if (this.mCommand != null && this.mCommand instanceof <any>com.vzome.core.commands.CommandObliquePentagon){
                    const edit: com.vzome.core.editor.api.UndoableEdit = new com.vzome.core.edits.AffinePentagon(this.mEditorModel);
                    context.performAndRecord(edit);
                    return;
                }
                this.mCommand.setFixedAttributes(this.mAttrs, format);
                this.mAttrs.put(com.vzome.core.commands.Command.LOADING_FROM_FILE, javaemul.internal.BooleanHelper.TRUE);
                context.performAndRecord(this);
            } else super.loadAndPerform(xml, format, context);
        }
    }
    CommandEdit["__class"] = "com.vzome.core.editor.CommandEdit";


    export namespace CommandEdit {

        export class NewConstructions extends java.util.ArrayList<com.vzome.core.construction.Construction> implements com.vzome.core.construction.ConstructionChanges {
            public constructionAdded$com_vzome_core_construction_Construction(c: com.vzome.core.construction.Construction) {
                this.add(c);
            }

            public constructionAdded$com_vzome_core_construction_Construction$com_vzome_core_construction_Color(c: com.vzome.core.construction.Construction, color: com.vzome.core.construction.Color) {
                this.add(c);
            }

            /**
             * 
             * @param {com.vzome.core.construction.Construction} c
             * @param {com.vzome.core.construction.Color} color
             */
            public constructionAdded(c?: any, color?: any) {
                if (((c != null && c instanceof <any>com.vzome.core.construction.Construction) || c === null) && ((color != null && color instanceof <any>com.vzome.core.construction.Color) || color === null)) {
                    return <any>this.constructionAdded$com_vzome_core_construction_Construction$com_vzome_core_construction_Color(c, color);
                } else if (((c != null && c instanceof <any>com.vzome.core.construction.Construction) || c === null) && color === undefined) {
                    return <any>this.constructionAdded$com_vzome_core_construction_Construction(c);
                } else throw new Error('invalid overload');
            }

            constructor() {
                super();
            }
        }
        NewConstructions["__class"] = "com.vzome.core.editor.CommandEdit.NewConstructions";
        NewConstructions["__interfaces"] = ["java.util.RandomAccess","java.util.List","java.lang.Cloneable","com.vzome.core.construction.ConstructionChanges","java.util.Collection","java.lang.Iterable","java.io.Serializable"];


    }

}
namespace com.vzome.core.editor {
    export abstract class Tool extends com.vzome.core.editor.api.ChangeManifestations implements com.vzome.api.Tool {
        /*private*/ id: string;

        /*private*/ tools: com.vzome.core.editor.ToolsModel;

        parameters: java.util.List<com.vzome.core.construction.Construction>;

        /*private*/ category: string;

        /*private*/ predefined: boolean;

        /*private*/ hidden: boolean;

        /*private*/ label: string;

        /*private*/ selectInputs: boolean;

        /*private*/ deleteInputs: boolean;

        /*private*/ copyColors: boolean;

        /*private*/ pcs: java.beans.PropertyChangeSupport;

        public constructor(id: string, tools: com.vzome.core.editor.ToolsModel) {
            super(tools.getEditorModel());
            if (this.id === undefined) { this.id = null; }
            if (this.tools === undefined) { this.tools = null; }
            this.parameters = <any>(new java.util.ArrayList<any>());
            if (this.category === undefined) { this.category = null; }
            if (this.predefined === undefined) { this.predefined = false; }
            if (this.hidden === undefined) { this.hidden = false; }
            if (this.label === undefined) { this.label = null; }
            if (this.selectInputs === undefined) { this.selectInputs = false; }
            if (this.deleteInputs === undefined) { this.deleteInputs = false; }
            if (this.copyColors === undefined) { this.copyColors = false; }
            this.pcs = new java.beans.PropertyChangeSupport(this);
            this.tools = tools;
            this.id = id;
            this.selectInputs = true;
            this.deleteInputs = false;
            this.copyColors = true;
        }

        public isSelectInputs(): boolean {
            return this.selectInputs;
        }

        public isDeleteInputs(): boolean {
            return this.deleteInputs;
        }

        public isCopyColors(): boolean {
            return this.copyColors;
        }

        public setInputBehaviors(selectInputs: boolean, deleteInputs: boolean) {
            this.selectInputs = selectInputs;
            this.deleteInputs = deleteInputs;
        }

        public setCopyColors(value: boolean) {
            this.copyColors = value;
        }

        public addPropertyChangeListener(listener: java.beans.PropertyChangeListener) {
            this.pcs.addPropertyChangeListener$java_beans_PropertyChangeListener(listener);
        }

        public setCategory(category: string) {
            this.category = category;
        }

        addParameter(c: com.vzome.core.construction.Construction) {
            this.parameters.add(c);
        }

        public getParameters(): java.util.List<com.vzome.core.construction.Construction> {
            return this.parameters;
        }

        setPredefined(value: boolean) {
            this.predefined = value;
        }

        /**
         * 
         * @return {boolean}
         */
        public isNoOp(): boolean {
            return false;
        }

        /**
         * 
         * @return {boolean}
         */
        public isSticky(): boolean {
            return true;
        }

        /**
         * 
         */
        public redo() {
        }

        /**
         * 
         */
        public undo() {
        }

        /**
         * 
         */
        public perform() {
            const error: string = this.checkSelection(true);
            if (error != null)throw new com.vzome.core.commands.Command.Failure(error);
            this.tools.put(this.getId(), this);
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            element.setAttribute("name", this.id);
        }

        /**
         * Check the selection applicability for this tool, and possibly record the tool parameters.
         * @param {boolean} prepareTool is true when actually creating a tool, whether interactively or when loading a file.
         * It is false when just validating the selection.
         * @return
         * @return {string}
         */
        abstract checkSelection(prepareTool: boolean): string;

        abstract prepare(applyTool: com.vzome.core.editor.api.ChangeManifestations);

        abstract performEdit(c: com.vzome.core.construction.Construction, edit: com.vzome.core.editor.api.ChangeManifestations);

        abstract performSelect(man: com.vzome.core.model.Manifestation, applyTool: com.vzome.core.editor.api.ChangeManifestations);

        abstract complete(applyTool: com.vzome.core.editor.api.ChangeManifestations);

        abstract needsInput(): boolean;

        /**
         * 
         * @return {string}
         */
        public getId(): string {
            return this.id;
        }

        /**
         * 
         * @return {string}
         */
        public getCategory(): string {
            return this.category;
        }

        /**
         * 
         * @param {boolean} selectInputs
         * @param {boolean} deleteInputs
         * @param {boolean} createOutputs
         * @param {boolean} selectOutputs
         * @param {boolean} copyColors
         */
        public apply(selectInputs: boolean, deleteInputs: boolean, createOutputs: boolean, selectOutputs: boolean, copyColors: boolean) {
            this.tools.applyTool(this, selectInputs, deleteInputs, createOutputs, selectOutputs, copyColors);
        }

        /**
         * 
         */
        public selectParameters() {
            this.tools.selectToolParameters(this);
        }

        /**
         * 
         * @return {boolean}
         */
        public isPredefined(): boolean {
            return this.predefined;
        }

        /**
         * 
         * @return {string}
         */
        public getLabel(): string {
            return this.label;
        }

        /**
         * 
         * @param {string} label
         */
        public setLabel(label: string) {
            this.label = label;
        }

        /**
         * 
         * @return {boolean}
         */
        public isHidden(): boolean {
            return this.hidden;
        }

        /**
         * 
         * @param {boolean} hidden
         */
        public setHidden(hidden: boolean) {
            this.hidden = hidden;
            this.tools.hideTool(this);
        }
    }
    Tool["__class"] = "com.vzome.core.editor.Tool";
    Tool["__interfaces"] = ["com.vzome.api.Tool"];


}
namespace com.vzome.core.editor {
    export class ApplyTool extends com.vzome.core.editor.api.ChangeManifestations {
        static logger: java.util.logging.Logger; public static logger_$LI$(): java.util.logging.Logger { if (ApplyTool.logger == null) { ApplyTool.logger = java.util.logging.Logger.getLogger("com.vzome.core.editor.ApplyTool"); }  return ApplyTool.logger; }

        /**
         * 
         */
        public perform() {
            if (ApplyTool.logger_$LI$().isLoggable(java.util.logging.Level.FINE))ApplyTool.logger_$LI$().fine("performing ApplyTool " + this.tool.getId() + " :: " + this.tool.getCategory());
            const inputs: java.util.List<com.vzome.core.model.Manifestation> = <any>(new java.util.ArrayList<any>());
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (this.deleteInputs && this.tool.needsInput()){
                        super.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                        super.deleteManifestation(man);
                        if (ApplyTool.logger_$LI$().isLoggable(java.util.logging.Level.FINEST))ApplyTool.logger_$LI$().finest("ApplyTool - unselect and delete " + man.toString());
                    } else if (this.hideInputs && this.tool.needsInput()){
                        super.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                        super.hideManifestation(man);
                        if (ApplyTool.logger_$LI$().isLoggable(java.util.logging.Level.FINEST))ApplyTool.logger_$LI$().finest("ApplyTool - unselect and hide " + man.toString());
                    } else if (!this.selectInputs){
                        super.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                        if (ApplyTool.logger_$LI$().isLoggable(java.util.logging.Level.FINEST))ApplyTool.logger_$LI$().finest("ApplyTool - unselect " + man.toString());
                    }
                    if (this.tool.needsInput())inputs.add(man);
                }
            }
            this.redo();
            this.tool.prepare(this);
            if (this.tool.needsInput()){
                for(let index=inputs.iterator();index.hasNext();) {
                    let man = index.next();
                    {
                        const c: com.vzome.core.construction.Construction = man.toConstruction();
                        c.setColor(this.copyColors ? man.getColor() : null);
                        this.tool.performEdit(c, this);
                    }
                }
            } else {
                for(let index=this.mManifestations.iterator();index.hasNext();) {
                    let man = index.next();
                    {
                        this.tool.performSelect(man, this);
                    }
                }
            }
            this.tool.complete(this);
            this.redo();
            super.perform();
        }

        /*private*/ tool: com.vzome.core.editor.Tool;

        /*private*/ selectInputs: boolean;

        /*private*/ deselectOutputs: boolean;

        /*private*/ justSelect: boolean;

        /*private*/ hideInputs: boolean;

        /*private*/ deleteInputs: boolean;

        /*private*/ redundantOutputs: boolean;

        /*private*/ copyColors: boolean;

        /*private*/ tools: com.vzome.core.editor.ToolsModel;

        public constructor(tools: com.vzome.core.editor.ToolsModel, tool: com.vzome.core.editor.Tool, selectInputs: boolean, deleteInputs: boolean, createOutputs: boolean, selectOutputs: boolean, redundantOutputs: boolean, copyColors: boolean) {
            super(tools.getEditorModel());
            if (this.tool === undefined) { this.tool = null; }
            if (this.selectInputs === undefined) { this.selectInputs = false; }
            if (this.deselectOutputs === undefined) { this.deselectOutputs = false; }
            if (this.justSelect === undefined) { this.justSelect = false; }
            if (this.hideInputs === undefined) { this.hideInputs = false; }
            if (this.deleteInputs === undefined) { this.deleteInputs = false; }
            if (this.redundantOutputs === undefined) { this.redundantOutputs = false; }
            if (this.copyColors === undefined) { this.copyColors = false; }
            if (this.tools === undefined) { this.tools = null; }
            this.tools = tools;
            this.tool = tool;
            this.selectInputs = selectInputs;
            this.deleteInputs = deleteInputs;
            this.copyColors = copyColors;
            this.hideInputs = false;
            this.deselectOutputs = !selectOutputs;
            this.justSelect = !createOutputs;
            this.redundantOutputs = redundantOutputs;
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            if (this.redundantOutputs)return "ApplyTool"; else return "ToolApplied";
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            element.setAttribute("name", this.tool.getId());
            if (this.selectInputs)element.setAttribute("selectInputs", "true");
            if (this.deselectOutputs)element.setAttribute("deselectOutputs", "true");
            if (this.justSelect)element.setAttribute("justSelect", "true");
            if (this.hideInputs)element.setAttribute("hideInputs", "true");
            if (this.deleteInputs)element.setAttribute("deleteInputs", "true");
            element.setAttribute("copyColors", javaemul.internal.BooleanHelper.toString(this.copyColors));
        }

        /**
         * 
         * @param {*} element
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(element: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            const toolName: string = element.getAttribute("name");
            this.tool = this.tools.get(toolName);
            this.selectInputs = this.isAttributeTrue(element, "selectInputs");
            this.deselectOutputs = this.isAttributeTrue(element, "deselectOutputs");
            this.justSelect = this.isAttributeTrue(element, "justSelect");
            this.hideInputs = this.isAttributeTrue(element, "hideInputs");
            this.deleteInputs = this.isAttributeTrue(element, "deleteInputs");
            const value: string = element.getAttribute("copyColors");
            this.copyColors = value == null || !(value === ("false"));
        }

        /*private*/ isAttributeTrue(element: org.w3c.dom.Element, name: string): boolean {
            const value: string = element.getAttribute(name);
            return value != null && (value === ("true"));
        }

        /**
         * 
         * @param {com.vzome.core.construction.Construction} c
         * @return {*}
         */
        public manifestConstruction(c: com.vzome.core.construction.Construction): com.vzome.core.model.Manifestation {
            let m: com.vzome.core.model.Manifestation = this.getManifestation(c);
            const preExistsNotHidden: boolean = (m != null && m.isRendered());
            if (this.justSelect){
                if (preExistsNotHidden)super.select$com_vzome_core_model_Manifestation$boolean(m, false);
            } else if (this.redundantOutputs || !preExistsNotHidden){
                m = super.manifestConstruction(c);
                if (!this.deselectOutputs)super.select$com_vzome_core_model_Manifestation$boolean(m, true);
            }
            return m;
        }

        public select(man?: any, ignoreGroups?: any) {
            if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ((typeof ignoreGroups === 'boolean') || ignoreGroups === null)) {
                super.select(man, ignoreGroups);
            } else if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ignoreGroups === undefined) {
                return <any>this.select$com_vzome_core_model_Manifestation(man);
            } else throw new Error('invalid overload');
        }

        public select$com_vzome_core_model_Manifestation(m: com.vzome.core.model.Manifestation) {
            if (this.tool.needsInput())throw new java.lang.UnsupportedOperationException("select is not supported within Tool.performEdit");
            if (!m.isRendered())super.showManifestation(m);
            super.select$com_vzome_core_model_Manifestation$boolean(m, true);
        }

        public unselect(man?: any, ignoreGroups?: any) {
            if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ((typeof ignoreGroups === 'boolean') || ignoreGroups === null)) {
                super.unselect(man, ignoreGroups);
            } else if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ignoreGroups === undefined) {
                return <any>this.unselect$com_vzome_core_model_Manifestation(man);
            } else throw new Error('invalid overload');
        }

        public unselect$com_vzome_core_model_Manifestation(man: com.vzome.core.model.Manifestation) {
            throw new java.lang.UnsupportedOperationException("unselect is not supported within Tool.performEdit");
        }

        /**
         * 
         * @param {*} m
         */
        showManifestation(m: com.vzome.core.model.Manifestation) {
            throw new java.lang.UnsupportedOperationException("showManifestation is not supported within Tool.performEdit");
        }

        /**
         * 
         * @param {*} m
         */
        hideManifestation(m: com.vzome.core.model.Manifestation) {
            throw new java.lang.UnsupportedOperationException("hideManifestation is not supported within Tool.performEdit");
        }
    }
    ApplyTool["__class"] = "com.vzome.core.editor.ApplyTool";

}
namespace com.vzome.core.editor {
    export class SelectToolParameters extends com.vzome.core.editor.api.ChangeManifestations {
        /*private*/ tool: com.vzome.core.editor.Tool;

        /*private*/ tools: com.vzome.core.editor.ToolsModel;

        constructor(tools: com.vzome.core.editor.ToolsModel, tool: com.vzome.core.editor.Tool) {
            super(tools.getEditorModel());
            if (this.tool === undefined) { this.tool = null; }
            if (this.tools === undefined) { this.tools = null; }
            this.tools = tools;
            this.tool = tool;
        }

        /**
         * 
         */
        public perform() {
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                super.unselect$com_vzome_core_model_Manifestation$boolean(man, true)
            }
            this.redo();
            for(let index=this.tool.getParameters().iterator();index.hasNext();) {
                let con = index.next();
                {
                    const man: com.vzome.core.model.Manifestation = this.manifestConstruction(con);
                    this.select$com_vzome_core_model_Manifestation(man);
                }
            }
            this.redo();
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "SelectToolParameters";
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            element.setAttribute("name", this.tool.getId());
        }

        /**
         * 
         * @param {*} element
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(element: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            const toolName: string = element.getAttribute("name");
            this.tool = this.tools.get(toolName);
        }
    }
    SelectToolParameters["__class"] = "com.vzome.core.editor.SelectToolParameters";

}
namespace com.vzome.core.edits {
    export class SelectByDiameter extends com.vzome.core.edits.SelectByBoundary {
        public static NAME: string = "SelectByDiameter";

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return SelectByDiameter.NAME;
        }

        center: com.vzome.core.algebra.AlgebraicVector;

        maxRadiusSquared: com.vzome.core.algebra.AlgebraicNumber;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            if (this.center === undefined) { this.center = null; }
            if (this.maxRadiusSquared === undefined) { this.maxRadiusSquared = null; }
        }

        /**
         * 
         * @return {string}
         */
        public usage(): string {
            return "This command requires two connectors which define the\ndiameter of a sphere centered at their midpoint.\n\nAll parts that are completely within the sphere will be selected.\n";
        }

        adjustBoundary(vectors: java.util.List<com.vzome.core.algebra.AlgebraicVector>): string {
            switch((vectors.size())) {
            case 1:
                return null;
            case 2:
                this.center = com.vzome.core.algebra.AlgebraicVectors.calculateCentroid(vectors);
                const v1: com.vzome.core.algebra.AlgebraicVector = vectors.get(0).minus(this.center);
                this.maxRadiusSquared = v1.dot(v1);
                return null;
            }
            return "Too many connectors are selected.";
        }

        /**
         * 
         * @return {string}
         */
        setBoundary(): string {
            this.center = null;
            this.maxRadiusSquared = null;
            const vectors: java.util.List<com.vzome.core.algebra.AlgebraicVector> = <any>(new java.util.ArrayList<any>());
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        vectors.add(man.getLocation());
                        const errMsg: string = this.adjustBoundary(vectors);
                        if (errMsg != null){
                            return errMsg;
                        }
                    }
                }
            }
            if (vectors.isEmpty()){
                return "No connectors are selected.";
            }
            if (this.center == null || this.maxRadiusSquared == null){
                const n: number = vectors.size();
                return n === 1 ? "Only one connector is selected." : "Only " + n + " connectors are selected.";
            }
            return null;
        }

        public boundaryContains$com_vzome_core_algebra_AlgebraicVector(v: com.vzome.core.algebra.AlgebraicVector): boolean {
            v = v.minus(this.center);
            const vSq: com.vzome.core.algebra.AlgebraicNumber = v.dot(v);
            return vSq.compareTo(this.maxRadiusSquared) <= 0;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} v
         * @return {boolean}
         */
        public boundaryContains(v?: any): boolean {
            if (((v != null && v instanceof <any>com.vzome.core.algebra.AlgebraicVector) || v === null)) {
                return <any>this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(v);
            } else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || v === null)) {
                return super.boundaryContains(v);
            } else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || v === null)) {
                return <any>this.boundaryContains$com_vzome_core_model_Strut(v);
            } else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) || v === null)) {
                return <any>this.boundaryContains$com_vzome_core_model_Panel(v);
            } else throw new Error('invalid overload');
        }
    }
    SelectByDiameter["__class"] = "com.vzome.core.edits.SelectByDiameter";

}
namespace com.vzome.core.edits {
    export class SelectByPlane extends com.vzome.core.edits.SelectByBoundary {
        public static NAME: string = "SelectByPlane";

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return SelectByPlane.NAME;
        }

        /*private*/ plane: com.vzome.core.algebra.Bivector3d;

        /*private*/ anchor: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ desiredOrientation: number;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            if (this.plane === undefined) { this.plane = null; }
            if (this.anchor === undefined) { this.anchor = null; }
            if (this.desiredOrientation === undefined) { this.desiredOrientation = 0; }
        }

        /**
         * 
         * @return {string}
         */
        public usage(): string {
            return "This command requires four selected connectors.\n\nThe first three connectors must not be collinear,\nso that they define a plane.\nThe fourth connector must lie outside of that plane,\nand defines which half space you wish to select.\n\nAll parts that are completely within that half-space will be selected.\n";
        }

        /**
         * 
         */
        public perform() {
            this.setOrderedSelection(true);
            super.perform();
        }

        /**
         * 
         * @return {string}
         */
        setBoundary(): string {
            let p1: com.vzome.core.algebra.AlgebraicVector = null;
            let p2: com.vzome.core.algebra.AlgebraicVector = null;
            let p3: com.vzome.core.algebra.AlgebraicVector = null;
            let p4: com.vzome.core.algebra.AlgebraicVector = null;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        if (p1 == null){
                            p1 = man.getLocation();
                            continue;
                        }
                        if (p2 == null){
                            p2 = man.getLocation();
                            continue;
                        }
                        if (p3 == null){
                            p3 = man.getLocation();
                            continue;
                        }
                        if (p4 == null){
                            p4 = man.getLocation();
                            continue;
                        } else {
                            return "You have selected more than four connectors.";
                        }
                    }
                }
            }
            if (p4 == null)return "You have selected fewer than four connectors.";
            const v1: com.vzome.core.algebra.Vector3d = new com.vzome.core.algebra.Vector3d(p2.minus(p1));
            const v2: com.vzome.core.algebra.Vector3d = new com.vzome.core.algebra.Vector3d(p3.minus(p1));
            this.plane = v1.outer(v2);
            this.anchor = p1;
            this.desiredOrientation = this.orient(p4);
            if (this.desiredOrientation === 0){
                return "Your last selected connector lies in the plane of the other three.";
            }
            return null;
        }

        /*private*/ orient(point: com.vzome.core.algebra.AlgebraicVector): number {
            const diff: com.vzome.core.algebra.AlgebraicVector = point.minus(this.anchor);
            const v: com.vzome.core.algebra.Vector3d = new com.vzome.core.algebra.Vector3d(diff);
            const volume: com.vzome.core.algebra.AlgebraicNumber = this.plane.outer(v);
            if (volume.isZero())return 0; else {
                const volD: number = volume.evaluate();
                return (volD > 0.0) ? 1 : -1;
            }
        }

        public boundaryContains$com_vzome_core_algebra_AlgebraicVector(v: com.vzome.core.algebra.AlgebraicVector): boolean {
            const orientation: number = this.orient(v);
            return (orientation === 0) || (orientation === this.desiredOrientation);
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} v
         * @return {boolean}
         */
        public boundaryContains(v?: any): boolean {
            if (((v != null && v instanceof <any>com.vzome.core.algebra.AlgebraicVector) || v === null)) {
                return <any>this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(v);
            } else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || v === null)) {
                return super.boundaryContains(v);
            } else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || v === null)) {
                return <any>this.boundaryContains$com_vzome_core_model_Strut(v);
            } else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) || v === null)) {
                return <any>this.boundaryContains$com_vzome_core_model_Panel(v);
            } else throw new Error('invalid overload');
        }
    }
    SelectByPlane["__class"] = "com.vzome.core.edits.SelectByPlane";

}
namespace com.vzome.core.edits {
    export class SelectCoplanar extends com.vzome.core.edits.SelectByBoundary {
        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            this.pickedVectors = <any>(new java.util.ArrayList<any>());
            this.vectors = <any>(new java.util.HashSet<any>());
            this.pointOnPlane = null;
            this.normal = null;
        }

        /**
         * 
         * @return {string}
         */
        public usage(): string {
            return "Select any combination of connectors, struts or panels to specify\n3 or more points that are all coplanar, but not simply collinear.\n\nAll parts that are completely on the corresponding plane will be selected.\n";
        }

        pickedVectors: java.util.List<com.vzome.core.algebra.AlgebraicVector>;

        vectors: java.util.Set<com.vzome.core.algebra.AlgebraicVector>;

        pointOnPlane: com.vzome.core.algebra.AlgebraicVector;

        normal: com.vzome.core.algebra.AlgebraicVector;

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
            const panel: com.vzome.core.model.Panel = <com.vzome.core.model.Panel><any>props.get("picked");
            if (panel != null){
                for(let index=panel.iterator();index.hasNext();) {
                    let v = index.next();
                    {
                        this.pickedVectors.add(v);
                    }
                }
            }
        }

        /**
         * 
         * @return {string}
         */
        setBoundary(): string {
            if (this.pickedVectors.isEmpty()){
                for(let index=this.mSelection.iterator();index.hasNext();) {
                    let man = index.next();
                    {
                        if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                            this.vectors.add(man.getLocation());
                        } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                            this.vectors.add(man.getLocation());
                            this.vectors.add((<com.vzome.core.model.Strut><any>man).getEnd());
                        } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                            for(let index=(<com.vzome.core.model.Panel><any>man).iterator();index.hasNext();) {
                                let v = index.next();
                                {
                                    this.vectors.add(v);
                                }
                            }
                        } else {
                            throw new java.lang.IllegalStateException("Unknown manifestation: " + /* getSimpleName */(c => typeof c === 'string' ? (<any>c).substring((<any>c).lastIndexOf('.')+1) : c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.')+1) : c["name"].substring(c["name"].lastIndexOf('.')+1))((<any>man.constructor)));
                        }
                    }
                }
                if (this.vectors.size() < 3){
                    return "Additional connectors, struts or panels must be selected to define a plane.";
                }
                if (com.vzome.core.algebra.AlgebraicVectors.areCollinear$java_util_Collection(this.vectors)){
                    return "Selected items are collinear. Select another non-collinear ball to specify the plane.";
                }
                if (!com.vzome.core.algebra.AlgebraicVectors.areCoplanar(this.vectors)){
                    return "Selected items are not coplanar.";
                }
            } else {
                this.vectors.addAll(this.pickedVectors);
                this.unselectAll();
                this.redo();
            }
            for(let index=this.vectors.iterator();index.hasNext();) {
                let v = index.next();
                {
                    this.pointOnPlane = v;
                    break;
                }
            }
            this.normal = com.vzome.core.algebra.AlgebraicVectors.getNormal$java_util_Collection(this.vectors);
            return null;
        }

        public boundaryContains$com_vzome_core_algebra_AlgebraicVector(v: com.vzome.core.algebra.AlgebraicVector): boolean {
            return this.vectors.contains(v) || this.pointOnPlane.minus(v).dot(this.normal).isZero();
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} v
         * @return {boolean}
         */
        public boundaryContains(v?: any): boolean {
            if (((v != null && v instanceof <any>com.vzome.core.algebra.AlgebraicVector) || v === null)) {
                return <any>this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(v);
            } else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || v === null)) {
                return super.boundaryContains(v);
            } else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || v === null)) {
                return <any>this.boundaryContains$com_vzome_core_model_Strut(v);
            } else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) || v === null)) {
                return <any>this.boundaryContains$com_vzome_core_model_Panel(v);
            } else throw new Error('invalid overload');
        }

        public static NAME: string = "SelectCoplanar";

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return SelectCoplanar.NAME;
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            if (!this.pickedVectors.isEmpty()){
                com.vzome.xml.DomUtils.addAttribute(element, "nPickedVectors", /* toString */(''+(this.pickedVectors.size())));
                for(let i: number = 0; i < this.pickedVectors.size(); i++) {{
                    com.vzome.xml.DomUtils.addAttribute(element, "vector" + i, this.pickedVectors.get(i).toParsableString());
                };}
            }
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            const nPickedVectors: string = xml.getAttribute("nPickedVectors");
            if (nPickedVectors != null && !/* isEmpty */(nPickedVectors.length === 0)){
                const nPicked: number = javaemul.internal.IntegerHelper.parseInt(nPickedVectors);
                for(let i: number = 0; i < nPicked; i++) {{
                    this.pickedVectors.add(format.parseRationalVector(xml, "vector" + i));
                };}
            }
        }
    }
    SelectCoplanar["__class"] = "com.vzome.core.edits.SelectCoplanar";

}
namespace com.vzome.core.edits {
    export class ConvexHull3d extends com.vzome.core.edits.ConvexHull {
        public static NAME: string = "ConvexHull3d";

        /*private*/ mode: string;

        /*private*/ generateStruts: boolean;

        /*private*/ generatePanels: boolean;

        public constructor(editorModel: com.vzome.core.editor.api.EditorModel) {
            super(editorModel);
            this.mode = null;
            this.generateStruts = true;
            this.generatePanels = true;
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return ConvexHull3d.NAME;
        }

        /**
         * 
         * @return {boolean}
         */
        public isNoOp(): boolean {
            return (this.generateStruts || this.generatePanels) ? super.isNoOp() : true;
        }

        /**
         * 
         * @param {*} props
         */
        public configure(props: java.util.Map<string, any>) {
            this.setMode(<string>props.get("mode"));
        }

        /*private*/ setMode(newMode: string) {
            this.mode = "";
            this.generateStruts = true;
            this.generatePanels = true;
            if (newMode != null)switch((newMode)) {
            case "":
                this.mode = newMode;
                this.generateStruts = true;
                this.generatePanels = true;
                break;
            case "noPanels":
                this.mode = newMode;
                this.generateStruts = true;
                this.generatePanels = false;
                break;
            case "onlyPanels":
                this.mode = newMode;
                this.generateStruts = false;
                this.generatePanels = true;
                break;
            default:
                if (com.vzome.core.editor.api.ChangeSelection.logger_$LI$().isLoggable(java.util.logging.Level.WARNING)){
                    com.vzome.core.editor.api.ChangeSelection.logger_$LI$().warning(ConvexHull3d.NAME + ": Ignoring unknown mode: \"" + newMode + "\".");
                }
                break;
            }
        }

        /**
         * 
         */
        public perform() {
            const hull3d: com.vzome.core.math.convexhull.QuickHull3D = new com.vzome.core.math.convexhull.QuickHull3D();
            hull3d.build$java_util_Collection(this.getSelectedVertexSet(true));
            this.redo();
            const vertices: com.vzome.core.algebra.AlgebraicVector[] = hull3d.getVertices$();
            const pointMap: java.util.Map<com.vzome.core.algebra.AlgebraicVector, com.vzome.core.construction.Point> = <any>(new java.util.HashMap<any, any>(vertices.length));
            for(let index = 0; index < vertices.length; index++) {
                let vertex = vertices[index];
                {
                    const point: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(vertex);
                    pointMap.put(vertex, point);
                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(point));
                }
            }
            const faces: number[][] = hull3d.getFaces$();
            for(let index = 0; index < faces.length; index++) {
                let face = faces[index];
                {
                    const points: com.vzome.core.construction.Point[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(face.length);
                    let startIndex: number = face[face.length - 1];
                    let start: com.vzome.core.construction.Point = pointMap.get(vertices[startIndex]);
                    for(let i: number = 0; i < face.length; i++) {{
                        const endIndex: number = startIndex;
                        startIndex = face[i];
                        const end: com.vzome.core.construction.Point = points[i] = pointMap.get(vertices[startIndex]);
                        if (this.generateStruts && (startIndex < endIndex)){
                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(start, end)));
                        }
                        start = end;
                    };}
                    if (this.generatePanels){
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices(points)));
                    }
                }
            }
            this.redo();
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            if (this.mode != null){
                element.setAttribute("mode", this.mode);
            }
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            this.setMode(xml.getAttribute("mode"));
        }
    }
    ConvexHull3d["__class"] = "com.vzome.core.edits.ConvexHull3d";

}
namespace com.vzome.core.edits {
    export class ConvexHull2d extends com.vzome.core.edits.ConvexHull {
        public static NAME: string = "ConvexHull2d";

        public constructor(editorModel: com.vzome.core.editor.api.EditorModel) {
            super(editorModel);
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return ConvexHull2d.NAME;
        }

        /**
         * 
         */
        public perform() {
            const hull2d: com.vzome.core.algebra.AlgebraicVector[] = com.vzome.core.math.convexhull.GrahamScan2D.buildHull(this.getSelectedVertexSet(true));
            this.redo();
            const vertices: com.vzome.core.construction.Point[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(hull2d.length);
            let p: number = 0;
            const pointMap: java.util.Map<com.vzome.core.algebra.AlgebraicVector, com.vzome.core.construction.Point> = <any>(new java.util.HashMap<any, any>(hull2d.length));
            for(let index = 0; index < hull2d.length; index++) {
                let vertex = hull2d[index];
                {
                    const point: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(vertex);
                    pointMap.put(vertex, point);
                    vertices[p++] = point;
                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(point));
                }
            }
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices(vertices)));
            let start: com.vzome.core.construction.Point = pointMap.get(hull2d[0]);
            for(let i: number = 1; i < hull2d.length; i++) {{
                const end: com.vzome.core.construction.Point = pointMap.get(hull2d[i]);
                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(start, end)));
                start = end;
            };}
            const end: com.vzome.core.construction.Point = pointMap.get(hull2d[0]);
            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(start, end)));
            this.redo();
        }
    }
    ConvexHull2d["__class"] = "com.vzome.core.edits.ConvexHull2d";

}
namespace com.vzome.core.edits {
    export class StrutMove extends com.vzome.core.edits.StrutCreation {
        /*private*/ oldStrut: com.vzome.core.model.Strut;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            if (this.oldStrut === undefined) { this.oldStrut = null; }
        }

        /**
         * 
         * @param {*} params
         */
        public configure(params: java.util.Map<string, any>) {
            super.configure(params);
            this.oldStrut = <com.vzome.core.model.Strut><any>params.get("oldStrut");
        }

        /**
         * 
         */
        public perform() {
            this.deleteManifestation(this.oldStrut);
            this.manifestConstruction(this.mAnchor);
            super.redo();
            super.perform();
        }

        /**
         * 
         * @param {*} xml
         */
        getXmlAttributes(xml: org.w3c.dom.Element) {
            com.vzome.core.commands.XmlSaveFormat.serializeSegment(xml, "startSegment", "endSegment", <com.vzome.core.construction.Segment>this.oldStrut.getFirstConstruction());
            super.getXmlAttributes(xml);
        }

        /**
         * 
         * @param {*} xml
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        public setXmlAttributes(xml: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            const construction: com.vzome.core.construction.Construction = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "startSegment", "endSegment");
            if (construction != null)this.oldStrut = <com.vzome.core.model.Strut><any>this.getManifestation(construction);
            super.setXmlAttributes(xml, format);
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "StrutMove";
        }
    }
    StrutMove["__class"] = "com.vzome.core.edits.StrutMove";

}
namespace com.vzome.core.edits {
    export class LoadVEF extends com.vzome.core.edits.ImportMesh {
        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
        }

        deselectInputs(): boolean {
            return false;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} offset
         * @param {com.vzome.core.editor.api.ManifestConstructions} events
         * @param {*} registry
         */
        parseMeshData(offset: com.vzome.core.algebra.AlgebraicVector, events: com.vzome.core.editor.api.ManifestConstructions, registry: com.vzome.core.algebra.AlgebraicField.Registry) {
            const v2m: com.vzome.core.construction.VefToModel = new com.vzome.core.construction.VefToModel(this.projection, events, this.scale, offset);
            v2m.parseVEF(this.meshData, this.mManifestations.getField());
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "LoadVEF";
        }
    }
    LoadVEF["__class"] = "com.vzome.core.edits.LoadVEF";

}
namespace com.vzome.core.tools {
    export abstract class TransformationTool extends com.vzome.core.editor.Tool {
        /**
         * 
         * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
         */
        public prepare(applyTool: com.vzome.core.editor.api.ChangeManifestations) {
        }

        /**
         * 
         * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
         */
        public complete(applyTool: com.vzome.core.editor.api.ChangeManifestations) {
        }

        /**
         * 
         * @return {boolean}
         */
        public needsInput(): boolean {
            return true;
        }

        transforms: com.vzome.core.construction.Transformation[];

        originPoint: com.vzome.core.construction.Point;

        public constructor(id: string, tools: com.vzome.core.editor.ToolsModel) {
            super(id, tools);
            if (this.transforms === undefined) { this.transforms = null; }
            if (this.originPoint === undefined) { this.originPoint = null; }
            this.originPoint = tools.getOriginPoint();
        }

        /**
         * 
         * @param {*} that
         * @return {boolean}
         */
        public equals(that: any): boolean {
            if (this === that){
                return true;
            }
            if (that == null){
                return false;
            }
            if (!/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })((<any>that.constructor),(<any>this.constructor)))){
                return false;
            }
            const other: TransformationTool = <TransformationTool>that;
            if (this.originPoint == null){
                if (other.originPoint != null){
                    return false;
                }
            } else if (!/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(this.originPoint,other.originPoint))){
                return false;
            }
            if (!java.util.Arrays.equals(this.transforms, other.transforms)){
                return false;
            }
            return true;
        }

        /**
         * 
         * @param {com.vzome.core.construction.Construction} c
         * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
         */
        public performEdit(c: com.vzome.core.construction.Construction, applyTool: com.vzome.core.editor.api.ChangeManifestations) {
            for(let index = 0; index < this.transforms.length; index++) {
                let transform = this.transforms[index];
                {
                    const result: com.vzome.core.construction.Construction = transform.transform$com_vzome_core_construction_Construction(c);
                    if (result == null)continue;
                    const color: com.vzome.core.construction.Color = c.getColor();
                    result.setColor(color);
                    const m: com.vzome.core.model.Manifestation = applyTool.manifestConstruction(result);
                    if (m != null)if (color != null)applyTool.colorManifestation(m, c.getColor());
                }
            }
            applyTool.redo();
        }

        /**
         * 
         * @param {*} man
         * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
         */
        public performSelect(man: com.vzome.core.model.Manifestation, applyTool: com.vzome.core.editor.api.ChangeManifestations) {
        }

        public unselect$com_vzome_core_model_Manifestation$boolean(man: com.vzome.core.model.Manifestation, ignoreGroups: boolean) {
            const c: com.vzome.core.construction.Construction = man.getFirstConstruction();
            this.addParameter(c);
            super.unselect$com_vzome_core_model_Manifestation$boolean(man, ignoreGroups);
        }

        /**
         * 
         * @param {*} man
         * @param {boolean} ignoreGroups
         */
        public unselect(man?: any, ignoreGroups?: any) {
            if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ((typeof ignoreGroups === 'boolean') || ignoreGroups === null)) {
                return <any>this.unselect$com_vzome_core_model_Manifestation$boolean(man, ignoreGroups);
            } else if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ignoreGroups === undefined) {
                return <any>this.unselect$com_vzome_core_model_Manifestation(man);
            } else throw new Error('invalid overload');
        }

        isAutomatic(): boolean {
            return /* contains */(this.getId().indexOf(".auto/") != -1);
        }
    }
    TransformationTool["__class"] = "com.vzome.core.tools.TransformationTool";
    TransformationTool["__interfaces"] = ["com.vzome.api.Tool"];


}
namespace com.vzome.core.tools {
    export class PlaneSelectionTool extends com.vzome.core.editor.Tool {
        /*private*/ plane: com.vzome.core.algebra.Bivector3d;

        /*private*/ anchor: com.vzome.core.algebra.AlgebraicVector;

        /*private*/ halfSpace: boolean;

        /*private*/ boundaryOpen: boolean;

        /*private*/ above: boolean;

        /*private*/ includeBalls: boolean;

        /*private*/ includeStruts: boolean;

        /*private*/ includePanels: boolean;

        /*private*/ includePartials: boolean;

        public constructor(id: string, tools: com.vzome.core.editor.ToolsModel) {
            super(id, tools);
            if (this.plane === undefined) { this.plane = null; }
            if (this.anchor === undefined) { this.anchor = null; }
            this.halfSpace = true;
            this.boundaryOpen = false;
            this.above = true;
            this.includeBalls = true;
            this.includeStruts = true;
            this.includePanels = true;
            this.includePartials = false;
        }

        /**
         * 
         * @return {boolean}
         */
        public isSticky(): boolean {
            return true;
        }

        /**
         * 
         */
        public perform() {
            let p1: com.vzome.core.algebra.AlgebraicVector = null;
            let p2: com.vzome.core.algebra.AlgebraicVector = null;
            let p3: com.vzome.core.algebra.AlgebraicVector = null;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        if (p1 == null){
                            p1 = man.getLocation();
                            continue;
                        }
                        if (p2 == null){
                            p2 = man.getLocation();
                            continue;
                        }
                        if (p3 == null){
                            p3 = man.getLocation();
                            continue;
                        } else {
                            throw new com.vzome.core.commands.Command.Failure("half-space selection tool requires exactly three balls");
                        }
                    }
                }
            }
            if (p3 == null)throw new com.vzome.core.commands.Command.Failure("half-space selection tool requires exactly three balls");
            const v1: com.vzome.core.algebra.Vector3d = new com.vzome.core.algebra.Vector3d(p2.minus(p1));
            const v2: com.vzome.core.algebra.Vector3d = new com.vzome.core.algebra.Vector3d(p3.minus(p1));
            this.plane = v1.outer(v2);
            this.anchor = p1;
            super.perform();
        }

        /**
         * 
         * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
         */
        public prepare(applyTool: com.vzome.core.editor.api.ChangeManifestations) {
        }

        /**
         * 
         * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
         */
        public complete(applyTool: com.vzome.core.editor.api.ChangeManifestations) {
        }

        /**
         * 
         * @return {boolean}
         */
        public needsInput(): boolean {
            return false;
        }

        /**
         * 
         * @param {com.vzome.core.construction.Construction} c
         * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
         */
        public performEdit(c: com.vzome.core.construction.Construction, applyTool: com.vzome.core.editor.api.ChangeManifestations) {
        }

        /**
         * 
         * @param {*} man
         * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
         */
        public performSelect(man: com.vzome.core.model.Manifestation, applyTool: com.vzome.core.editor.api.ChangeManifestations) {
            if (man.isHidden())return;
            if (!man.isRendered())return;
            if (this.includePanels && (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)))return;
            if (this.includeBalls && (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))){
                const c: com.vzome.core.model.Connector = <com.vzome.core.model.Connector><any>man;
                const orientation: number = this.orient(c.getLocation());
                if (!this.boundaryOpen && orientation === 0)applyTool.select$com_vzome_core_model_Manifestation(man); else if (this.halfSpace && this.above && orientation > 0)applyTool.select$com_vzome_core_model_Manifestation(man); else if (this.halfSpace && !this.above && orientation < 0)applyTool.select$com_vzome_core_model_Manifestation(man);
            } else if (this.includeStruts && (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))){
                const o1: number = this.orient((<com.vzome.core.model.Strut><any>man).getLocation());
                const o2: number = this.orient((<com.vzome.core.model.Strut><any>man).getEnd());
                if (this.includePartials){
                    if (!this.boundaryOpen && (o1 === 0 || o2 === 0))applyTool.select$com_vzome_core_model_Manifestation(man); else if (this.halfSpace){
                        if (this.above && (o1 > 0 || o2 > 0))applyTool.select$com_vzome_core_model_Manifestation(man); else if (!this.above && (o1 < 0 || o2 < 0))applyTool.select$com_vzome_core_model_Manifestation(man);
                    }
                } else {
                    if (!this.halfSpace && o1 === 0 && o2 === 0)applyTool.select$com_vzome_core_model_Manifestation(man); else if (this.halfSpace){
                        if (this.boundaryOpen){
                            if (this.above && (o1 > 0 && o2 > 0))applyTool.select$com_vzome_core_model_Manifestation(man); else if (!this.above && (o1 < 0 && o2 < 0))applyTool.select$com_vzome_core_model_Manifestation(man);
                        } else {
                            if (this.above && (o1 >= 0 && o2 >= 0))applyTool.select$com_vzome_core_model_Manifestation(man); else if (!this.above && (o1 <= 0 && o2 <= 0))applyTool.select$com_vzome_core_model_Manifestation(man);
                        }
                    }
                }
            }
            applyTool.redo();
        }

        /*private*/ orient(point: com.vzome.core.algebra.AlgebraicVector): number {
            const diff: com.vzome.core.algebra.AlgebraicVector = point.minus(this.anchor);
            const v: com.vzome.core.algebra.Vector3d = new com.vzome.core.algebra.Vector3d(diff);
            const volume: com.vzome.core.algebra.AlgebraicNumber = this.plane.outer(v);
            if (volume.isZero())return 0; else {
                const volD: number = volume.evaluate();
                return (volD > 0.0) ? 1 : -1;
            }
        }

        /**
         * 
         */
        public redo() {
        }

        /**
         * 
         */
        public undo() {
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "PlaneSelectionTool";
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            element.setAttribute("name", this.getId());
        }

        /**
         * 
         * @param {*} element
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(element: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            super.setXmlAttributes(element, format);
            this.includeBalls = !("false" === element.getAttribute("balls"));
            this.includeStruts = !("false" === element.getAttribute("struts"));
            this.includePanels = "true" === element.getAttribute("panels");
            this.includePartials = "any" === element.getAttribute("vertices");
            this.boundaryOpen = "true" === element.getAttribute("open");
            const halfSpace: string = element.getAttribute("halfSpace");
            if ("above" === halfSpace){
                this.halfSpace = true;
                this.above = true;
            } else if ("below" === halfSpace){
                this.halfSpace = true;
                this.above = false;
            } else {
                this.halfSpace = false;
                this.boundaryOpen = false;
            }
        }

        /**
         * 
         * @return {string}
         */
        public getCategory(): string {
            return "plane";
        }

        public getDefaultName(): string {
            return "plane";
        }

        /**
         * 
         * @param {boolean} prepareTool
         * @return {string}
         */
        checkSelection(prepareTool: boolean): string {
            return null;
        }
    }
    PlaneSelectionTool["__class"] = "com.vzome.core.tools.PlaneSelectionTool";
    PlaneSelectionTool["__interfaces"] = ["com.vzome.api.Tool"];


}
namespace com.vzome.core.tools {
    export class BookmarkTool extends com.vzome.core.editor.Tool {
        public static ID: string = "bookmark";

        static LABEL: string = "Create a selection bookmark";

        static TOOLTIP: string = "<p>A selection bookmark lets you re-create<br>any selection at a later time.</p>";

        /*private*/ bookmarkedConstructions: java.util.List<com.vzome.core.construction.Construction>;

        public constructor(id: string, tools: com.vzome.core.editor.ToolsModel) {
            super(id, tools);
            this.bookmarkedConstructions = <any>(new java.util.ArrayList<any>());
        }

        /**
         * 
         * @return {boolean}
         */
        public isSticky(): boolean {
            return true;
        }

        /**
         * 
         */
        public perform() {
            const duper: com.vzome.core.editor.Duplicator = new com.vzome.core.editor.Duplicator(null, null);
            if (this.mSelection.size() === 0)this.bookmarkedConstructions.add(new com.vzome.core.construction.FreePoint(this.mManifestations.getField().origin(3))); else for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    const result: com.vzome.core.construction.Construction = duper.duplicateConstruction(man);
                    this.bookmarkedConstructions.add(result);
                    this.addParameter(result);
                }
            }
            super.perform();
        }

        /**
         * 
         * @return {boolean}
         */
        public needsInput(): boolean {
            return false;
        }

        /**
         * 
         * @param {com.vzome.core.editor.api.ChangeManifestations} edit
         */
        public prepare(edit: com.vzome.core.editor.api.ChangeManifestations) {
            if (this.bookmarkedConstructions.isEmpty()){
                edit.manifestConstruction(new com.vzome.core.construction.FreePoint(this.mManifestations.getField().origin(3)));
            } else for(let index=this.bookmarkedConstructions.iterator();index.hasNext();) {
                let con = index.next();
                {
                    edit.manifestConstruction(con);
                }
            }
            edit.redo();
        }

        /**
         * 
         * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
         */
        public complete(applyTool: com.vzome.core.editor.api.ChangeManifestations) {
        }

        /**
         * 
         * @param {com.vzome.core.construction.Construction} c
         * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
         */
        public performEdit(c: com.vzome.core.construction.Construction, applyTool: com.vzome.core.editor.api.ChangeManifestations) {
        }

        /**
         * 
         * @param {*} man
         * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
         */
        public performSelect(man: com.vzome.core.model.Manifestation, applyTool: com.vzome.core.editor.api.ChangeManifestations) {
        }

        /**
         * 
         */
        public redo() {
        }

        /**
         * 
         */
        public undo() {
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "BookmarkTool";
        }

        /**
         * 
         * @return {string}
         */
        public getCategory(): string {
            return BookmarkTool.ID;
        }

        /**
         * 
         * @param {boolean} prepareTool
         * @return {string}
         */
        checkSelection(prepareTool: boolean): string {
            return null;
        }
    }
    BookmarkTool["__class"] = "com.vzome.core.tools.BookmarkTool";
    BookmarkTool["__interfaces"] = ["com.vzome.api.Tool"];


}
namespace com.vzome.core.tools {
    export class ModuleTool extends com.vzome.core.editor.Tool {
        static ID: string = "module";

        static LABEL: string = "Create a module tool";

        static TOOLTIP: string = "<p>Each tool duplicates the original module.<br></p>";

        /*private*/ name: string;

        /*private*/ bookmarkedSelection: java.util.List<com.vzome.core.model.Manifestation>;

        public constructor(id: string, tools: com.vzome.core.editor.ToolsModel) {
            super(id, tools);
            if (this.name === undefined) { this.name = null; }
            this.bookmarkedSelection = <any>(new java.util.ArrayList<any>());
            this.mSelection.copy(this.bookmarkedSelection);
        }

        /**
         * 
         * @return {boolean}
         */
        public isSticky(): boolean {
            return true;
        }

        /**
         * 
         * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
         */
        public prepare(applyTool: com.vzome.core.editor.api.ChangeManifestations) {
        }

        /**
         * 
         * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
         */
        public complete(applyTool: com.vzome.core.editor.api.ChangeManifestations) {
        }

        /**
         * 
         * @return {boolean}
         */
        public needsInput(): boolean {
            return true;
        }

        /**
         * 
         * @param {com.vzome.core.construction.Construction} c
         * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
         */
        public performEdit(c: com.vzome.core.construction.Construction, applyTool: com.vzome.core.editor.api.ChangeManifestations) {
            if (!(c != null && c instanceof <any>com.vzome.core.construction.Point))return;
            const p: com.vzome.core.construction.Point = <com.vzome.core.construction.Point>c;
            const loc: com.vzome.core.algebra.AlgebraicVector = p.getLocation();
            const duper: com.vzome.core.editor.Duplicator = new com.vzome.core.editor.Duplicator(applyTool, loc);
            for(let index=this.bookmarkedSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    duper.duplicateManifestation(man);
                }
            }
            applyTool.redo();
        }

        /**
         * 
         * @param {*} man
         * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
         */
        public performSelect(man: com.vzome.core.model.Manifestation, applyTool: com.vzome.core.editor.api.ChangeManifestations) {
        }

        /**
         * 
         */
        public redo() {
        }

        /**
         * 
         */
        public undo() {
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "ModuleTool";
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            element.setAttribute("name", this.name);
        }

        /**
         * 
         * @param {*} element
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(element: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            this.name = element.getAttribute("name");
        }

        /**
         * 
         * @return {string}
         */
        public getCategory(): string {
            return ModuleTool.ID;
        }

        /**
         * 
         * @param {boolean} prepareTool
         * @return {string}
         */
        checkSelection(prepareTool: boolean): string {
            return null;
        }
    }
    ModuleTool["__class"] = "com.vzome.core.tools.ModuleTool";
    ModuleTool["__interfaces"] = ["com.vzome.api.Tool"];


}
namespace com.vzome.core.edits {
    export class SelectByRadius extends com.vzome.core.edits.SelectByDiameter {
        public static NAME: string = "SelectByRadius";

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return SelectByRadius.NAME;
        }

        minRadiusSquared: com.vzome.core.algebra.AlgebraicNumber;

        public constructor(editor: com.vzome.core.editor.api.EditorModel) {
            super(editor);
            if (this.minRadiusSquared === undefined) { this.minRadiusSquared = null; }
        }

        /**
         * 
         * @return {string}
         */
        public usage(): string {
            return "This command requires either two or three selected connectors.\n\nThe first connector marks the center of a sphere.\nThe second connector defines its radius.\nAn optional third connector defines the radius of\n a second sphere with the same center.\n\nAll parts that are completely within the larger sphere will be selected.\n\nIf a second sphere is defined then any parts\n     within the smaller sphere, even partially, will be excluded.\n";
        }

        /**
         * 
         */
        public perform() {
            this.setOrderedSelection(true);
            super.perform();
        }

        /**
         * 
         * @param {*} vectors
         * @return {string}
         */
        adjustBoundary(vectors: java.util.List<com.vzome.core.algebra.AlgebraicVector>): string {
            const v: com.vzome.core.algebra.AlgebraicVector = vectors.get(vectors.size() - 1);
            switch((vectors.size())) {
            case 1:
                this.center = v;
                this.maxRadiusSquared = null;
                this.minRadiusSquared = null;
                return null;
            case 2:
                const v2: com.vzome.core.algebra.AlgebraicVector = v.minus(this.center);
                this.maxRadiusSquared = v2.dot(v2);
                return null;
            case 3:
                const v3: com.vzome.core.algebra.AlgebraicVector = v.minus(this.center);
                this.minRadiusSquared = v3.dot(v3);
                if (this.maxRadiusSquared.compareTo(this.minRadiusSquared) < 0){
                    const temp: com.vzome.core.algebra.AlgebraicNumber = this.maxRadiusSquared;
                    this.maxRadiusSquared = this.minRadiusSquared;
                    this.minRadiusSquared = temp;
                }
                return null;
            }
            return super.adjustBoundary(vectors);
        }

        public boundaryContains$com_vzome_core_algebra_AlgebraicVector(v: com.vzome.core.algebra.AlgebraicVector): boolean {
            if (super.boundaryContains$com_vzome_core_algebra_AlgebraicVector(v)){
                if (this.minRadiusSquared != null){
                    const v1: com.vzome.core.algebra.AlgebraicVector = v.minus(this.center);
                    return v1.dot(v1).compareTo(this.minRadiusSquared) >= 0;
                }
                return true;
            }
            return false;
        }

        /**
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} v
         * @return {boolean}
         */
        public boundaryContains(v?: any): boolean {
            if (((v != null && v instanceof <any>com.vzome.core.algebra.AlgebraicVector) || v === null)) {
                return <any>this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(v);
            } else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || v === null)) {
                return super.boundaryContains(v);
            } else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || v === null)) {
                return <any>this.boundaryContains$com_vzome_core_model_Strut(v);
            } else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) || v === null)) {
                return <any>this.boundaryContains$com_vzome_core_model_Panel(v);
            } else throw new Error('invalid overload');
        }
    }
    SelectByRadius["__class"] = "com.vzome.core.edits.SelectByRadius";

}
namespace com.vzome.core.tools {
    export class InversionTool extends com.vzome.core.tools.TransformationTool {
        static ID: string = "point reflection";

        static LABEL: string = "Create a point reflection tool";

        static TOOLTIP: string = "<p>Each tool duplicates the selection by reflecting<br>each point through the defined center.  To create a<br>tool, select a single ball that defines that center.<br></p>";

        public constructor(toolName: string, tools: com.vzome.core.editor.ToolsModel) {
            super(toolName, tools);
        }

        /**
         * 
         * @param {boolean} prepareTool
         * @return {string}
         */
        checkSelection(prepareTool: boolean): string {
            let center: com.vzome.core.construction.Point = null;
            if (!this.isAutomatic())for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (prepareTool)this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        if (center != null)return "more than one center selected";
                        center = <com.vzome.core.construction.Point>(<com.vzome.core.model.Connector><any>man).getFirstConstruction();
                    } else if (!prepareTool)return "panel or strut selected";
                }
            }
            if (center == null){
                if (prepareTool){
                    center = this.originPoint;
                    this.addParameter(center);
                } else return "No symmetry center selected";
            }
            if (prepareTool){
                this.transforms = [null];
                this.transforms[0] = new com.vzome.core.construction.PointReflection(center);
            }
            return null;
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "InversionTool";
        }

        /**
         * 
         * @return {string}
         */
        public getCategory(): string {
            return InversionTool.ID;
        }
    }
    InversionTool["__class"] = "com.vzome.core.tools.InversionTool";
    InversionTool["__interfaces"] = ["com.vzome.api.Tool"];


}
namespace com.vzome.core.tools {
    export class AxialStretchTool extends com.vzome.core.tools.TransformationTool {
        static TOOLTIP_REDSQUASH1: string = "<p>Each tool applies a \"squash\" transformation to the<br>selected objects, compressing along a red axis.  To create<br>a tool, select a ball as the center of the mapping, and a<br>red strut as the direction of the compression.  The ball and<br>strut need not be collinear.<br><br>The mapping comes from the usual Zome projection of the<br>120-cell.  It is the mapping that transforms the central,<br>blue dodecahedron into the compressed form in the next<br>layer outward.<br><br>By default, the input selection will be removed, and replaced<br>with the squashed equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";

        static TOOLTIP_REDSTRETCH1: string = "<p>Each tool applies a \"stretch\" transformation to the<br>selected objects, stretching along a red axis.  To create<br>a tool, select a ball as the center of the mapping, and a<br>red strut as the direction of the stretch.  The ball and<br>strut need not be collinear.<br><br>The mapping comes from the usual Zome projection of the<br>120-cell.  It is the inverse of the mapping that transforms<br>the central, blue dodecahedron into the compressed form in<br>the next layer outward.<br><br>By default, the input selection will be removed, and replaced<br>with the stretched equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";

        static TOOLTIP_YELLOWSQUASH: string = "<p>Each tool applies a \"squash\" transformation to the<br>selected objects, compressing along a yellow axis.  To create<br>a tool, select a ball as the center of the mapping, and a<br>yellow strut as the direction of the compression.  The ball and<br>strut need not be collinear.<br><br>The mapping comes from the usual Zome projection of the<br>120-cell.  It is the mapping that transforms the central,<br>blue dodecahedron into the compressed form along a yellow axis.<br><br>By default, the input selection will be removed, and replaced<br>with the squashed equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";

        static TOOLTIP_YELLOWSTRETCH: string = "<p>Each tool applies a \"stretch\" transformation to the<br>selected objects, stretching along a yellow axis.  To create<br>a tool, select a ball as the center of the mapping, and a<br>yellow strut as the direction of the stretch.  The ball and<br>strut need not be collinear.<br><br>The mapping comes from the usual Zome projection of the<br>120-cell.  It is the inverse of the mapping that transforms<br>the central, blue dodecahedron into the compressed form along<br>a yellow axis.<br><br>By default, the input selection will be removed, and replaced<br>with the stretched equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";

        static TOOLTIP_REDSQUASH2: string = "<p>Each tool applies a \"squash\" transformation to the<br>selected objects, compressing along a red axis.  To create<br>a tool, select a ball as the center of the mapping, and a<br>red strut as the direction of the compression.  The ball and<br>strut need not be collinear.<br><br>The mapping comes from the usual Zome projection of the<br>120-cell.  It is the mapping that transforms the central,<br>blue dodecahedron into the compressed form in the second<br>layer outward along a red axis.<br><br>By default, the input selection will be removed, and replaced<br>with the squashed equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";

        static TOOLTIP_REDSTRETCH2: string = "<p>Each tool applies a \"stretch\" transformation to the<br>selected objects, stretching along a red axis.  To create<br>a tool, select a ball as the center of the mapping, and a<br>red strut as the direction of the stretch.  The ball and<br>strut need not be collinear.<br><br>The mapping comes from the usual Zome projection of the<br>120-cell.  It is the inverse of the mapping that transforms<br>the central, blue dodecahedron into the compressed form in<br>the second layer outward along a red axis.<br><br>By default, the input selection will be removed, and replaced<br>with the stretched equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";

        /*private*/ symmetry: com.vzome.core.math.symmetry.IcosahedralSymmetry;

        /*private*/ stretch: boolean;

        /*private*/ red: boolean;

        /*private*/ first: boolean;

        /*private*/ __com_vzome_core_tools_AxialStretchTool_category: string;

        public constructor(id: string, symmetry: com.vzome.core.math.symmetry.IcosahedralSymmetry, tools: com.vzome.core.editor.ToolsModel, stretch: boolean, red: boolean, first: boolean, category: string) {
            super(id, tools);
            if (this.symmetry === undefined) { this.symmetry = null; }
            if (this.stretch === undefined) { this.stretch = false; }
            if (this.red === undefined) { this.red = false; }
            if (this.first === undefined) { this.first = false; }
            if (this.__com_vzome_core_tools_AxialStretchTool_category === undefined) { this.__com_vzome_core_tools_AxialStretchTool_category = null; }
            this.symmetry = symmetry;
            this.stretch = stretch;
            this.red = red;
            this.first = first;
            this.__com_vzome_core_tools_AxialStretchTool_category = category;
            this.setInputBehaviors(false, true);
        }

        /**
         * 
         * @param {boolean} prepareTool
         * @return {string}
         */
        checkSelection(prepareTool: boolean): string {
            let center: com.vzome.core.construction.Point = null;
            let axis: com.vzome.core.construction.Segment = null;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (prepareTool)this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        if (center != null)return "Only one ball may be selected";
                        center = <com.vzome.core.construction.Point>(<com.vzome.core.model.Connector><any>man).getFirstConstruction();
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        if (axis != null)return "Only one strut may be selected";
                        axis = <com.vzome.core.construction.Segment>(<com.vzome.core.model.Strut><any>man).getFirstConstruction();
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                        return "Panels are not supported.";
                    }
                }
            }
            if (center == null)return "Exactly one ball must be selected.";
            if (axis == null)return "Exactly one strut must be selected.";
            const zone: com.vzome.core.math.symmetry.Axis = this.symmetry.getAxis$com_vzome_core_algebra_AlgebraicVector(axis.getOffset());
            if (zone == null)return "Selected alignment strut is not an appropriate axis.";
            let o0: com.vzome.core.algebra.AlgebraicVector;
            let o1: com.vzome.core.algebra.AlgebraicVector;
            let o2: com.vzome.core.algebra.AlgebraicVector;
            let n0: com.vzome.core.algebra.AlgebraicVector;
            let n1: com.vzome.core.algebra.AlgebraicVector;
            let n2: com.vzome.core.algebra.AlgebraicVector;
            switch((zone.getDirection().getName())) {
            case "yellow":
                {
                    if (this.red)return "A red axis strut must be selected.";
                    const blueOrbit: com.vzome.core.math.symmetry.Direction = this.symmetry.getDirection("blue");
                    const blueScale: com.vzome.core.algebra.AlgebraicNumber = blueOrbit.getUnitLength();
                    o0 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 2).normal().scale(blueScale);
                    o1 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 54).normal().scale(blueScale);
                    o2 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 36).normal().scale(blueScale);
                    const redOrbit: com.vzome.core.math.symmetry.Direction = this.symmetry.getDirection("red");
                    const redScale: com.vzome.core.algebra.AlgebraicNumber = redOrbit.getUnitLength();
                    n0 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 2).normal().scale(redScale);
                    n1 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 46).normal().scale(redScale);
                    n2 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 16).normal().scale(redScale);
                    break;
                };
            case "red":
                {
                    if (!this.red)return "A yellow axis strut must be selected.";
                    const blueOrbit: com.vzome.core.math.symmetry.Direction = this.symmetry.getDirection("blue");
                    const blueScale: com.vzome.core.algebra.AlgebraicNumber = blueOrbit.getUnitLength();
                    const redOrbit: com.vzome.core.math.symmetry.Direction = this.symmetry.getDirection("red");
                    let redScale: com.vzome.core.algebra.AlgebraicNumber = redOrbit.getUnitLength();
                    if (this.first){
                        o0 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 56).normal().scale(blueScale);
                        o1 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 38).normal().scale(blueScale);
                        o2 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 40).normal().scale(blueScale);
                        n0 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 46).normal().scale(redScale);
                        n1 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 1).normal().scale(redScale);
                        n2 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 2).normal().scale(redScale);
                    } else {
                        o0 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 37).normal().scale(blueScale);
                        o1 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 25).normal().scale(blueScale);
                        o2 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 45).normal().scale(blueScale);
                        n0 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 37).normal().scale(blueScale);
                        n1 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 25).normal().scale(blueScale);
                        redScale = redScale['times$com_vzome_core_algebra_AlgebraicNumber'](this.symmetry.getField()['createPower$int'](-1));
                        n2 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 45).normal().scale(redScale);
                    }
                    break;
                };
            default:
                return "Selected alignment strut is not an appropriate axis.";
            }
            if (prepareTool){
                const orientation: com.vzome.core.algebra.AlgebraicMatrix = this.symmetry.getMatrix(zone.getOrientation());
                const inverse: com.vzome.core.algebra.AlgebraicMatrix = orientation.inverse();
                let oldBasis: com.vzome.core.algebra.AlgebraicMatrix = new com.vzome.core.algebra.AlgebraicMatrix(o0, o1, o2);
                let newBasis: com.vzome.core.algebra.AlgebraicMatrix = new com.vzome.core.algebra.AlgebraicMatrix(n0, n1, n2);
                if (this.stretch){
                    const temp: com.vzome.core.algebra.AlgebraicMatrix = oldBasis;
                    oldBasis = newBasis;
                    newBasis = temp;
                }
                const matrix: com.vzome.core.algebra.AlgebraicMatrix = orientation.times(newBasis.times(oldBasis.inverse()).times(inverse));
                this.transforms = [null];
                this.transforms[0] = new com.vzome.core.construction.MatrixTransformation(matrix, center.getLocation());
            }
            return null;
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "AxialStretchTool";
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            super.getXmlAttributes(element);
            if (this.stretch)element.setAttribute("stretch", "true");
            element.setAttribute("orbit", this.red ? "red" : "yellow");
            if (!this.first)element.setAttribute("first", "false");
        }

        /**
         * 
         * @param {*} element
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(element: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            let value: string = element.getAttribute("stretch");
            this.stretch = value != null && (value === ("true"));
            value = element.getAttribute("orbit");
            this.red = value === ("red");
            value = element.getAttribute("first");
            this.first = value == null || !(value === ("false"));
            this.__com_vzome_core_tools_AxialStretchTool_category = AxialStretchTool.Factory.getCategory(this.red, this.stretch, this.first);
            this.symmetry = <com.vzome.core.math.symmetry.IcosahedralSymmetry><any>(<com.vzome.core.commands.XmlSymmetryFormat>format).parseSymmetry("icosahedral");
            super.setXmlAttributes(element, format);
        }

        /**
         * 
         * @return {string}
         */
        public getCategory(): string {
            return this.__com_vzome_core_tools_AxialStretchTool_category;
        }
    }
    AxialStretchTool["__class"] = "com.vzome.core.tools.AxialStretchTool";
    AxialStretchTool["__interfaces"] = ["com.vzome.api.Tool"];



    export namespace AxialStretchTool {

        export class Factory extends com.vzome.core.editor.AbstractToolFactory {
            red: boolean;

            stretch: boolean;

            first: boolean;

            static getCategory(red: boolean, stretch: boolean, first: boolean): string {
                if (red)if (first)return stretch ? "redstretch1" : "redsquash1"; else return stretch ? "redstretch2" : "redsquash2"; else return stretch ? "yellowstretch" : "yellowsquash";
            }

            static getLabel(red: boolean, stretch: boolean, first: boolean): string {
                let label: string;
                if (red)if (first)label = stretch ? "weak red stretch" : "weak red squash"; else label = stretch ? "strong red stretch" : "strong red squash"; else label = stretch ? "yellow stretch" : "yellow squash";
                return "Create a " + label + " tool";
            }

            static getToolTip(red: boolean, stretch: boolean, first: boolean): string {
                if (red)if (first)return stretch ? com.vzome.core.tools.AxialStretchTool.TOOLTIP_REDSTRETCH1 : com.vzome.core.tools.AxialStretchTool.TOOLTIP_REDSQUASH1; else return stretch ? com.vzome.core.tools.AxialStretchTool.TOOLTIP_REDSTRETCH2 : com.vzome.core.tools.AxialStretchTool.TOOLTIP_REDSQUASH2; else return stretch ? com.vzome.core.tools.AxialStretchTool.TOOLTIP_YELLOWSTRETCH : com.vzome.core.tools.AxialStretchTool.TOOLTIP_YELLOWSQUASH;
            }

            public constructor(tools: com.vzome.core.editor.ToolsModel, symmetry: com.vzome.core.math.symmetry.IcosahedralSymmetry, red: boolean, stretch: boolean, first: boolean) {
                super(tools, symmetry, Factory.getCategory(red, stretch, first), Factory.getLabel(red, stretch, first), Factory.getToolTip(red, stretch, first));
                if (this.red === undefined) { this.red = false; }
                if (this.stretch === undefined) { this.stretch = false; }
                if (this.first === undefined) { this.first = false; }
                this.red = red;
                this.stretch = stretch;
                this.first = first;
            }

            /**
             * 
             * @param {number} total
             * @param {number} balls
             * @param {number} struts
             * @param {number} panels
             * @return {boolean}
             */
            countsAreValid(total: number, balls: number, struts: number, panels: number): boolean {
                return (total === 2 && balls === 1 && struts === 1);
            }

            /**
             * 
             * @param {string} id
             * @return {com.vzome.core.editor.Tool}
             */
            public createToolInternal(id: string): com.vzome.core.editor.Tool {
                const category: string = Factory.getCategory(this.red, this.stretch, this.first);
                return new com.vzome.core.tools.AxialStretchTool(id, <com.vzome.core.math.symmetry.IcosahedralSymmetry><any>this.getSymmetry(), this.getToolsModel(), this.stretch, this.red, this.first, category);
            }

            /**
             * 
             * @return {com.vzome.core.editor.Tool}
             */
            public createTool(): com.vzome.core.editor.Tool {
                const result: com.vzome.core.editor.Tool = super.createTool();
                result.setCopyColors(false);
                return result;
            }

            /**
             * 
             * @param {*} selection
             * @return {boolean}
             */
            bindParameters(selection: com.vzome.core.editor.api.Selection): boolean {
                const symmetry: com.vzome.core.math.symmetry.IcosahedralSymmetry = <com.vzome.core.math.symmetry.IcosahedralSymmetry><any>this.getSymmetry();
                for(let index=selection.iterator();index.hasNext();) {
                    let man = index.next();
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        const axisStrut: com.vzome.core.model.Strut = <com.vzome.core.model.Strut><any>man;
                        let vector: com.vzome.core.algebra.AlgebraicVector = axisStrut.getOffset();
                        vector = symmetry.getField().projectTo3d(vector, true);
                        const axis: com.vzome.core.math.symmetry.Axis = symmetry.getAxis$com_vzome_core_algebra_AlgebraicVector(vector);
                        if (axis == null)return false;
                        const orbitName: string = axis.getDirection().getName();
                        if (this.red)return orbitName === ("red"); else return orbitName === ("yellow");
                    }
                }
                return true;
            }
        }
        Factory["__class"] = "com.vzome.core.tools.AxialStretchTool.Factory";
        Factory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener","com.vzome.api.Tool.Factory"];


    }

}
namespace com.vzome.core.tools {
    export class SymmetryTool extends com.vzome.core.tools.TransformationTool {
        static ID: string = "symmetry";

        static LABEL: string = "Create a general symmetry tool";

        static TOOLTIP: string = "<p>General symmetry tool.<br></p>";

        symmetry: com.vzome.core.math.symmetry.Symmetry;

        public constructor(id: string, symmetry: com.vzome.core.math.symmetry.Symmetry, tools: com.vzome.core.editor.ToolsModel) {
            super(id, tools);
            if (this.symmetry === undefined) { this.symmetry = null; }
            this.symmetry = symmetry;
        }

        /**
         * 
         * @return {number}
         */
        public hashCode(): number {
            const prime: number = 31;
            let result: number = 1;
            result = prime * result + ((this.symmetry == null) ? 0 : /* hashCode */(<any>((o: any) => { if (o.hashCode) { return o.hashCode(); } else { return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0); }})(this.symmetry)));
            return result;
        }

        /**
         * 
         * @param {*} that
         * @return {boolean}
         */
        public equals(that: any): boolean {
            if (this === that){
                return true;
            }
            if (!super.equals(that)){
                return false;
            }
            if ((<any>this.constructor) !== (<any>that.constructor)){
                return false;
            }
            const other: SymmetryTool = <SymmetryTool>that;
            if (this.symmetry == null){
                if (other.symmetry != null){
                    return false;
                }
            } else if (!/* equals */(<any>((o1: any, o2: any) => { if (o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(this.symmetry,other.symmetry))){
                return false;
            }
            return true;
        }

        /**
         * 
         * @param {boolean} prepareTool
         * @return {string}
         */
        checkSelection(prepareTool: boolean): string {
            let center: com.vzome.core.construction.Point = null;
            let axis: com.vzome.core.model.Strut = null;
            let correct: boolean = true;
            let hasPanels: boolean = false;
            if (!this.isAutomatic())for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (prepareTool)this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        if (center != null)return "No unique symmetry center selected";
                        center = <com.vzome.core.construction.Point>(<com.vzome.core.model.Connector><any>man).getFirstConstruction();
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        if (axis != null)correct = false; else axis = <com.vzome.core.model.Strut><any>man;
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                        hasPanels = true;
                    }
                }
            }
            if (center == null){
                if (prepareTool){
                    center = this.originPoint;
                    this.addParameter(center);
                } else return "No symmetry center selected";
            }
            if (hasPanels){
                if (!prepareTool)return "panels are selected";
            }
            let closure: number[] = this.symmetry.subgroup(com.vzome.core.math.symmetry.Symmetry.TETRAHEDRAL);
            switch((this.symmetry.getName())) {
            case "icosahedral":
                if (!prepareTool && (axis != null) && (this.getCategory() === ("icosahedral")))return "No struts needed for icosahedral symmetry.";
                switch((this.getCategory())) {
                case "tetrahedral":
                    if (!correct)return "no unique alignment strut selected.";
                    if (axis == null){
                        if (!prepareTool)return "no aligment strut selected.";
                    } else {
                        const icosa: com.vzome.core.math.symmetry.IcosahedralSymmetry = <com.vzome.core.math.symmetry.IcosahedralSymmetry><any>this.symmetry;
                        const zone: com.vzome.core.math.symmetry.Axis = icosa.getAxis$com_vzome_core_algebra_AlgebraicVector(axis.getOffset());
                        if (zone == null)return "selected alignment strut is not a tetrahedral axis.";
                        const allowYellow: boolean = prepareTool;
                        closure = icosa.subgroup$java_lang_String$com_vzome_core_math_symmetry_Axis$boolean(com.vzome.core.math.symmetry.Symmetry.TETRAHEDRAL, zone, allowYellow);
                        if (closure == null)return "selected alignment strut is not a tetrahedral axis.";
                    }
                    if (prepareTool){
                        const order: number = closure.length;
                        this.transforms = (s => { let a=[]; while(s-->0) a.push(null); return a; })(order - 1);
                        for(let i: number = 0; i < order - 1; i++) {this.transforms[i] = new com.vzome.core.construction.SymmetryTransformation(this.symmetry, closure[i + 1], center);}
                    }
                    break;
                case "octahedral":
                    let orientation: com.vzome.core.algebra.AlgebraicMatrix = null;
                    if (!correct)return "no unique alignment strut selected.";
                    if (axis == null){
                        if (!prepareTool)return "no aligment strut selected.";
                    } else {
                        const icosa: com.vzome.core.math.symmetry.IcosahedralSymmetry = <com.vzome.core.math.symmetry.IcosahedralSymmetry><any>this.symmetry;
                        const zone: com.vzome.core.math.symmetry.Axis = icosa.getAxis$com_vzome_core_algebra_AlgebraicVector(axis.getOffset());
                        if (zone == null)return "selected alignment strut is not an octahedral axis.";
                        let blueIndex: number = 0;
                        switch((zone.getDirection().getName())) {
                        case "green":
                            blueIndex = icosa.blueTetrahedralFromGreen(zone.getOrientation());
                            break;
                        case "blue":
                            blueIndex = zone.getOrientation();
                            break;
                        default:
                            return "selected alignment strut is not an octahedral axis.";
                        }
                        orientation = this.symmetry.getMatrix(blueIndex);
                    }
                    if (prepareTool){
                        const inverse: com.vzome.core.algebra.AlgebraicMatrix = orientation.inverse();
                        const octa: com.vzome.core.math.symmetry.OctahedralSymmetry = (this.symmetry != null && this.symmetry instanceof <any>com.vzome.core.math.symmetry.OctahedralSymmetry) ? <com.vzome.core.math.symmetry.OctahedralSymmetry><any>this.symmetry : new com.vzome.core.math.symmetry.OctahedralSymmetry(this.symmetry.getField());
                        const order: number = octa.getChiralOrder();
                        this.transforms = (s => { let a=[]; while(s-->0) a.push(null); return a; })(order - 1);
                        for(let i: number = 0; i < order - 1; i++) {{
                            let matrix: com.vzome.core.algebra.AlgebraicMatrix = octa.getMatrix(i + 1);
                            matrix = orientation.times(matrix.times(inverse));
                            this.transforms[i] = new com.vzome.core.construction.MatrixTransformation(matrix, center.getLocation());
                        };}
                    }
                    break;
                default:
                    if (prepareTool)this.prepareFullSymmetry(center);
                    break;
                }
                break;
            case "synestructics":
            case "octahedral":
                if (prepareTool){
                    if (this.getCategory() === ("tetrahedral")){
                        const order: number = closure.length;
                        this.transforms = (s => { let a=[]; while(s-->0) a.push(null); return a; })(order - 1);
                        for(let i: number = 0; i < order - 1; i++) {this.transforms[i] = new com.vzome.core.construction.SymmetryTransformation(this.symmetry, closure[i + 1], center);}
                    } else {
                        this.prepareFullSymmetry(center);
                    }
                } else {
                    if (axis != null)return "No struts needed for symmetry";
                }
                break;
            default:
                if (prepareTool)this.prepareFullSymmetry(center);
                break;
            }
            return null;
        }

        /*private*/ prepareFullSymmetry(center: com.vzome.core.construction.Point) {
            const order: number = this.symmetry.getChiralOrder();
            this.transforms = (s => { let a=[]; while(s-->0) a.push(null); return a; })(order - 1);
            for(let i: number = 0; i < order - 1; i++) {this.transforms[i] = new com.vzome.core.construction.SymmetryTransformation(this.symmetry, i + 1, center);}
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "SymmetryTool";
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            element.setAttribute("symmetry", this.symmetry.getName());
            super.getXmlAttributes(element);
        }

        /**
         * 
         * @param {*} element
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(element: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            const symmName: string = element.getAttribute("symmetry");
            this.symmetry = (<com.vzome.core.commands.XmlSymmetryFormat>format).parseSymmetry(symmName);
            super.setXmlAttributes(element, format);
        }
    }
    SymmetryTool["__class"] = "com.vzome.core.tools.SymmetryTool";
    SymmetryTool["__interfaces"] = ["com.vzome.api.Tool"];


}
namespace com.vzome.core.tools {
    export class LinearMapTool extends com.vzome.core.tools.TransformationTool {
        static CATEGORY: string = "linear map";

        static LABEL: string = "Create a linear map tool";

        static TOOLTIP: string = "<p><b>For experts and Linear Algebra students...</b><br><br>Each tool applies a linear transformation to the selected<br>objects, possibly rotating, stretching, and compressing.  To<br>create a tool, select a ball as the center of the mapping,<br>three struts (in order) to define the input basis, and three<br>more struts to define the output basis.<br><br>You can omit the input basis if it would consist of three<br>identical blue struts at right angles; the three struts you<br>select will be interpreted as the output basis.<br><br>By default, the input selection will be removed, and replaced<br>with the transformed equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";

        /*private*/ originalScaling: boolean;

        public constructor(name: string, tools: com.vzome.core.editor.ToolsModel, originalScaling: boolean) {
            super(name, tools);
            if (this.originalScaling === undefined) { this.originalScaling = false; }
            this.originalScaling = originalScaling;
            this.setInputBehaviors(false, true);
        }

        checkSelection(prepareTool: boolean): string {
            const oldBasis: com.vzome.core.construction.Segment[] = [null, null, null];
            const newBasis: com.vzome.core.construction.Segment[] = [null, null, null];
            let index: number = 0;
            let correct: boolean = true;
            let center: com.vzome.core.construction.Point = null;
            for(let index1=this.mSelection.iterator();index1.hasNext();) {
                let man = index1.next();
                {
                    if (prepareTool)this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        if (center != null){
                            correct = false;
                            break;
                        }
                        center = <com.vzome.core.construction.Point>(<com.vzome.core.model.Connector><any>man).getFirstConstruction();
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        if (index >= 6){
                            correct = false;
                            break;
                        }
                        if ((index / 3|0) === 0){
                            oldBasis[index % 3] = <com.vzome.core.construction.Segment>man.getFirstConstruction();
                        } else {
                            newBasis[index % 3] = <com.vzome.core.construction.Segment>man.getFirstConstruction();
                        }
                        ++index;
                    }
                }
            }
            correct = correct && ((index === 3) || (index === 6));
            if (!correct)return "linear map tool requires three adjacent, non-parallel struts (or two sets of three) and a single (optional) center ball";
            if (prepareTool){
                if (center == null)center = this.originPoint;
                this.transforms = [null];
                if (index === 6)this.transforms[0] = new com.vzome.core.construction.ChangeOfBasis(oldBasis, newBasis, center); else this.transforms[0] = new com.vzome.core.construction.ChangeOfBasis(oldBasis[0], oldBasis[1], oldBasis[2], center, this.originalScaling);
            }
            return null;
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "LinearTransformTool";
        }

        /**
         * 
         * @return {string}
         */
        public getCategory(): string {
            return LinearMapTool.CATEGORY;
        }
    }
    LinearMapTool["__class"] = "com.vzome.core.tools.LinearMapTool";
    LinearMapTool["__interfaces"] = ["com.vzome.api.Tool"];


}
namespace com.vzome.core.tools {
    export class ProjectionTool extends com.vzome.core.tools.TransformationTool {
        static ID: string = "projection";

        static LABEL: string = "Create a plane projection tool";

        static TOOLTIP: string = "<p>Created tools project selected objects to a 2D plane.<br><br>To create a tool, define the projection plane<br> by selecting either a single panel<br> or strut that is normal to the projection plane<br> and a ball on the plane.<br>When the projection plane is defined by selecting a panel,<br>  an optional strut may be selected to define the line of projection.<br>The default line of projection is orthogonal to the projection plane.<br></p>";

        public constructor(id: string, tools: com.vzome.core.editor.ToolsModel) {
            super(id, tools);
            this.setInputBehaviors(false, true);
        }

        /**
         * 
         */
        public perform() {
            let plane: com.vzome.core.construction.Plane = null;
            let line: com.vzome.core.construction.Line = null;
            let point: com.vzome.core.algebra.AlgebraicVector = null;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                        if (plane == null){
                            const panel: com.vzome.core.model.Panel = <com.vzome.core.model.Panel><any>man;
                            const polygon: com.vzome.core.construction.Polygon = <com.vzome.core.construction.Polygon>panel.toConstruction();
                            plane = new com.vzome.core.construction.PlaneExtensionOfPolygon(polygon);
                        } else {
                            throw new com.vzome.core.commands.Command.Failure("Projection tool allows only a single selected panel");
                        }
                    }
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        if (line == null){
                            const strut: com.vzome.core.model.Strut = <com.vzome.core.model.Strut><any>man;
                            const segment: com.vzome.core.construction.Segment = <com.vzome.core.construction.Segment>strut.toConstruction();
                            line = new com.vzome.core.construction.LineExtensionOfSegment(segment);
                        } else {
                            throw new com.vzome.core.commands.Command.Failure("Projection tool allows only a single selected strut");
                        }
                    }
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        if (point == null){
                            point = man.getLocation();
                            continue;
                        } else {
                            throw new com.vzome.core.commands.Command.Failure("Projection tool allows only a single selected ball");
                        }
                    }
                }
            }
            if (point != null && line != null){
                plane = new com.vzome.core.construction.PlaneFromPointAndNormal(point, line.getDirection());
            }
            if (plane == null){
                throw new com.vzome.core.commands.Command.Failure("Projection tool requires a selected panel or else a selected ball and strut.");
            }
            this.transforms = [null];
            this.transforms[0] = new com.vzome.core.construction.PlaneProjection(plane, line);
            if (line != null){
                const test: com.vzome.core.algebra.AlgebraicVector = this.transforms[0].transform$com_vzome_core_algebra_AlgebraicVector(line.getDirection());
                if (test == null)throw new com.vzome.core.commands.Command.Failure("Selected strut and plane must not be parallel");
            }
            super.perform();
        }

        /**
         * 
         * @param {boolean} prepareTool
         * @return {string}
         */
        checkSelection(prepareTool: boolean): string {
            return null;
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "ProjectionTool";
        }

        /**
         * 
         * @return {string}
         */
        public getCategory(): string {
            return ProjectionTool.ID;
        }
    }
    ProjectionTool["__class"] = "com.vzome.core.tools.ProjectionTool";
    ProjectionTool["__interfaces"] = ["com.vzome.api.Tool"];


}
namespace com.vzome.core.tools {
    export class LineReflectionTool extends com.vzome.core.tools.TransformationTool {
        public constructor(id: string, tools: com.vzome.core.editor.ToolsModel) {
            super(id, tools);
            this.setCopyColors(false);
        }

        /**
         * 
         * @param {boolean} prepareTool
         * @return {string}
         */
        checkSelection(prepareTool: boolean): string {
            let axis: com.vzome.core.construction.Segment = null;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (prepareTool){
                        this.unselect$com_vzome_core_model_Manifestation(man);
                    }
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        if (axis != null){
                            if (prepareTool){
                                break;
                            } else {
                                return "Only one mirror axis strut may be selected";
                            }
                        }
                        axis = <com.vzome.core.construction.Segment>(<com.vzome.core.model.Strut><any>man).getFirstConstruction();
                    }
                }
            }
            if (axis == null){
                return "line reflection tool requires a single strut";
            }
            if (prepareTool){
                this.transforms = [null];
                this.transforms[0] = new com.vzome.core.construction.LineReflection(axis);
            }
            return null;
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "LineReflectionTool";
        }
    }
    LineReflectionTool["__class"] = "com.vzome.core.tools.LineReflectionTool";
    LineReflectionTool["__interfaces"] = ["com.vzome.api.Tool"];


}
namespace com.vzome.core.tools {
    export class MirrorTool extends com.vzome.core.tools.TransformationTool {
        static ID: string = "mirror";

        static LABEL: string = "Create a mirror reflection tool";

        static TOOLTIP: string = "<p>Each tool duplicates the selection by reflecting<br>each object in a mirror plane.  To create a<br>tool, define the mirror plane by selecting a single<br>panel, or by selecting a strut orthogonal to the<br>plane and a ball lying in the plane.<br></p>";

        symmSys: com.vzome.core.editor.api.OrbitSource;

        public constructor(id: string, tools: com.vzome.core.editor.ToolsModel) {
            super(id, tools);
            if (this.symmSys === undefined) { this.symmSys = null; }
            this.symmSys = (<com.vzome.core.editor.api.SymmetryAware><any>tools.getEditorModel())['getSymmetrySystem$']();
        }

        /**
         * 
         * @param {boolean} prepareTool
         * @return {string}
         */
        checkSelection(prepareTool: boolean): string {
            let center: com.vzome.core.construction.Point = null;
            let axis: com.vzome.core.construction.Segment = null;
            let mirrorPanel: com.vzome.core.construction.Polygon = null;
            if (this.getId() === ("mirror.builtin/reflection through XY plane")){
                center = this.originPoint;
                this.addParameter(center);
                const field: com.vzome.core.algebra.AlgebraicField = this.originPoint.getField();
                const zAxis: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z).scale(field['createPower$int'](com.vzome.core.math.symmetry.Direction.USER_SCALE));
                const p2: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(zAxis);
                axis = new com.vzome.core.construction.SegmentJoiningPoints(center, p2);
                this.addParameter(axis);
            } else if (this.getId() === ("mirror.builtin/reflection through X=Y green plane")){
                center = this.originPoint;
                this.addParameter(center);
                const field: com.vzome.core.algebra.AlgebraicField = this.originPoint.getField();
                const greenAxis: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X).plus(field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y)).scale(field['createPower$int'](com.vzome.core.math.symmetry.Direction.USER_SCALE));
                const p2: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(greenAxis);
                axis = new com.vzome.core.construction.SegmentJoiningPoints(center, p2);
                this.addParameter(axis);
            } else if (this.getId() === ("mirror.builtin/reflection through red plane")){
                center = this.originPoint;
                this.addParameter(center);
                const redAxis: com.vzome.core.algebra.AlgebraicVector = this.symmSys.getSymmetry().getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.RED).getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 0).normal();
                const p2: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(redAxis);
                axis = new com.vzome.core.construction.SegmentJoiningPoints(center, p2);
                this.addParameter(axis);
            } else if (this.isAutomatic()){
                center = this.originPoint;
                const field: com.vzome.core.algebra.AlgebraicField = this.originPoint.getField();
                const xAxis: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                const p2: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(xAxis);
                axis = new com.vzome.core.construction.SegmentJoiningPoints(center, p2);
            } else for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (prepareTool)this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        if (center != null){
                            if (prepareTool)break; else return "Only one center ball may be selected";
                        }
                        center = <com.vzome.core.construction.Point>(<com.vzome.core.model.Connector><any>man).getFirstConstruction();
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        if (axis != null){
                            if (prepareTool)break; else return "Only one mirror axis strut may be selected";
                        }
                        axis = <com.vzome.core.construction.Segment>(<com.vzome.core.model.Strut><any>man).getFirstConstruction();
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                        if (mirrorPanel != null){
                            if (prepareTool)break; else return "Only one mirror panel may be selected";
                        }
                        mirrorPanel = <com.vzome.core.construction.Polygon>(<com.vzome.core.model.Panel><any>man).getFirstConstruction();
                    }
                }
            }
            if (center == null){
                if (prepareTool)center = this.originPoint; else if (mirrorPanel == null)return "No symmetry center selected";
            }
            let mirrorPlane: com.vzome.core.construction.Plane = null;
            if (axis != null && center != null && mirrorPanel == null){
                if (prepareTool)mirrorPlane = new com.vzome.core.construction.PlaneFromNormalSegment(center, axis);
            } else if (axis == null && mirrorPanel != null){
                if (prepareTool)mirrorPlane = new com.vzome.core.construction.PlaneExtensionOfPolygon(mirrorPanel); else if (center != null)return "mirror tool requires a single panel,\nor a single strut and a single center ball";
            } else {
                const msg: string = "mirror tool requires a single panel,\nor a single strut and a single center ball";
                if (prepareTool){
                    throw new java.lang.IllegalStateException("Failed to prepare tool: " + msg);
                } else {
                    return msg;
                }
            }
            if (prepareTool){
                this.transforms = [null];
                this.transforms[0] = new com.vzome.core.construction.PlaneReflection(mirrorPlane);
            }
            return null;
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "MirrorTool";
        }

        /**
         * 
         * @return {string}
         */
        public getCategory(): string {
            return MirrorTool.ID;
        }
    }
    MirrorTool["__class"] = "com.vzome.core.tools.MirrorTool";
    MirrorTool["__interfaces"] = ["com.vzome.api.Tool"];


}
namespace com.vzome.core.tools {
    export class TranslationTool extends com.vzome.core.tools.TransformationTool {
        public constructor(id: string, tools: com.vzome.core.editor.ToolsModel) {
            super(id, tools);
            this.setInputBehaviors(false, true);
        }

        static ID: string = "translation";

        static LABEL: string = "Create a translation tool";

        static TOOLTIP: string = "<p>Each tool moves the selected objects to a new location.<br>To create a tool, select two balls that are separated by<br>your desired translation offset.  Order of selection<br>matters: the first ball selected is the \"from\" location,<br>and the second is the \"to\" location.<br><br>By default, the input selection will be moved to the new<br>location.  If you want to copy rather than move, you can<br>right-click after creating the tool, to configure it.<br></p>";

        /**
         * 
         * @param {boolean} prepareTool
         * @return {string}
         */
        checkSelection(prepareTool: boolean): string {
            let p1: com.vzome.core.construction.Point = null;
            let p2: com.vzome.core.construction.Point = null;
            let correct: boolean = true;
            if (!this.isAutomatic())for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (prepareTool)this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        if (p2 != null){
                            correct = false;
                            break;
                        }
                        if (p1 == null)p1 = <com.vzome.core.construction.Point>(<com.vzome.core.model.Connector><any>man).getFirstConstruction(); else p2 = <com.vzome.core.construction.Point>(<com.vzome.core.model.Connector><any>man).getFirstConstruction();
                    } else if (!prepareTool){
                        return "Only balls can be selected for this tool.";
                    }
                }
            }
            if (p1 == null){
                if (this.isAutomatic() || this.isPredefined()){
                    p1 = this.originPoint;
                    this.addParameter(p1);
                    const field: com.vzome.core.algebra.AlgebraicField = this.originPoint.getField();
                    let xAxis: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                    let scale: com.vzome.core.algebra.AlgebraicNumber = field['createPower$int'](3);
                    scale = scale['times$com_vzome_core_algebra_AlgebraicNumber'](field['createRational$long'](2));
                    xAxis = xAxis.scale(scale);
                    p2 = new com.vzome.core.construction.FreePoint(xAxis);
                    this.addParameter(p2);
                } else {
                    correct = false;
                }
            } else if (p2 == null)if (prepareTool){
                p2 = p1;
                p1 = this.originPoint;
            } else correct = false;
            if (!correct)return "translation tool requires start and end points, or just an end point";
            if (prepareTool){
                this.transforms = [null];
                this.transforms[0] = new com.vzome.core.construction.PointToPointTranslation(p1, p2);
            }
            return null;
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "TranslationTool";
        }

        /**
         * 
         * @return {string}
         */
        public getCategory(): string {
            return TranslationTool.ID;
        }
    }
    TranslationTool["__class"] = "com.vzome.core.tools.TranslationTool";
    TranslationTool["__interfaces"] = ["com.vzome.api.Tool"];


}
namespace com.vzome.core.tools {
    export class PerspectiveProjectionTool extends com.vzome.core.tools.TransformationTool {
        static ID: string = "perspective";

        static LABEL: string = "Create a perspective projection tool";

        static TOOLTIP: string = "<p>Created tools project selected objects to a 2D plane.<br><br>To create a tool, define the projection<br> by selecting a single panel<br> and a ball not in the plane of the panel.</p>";

        public constructor(id: string, tools: com.vzome.core.editor.ToolsModel) {
            super(id, tools);
            this.setInputBehaviors(false, true);
        }

        /**
         * 
         */
        public perform() {
            let plane: com.vzome.core.construction.Plane = null;
            let point: com.vzome.core.construction.Point = null;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)){
                        if (plane == null){
                            const panel: com.vzome.core.model.Panel = <com.vzome.core.model.Panel><any>man;
                            const polygon: com.vzome.core.construction.Polygon = <com.vzome.core.construction.Polygon>panel.toConstruction();
                            plane = new com.vzome.core.construction.PlaneExtensionOfPolygon(polygon);
                        } else {
                            throw new com.vzome.core.commands.Command.Failure("Projection tool allows only a single selected panel");
                        }
                    }
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        if (point == null){
                            const ball: com.vzome.core.model.Connector = <com.vzome.core.model.Connector><any>man;
                            point = <com.vzome.core.construction.Point>ball.toConstruction();
                            continue;
                        } else {
                            throw new com.vzome.core.commands.Command.Failure("Projection tool allows only a single selected ball");
                        }
                    }
                }
            }
            if (plane == null || point == null){
                throw new com.vzome.core.commands.Command.Failure("Projection tool requires a selected panel and a selected ball.");
            }
            this.transforms = [null];
            this.transforms[0] = new com.vzome.core.construction.PerspectiveProjection(plane, point);
            super.perform();
        }

        /**
         * 
         * @param {boolean} prepareTool
         * @return {string}
         */
        checkSelection(prepareTool: boolean): string {
            return null;
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "PerspectiveProjectionTool";
        }

        /**
         * 
         * @return {string}
         */
        public getCategory(): string {
            return PerspectiveProjectionTool.ID;
        }
    }
    PerspectiveProjectionTool["__class"] = "com.vzome.core.tools.PerspectiveProjectionTool";
    PerspectiveProjectionTool["__interfaces"] = ["com.vzome.api.Tool"];


}
namespace com.vzome.core.tools {
    export class RotationTool extends com.vzome.core.tools.SymmetryTool {
        /*private*/ fullRotation: boolean;

        /*private*/ corrected: boolean;

        /**
         * 
         * @return {string}
         */
        public getCategory(): string {
            if (this.fullRotation)return "axial symmetry"; else return com.vzome.core.tools.RotationToolFactory.ID;
        }

        public constructor(id?: any, symmetry?: any, tools?: any, full?: any) {
            if (((typeof id === 'string') || id === null) && ((symmetry != null && (symmetry.constructor != null && symmetry.constructor["__interfaces"] != null && symmetry.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symmetry === null) && ((tools != null && tools instanceof <any>com.vzome.core.editor.ToolsModel) || tools === null) && ((typeof full === 'boolean') || full === null)) {
                let __args = arguments;
                super(id, symmetry, tools);
                if (this.fullRotation === undefined) { this.fullRotation = false; } 
                if (this.corrected === undefined) { this.corrected = false; } 
                this.fullRotation = full;
                this.corrected = true;
                if (full)this.setInputBehaviors(true, false); else this.setInputBehaviors(false, true);
            } else if (((typeof id === 'string') || id === null) && ((symmetry != null && (symmetry.constructor != null && symmetry.constructor["__interfaces"] != null && symmetry.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symmetry === null) && ((tools != null && tools instanceof <any>com.vzome.core.editor.ToolsModel) || tools === null) && full === undefined) {
                let __args = arguments;
                let editor: any = __args[2];
                {
                    let __args = arguments;
                    let tools: any = editor;
                    let full: any = false;
                    super(id, symmetry, tools);
                    if (this.fullRotation === undefined) { this.fullRotation = false; } 
                    if (this.corrected === undefined) { this.corrected = false; } 
                    this.fullRotation = full;
                    this.corrected = true;
                    if (full)this.setInputBehaviors(true, false); else this.setInputBehaviors(false, true);
                }
                (() => {
                    this.corrected = false;
                })();
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {boolean} prepareTool
         * @return {string}
         */
        checkSelection(prepareTool: boolean): string {
            let center: com.vzome.core.construction.Point = null;
            let axisStrut: com.vzome.core.construction.Segment = null;
            let correct: boolean = true;
            let rotationZone: com.vzome.core.math.symmetry.Axis = null;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (prepareTool)this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        if (center != null){
                            correct = false;
                            break;
                        }
                        center = <com.vzome.core.construction.Point>(<com.vzome.core.model.Connector><any>man).getFirstConstruction();
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        if (axisStrut != null){
                            correct = false;
                            break;
                        }
                        axisStrut = <com.vzome.core.construction.Segment>(<com.vzome.core.model.Strut><any>man).getFirstConstruction();
                        let vector: com.vzome.core.algebra.AlgebraicVector = axisStrut.getOffset();
                        vector = axisStrut.getField().projectTo3d(vector, true);
                        rotationZone = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](vector);
                    }
                }
            }
            if (axisStrut == null){
                rotationZone = this.symmetry.getPreferredAxis();
                if (rotationZone != null){
                    const field: com.vzome.core.algebra.AlgebraicField = this.symmetry.getField();
                    center = this.originPoint;
                    this.addParameter(center);
                    axisStrut = new com.vzome.core.construction.AnchoredSegment(rotationZone, field.one(), center);
                    this.addParameter(axisStrut);
                } else if (this.isPredefined()){
                    center = this.originPoint;
                    this.addParameter(center);
                    const redOrbit: com.vzome.core.math.symmetry.Direction = this.symmetry.getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.RED);
                    rotationZone = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 1);
                    const field: com.vzome.core.algebra.AlgebraicField = this.symmetry.getField();
                    const redScale: com.vzome.core.algebra.AlgebraicNumber = redOrbit.getUnitLength()['times$com_vzome_core_algebra_AlgebraicNumber'](field['createPower$int'](com.vzome.core.math.symmetry.Direction.USER_SCALE));
                    axisStrut = new com.vzome.core.construction.AnchoredSegment(rotationZone, redScale, center);
                    this.addParameter(axisStrut);
                } else if (this.isAutomatic()){
                    center = this.originPoint;
                    this.addParameter(center);
                    const field: com.vzome.core.algebra.AlgebraicField = this.symmetry.getField();
                    const zAxis: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
                    const len: com.vzome.core.algebra.AlgebraicNumber = field['createPower$int'](2);
                    rotationZone = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](zAxis);
                    axisStrut = new com.vzome.core.construction.AnchoredSegment(rotationZone, len, center);
                    this.addParameter(axisStrut);
                } else correct = false;
            } else if (center == null)center = new com.vzome.core.construction.SegmentEndPoint(axisStrut);
            if (!correct)return "rotation tool requires a single axis strut,\nand optionally a separate center point";
            if (rotationZone == null)return "selected strut is not an axis of rotation";
            const perm: com.vzome.core.math.symmetry.Permutation = rotationZone.getRotationPermutation();
            if (perm == null)return "selected strut is not an axis of rotation";
            let rotation: number = this.corrected ? perm.mapIndex(0) : rotationZone.getRotation();
            if (prepareTool){
                if (this.fullRotation){
                    const order: number = perm.getOrder();
                    this.transforms = (s => { let a=[]; while(s-->0) a.push(null); return a; })(order - 1);
                    for(let i: number = 0; i < this.transforms.length; i++) {{
                        this.transforms[i] = new com.vzome.core.construction.SymmetryTransformation(this.symmetry, rotation, center);
                        rotation = perm.mapIndex(rotation);
                    };}
                } else {
                    this.transforms = [null];
                    this.transforms[0] = new com.vzome.core.construction.SymmetryTransformation(this.symmetry, rotation, center);
                }
            }
            return null;
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "RotationTool";
        }

        /**
         * 
         * @param {*} element
         */
        getXmlAttributes(element: org.w3c.dom.Element) {
            if (this.fullRotation)element.setAttribute("full", "true");
            if (this.corrected)element.setAttribute("corrected", "true");
            super.getXmlAttributes(element);
        }

        /**
         * 
         * @param {*} element
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(element: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            let value: string = element.getAttribute("full");
            this.fullRotation = (value != null) && ("true" === value);
            value = element.getAttribute("corrected");
            this.corrected = (value != null) && ("true" === value);
            super.setXmlAttributes(element, format);
        }
    }
    RotationTool["__class"] = "com.vzome.core.tools.RotationTool";
    RotationTool["__interfaces"] = ["com.vzome.api.Tool"];


}
namespace com.vzome.core.tools {
    export class ScalingTool extends com.vzome.core.tools.SymmetryTool {
        static ID: string = "scaling";

        static LABEL: string = "Create a scaling tool";

        static TOOLTIP: string = "<p>Each tool enlarges or shrinks the selected objects,<br>relative to a central point.  To create a tool,<br>select a ball representing the central point, and<br>two struts from the same orbit (color) with different<br>sizes.<br><br>The selection order matters.  First select a strut<br>that you want to enlarge or shrink, then select a<br>strut that has the desired target size.<br></p>";

        /*private*/ scaleFactor: com.vzome.core.algebra.AlgebraicNumber;

        /**
         * 
         * @return {string}
         */
        public getCategory(): string {
            return ScalingTool.ID;
        }

        public constructor(id: string, symmetry: com.vzome.core.math.symmetry.Symmetry, tools: com.vzome.core.editor.ToolsModel) {
            super(id, symmetry, tools);
            if (this.scaleFactor === undefined) { this.scaleFactor = null; }
            this.scaleFactor = null;
            this.setInputBehaviors(false, true);
        }

        setScaleFactor(scaleFactor: com.vzome.core.algebra.AlgebraicNumber) {
            this.scaleFactor = scaleFactor;
        }

        /**
         * 
         * @param {boolean} prepareTool
         * @return {string}
         */
        checkSelection(prepareTool: boolean): string {
            if (this.scaleFactor != null){
                const field: com.vzome.core.algebra.AlgebraicField = this.scaleFactor.getField();
                this.transforms = [null];
                const column1: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X).scale(this.scaleFactor);
                const column2: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y).scale(this.scaleFactor);
                const column3: com.vzome.core.algebra.AlgebraicVector = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z).scale(this.scaleFactor);
                const p1: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X).scale(field['createPower$int'](4)));
                const p2: com.vzome.core.construction.Point = new com.vzome.core.construction.FreePoint(column2.scale(field['createPower$int'](4)));
                this.addParameter(this.originPoint);
                this.addParameter(new com.vzome.core.construction.SegmentJoiningPoints(this.originPoint, p1));
                this.addParameter(new com.vzome.core.construction.SegmentJoiningPoints(this.originPoint, p2));
                const transform: com.vzome.core.algebra.AlgebraicMatrix = new com.vzome.core.algebra.AlgebraicMatrix(column1, column2, column3);
                this.transforms[0] = new com.vzome.core.construction.MatrixTransformation(transform, this.originPoint.getLocation());
                return null;
            }
            let s1: com.vzome.core.construction.Segment = null;
            let s2: com.vzome.core.construction.Segment = null;
            let center: com.vzome.core.construction.Point = null;
            let correct: boolean = true;
            let hasPanels: boolean = false;
            for(let index=this.mSelection.iterator();index.hasNext();) {
                let man = index.next();
                {
                    if (prepareTool)this.unselect$com_vzome_core_model_Manifestation(man);
                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)){
                        if (center != null){
                            correct = false;
                            break;
                        }
                        center = <com.vzome.core.construction.Point>(<com.vzome.core.model.Connector><any>man).getFirstConstruction();
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)){
                        if (s2 != null){
                            correct = false;
                            break;
                        }
                        if (s1 == null)s1 = <com.vzome.core.construction.Segment>(<com.vzome.core.model.Strut><any>man).getFirstConstruction(); else s2 = <com.vzome.core.construction.Segment>(<com.vzome.core.model.Strut><any>man).getFirstConstruction();
                    } else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0))hasPanels = true;
                }
            }
            if (center == null){
                if (prepareTool)center = this.originPoint; else return "No symmetry center selected";
            }
            correct = correct && s2 != null;
            if (!prepareTool && hasPanels)correct = false;
            if (!correct)return "scaling tool requires before and after struts, and a single center";
            const zone1: com.vzome.core.math.symmetry.Axis = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](s1.getOffset());
            const zone2: com.vzome.core.math.symmetry.Axis = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](s2.getOffset());
            if (zone1 == null || zone2 == null)return "struts cannot be automatic";
            const orbit: com.vzome.core.math.symmetry.Direction = zone1.getDirection();
            if (orbit !== zone2.getDirection())return "before and after struts must be from the same orbit";
            if (prepareTool){
                this.transforms = [null];
                this.transforms[0] = new com.vzome.core.construction.Scaling(s1, s2, center, this.symmetry);
            }
            return null;
        }

        /**
         * 
         * @return {string}
         */
        getXmlElementName(): string {
            return "ScalingTool";
        }

        /**
         * 
         * @param {*} element
         * @param {com.vzome.core.commands.XmlSaveFormat} format
         */
        setXmlAttributes(element: org.w3c.dom.Element, format: com.vzome.core.commands.XmlSaveFormat) {
            const symmName: string = element.getAttribute("symmetry");
            if (symmName == null || /* isEmpty */(symmName.length === 0)){
                element.setAttribute("symmetry", "icosahedral");
                com.vzome.core.editor.api.SideEffects.logBugAccommodation("scaling tool serialized with no symmetry; assuming icosahedral");
            }
            super.setXmlAttributes(element, format);
        }
    }
    ScalingTool["__class"] = "com.vzome.core.tools.ScalingTool";
    ScalingTool["__interfaces"] = ["com.vzome.api.Tool"];


}


com.vzome.core.editor.ApplyTool.logger_$LI$();

com.vzome.core.editor.CommandEdit.loadAndPerformLgger_$LI$();

com.vzome.core.editor.CommandEdit.logger_$LI$();

com.vzome.core.commands.CommandTetrahedralSymmetry.ATTR_SIGNATURE_$LI$();

com.vzome.core.commands.CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$();

com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$();

com.vzome.fields.sqrtphi.SqrtPhiField.SQRT_PHI_VALUE_$LI$();

com.vzome.fields.sqrtphi.SqrtPhiField.PHI_VALUE_$LI$();

com.vzome.core.editor.api.ChangeSelection.logger_$LI$();

com.vzome.core.commands.CommandCentroid.ATTR_SIGNATURE_$LI$();

com.vzome.core.commands.CommandCentroid.PARAM_SIGNATURE_$LI$();

com.vzome.core.commands.CommandPolygon.ATTR_SIGNATURE_$LI$();

com.vzome.core.commands.CommandPolygon.PARAM_SIGNATURE_$LI$();

com.vzome.core.commands.CommandTauDivision.ATTR_SIGNATURE_$LI$();

com.vzome.core.commands.CommandTauDivision.PARAM_SIGNATURE_$LI$();

com.vzome.core.commands.CommandExecuteZomicScript.ATTR_SIGNATURE_$LI$();

com.vzome.core.commands.CommandExecuteZomicScript.PARAM_SIGNATURE_$LI$();

com.vzome.core.commands.CommandBuildAnchoredSegment.PARAM_SIGNATURE_$LI$();

com.vzome.core.commands.CommandTransform.GROUP_ATTR_SIGNATURE_$LI$();

com.vzome.core.commands.CommandTransform.AXIS_ATTR_SIGNATURE_$LI$();

com.vzome.core.commands.CommandTransform.ATTR_SIGNATURE_$LI$();

com.vzome.core.commands.CommandTransform.PARAM_SIGNATURE_$LI$();

com.vzome.core.commands.CommandJoinPoints.ATTR_SIGNATURE_$LI$();

com.vzome.core.commands.CommandJoinPoints.PARAM_SIGNATURE_$LI$();

com.vzome.core.commands.CommandMidpoint.ATTR_SIGNATURE_$LI$();

com.vzome.core.commands.CommandMidpoint.PARAM_SIGNATURE_$LI$();

com.vzome.core.commands.CommandObliquePentagon.ATTR_SIGNATURE_$LI$();

com.vzome.core.commands.CommandObliquePentagon.PARAM_SIGNATURE_$LI$();

com.vzome.core.commands.CommandLinePlaneIntersect.ATTR_SIGNATURE_$LI$();

com.vzome.core.commands.CommandLinePlaneIntersect.PARAM_SIGNATURE_$LI$();

com.vzome.core.construction.SegmentRotated4D.logger_$LI$();

com.vzome.core.commands.CommandImportVEFData.ATTR_SIGNATURE_$LI$();

com.vzome.core.commands.CommandImportVEFData.PARAM_SIGNATURE_$LI$();

com.vzome.core.exporters.POVRayExporter.FORMAT_$LI$();

com.vzome.core.exporters.PlyExporter.FORMAT_$LI$();

com.vzome.core.exporters.PlyExporter.__static_initialize();

com.vzome.desktop.controller.PreviewStrut.logger_$LI$();

com.vzome.desktop.controller.LengthController.SCALE_OFFSET_$LI$();

com.vzome.desktop.controller.NumberController.MATH_OPS_$LI$();

com.vzome.desktop.controller.NumberController.OPTIONAL_NAMED_VALUES_$LI$();

com.vzome.core.algebra.SnubDodecField.IRRATIONAL_LABELS_$LI$();

com.vzome.core.algebra.SnubDodecField.PHI_VALUE_$LI$();

com.vzome.core.exporters.MathTableExporter.OPTIONAL_NAMED_VALUES_$LI$();

com.vzome.core.exporters.MathTableExporter.Y_$LI$();

com.vzome.core.exporters.MathTableExporter.X_$LI$();

com.vzome.core.editor.api.SideEffects.BUG_ACCOMMODATION_LOGGER_$LI$();

com.vzome.core.editor.EditHistory.breakpointLogger_$LI$();

com.vzome.core.editor.EditHistory.logger_$LI$();

com.vzome.core.commands.CommandLoad.ATTR_SIGNATURE_$LI$();

com.vzome.core.commands.CommandLoad.PARAM_SIGNATURE_$LI$();

com.vzome.core.commands.CommandSetColor.PARAM_SIGNATURE_$LI$();

com.vzome.core.commands.CommandHide.ATTR_SIGNATURE_$LI$();

com.vzome.core.commands.CommandHide.PARAM_SIGNATURE_$LI$();

com.vzome.core.commands.CommandFreePoint.PARAMS_$LI$();

com.vzome.core.commands.XmlSymmetryFormat.__com_vzome_core_commands_XmlSymmetryFormat_logger_$LI$();

com.vzome.core.commands.XmlSymmetryFormat.__static_initialize();

com.vzome.core.construction.VefToModel.logger_$LI$();

com.vzome.core.viewing.ExportedVEFShapes.LOGGER_$LI$();

com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry.PRINCIPAL_REFLECTION_$LI$();

com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry.TWOFOLD_ROTATION_$LI$();

com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry.FIVEFOLD_ROTATION_$LI$();

com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry.NEXT_TWOFOLD_AXIS_$LI$();

com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry.TWOFOLD_AXIS_$LI$();

com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry.FIVEFOLD_AXIS_$LI$();

com.vzome.core.exporters.StlExporter.FORMAT_$LI$();

com.vzome.core.exporters.PythonBuild123dExporter.FORMAT_$LI$();

com.vzome.core.exporters.PythonBuild123dExporter.__static_initialize();

com.vzome.core.exporters.OpenScadMeshExporter.FORMAT_$LI$();

com.vzome.core.exporters.OpenScadMeshExporter.__static_initialize();

com.vzome.core.exporters.OffExporter.FORMAT_$LI$();

com.vzome.core.exporters.OffExporter.__static_initialize();

com.vzome.core.math.RealVector.DIRECTION_0_$LI$();

com.vzome.core.math.RealVector.FORMAT_$LI$();

com.vzome.core.math.RealVector.ORIGIN_$LI$();

com.vzome.core.math.RealVector.__static_initialize();

java.beans.PropertyChangeSupport.PropertyChangeListenerMap.EMPTY_$LI$();

com.vzome.desktop.controller.ZoneVectorBall.logger_$LI$();

com.vzome.desktop.controller.DefaultController.logger_$LI$();

com.vzome.xml.ResourceLoader.logger_$LI$();

com.vzome.xml.ResourceLoader.RESOURCE_LOADER_$LI$();

com.vzome.core.editor.SymmetrySystem.logger_$LI$();

com.vzome.core.editor.SelectionSummary.LOGGER_$LI$();

com.vzome.core.editor.SelectionImpl.logger_$LI$();

com.vzome.core.edits.ManifestationColorMappers.colorMappers_$LI$();

com.vzome.core.edits.ManifestationColorMappers.__static_initialize();

com.vzome.core.commands.Command.Failure.logger_$LI$();

com.vzome.core.commands.XmlSaveFormat.NOT_AN_ATTRIBUTE_$LI$();

com.vzome.core.commands.XmlSaveFormat.logger_$LI$();

com.vzome.core.commands.XmlSaveFormat.FORMATS_$LI$();

com.vzome.core.construction.Color.GREY_TRANSPARENT_$LI$();

com.vzome.core.construction.Color.WHITE_$LI$();

com.vzome.core.construction.Color.BLACK_$LI$();

com.vzome.core.model.RealizedModelImpl.logger_$LI$();

com.vzome.core.math.symmetry.B4Group.B4_PERMS_$LI$();

com.vzome.core.math.symmetry.Direction.logger_$LI$();

com.vzome.core.math.symmetry.DirectionNaming.SIGN_$LI$();

com.vzome.core.math.symmetry.D4Group.D4_PERMS_$LI$();

com.vzome.core.math.symmetry.A4Group.S5_PERMS_$LI$();

com.vzome.core.math.Polyhedron.logger_$LI$();

com.vzome.core.viewing.ExportedVEFStrutGeometry.LOGGER_$LI$();

com.vzome.core.render.RenderedManifestation.logger_$LI$();

com.vzome.core.render.Colors.NO_VECTOR_$LI$();

com.vzome.core.render.Colors.PLANE_$LI$();

com.vzome.core.render.Colors.DIRECTION_$LI$();

com.vzome.core.render.Colors.CONNECTOR_$LI$();

com.vzome.core.render.Colors.HIGHLIGHT_MAC_$LI$();

com.vzome.core.render.Colors.HIGHLIGHT_$LI$();

com.vzome.core.render.Colors.PANEL_$LI$();

com.vzome.core.render.Colors.BACKGROUND_$LI$();

java.awt.Color.BLACK_$LI$();

java.awt.Color.WHITE_$LI$();
