/* Generated from Java with JSweet 3.2.0-SNAPSHOT - http://www.jsweet.org */
namespace com.vzome.core.algebra {
    export interface AlgebraicField {
        getOrder(): number;

        getNumIrrationals(): number;

        /**
         * Returns the label using the specified format for the irrational term with ordinal i. <br>
         * i=0 refers to the rational term.
         * @param {number} i
         * @param {number} format must be either {@code DEFAULT_FORMAT = 0} or
         * {@code EXPRESSION_FORMAT = 1}
         * @return
         * @return {string}
         */
        getIrrational(i?: any, format?: any): string;

        nearestAlgebraicVector(target: com.vzome.core.math.RealVector): com.vzome.core.algebra.AlgebraicVector;

        getName(): string;

        /**
         * Generates an AlgebraicNumber from a "trailing divisor" int array representation.
         * @param {int[]} trailingDivisorForm numerators trailed by a common denominator for all numerators
         * @return
         * @return {*}
         */
        createAlgebraicNumberFromTD(trailingDivisorForm: number[]): com.vzome.core.algebra.AlgebraicNumber;

        createAlgebraicNumber(ones?: any, irrat?: any, denominator?: any, scalePower?: any): com.vzome.core.algebra.AlgebraicNumber;

        /**
         * The golden ratio (and thus icosahedral symmetry and related tools)
         * can be generated by some fields even though it's not one of their irrational coefficients.
         * For example, SqrtField(5) and PolygonField(10) can both generate the golden ratio
         * so they can support icosa symmetry and related tools.
         * In some such cases, the resulting AlgebraicNumber
         * may have multiple terms and/or factors other than one.
         * 
         * @return {*} An AlgebraicNumber which evaluates to the golden ratio, or null if not possible in this field.
         */
        getGoldenRatio(): com.vzome.core.algebra.AlgebraicNumber;

        createPower(power?: any, irr?: any): com.vzome.core.algebra.AlgebraicNumber;

        /**
         * @param {number} numerator
         * @param {number} denominator
         * @return {*} AlgebraicNumber
         */
        createRational(numerator?: any, denominator?: any): com.vzome.core.algebra.AlgebraicNumber;

        /**
         * @param {number} n specifies the ordinal of the term in the AlgebraicNumber which will be set to one.
         * When {@code n == 0}, the result is the same as {@code createRational(1)}.
         * When {@code n == 1}, the result is the same as {@code createPower(1)}.
         * When {@code n < 0}, the result will be {@code zero()}.
         * When {@code n >= getOrder()}, an IndexOutOfBoundsException will be thrown.
         * @return {*} an AlgebraicNumber with the factor specified by {@code n} set to one.
         */
        getUnitTerm(n: number): com.vzome.core.algebra.AlgebraicNumber;

        /**
         * Drop one coordinate from the 4D vector. If wFirst (the usual), then drop
         * the first coordinate, taking the "imaginary part" of the vector. If
         * !wFirst (for old VEF import, etc.), drop the last coordinate.
         * 
         * @param {com.vzome.core.algebra.AlgebraicVector} source
         * @param {boolean} wFirst
         * @return
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        projectTo3d(source: com.vzome.core.algebra.AlgebraicVector, wFirst: boolean): com.vzome.core.algebra.AlgebraicVector;

        origin(dims: number): com.vzome.core.algebra.AlgebraicVector;

        basisVector(dims: number, axis: number): com.vzome.core.algebra.AlgebraicVector;

        zero(): com.vzome.core.algebra.AlgebraicNumber;

        one(): com.vzome.core.algebra.AlgebraicNumber;

        /**
         * 
         * @param {int[][]} nums is an array of integer arrays: One array of coordinate terms per dimension.
         * Initially, this is designed to simplify migration of order 2 golden directions
         * to new fields of higher order having golden subfields as their first two factors.
         * {@code
         * field.createVector( new int[]  {  0,1,2,3,   4,5,6,7,   8,9,0,1  } );   // older code like this...
         * field.createVector( new int[][]{ {0,1,2,3}, {4,5,6,7}, {8,9,0,1} } );   // should be replaced by this...
         * field.createVector( new int[][]{ {0,1,2,3}, {4,5,6,7}, {8,9    } } );   // ... or even this.
         * }
         * The older code shown in the first example requires an order 2 field.
         * The second example will work with any field of order 2 or greater.
         * This new overload has the advantage that the internal arrays representing the individual dimensions are more clearly delineated and controlled.
         * As shown in the third example, the internal arrays need not be all the same length. Trailing zero terms can be omitted as shown.
         * Inner arrays require an even number of elements since they represent a sequence of numerator/denominator pairs.
         * 
         * createVector is currently limited to int valued vectors, not long, and definitely not BigInteger
         * In most cases, this is adequate, but in the case where it's called by XmlSaveFormat.parseAlgebraicObject(),
         * it seems possible that a value larger than Integer.MAX_VALUE could be saved to the XML which could not subsequently be parsed.
         * TODO: Consider refactoring createVector to use long[][] instead of int[][] if this becomes an issue.
         * 
         * @return {com.vzome.core.algebra.AlgebraicVector} an AlgebraicVector
         */
        createVector(nums: number[][]): com.vzome.core.algebra.AlgebraicVector;

        /**
         * 
         * @param {int[][]} nums nums is an array of integer arrays: One array of coordinate terms per dimension.
         * Each inner array is in "trailing divisor" form, to represent a rational AlgebraicNumber.
         * If the order of the field is N, each inner array will be of length N+1, with the last
         * element being the divisor.
         * @return
         * @return {com.vzome.core.algebra.AlgebraicVector}
         */
        createVectorFromTDs(nums: number[][]): com.vzome.core.algebra.AlgebraicVector;

        /**
         * Generates an AlgebraicVector with all AlgebraicNumber terms being integers (having unit denominators).
         * Contrast this with {@code createVector(int[][] nums)} which requires all denominators to be specified.
         * @param {int[][]} nums is a 2 dimensional integer array. The length of nums becomes the number of dimensions in the resulting AlgebraicVector.
         * For example, {@code (new PentagonField()).createIntegerVector( new int[][]{ {0,-1}, {2,3}, {4,5} } ); }
         * generates the 3 dimensional vector (-φ, 2 +3φ, 4 +5φ) having all integer terms.
         * @return {com.vzome.core.algebra.AlgebraicVector} an AlgebraicVector
         */
        createIntegerVector(nums: number[][]): com.vzome.core.algebra.AlgebraicVector;

        /**
         * Create a 3x3 square matrix from integer data.
         * TODO: Generalize this method to create a matrix with dimensions matching the dimensions of the data array
         * Sample input data for an order-4 field:
         * {{{7,5,0,1,-4,5,0,1},{-2,5,0,1,4,5,0,1},{0,1,-8,5,0,1,6,5}},
         * {{-2,5,0,1,4,5,0,1},{7,5,0,1,-4,5,0,1},{0,1,8,5,0,1,-6,5}},
         * {{0,1,-8,5,0,1,6,5},{0,1,8,5,0,1,-6,5},{-9,5,0,1,8,5,0,1}}}
         * @param field
         * @param {int[][][]} data integer coordinates, in row-major order, complete with denominators.
         * @return
         * @return {com.vzome.core.algebra.AlgebraicMatrix}
         */
        createMatrix(data: number[][][]): com.vzome.core.algebra.AlgebraicMatrix;

        parseLegacyNumber(val: string): com.vzome.core.algebra.AlgebraicNumber;

        parseNumber(nums: string): com.vzome.core.algebra.AlgebraicNumber;

        parseVector(nums: string): com.vzome.core.algebra.AlgebraicVector;

        identityMatrix(dims: number): com.vzome.core.algebra.AlgebraicMatrix;

        /**
         * @return {number} the number of independent multipliers in this field.
         * These are the primitive elements of the field.
         * The value should be less than or equal to getNumIrrationals.
         * It will be less whenever the irrationals are dependent.
         * For example, in the field for sqrt(phi), there is only one
         * multiplier, since the other irrational is just the square of that one.
         */
        getNumMultipliers(): number;

        parseVefNumber(string: string, isRational: boolean): com.vzome.core.algebra.AlgebraicNumber;

        scale4dRoots(): boolean;

        doubleFrameVectors(): boolean;

        /**
         * If the field supports the value having the common name specified,
         * this method returns an AlgebraicNumber having that value.
         * Note that the value may not correspond to a unique term in the AlgebraicField (e.g. {"phi" for @code PolygonField(10)}). <br>
         * For example, {@code getNumberByName("phi")}
         * should return the same value as {@code getGoldenRatio()}
         * @param {string} name
         * @return {*} An AlgebraicNumber which evaluates to the specified name, or null if not possible in this field.
         */
        getNumberByName(name: string): com.vzome.core.algebra.AlgebraicNumber;

        supportsSubfield(fieldName: string): boolean;

        interpretScript(script: string, language: string, offset: com.vzome.core.construction.Point, symmetry: com.vzome.core.math.symmetry.Symmetry, effects: com.vzome.core.construction.ConstructionChanges);
    }

    export namespace AlgebraicField {

        export const DEFAULT_FORMAT: number = 0;

        export const EXPRESSION_FORMAT: number = 1;

        export const ZOMIC_FORMAT: number = 2;

        export const VEF_FORMAT: number = 3;

        export function getIrrationals(field: AlgebraicField): string[] {
            const len: number = field.getNumIrrationals();
            const result: string[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(len);
            for(let i: number = 0; i < result.length; i++) {{
                result[i] = field['getIrrational$int'](i + 1);
            };}
            return result;
        }

        export function getMultipliers(field: AlgebraicField): string[] {
            const len: number = field.getNumMultipliers();
            const result: string[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(len);
            for(let i: number = 0; i < result.length; i++) {{
                result[i] = field['getIrrational$int'](i + 1);
            };}
            return result;
        }
    }


    export namespace AlgebraicField {

        export interface Registry {
            getField(name: string): com.vzome.core.algebra.AlgebraicField;
        }
    }

}

