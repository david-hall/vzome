import { a as ce, c as zw } from "./chunk-QXUNN3TL.js";
import { a as cr, b as oP, c as rn } from "./chunk-5JBAU6D4.js";
var Zw = cr((ht) => {
  "use strict";
  var jc = Symbol.for("react.element"),
    aP = Symbol.for("react.portal"),
    lP = Symbol.for("react.fragment"),
    uP = Symbol.for("react.strict_mode"),
    cP = Symbol.for("react.profiler"),
    fP = Symbol.for("react.provider"),
    dP = Symbol.for("react.context"),
    hP = Symbol.for("react.forward_ref"),
    pP = Symbol.for("react.suspense"),
    mP = Symbol.for("react.memo"),
    gP = Symbol.for("react.lazy"),
    Bw = Symbol.iterator;
  function vP(n) {
    return n === null || typeof n != "object"
      ? null
      : (n = Bw && n[Bw] || n["@@iterator"], typeof n == "function" ? n : null);
  }
  var Uw = {
      isMounted: function () {
        return !1;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    Vw = Object.assign,
    Hw = {};
  function Kl(n, e, t) {
    this.props = n, this.context = e, this.refs = Hw, this.updater = t || Uw;
  }
  Kl.prototype.isReactComponent = {};
  Kl.prototype.setState = function (n, e) {
    if (typeof n != "object" && typeof n != "function" && n != null) {
      throw Error(
        "setState(...): takes an object of state variables to update or a function which returns an object of state variables.",
      );
    }
    this.updater.enqueueSetState(this, n, e, "setState");
  };
  Kl.prototype.forceUpdate = function (n) {
    this.updater.enqueueForceUpdate(this, n, "forceUpdate");
  };
  function Gw() {}
  Gw.prototype = Kl.prototype;
  function j0(n, e, t) {
    this.props = n, this.context = e, this.refs = Hw, this.updater = t || Uw;
  }
  var W0 = j0.prototype = new Gw();
  W0.constructor = j0;
  Vw(W0, Kl.prototype);
  W0.isPureReactComponent = !0;
  var jw = Array.isArray,
    Ww = Object.prototype.hasOwnProperty,
    X0 = { current: null },
    Xw = { key: !0, ref: !0, __self: !0, __source: !0 };
  function qw(n, e, t) {
    var r, i = {}, s = null, o = null;
    if (e != null) {
      for (
        r in e.ref !== void 0 && (o = e.ref),
          e.key !== void 0 && (s = "" + e.key),
          e
      ) Ww.call(e, r) && !Xw.hasOwnProperty(r) && (i[r] = e[r]);
    }
    var a = arguments.length - 2;
    if (a === 1) i.children = t;
    else if (1 < a) {
      for (var u = Array(a), f = 0; f < a; f++) u[f] = arguments[f + 2];
      i.children = u;
    }
    if (n && n.defaultProps) {
      for (r in a = n.defaultProps, a) i[r] === void 0 && (i[r] = a[r]);
    }
    return {
      $$typeof: jc,
      type: n,
      key: s,
      ref: o,
      props: i,
      _owner: X0.current,
    };
  }
  function yP(n, e) {
    return {
      $$typeof: jc,
      type: n.type,
      key: e,
      ref: n.ref,
      props: n.props,
      _owner: n._owner,
    };
  }
  function q0(n) {
    return typeof n == "object" && n !== null && n.$$typeof === jc;
  }
  function xP(n) {
    var e = { "=": "=0", ":": "=2" };
    return "$" + n.replace(/[=:]/g, function (t) {
      return e[t];
    });
  }
  var Yw = /\/+/g;
  function Y0(n, e) {
    return typeof n == "object" && n !== null && n.key != null
      ? xP("" + n.key)
      : e.toString(36);
  }
  function Th(n, e, t, r, i) {
    var s = typeof n;
    (s === "undefined" || s === "boolean") && (n = null);
    var o = !1;
    if (n === null) o = !0;
    else {switch (s) {
        case "string":
        case "number":
          o = !0;
          break;
        case "object":
          switch (n.$$typeof) {
            case jc:
            case aP:
              o = !0;
          }
      }}
    if (o) {
      return o = n,
        i = i(o),
        n = r === "" ? "." + Y0(o, 0) : r,
        jw(i)
          ? (t = "",
            n != null && (t = n.replace(Yw, "$&/") + "/"),
            Th(i, e, t, "", function (f) {
              return f;
            }))
          : i != null &&
            (q0(i) && (i = yP(
              i,
              t + (!i.key || o && o.key === i.key
                ? ""
                : ("" + i.key).replace(Yw, "$&/") + "/") + n,
            )),
              e.push(i)),
        1;
    }
    if (o = 0, r = r === "" ? "." : r + ":", jw(n)) {
      for (var a = 0; a < n.length; a++) {
        s = n[a];
        var u = r + Y0(s, a);
        o += Th(s, e, t, u, i);
      }
    } else if (u = vP(n), typeof u == "function") {
      for (n = u.call(n), a = 0; !(s = n.next()).done;) {
        s = s.value, u = r + Y0(s, a++), o += Th(s, e, t, u, i);
      }
    } else if (s === "object") {
      throw e = String(n),
        Error(
          "Objects are not valid as a React child (found: " +
            (e === "[object Object]"
              ? "object with keys {" + Object.keys(n).join(", ") + "}"
              : e) +
            "). If you meant to render a collection of children, use an array instead.",
        );
    }
    return o;
  }
  function Ah(n, e, t) {
    if (n == null) return n;
    var r = [], i = 0;
    return Th(n, r, "", "", function (s) {
      return e.call(t, s, i++);
    }),
      r;
  }
  function _P(n) {
    if (n._status === -1) {
      var e = n._result;
      e = e(),
        e.then(function (t) {
          (n._status === 0 || n._status === -1) &&
            (n._status = 1, n._result = t);
        }, function (t) {
          (n._status === 0 || n._status === -1) &&
            (n._status = 2, n._result = t);
        }),
        n._status === -1 && (n._status = 0, n._result = e);
    }
    if (n._status === 1) return n._result.default;
    throw n._result;
  }
  var fr = { current: null },
    Ch = { transition: null },
    SP = {
      ReactCurrentDispatcher: fr,
      ReactCurrentBatchConfig: Ch,
      ReactCurrentOwner: X0,
    };
  ht.Children = {
    map: Ah,
    forEach: function (n, e, t) {
      Ah(n, function () {
        e.apply(this, arguments);
      }, t);
    },
    count: function (n) {
      var e = 0;
      return Ah(n, function () {
        e++;
      }),
        e;
    },
    toArray: function (n) {
      return Ah(n, function (e) {
        return e;
      }) || [];
    },
    only: function (n) {
      if (!q0(n)) {
        throw Error(
          "React.Children.only expected to receive a single React element child.",
        );
      }
      return n;
    },
  };
  ht.Component = Kl;
  ht.Fragment = lP;
  ht.Profiler = cP;
  ht.PureComponent = j0;
  ht.StrictMode = uP;
  ht.Suspense = pP;
  ht.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = SP;
  ht.cloneElement = function (n, e, t) {
    if (n == null) {
      throw Error(
        "React.cloneElement(...): The argument must be a React element, but you passed " +
          n + ".",
      );
    }
    var r = Vw({}, n.props), i = n.key, s = n.ref, o = n._owner;
    if (e != null) {
      if (
        e.ref !== void 0 && (s = e.ref, o = X0.current),
          e.key !== void 0 && (i = "" + e.key),
          n.type && n.type.defaultProps
      ) { var a = n.type.defaultProps; }
      for (u in e) {
        Ww.call(e, u) && !Xw.hasOwnProperty(u) &&
          (r[u] = e[u] === void 0 && a !== void 0 ? a[u] : e[u]);
      }
    }
    var u = arguments.length - 2;
    if (u === 1) r.children = t;
    else if (1 < u) {
      a = Array(u);
      for (var f = 0; f < u; f++) a[f] = arguments[f + 2];
      r.children = a;
    }
    return { $$typeof: jc, type: n.type, key: i, ref: s, props: r, _owner: o };
  };
  ht.createContext = function (n) {
    return n = {
      $$typeof: dP,
      _currentValue: n,
      _currentValue2: n,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    },
      n.Provider = { $$typeof: fP, _context: n },
      n.Consumer = n;
  };
  ht.createElement = qw;
  ht.createFactory = function (n) {
    var e = qw.bind(null, n);
    return e.type = n, e;
  };
  ht.createRef = function () {
    return { current: null };
  };
  ht.forwardRef = function (n) {
    return { $$typeof: hP, render: n };
  };
  ht.isValidElement = q0;
  ht.lazy = function (n) {
    return { $$typeof: gP, _payload: { _status: -1, _result: n }, _init: _P };
  };
  ht.memo = function (n, e) {
    return { $$typeof: mP, type: n, compare: e === void 0 ? null : e };
  };
  ht.startTransition = function (n) {
    var e = Ch.transition;
    Ch.transition = {};
    try {
      n();
    } finally {
      Ch.transition = e;
    }
  };
  ht.unstable_act = function () {
    throw Error("act(...) is not supported in production builds of React.");
  };
  ht.useCallback = function (n, e) {
    return fr.current.useCallback(n, e);
  };
  ht.useContext = function (n) {
    return fr.current.useContext(n);
  };
  ht.useDebugValue = function () {};
  ht.useDeferredValue = function (n) {
    return fr.current.useDeferredValue(n);
  };
  ht.useEffect = function (n, e) {
    return fr.current.useEffect(n, e);
  };
  ht.useId = function () {
    return fr.current.useId();
  };
  ht.useImperativeHandle = function (n, e, t) {
    return fr.current.useImperativeHandle(n, e, t);
  };
  ht.useInsertionEffect = function (n, e) {
    return fr.current.useInsertionEffect(n, e);
  };
  ht.useLayoutEffect = function (n, e) {
    return fr.current.useLayoutEffect(n, e);
  };
  ht.useMemo = function (n, e) {
    return fr.current.useMemo(n, e);
  };
  ht.useReducer = function (n, e, t) {
    return fr.current.useReducer(n, e, t);
  };
  ht.useRef = function (n) {
    return fr.current.useRef(n);
  };
  ht.useState = function (n) {
    return fr.current.useState(n);
  };
  ht.useSyncExternalStore = function (n, e, t) {
    return fr.current.useSyncExternalStore(n, e, t);
  };
  ht.useTransition = function () {
    return fr.current.useTransition();
  };
  ht.version = "18.2.0";
});
var An = cr((wU, Kw) => {
  "use strict";
  Kw.exports = Zw();
});
var oM = cr((Ut) => {
  "use strict";
  function Z0(n, e) {
    var t = n.length;
    n.push(e);
    e: for (; 0 < t;) {
      var r = t - 1 >>> 1, i = n[r];
      if (0 < Rh(i, e)) n[r] = e, n[t] = i, t = r;
      else break e;
    }
  }
  function ki(n) {
    return n.length === 0 ? null : n[0];
  }
  function bh(n) {
    if (n.length === 0) return null;
    var e = n[0], t = n.pop();
    if (t !== e) {
      n[0] = t;
      e: for (var r = 0, i = n.length, s = i >>> 1; r < s;) {
        var o = 2 * (r + 1) - 1, a = n[o], u = o + 1, f = n[u];
        if (0 > Rh(a, t)) {
          u < i && 0 > Rh(f, a)
            ? (n[r] = f, n[u] = t, r = u)
            : (n[r] = a, n[o] = t, r = o);
        } else if (u < i && 0 > Rh(f, t)) n[r] = f, n[u] = t, r = u;
        else break e;
      }
    }
    return e;
  }
  function Rh(n, e) {
    var t = n.sortIndex - e.sortIndex;
    return t !== 0 ? t : n.id - e.id;
  }
  typeof performance == "object" && typeof performance.now == "function"
    ? (Jw = performance,
      Ut.unstable_now = function () {
        return Jw.now();
      })
    : (K0 = Date,
      Qw = K0.now(),
      Ut.unstable_now = function () {
        return K0.now() - Qw;
      });
  var Jw,
    K0,
    Qw,
    hs = [],
    So = [],
    wP = 1,
    gi = null,
    Qn = 3,
    Lh = !1,
    ka = !1,
    Wc = !1,
    $w = typeof setTimeout == "function" ? setTimeout : null,
    eM = typeof clearTimeout == "function" ? clearTimeout : null,
    tM = typeof setImmediate != "undefined" ? setImmediate : null;
  typeof navigator != "undefined" && navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function J0(n) {
    for (var e = ki(So); e !== null;) {
      if (e.callback === null) bh(So);
      else if (e.startTime <= n) {
        bh(So), e.sortIndex = e.expirationTime, Z0(hs, e);
      } else break;
      e = ki(So);
    }
  }
  function Q0(n) {
    if (Wc = !1, J0(n), !ka) {
      if (ki(hs) !== null) ka = !0, nv($0);
      else {
        var e = ki(So);
        e !== null && rv(Q0, e.startTime - n);
      }
    }
  }
  function $0(n, e) {
    ka = !1, Wc && (Wc = !1, eM(Xc), Xc = -1), Lh = !0;
    var t = Qn;
    try {
      for (
        J0(e), gi = ki(hs);
        gi !== null && (!(gi.expirationTime > e) || n && !iM());
      ) {
        var r = gi.callback;
        if (typeof r == "function") {
          gi.callback = null, Qn = gi.priorityLevel;
          var i = r(gi.expirationTime <= e);
          e = Ut.unstable_now(),
            typeof i == "function" ? gi.callback = i : gi === ki(hs) && bh(hs),
            J0(e);
        } else bh(hs);
        gi = ki(hs);
      }
      if (gi !== null) { var s = !0; }
      else {
        var o = ki(So);
        o !== null && rv(Q0, o.startTime - e), s = !1;
      }
      return s;
    } finally {
      gi = null, Qn = t, Lh = !1;
    }
  }
  var Ph = !1, Ih = null, Xc = -1, nM = 5, rM = -1;
  function iM() {
    return !(Ut.unstable_now() - rM < nM);
  }
  function ev() {
    if (Ih !== null) {
      var n = Ut.unstable_now();
      rM = n;
      var e = !0;
      try {
        e = Ih(!0, n);
      } finally {
        e ? qc() : (Ph = !1, Ih = null);
      }
    } else Ph = !1;
  }
  var qc;
  typeof tM == "function"
    ? qc = function () {
      tM(ev);
    }
    : typeof MessageChannel != "undefined"
    ? (tv = new MessageChannel(),
      sM = tv.port2,
      tv.port1.onmessage = ev,
      qc = function () {
        sM.postMessage(null);
      })
    : qc = function () {
      $w(ev, 0);
    };
  var tv, sM;
  function nv(n) {
    Ih = n, Ph || (Ph = !0, qc());
  }
  function rv(n, e) {
    Xc = $w(function () {
      n(Ut.unstable_now());
    }, e);
  }
  Ut.unstable_IdlePriority = 5;
  Ut.unstable_ImmediatePriority = 1;
  Ut.unstable_LowPriority = 4;
  Ut.unstable_NormalPriority = 3;
  Ut.unstable_Profiling = null;
  Ut.unstable_UserBlockingPriority = 2;
  Ut.unstable_cancelCallback = function (n) {
    n.callback = null;
  };
  Ut.unstable_continueExecution = function () {
    ka || Lh || (ka = !0, nv($0));
  };
  Ut.unstable_forceFrameRate = function (n) {
    0 > n || 125 < n
      ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported",
      )
      : nM = 0 < n ? Math.floor(1e3 / n) : 5;
  };
  Ut.unstable_getCurrentPriorityLevel = function () {
    return Qn;
  };
  Ut.unstable_getFirstCallbackNode = function () {
    return ki(hs);
  };
  Ut.unstable_next = function (n) {
    switch (Qn) {
      case 1:
      case 2:
      case 3:
        var e = 3;
        break;
      default:
        e = Qn;
    }
    var t = Qn;
    Qn = e;
    try {
      return n();
    } finally {
      Qn = t;
    }
  };
  Ut.unstable_pauseExecution = function () {};
  Ut.unstable_requestPaint = function () {};
  Ut.unstable_runWithPriority = function (n, e) {
    switch (n) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        n = 3;
    }
    var t = Qn;
    Qn = n;
    try {
      return e();
    } finally {
      Qn = t;
    }
  };
  Ut.unstable_scheduleCallback = function (n, e, t) {
    var r = Ut.unstable_now();
    switch (
      typeof t == "object" && t !== null
        ? (t = t.delay, t = typeof t == "number" && 0 < t ? r + t : r)
        : t = r, n
    ) {
      case 1:
        var i = -1;
        break;
      case 2:
        i = 250;
        break;
      case 5:
        i = 1073741823;
        break;
      case 4:
        i = 1e4;
        break;
      default:
        i = 5e3;
    }
    return i = t + i,
      n = {
        id: wP++,
        callback: e,
        priorityLevel: n,
        startTime: t,
        expirationTime: i,
        sortIndex: -1,
      },
      t > r
        ? (n.sortIndex = t,
          Z0(So, n),
          ki(hs) === null && n === ki(So) &&
          (Wc ? (eM(Xc), Xc = -1) : Wc = !0, rv(Q0, t - r)))
        : (n.sortIndex = i, Z0(hs, n), ka || Lh || (ka = !0, nv($0))),
      n;
  };
  Ut.unstable_shouldYield = iM;
  Ut.unstable_wrapCallback = function (n) {
    var e = Qn;
    return function () {
      var t = Qn;
      Qn = e;
      try {
        return n.apply(this, arguments);
      } finally {
        Qn = t;
      }
    };
  };
});
var lM = cr((EU, aM) => {
  "use strict";
  aM.exports = oM();
});
var pA = cr((Zr) => {
  "use strict";
  var uM = An(), jr = lM();
  function he(n) {
    for (
      var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n,
        t = 1;
      t < arguments.length;
      t++
    ) e += "&args[]=" + encodeURIComponent(arguments[t]);
    return "Minified React error #" + n + "; visit " + e +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var cM = new Set(), Yc = {};
  function Fa(n, e) {
    Jl(n, e), Jl(n + "Capture", e);
  }
  function Jl(n, e) {
    for (Yc[n] = e, n = 0; n < e.length; n++) cM.add(e[n]);
  }
  var Ns =
      !(typeof window == "undefined" || typeof window.document == "undefined" ||
        typeof window.document.createElement == "undefined"),
    iv = Object.prototype.hasOwnProperty,
    MP =
      /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    fM = {},
    dM = {};
  function EP(n) {
    return iv.call(dM, n)
      ? !0
      : iv.call(fM, n)
      ? !1
      : MP.test(n)
      ? dM[n] = !0
      : (fM[n] = !0, !1);
  }
  function TP(n, e, t, r) {
    if (t !== null && t.type === 0) return !1;
    switch (typeof e) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return r
          ? !1
          : t !== null
          ? !t.acceptsBooleans
          : (n = n.toLowerCase().slice(0, 5), n !== "data-" && n !== "aria-");
      default:
        return !1;
    }
  }
  function AP(n, e, t, r) {
    if (e === null || typeof e == "undefined" || TP(n, e, t, r)) return !0;
    if (r) return !1;
    if (t !== null) {
      switch (t.type) {
        case 3:
          return !e;
        case 4:
          return e === !1;
        case 5:
          return isNaN(e);
        case 6:
          return isNaN(e) || 1 > e;
      }
    }
    return !1;
  }
  function dr(n, e, t, r, i, s, o) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4,
      this.attributeName = r,
      this.attributeNamespace = i,
      this.mustUseProperty = t,
      this.propertyName = n,
      this.type = e,
      this.sanitizeURL = s,
      this.removeEmptyString = o;
  }
  var Gn = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
    .split(" ").forEach(function (n) {
      Gn[n] = new dr(n, 0, !1, n, null, !1, !1);
    });
  [["acceptCharset", "accept-charset"], ["className", "class"], [
    "htmlFor",
    "for",
  ], ["httpEquiv", "http-equiv"]].forEach(function (n) {
    var e = n[0];
    Gn[e] = new dr(e, 1, !1, n[1], null, !1, !1);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) {
    Gn[n] = new dr(n, 2, !1, n.toLowerCase(), null, !1, !1);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"]
    .forEach(function (n) {
      Gn[n] = new dr(n, 2, !1, n, null, !1, !1);
    });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
    .split(" ").forEach(function (n) {
      Gn[n] = new dr(n, 3, !1, n.toLowerCase(), null, !1, !1);
    });
  ["checked", "multiple", "muted", "selected"].forEach(function (n) {
    Gn[n] = new dr(n, 3, !0, n, null, !1, !1);
  });
  ["capture", "download"].forEach(function (n) {
    Gn[n] = new dr(n, 4, !1, n, null, !1, !1);
  });
  ["cols", "rows", "size", "span"].forEach(function (n) {
    Gn[n] = new dr(n, 6, !1, n, null, !1, !1);
  });
  ["rowSpan", "start"].forEach(function (n) {
    Gn[n] = new dr(n, 5, !1, n.toLowerCase(), null, !1, !1);
  });
  var sv = /[\-:]([a-z])/g;
  function ov(n) {
    return n[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
    .split(" ").forEach(function (n) {
      var e = n.replace(sv, ov);
      Gn[e] = new dr(e, 1, !1, n, null, !1, !1);
    });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
    .split(" ").forEach(function (n) {
      var e = n.replace(sv, ov);
      Gn[e] = new dr(e, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1);
    });
  ["xml:base", "xml:lang", "xml:space"].forEach(function (n) {
    var e = n.replace(sv, ov);
    Gn[e] = new dr(e, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1);
  });
  ["tabIndex", "crossOrigin"].forEach(function (n) {
    Gn[n] = new dr(n, 1, !1, n.toLowerCase(), null, !1, !1);
  });
  Gn.xlinkHref = new dr(
    "xlinkHref",
    1,
    !1,
    "xlink:href",
    "http://www.w3.org/1999/xlink",
    !0,
    !1,
  );
  ["src", "href", "action", "formAction"].forEach(function (n) {
    Gn[n] = new dr(n, 1, !1, n.toLowerCase(), null, !0, !0);
  });
  function av(n, e, t, r) {
    var i = Gn.hasOwnProperty(e) ? Gn[e] : null;
    (i !== null
      ? i.type !== 0
      : r || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" ||
        e[1] !== "n" && e[1] !== "N") && (AP(e, t, i, r) && (t = null),
        r || i === null
          ? EP(e) &&
            (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t))
          : i.mustUseProperty
          ? n[i.propertyName] = t === null ? i.type === 3 ? !1 : "" : t
          : (e = i.attributeName,
            r = i.attributeNamespace,
            t === null
              ? n.removeAttribute(e)
              : (i = i.type,
                t = i === 3 || i === 4 && t === !0 ? "" : "" + t,
                r ? n.setAttributeNS(r, e, t) : n.setAttribute(e, t))));
  }
  var Ds = uM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    Nh = Symbol.for("react.element"),
    Ql = Symbol.for("react.portal"),
    $l = Symbol.for("react.fragment"),
    lv = Symbol.for("react.strict_mode"),
    uv = Symbol.for("react.profiler"),
    hM = Symbol.for("react.provider"),
    pM = Symbol.for("react.context"),
    cv = Symbol.for("react.forward_ref"),
    fv = Symbol.for("react.suspense"),
    dv = Symbol.for("react.suspense_list"),
    hv = Symbol.for("react.memo"),
    wo = Symbol.for("react.lazy");
  Symbol.for("react.scope");
  Symbol.for("react.debug_trace_mode");
  var mM = Symbol.for("react.offscreen");
  Symbol.for("react.legacy_hidden");
  Symbol.for("react.cache");
  Symbol.for("react.tracing_marker");
  var gM = Symbol.iterator;
  function Zc(n) {
    return n === null || typeof n != "object"
      ? null
      : (n = gM && n[gM] || n["@@iterator"], typeof n == "function" ? n : null);
  }
  var sn = Object.assign, pv;
  function Kc(n) {
    if (pv === void 0) {
      try {
        throw Error();
      } catch (t) {
        var e = t.stack.trim().match(/\n( *(at )?)/);
        pv = e && e[1] || "";
      }
    }
    return `
` + pv + n;
  }
  var mv = !1;
  function gv(n, e) {
    if (!n || mv) return "";
    mv = !0;
    var t = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (e) {
        if (
          e = function () {
            throw Error();
          },
            Object.defineProperty(e.prototype, "props", {
              set: function () {
                throw Error();
              },
            }),
            typeof Reflect == "object" && Reflect.construct
        ) {
          try {
            Reflect.construct(e, []);
          } catch (f) {
            var r = f;
          }
          Reflect.construct(n, [], e);
        } else {
          try {
            e.call();
          } catch (f) {
            r = f;
          }
          n.call(e.prototype);
        }
      } else {
        try {
          throw Error();
        } catch (f) {
          r = f;
        }
        n();
      }
    } catch (f) {
      if (f && r && typeof f.stack == "string") {
        for (
          var i = f.stack.split(`
`),
            s = r.stack.split(`
`),
            o = i.length - 1,
            a = s.length - 1;
          1 <= o && 0 <= a && i[o] !== s[a];
        ) a--;
        for (; 1 <= o && 0 <= a; o--, a--) {
          if (i[o] !== s[a]) {
            if (o !== 1 || a !== 1) {
              do if (o--, a--, 0 > a || i[o] !== s[a]) {
                var u = `
` + i[o].replace(" at new ", " at ");
                return n.displayName && u.includes("<anonymous>") &&
                  (u = u.replace("<anonymous>", n.displayName)),
                  u;
              } while (1 <= o && 0 <= a);
            }
            break;
          }
        }
      }
    } finally {
      mv = !1, Error.prepareStackTrace = t;
    }
    return (n = n ? n.displayName || n.name : "") ? Kc(n) : "";
  }
  function CP(n) {
    switch (n.tag) {
      case 5:
        return Kc(n.type);
      case 16:
        return Kc("Lazy");
      case 13:
        return Kc("Suspense");
      case 19:
        return Kc("SuspenseList");
      case 0:
      case 2:
      case 15:
        return n = gv(n.type, !1), n;
      case 11:
        return n = gv(n.type.render, !1), n;
      case 1:
        return n = gv(n.type, !0), n;
      default:
        return "";
    }
  }
  function vv(n) {
    if (n == null) return null;
    if (typeof n == "function") return n.displayName || n.name || null;
    if (typeof n == "string") return n;
    switch (n) {
      case $l:
        return "Fragment";
      case Ql:
        return "Portal";
      case uv:
        return "Profiler";
      case lv:
        return "StrictMode";
      case fv:
        return "Suspense";
      case dv:
        return "SuspenseList";
    }
    if (typeof n == "object") {
      switch (n.$$typeof) {
        case pM:
          return (n.displayName || "Context") + ".Consumer";
        case hM:
          return (n._context.displayName || "Context") + ".Provider";
        case cv:
          var e = n.render;
          return n = n.displayName,
            n ||
            (n = e.displayName || e.name || "",
              n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"),
            n;
        case hv:
          return e = n.displayName || null,
            e !== null ? e : vv(n.type) || "Memo";
        case wo:
          e = n._payload, n = n._init;
          try {
            return vv(n(e));
          } catch {}
      }
    }
    return null;
  }
  function bP(n) {
    var e = n.type;
    switch (n.tag) {
      case 24:
        return "Cache";
      case 9:
        return (e.displayName || "Context") + ".Consumer";
      case 10:
        return (e._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return n = e.render,
          n = n.displayName || n.name || "",
          e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return e;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return vv(e);
      case 8:
        return e === lv ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof e == "function") return e.displayName || e.name || null;
        if (typeof e == "string") return e;
    }
    return null;
  }
  function Mo(n) {
    switch (typeof n) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return n;
      case "object":
        return n;
      default:
        return "";
    }
  }
  function vM(n) {
    var e = n.type;
    return (n = n.nodeName) && n.toLowerCase() === "input" &&
      (e === "checkbox" || e === "radio");
  }
  function RP(n) {
    var e = vM(n) ? "checked" : "value",
      t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e),
      r = "" + n[e];
    if (
      !n.hasOwnProperty(e) && typeof t != "undefined" &&
      typeof t.get == "function" && typeof t.set == "function"
    ) {
      var i = t.get, s = t.set;
      return Object.defineProperty(n, e, {
        configurable: !0,
        get: function () {
          return i.call(this);
        },
        set: function (o) {
          r = "" + o, s.call(this, o);
        },
      }),
        Object.defineProperty(n, e, { enumerable: t.enumerable }),
        {
          getValue: function () {
            return r;
          },
          setValue: function (o) {
            r = "" + o;
          },
          stopTracking: function () {
            n._valueTracker = null, delete n[e];
          },
        };
    }
  }
  function Dh(n) {
    n._valueTracker || (n._valueTracker = RP(n));
  }
  function yM(n) {
    if (!n) return !1;
    var e = n._valueTracker;
    if (!e) return !0;
    var t = e.getValue(), r = "";
    return n && (r = vM(n) ? n.checked ? "true" : "false" : n.value),
      n = r,
      n !== t ? (e.setValue(n), !0) : !1;
  }
  function kh(n) {
    if (
      n = n || (typeof document != "undefined" ? document : void 0),
        typeof n == "undefined"
    ) return null;
    try {
      return n.activeElement || n.body;
    } catch {
      return n.body;
    }
  }
  function yv(n, e) {
    var t = e.checked;
    return sn({}, e, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: t ?? n._wrapperState.initialChecked,
    });
  }
  function xM(n, e) {
    var t = e.defaultValue == null ? "" : e.defaultValue,
      r = e.checked != null ? e.checked : e.defaultChecked;
    t = Mo(e.value != null ? e.value : t),
      n._wrapperState = {
        initialChecked: r,
        initialValue: t,
        controlled: e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
      };
  }
  function _M(n, e) {
    e = e.checked, e != null && av(n, "checked", e, !1);
  }
  function xv(n, e) {
    _M(n, e);
    var t = Mo(e.value), r = e.type;
    if (t != null) {
      r === "number"
        ? (t === 0 && n.value === "" || n.value != t) && (n.value = "" + t)
        : n.value !== "" + t && (n.value = "" + t);
    } else if (r === "submit" || r === "reset") {
      n.removeAttribute("value");
      return;
    }
    e.hasOwnProperty("value")
      ? _v(n, e.type, t)
      : e.hasOwnProperty("defaultValue") && _v(n, e.type, Mo(e.defaultValue)),
      e.checked == null && e.defaultChecked != null &&
      (n.defaultChecked = !!e.defaultChecked);
  }
  function SM(n, e, t) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
      var r = e.type;
      if (
        !(r !== "submit" && r !== "reset" ||
          e.value !== void 0 && e.value !== null)
      ) return;
      e = "" + n._wrapperState.initialValue,
        t || e === n.value || (n.value = e),
        n.defaultValue = e;
    }
    t = n.name,
      t !== "" && (n.name = ""),
      n.defaultChecked = !!n._wrapperState.initialChecked,
      t !== "" && (n.name = t);
  }
  function _v(n, e, t) {
    (e !== "number" || kh(n.ownerDocument) !== n) &&
      (t == null
        ? n.defaultValue = "" + n._wrapperState.initialValue
        : n.defaultValue !== "" + t && (n.defaultValue = "" + t));
  }
  var Jc = Array.isArray;
  function eu(n, e, t, r) {
    if (n = n.options, e) {
      e = {};
      for (var i = 0; i < t.length; i++) e["$" + t[i]] = !0;
      for (t = 0; t < n.length; t++) {
        i = e.hasOwnProperty("$" + n[t].value),
          n[t].selected !== i && (n[t].selected = i),
          i && r && (n[t].defaultSelected = !0);
      }
    } else {
      for (t = "" + Mo(t), e = null, i = 0; i < n.length; i++) {
        if (n[i].value === t) {
          n[i].selected = !0, r && (n[i].defaultSelected = !0);
          return;
        }
        e !== null || n[i].disabled || (e = n[i]);
      }
      e !== null && (e.selected = !0);
    }
  }
  function Sv(n, e) {
    if (e.dangerouslySetInnerHTML != null) throw Error(he(91));
    return sn({}, e, {
      value: void 0,
      defaultValue: void 0,
      children: "" + n._wrapperState.initialValue,
    });
  }
  function wM(n, e) {
    var t = e.value;
    if (t == null) {
      if (t = e.children, e = e.defaultValue, t != null) {
        if (e != null) throw Error(he(92));
        if (Jc(t)) {
          if (1 < t.length) throw Error(he(93));
          t = t[0];
        }
        e = t;
      }
      e == null && (e = ""), t = e;
    }
    n._wrapperState = { initialValue: Mo(t) };
  }
  function MM(n, e) {
    var t = Mo(e.value), r = Mo(e.defaultValue);
    t != null &&
    (t = "" + t,
      t !== n.value && (n.value = t),
      e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
      r != null && (n.defaultValue = "" + r);
  }
  function EM(n) {
    var e = n.textContent;
    e === n._wrapperState.initialValue && e !== "" && e !== null &&
      (n.value = e);
  }
  function TM(n) {
    switch (n) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function wv(n, e) {
    return n == null || n === "http://www.w3.org/1999/xhtml"
      ? TM(e)
      : n === "http://www.w3.org/2000/svg" && e === "foreignObject"
      ? "http://www.w3.org/1999/xhtml"
      : n;
  }
  var Fh,
    AM = function (n) {
      return typeof MSApp != "undefined" && MSApp.execUnsafeLocalFunction
        ? function (e, t, r, i) {
          MSApp.execUnsafeLocalFunction(function () {
            return n(e, t, r, i);
          });
        }
        : n;
    }(function (n, e) {
      if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n) {
        n.innerHTML = e;
      } else {
        for (
          Fh = Fh || document.createElement("div"),
            Fh.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
            e = Fh.firstChild;
          n.firstChild;
        ) n.removeChild(n.firstChild);
        for (; e.firstChild;) n.appendChild(e.firstChild);
      }
    });
  function Qc(n, e) {
    if (e) {
      var t = n.firstChild;
      if (t && t === n.lastChild && t.nodeType === 3) {
        t.nodeValue = e;
        return;
      }
    }
    n.textContent = e;
  }
  var $c = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0,
    },
    LP = ["Webkit", "ms", "Moz", "O"];
  Object.keys($c).forEach(function (n) {
    LP.forEach(function (e) {
      e = e + n.charAt(0).toUpperCase() + n.substring(1), $c[e] = $c[n];
    });
  });
  function CM(n, e, t) {
    return e == null || typeof e == "boolean" || e === ""
      ? ""
      : t || typeof e != "number" || e === 0 || $c.hasOwnProperty(n) && $c[n]
      ? ("" + e).trim()
      : e + "px";
  }
  function bM(n, e) {
    n = n.style;
    for (var t in e) {
      if (e.hasOwnProperty(t)) {
        var r = t.indexOf("--") === 0, i = CM(t, e[t], r);
        t === "float" && (t = "cssFloat"), r ? n.setProperty(t, i) : n[t] = i;
      }
    }
  }
  var PP = sn({ menuitem: !0 }, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  });
  function Mv(n, e) {
    if (e) {
      if (PP[n] && (e.children != null || e.dangerouslySetInnerHTML != null)) {
        throw Error(he(137, n));
      }
      if (e.dangerouslySetInnerHTML != null) {
        if (e.children != null) throw Error(he(60));
        if (
          typeof e.dangerouslySetInnerHTML != "object" ||
          !("__html" in e.dangerouslySetInnerHTML)
        ) throw Error(he(61));
      }
      if (e.style != null && typeof e.style != "object") throw Error(he(62));
    }
  }
  function Ev(n, e) {
    if (n.indexOf("-") === -1) return typeof e.is == "string";
    switch (n) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Tv = null;
  function Av(n) {
    return n = n.target || n.srcElement || window,
      n.correspondingUseElement && (n = n.correspondingUseElement),
      n.nodeType === 3 ? n.parentNode : n;
  }
  var Cv = null, tu = null, nu = null;
  function RM(n) {
    if (n = Sf(n)) {
      if (typeof Cv != "function") throw Error(he(280));
      var e = n.stateNode;
      e && (e = up(e), Cv(n.stateNode, n.type, e));
    }
  }
  function LM(n) {
    tu ? nu ? nu.push(n) : nu = [n] : tu = n;
  }
  function PM() {
    if (tu) {
      var n = tu, e = nu;
      if (nu = tu = null, RM(n), e) { for (n = 0; n < e.length; n++) RM(e[n]); }
    }
  }
  function IM(n, e) {
    return n(e);
  }
  function NM() {}
  var bv = !1;
  function DM(n, e, t) {
    if (bv) return n(e, t);
    bv = !0;
    try {
      return IM(n, e, t);
    } finally {
      bv = !1, (tu !== null || nu !== null) && (NM(), PM());
    }
  }
  function ef(n, e) {
    var t = n.stateNode;
    if (t === null) return null;
    var r = up(t);
    if (r === null) return null;
    t = r[e];
    e: switch (e) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (r = !r.disabled) ||
        (n = n.type,
          r =
            !(n === "button" || n === "input" || n === "select" ||
              n === "textarea")), n = !r;
        break e;
      default:
        n = !1;
    }
    if (n) return null;
    if (t && typeof t != "function") throw Error(he(231, e, typeof t));
    return t;
  }
  var Rv = !1;
  if (Ns) {
    try {
      ru = {},
        Object.defineProperty(ru, "passive", {
          get: function () {
            Rv = !0;
          },
        }),
        window.addEventListener("test", ru, ru),
        window.removeEventListener("test", ru, ru);
    } catch {
      Rv = !1;
    }
  }
  var ru;
  function IP(n, e, t, r, i, s, o, a, u) {
    var f = Array.prototype.slice.call(arguments, 3);
    try {
      e.apply(t, f);
    } catch (d) {
      this.onError(d);
    }
  }
  var tf = !1,
    Oh = null,
    zh = !1,
    Lv = null,
    NP = {
      onError: function (n) {
        tf = !0, Oh = n;
      },
    };
  function DP(n, e, t, r, i, s, o, a, u) {
    tf = !1, Oh = null, IP.apply(NP, arguments);
  }
  function kP(n, e, t, r, i, s, o, a, u) {
    if (DP.apply(this, arguments), tf) {
      if (tf) {
        var f = Oh;
        tf = !1, Oh = null;
      } else throw Error(he(198));
      zh || (zh = !0, Lv = f);
    }
  }
  function Oa(n) {
    var e = n, t = n;
    if (n.alternate) { for (; e.return;) e = e.return; }
    else {
      n = e;
      do e = n, (e.flags & 4098) != 0 && (t = e.return), n = e.return; while (
        n
      );
    }
    return e.tag === 3 ? t : null;
  }
  function kM(n) {
    if (n.tag === 13) {
      var e = n.memoizedState;
      if (
        e === null && (n = n.alternate, n !== null && (e = n.memoizedState)),
          e !== null
      ) return e.dehydrated;
    }
    return null;
  }
  function FM(n) {
    if (Oa(n) !== n) throw Error(he(188));
  }
  function FP(n) {
    var e = n.alternate;
    if (!e) {
      if (e = Oa(n), e === null) throw Error(he(188));
      return e !== n ? null : n;
    }
    for (var t = n, r = e;;) {
      var i = t.return;
      if (i === null) break;
      var s = i.alternate;
      if (s === null) {
        if (r = i.return, r !== null) {
          t = r;
          continue;
        }
        break;
      }
      if (i.child === s.child) {
        for (s = i.child; s;) {
          if (s === t) return FM(i), n;
          if (s === r) return FM(i), e;
          s = s.sibling;
        }
        throw Error(he(188));
      }
      if (t.return !== r.return) t = i, r = s;
      else {
        for (var o = !1, a = i.child; a;) {
          if (a === t) {
            o = !0, t = i, r = s;
            break;
          }
          if (a === r) {
            o = !0, r = i, t = s;
            break;
          }
          a = a.sibling;
        }
        if (!o) {
          for (a = s.child; a;) {
            if (a === t) {
              o = !0, t = s, r = i;
              break;
            }
            if (a === r) {
              o = !0, r = s, t = i;
              break;
            }
            a = a.sibling;
          }
          if (!o) throw Error(he(189));
        }
      }
      if (t.alternate !== r) throw Error(he(190));
    }
    if (t.tag !== 3) throw Error(he(188));
    return t.stateNode.current === t ? n : e;
  }
  function OM(n) {
    return n = FP(n), n !== null ? zM(n) : null;
  }
  function zM(n) {
    if (n.tag === 5 || n.tag === 6) return n;
    for (n = n.child; n !== null;) {
      var e = zM(n);
      if (e !== null) return e;
      n = n.sibling;
    }
    return null;
  }
  var BM = jr.unstable_scheduleCallback,
    UM = jr.unstable_cancelCallback,
    OP = jr.unstable_shouldYield,
    zP = jr.unstable_requestPaint,
    vn = jr.unstable_now,
    BP = jr.unstable_getCurrentPriorityLevel,
    Pv = jr.unstable_ImmediatePriority,
    VM = jr.unstable_UserBlockingPriority,
    Bh = jr.unstable_NormalPriority,
    UP = jr.unstable_LowPriority,
    HM = jr.unstable_IdlePriority,
    Uh = null,
    ps = null;
  function VP(n) {
    if (ps && typeof ps.onCommitFiberRoot == "function") {
      try {
        ps.onCommitFiberRoot(Uh, n, void 0, (n.current.flags & 128) == 128);
      } catch {}
    }
  }
  var Fi = Math.clz32 ? Math.clz32 : jP, HP = Math.log, GP = Math.LN2;
  function jP(n) {
    return n >>>= 0, n === 0 ? 32 : 31 - (HP(n) / GP | 0) | 0;
  }
  var Vh = 64, Hh = 4194304;
  function nf(n) {
    switch (n & -n) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return n & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return n & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return n;
    }
  }
  function Gh(n, e) {
    var t = n.pendingLanes;
    if (t === 0) return 0;
    var r = 0, i = n.suspendedLanes, s = n.pingedLanes, o = t & 268435455;
    if (o !== 0) {
      var a = o & ~i;
      a !== 0 ? r = nf(a) : (s &= o, s !== 0 && (r = nf(s)));
    } else o = t & ~i, o !== 0 ? r = nf(o) : s !== 0 && (r = nf(s));
    if (r === 0) return 0;
    if (
      e !== 0 && e !== r && (e & i) == 0 &&
      (i = r & -r, s = e & -e, i >= s || i === 16 && (s & 4194240) != 0)
    ) return e;
    if ((r & 4) != 0 && (r |= t & 16), e = n.entangledLanes, e !== 0) {
      for (n = n.entanglements, e &= r; 0 < e;) {
        t = 31 - Fi(e), i = 1 << t, r |= n[t], e &= ~i;
      }
    }
    return r;
  }
  function WP(n, e) {
    switch (n) {
      case 1:
      case 2:
      case 4:
        return e + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return e + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function XP(n, e) {
    for (
      var t = n.suspendedLanes,
        r = n.pingedLanes,
        i = n.expirationTimes,
        s = n.pendingLanes;
      0 < s;
    ) {
      var o = 31 - Fi(s), a = 1 << o, u = i[o];
      u === -1
        ? ((a & t) == 0 || (a & r) != 0) && (i[o] = WP(a, e))
        : u <= e && (n.expiredLanes |= a), s &= ~a;
    }
  }
  function Iv(n) {
    return n = n.pendingLanes & -1073741825,
      n !== 0 ? n : n & 1073741824 ? 1073741824 : 0;
  }
  function GM() {
    var n = Vh;
    return Vh <<= 1, (Vh & 4194240) == 0 && (Vh = 64), n;
  }
  function Nv(n) {
    for (var e = [], t = 0; 31 > t; t++) e.push(n);
    return e;
  }
  function rf(n, e, t) {
    n.pendingLanes |= e,
      e !== 536870912 && (n.suspendedLanes = 0, n.pingedLanes = 0),
      n = n.eventTimes,
      e = 31 - Fi(e),
      n[e] = t;
  }
  function qP(n, e) {
    var t = n.pendingLanes & ~e;
    n.pendingLanes = e,
      n.suspendedLanes = 0,
      n.pingedLanes = 0,
      n.expiredLanes &= e,
      n.mutableReadLanes &= e,
      n.entangledLanes &= e,
      e = n.entanglements;
    var r = n.eventTimes;
    for (n = n.expirationTimes; 0 < t;) {
      var i = 31 - Fi(t), s = 1 << i;
      e[i] = 0, r[i] = -1, n[i] = -1, t &= ~s;
    }
  }
  function Dv(n, e) {
    var t = n.entangledLanes |= e;
    for (n = n.entanglements; t;) {
      var r = 31 - Fi(t), i = 1 << r;
      i & e | n[r] & e && (n[r] |= e), t &= ~i;
    }
  }
  var Dt = 0;
  function jM(n) {
    return n &= -n,
      1 < n ? 4 < n ? (n & 268435455) != 0 ? 16 : 536870912 : 4 : 1;
  }
  var WM,
    kv,
    XM,
    qM,
    YM,
    Fv = !1,
    jh = [],
    Eo = null,
    To = null,
    Ao = null,
    sf = new Map(),
    of = new Map(),
    Co = [],
    YP =
      "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit"
        .split(" ");
  function ZM(n, e) {
    switch (n) {
      case "focusin":
      case "focusout":
        Eo = null;
        break;
      case "dragenter":
      case "dragleave":
        To = null;
        break;
      case "mouseover":
      case "mouseout":
        Ao = null;
        break;
      case "pointerover":
      case "pointerout":
        sf.delete(e.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        of.delete(e.pointerId);
    }
  }
  function af(n, e, t, r, i, s) {
    return n === null || n.nativeEvent !== s
      ? (n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: r,
        nativeEvent: s,
        targetContainers: [i],
      },
        e !== null && (e = Sf(e), e !== null && kv(e)),
        n)
      : (n.eventSystemFlags |= r,
        e = n.targetContainers,
        i !== null && e.indexOf(i) === -1 && e.push(i),
        n);
  }
  function ZP(n, e, t, r, i) {
    switch (e) {
      case "focusin":
        return Eo = af(Eo, n, e, t, r, i), !0;
      case "dragenter":
        return To = af(To, n, e, t, r, i), !0;
      case "mouseover":
        return Ao = af(Ao, n, e, t, r, i), !0;
      case "pointerover":
        var s = i.pointerId;
        return sf.set(s, af(sf.get(s) || null, n, e, t, r, i)), !0;
      case "gotpointercapture":
        return s = i.pointerId,
          of.set(s, af(of.get(s) || null, n, e, t, r, i)),
          !0;
    }
    return !1;
  }
  function KM(n) {
    var e = za(n.target);
    if (e !== null) {
      var t = Oa(e);
      if (t !== null) {
        if (e = t.tag, e === 13) {
          if (e = kM(t), e !== null) {
            n.blockedOn = e,
              YM(n.priority, function () {
                XM(t);
              });
            return;
          }
        } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
          n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
          return;
        }
      }
    }
    n.blockedOn = null;
  }
  function Wh(n) {
    if (n.blockedOn !== null) return !1;
    for (var e = n.targetContainers; 0 < e.length;) {
      var t = zv(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
      if (t === null) {
        t = n.nativeEvent;
        var r = new t.constructor(t.type, t);
        Tv = r, t.target.dispatchEvent(r), Tv = null;
      } else return e = Sf(t), e !== null && kv(e), n.blockedOn = t, !1;
      e.shift();
    }
    return !0;
  }
  function JM(n, e, t) {
    Wh(n) && t.delete(e);
  }
  function KP() {
    Fv = !1,
      Eo !== null && Wh(Eo) && (Eo = null),
      To !== null && Wh(To) && (To = null),
      Ao !== null && Wh(Ao) && (Ao = null),
      sf.forEach(JM),
      of.forEach(JM);
  }
  function lf(n, e) {
    n.blockedOn === e &&
      (n.blockedOn = null,
        Fv ||
        (Fv = !0,
          jr.unstable_scheduleCallback(jr.unstable_NormalPriority, KP)));
  }
  function uf(n) {
    function e(i) {
      return lf(i, n);
    }
    if (0 < jh.length) {
      lf(jh[0], n);
      for (var t = 1; t < jh.length; t++) {
        var r = jh[t];
        r.blockedOn === n && (r.blockedOn = null);
      }
    }
    for (
      Eo !== null && lf(Eo, n),
        To !== null && lf(To, n),
        Ao !== null && lf(Ao, n),
        sf.forEach(e),
        of.forEach(e),
        t = 0;
      t < Co.length;
      t++
    ) r = Co[t], r.blockedOn === n && (r.blockedOn = null);
    for (; 0 < Co.length && (t = Co[0], t.blockedOn === null);) {
      KM(t), t.blockedOn === null && Co.shift();
    }
  }
  var iu = Ds.ReactCurrentBatchConfig, Xh = !0;
  function JP(n, e, t, r) {
    var i = Dt, s = iu.transition;
    iu.transition = null;
    try {
      Dt = 1, Ov(n, e, t, r);
    } finally {
      Dt = i, iu.transition = s;
    }
  }
  function QP(n, e, t, r) {
    var i = Dt, s = iu.transition;
    iu.transition = null;
    try {
      Dt = 4, Ov(n, e, t, r);
    } finally {
      Dt = i, iu.transition = s;
    }
  }
  function Ov(n, e, t, r) {
    if (Xh) {
      var i = zv(n, e, t, r);
      if (i === null) Qv(n, e, r, qh, t), ZM(n, r);
      else if (ZP(i, n, e, t, r)) r.stopPropagation();
      else if (ZM(n, r), e & 4 && -1 < YP.indexOf(n)) {
        for (; i !== null;) {
          var s = Sf(i);
          if (
            s !== null && WM(s),
              s = zv(n, e, t, r),
              s === null && Qv(n, e, r, qh, t),
              s === i
          ) break;
          i = s;
        }
        i !== null && r.stopPropagation();
      } else Qv(n, e, r, null, t);
    }
  }
  var qh = null;
  function zv(n, e, t, r) {
    if (qh = null, n = Av(r), n = za(n), n !== null) {
      if (e = Oa(n), e === null) {
        n = null;
      } else if (t = e.tag, t === 13) {
        if (n = kM(e), n !== null) return n;
        n = null;
      } else if (t === 3) {
        if (e.stateNode.current.memoizedState.isDehydrated) {
          return e.tag === 3
            ? e.stateNode.containerInfo
            : null;
        }
        n = null;
      } else e !== n && (n = null);
    }
    return qh = n, null;
  }
  function QM(n) {
    switch (n) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (BP()) {
          case Pv:
            return 1;
          case VM:
            return 4;
          case Bh:
          case UP:
            return 16;
          case HM:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var bo = null, Bv = null, Yh = null;
  function $M() {
    if (Yh) return Yh;
    var n,
      e = Bv,
      t = e.length,
      r,
      i = "value" in bo ? bo.value : bo.textContent,
      s = i.length;
    for (n = 0; n < t && e[n] === i[n]; n++);
    var o = t - n;
    for (r = 1; r <= o && e[t - r] === i[s - r]; r++);
    return Yh = i.slice(n, 1 < r ? 1 - r : void 0);
  }
  function Zh(n) {
    var e = n.keyCode;
    return "charCode" in n
      ? (n = n.charCode, n === 0 && e === 13 && (n = 13))
      : n = e,
      n === 10 && (n = 13),
      32 <= n || n === 13 ? n : 0;
  }
  function Kh() {
    return !0;
  }
  function eE() {
    return !1;
  }
  function Wr(n) {
    function e(t, r, i, s, o) {
      this._reactName = t,
        this._targetInst = i,
        this.type = r,
        this.nativeEvent = s,
        this.target = o,
        this.currentTarget = null;
      for (var a in n) {
        n.hasOwnProperty(a) && (t = n[a], this[a] = t ? t(s) : s[a]);
      }
      return this.isDefaultPrevented =
        (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1)
          ? Kh
          : eE,
        this.isPropagationStopped = eE,
        this;
    }
    return sn(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var t = this.nativeEvent;
        t &&
          (t.preventDefault
            ? t.preventDefault()
            : typeof t.returnValue != "unknown" && (t.returnValue = !1),
            this.isDefaultPrevented = Kh);
      },
      stopPropagation: function () {
        var t = this.nativeEvent;
        t &&
          (t.stopPropagation
            ? t.stopPropagation()
            : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
            this.isPropagationStopped = Kh);
      },
      persist: function () {},
      isPersistent: Kh,
    }),
      e;
  }
  var su = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (n) {
        return n.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    Uv = Wr(su),
    cf = sn({}, su, { view: 0, detail: 0 }),
    $P = Wr(cf),
    Vv,
    Hv,
    ff,
    Jh = sn({}, cf, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: jv,
      button: 0,
      buttons: 0,
      relatedTarget: function (n) {
        return n.relatedTarget === void 0
          ? n.fromElement === n.srcElement ? n.toElement : n.fromElement
          : n.relatedTarget;
      },
      movementX: function (n) {
        return "movementX" in n
          ? n.movementX
          : (n !== ff && (ff && n.type === "mousemove"
            ? (Vv = n.screenX - ff.screenX, Hv = n.screenY - ff.screenY)
            : Hv = Vv = 0,
            ff = n),
            Vv);
      },
      movementY: function (n) {
        return "movementY" in n ? n.movementY : Hv;
      },
    }),
    tE = Wr(Jh),
    eI = sn({}, Jh, { dataTransfer: 0 }),
    tI = Wr(eI),
    nI = sn({}, cf, { relatedTarget: 0 }),
    Gv = Wr(nI),
    rI = sn({}, su, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    iI = Wr(rI),
    sI = sn({}, su, {
      clipboardData: function (n) {
        return "clipboardData" in n ? n.clipboardData : window.clipboardData;
      },
    }),
    oI = Wr(sI),
    aI = sn({}, su, { data: 0 }),
    nE = Wr(aI),
    lI = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified",
    },
    uI = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta",
    },
    cI = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey",
    };
  function fI(n) {
    var e = this.nativeEvent;
    return e.getModifierState
      ? e.getModifierState(n)
      : (n = cI[n])
      ? !!e[n]
      : !1;
  }
  function jv() {
    return fI;
  }
  var dI = sn({}, cf, {
      key: function (n) {
        if (n.key) {
          var e = lI[n.key] || n.key;
          if (e !== "Unidentified") return e;
        }
        return n.type === "keypress"
          ? (n = Zh(n), n === 13 ? "Enter" : String.fromCharCode(n))
          : n.type === "keydown" || n.type === "keyup"
          ? uI[n.keyCode] || "Unidentified"
          : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: jv,
      charCode: function (n) {
        return n.type === "keypress" ? Zh(n) : 0;
      },
      keyCode: function (n) {
        return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
      },
      which: function (n) {
        return n.type === "keypress"
          ? Zh(n)
          : n.type === "keydown" || n.type === "keyup"
          ? n.keyCode
          : 0;
      },
    }),
    hI = Wr(dI),
    pI = sn({}, Jh, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    rE = Wr(pI),
    mI = sn({}, cf, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: jv,
    }),
    gI = Wr(mI),
    vI = sn({}, su, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    yI = Wr(vI),
    xI = sn({}, Jh, {
      deltaX: function (n) {
        return "deltaX" in n
          ? n.deltaX
          : "wheelDeltaX" in n
          ? -n.wheelDeltaX
          : 0;
      },
      deltaY: function (n) {
        return "deltaY" in n
          ? n.deltaY
          : "wheelDeltaY" in n
          ? -n.wheelDeltaY
          : "wheelDelta" in n
          ? -n.wheelDelta
          : 0;
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    _I = Wr(xI),
    SI = [9, 13, 27, 32],
    Wv = Ns && "CompositionEvent" in window,
    df = null;
  Ns && "documentMode" in document && (df = document.documentMode);
  var wI = Ns && "TextEvent" in window && !df,
    iE = Ns && (!Wv || df && 8 < df && 11 >= df),
    sE = String.fromCharCode(32),
    oE = !1;
  function aE(n, e) {
    switch (n) {
      case "keyup":
        return SI.indexOf(e.keyCode) !== -1;
      case "keydown":
        return e.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function lE(n) {
    return n = n.detail, typeof n == "object" && "data" in n ? n.data : null;
  }
  var ou = !1;
  function MI(n, e) {
    switch (n) {
      case "compositionend":
        return lE(e);
      case "keypress":
        return e.which !== 32 ? null : (oE = !0, sE);
      case "textInput":
        return n = e.data, n === sE && oE ? null : n;
      default:
        return null;
    }
  }
  function EI(n, e) {
    if (ou) {
      return n === "compositionend" || !Wv && aE(n, e)
        ? (n = $M(), Yh = Bv = bo = null, ou = !1, n)
        : null;
    }
    switch (n) {
      case "paste":
        return null;
      case "keypress":
        if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
          if (e.char && 1 < e.char.length) return e.char;
          if (e.which) return String.fromCharCode(e.which);
        }
        return null;
      case "compositionend":
        return iE && e.locale !== "ko" ? null : e.data;
      default:
        return null;
    }
  }
  var TI = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
  };
  function uE(n) {
    var e = n && n.nodeName && n.nodeName.toLowerCase();
    return e === "input" ? !!TI[n.type] : e === "textarea";
  }
  function cE(n, e, t, r) {
    LM(r),
      e = op(e, "onChange"),
      0 < e.length &&
      (t = new Uv("onChange", "change", null, t, r),
        n.push({ event: t, listeners: e }));
  }
  var hf = null, pf = null;
  function AI(n) {
    RE(n, 0);
  }
  function Qh(n) {
    var e = fu(n);
    if (yM(e)) return n;
  }
  function CI(n, e) {
    if (n === "change") return e;
  }
  var fE = !1;
  Ns &&
    (Ns
      ? (ep = "oninput" in document,
        ep ||
        (Xv = document.createElement("div"),
          Xv.setAttribute("oninput", "return;"),
          ep = typeof Xv.oninput == "function"),
        $h = ep)
      : $h = !1,
      fE = $h && (!document.documentMode || 9 < document.documentMode));
  var $h, ep, Xv;
  function dE() {
    hf && (hf.detachEvent("onpropertychange", hE), pf = hf = null);
  }
  function hE(n) {
    if (n.propertyName === "value" && Qh(pf)) {
      var e = [];
      cE(e, pf, n, Av(n)), DM(AI, e);
    }
  }
  function bI(n, e, t) {
    n === "focusin"
      ? (dE(), hf = e, pf = t, hf.attachEvent("onpropertychange", hE))
      : n === "focusout" && dE();
  }
  function RI(n) {
    if (n === "selectionchange" || n === "keyup" || n === "keydown") {
      return Qh(pf);
    }
  }
  function LI(n, e) {
    if (n === "click") return Qh(e);
  }
  function PI(n, e) {
    if (n === "input" || n === "change") return Qh(e);
  }
  function II(n, e) {
    return n === e && (n !== 0 || 1 / n == 1 / e) || n !== n && e !== e;
  }
  var Oi = typeof Object.is == "function" ? Object.is : II;
  function mf(n, e) {
    if (Oi(n, e)) return !0;
    if (
      typeof n != "object" || n === null || typeof e != "object" || e === null
    ) return !1;
    var t = Object.keys(n), r = Object.keys(e);
    if (t.length !== r.length) return !1;
    for (r = 0; r < t.length; r++) {
      var i = t[r];
      if (!iv.call(e, i) || !Oi(n[i], e[i])) return !1;
    }
    return !0;
  }
  function pE(n) {
    for (; n && n.firstChild;) n = n.firstChild;
    return n;
  }
  function mE(n, e) {
    var t = pE(n);
    n = 0;
    for (var r; t;) {
      if (t.nodeType === 3) {
        if (r = n + t.textContent.length, n <= e && r >= e) {
          return { node: t, offset: e - n };
        }
        n = r;
      }
      e: {
        for (; t;) {
          if (t.nextSibling) {
            t = t.nextSibling;
            break e;
          }
          t = t.parentNode;
        }
        t = void 0;
      }
      t = pE(t);
    }
  }
  function gE(n, e) {
    return n && e
      ? n === e
        ? !0
        : n && n.nodeType === 3
        ? !1
        : e && e.nodeType === 3
        ? gE(n, e.parentNode)
        : "contains" in n
        ? n.contains(e)
        : n.compareDocumentPosition
        ? !!(n.compareDocumentPosition(e) & 16)
        : !1
      : !1;
  }
  function vE() {
    for (var n = window, e = kh(); e instanceof n.HTMLIFrameElement;) {
      try {
        var t = typeof e.contentWindow.location.href == "string";
      } catch {
        t = !1;
      }
      if (t) n = e.contentWindow;
      else break;
      e = kh(n.document);
    }
    return e;
  }
  function qv(n) {
    var e = n && n.nodeName && n.nodeName.toLowerCase();
    return e &&
      (e === "input" &&
          (n.type === "text" || n.type === "search" || n.type === "tel" ||
            n.type === "url" || n.type === "password") ||
        e === "textarea" || n.contentEditable === "true");
  }
  function NI(n) {
    var e = vE(), t = n.focusedElem, r = n.selectionRange;
    if (
      e !== t && t && t.ownerDocument && gE(t.ownerDocument.documentElement, t)
    ) {
      if (r !== null && qv(t)) {
        if (
          e = r.start, n = r.end, n === void 0 && (n = e), "selectionStart" in t
        ) t.selectionStart = e, t.selectionEnd = Math.min(n, t.value.length);
        else if (
          n = (e = t.ownerDocument || document) && e.defaultView || window,
            n.getSelection
        ) {
          n = n.getSelection();
          var i = t.textContent.length, s = Math.min(r.start, i);
          r = r.end === void 0 ? s : Math.min(r.end, i),
            !n.extend && s > r && (i = r, r = s, s = i),
            i = mE(t, s);
          var o = mE(t, r);
          i && o &&
            (n.rangeCount !== 1 || n.anchorNode !== i.node ||
              n.anchorOffset !== i.offset || n.focusNode !== o.node ||
              n.focusOffset !== o.offset) &&
            (e = e.createRange(),
              e.setStart(i.node, i.offset),
              n.removeAllRanges(),
              s > r
                ? (n.addRange(e), n.extend(o.node, o.offset))
                : (e.setEnd(o.node, o.offset), n.addRange(e)));
        }
      }
      for (e = [], n = t; n = n.parentNode;) {
        n.nodeType === 1 &&
          e.push({ element: n, left: n.scrollLeft, top: n.scrollTop });
      }
      for (
        typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++
      ) n = e[t], n.element.scrollLeft = n.left, n.element.scrollTop = n.top;
    }
  }
  var DI = Ns && "documentMode" in document && 11 >= document.documentMode,
    au = null,
    Yv = null,
    gf = null,
    Zv = !1;
  function yE(n, e, t) {
    var r = t.window === t
      ? t.document
      : t.nodeType === 9
      ? t
      : t.ownerDocument;
    Zv || au == null || au !== kh(r) || (r = au,
      "selectionStart" in r && qv(r)
        ? r = { start: r.selectionStart, end: r.selectionEnd }
        : (r = (r.ownerDocument && r.ownerDocument.defaultView || window)
          .getSelection(),
          r = {
            anchorNode: r.anchorNode,
            anchorOffset: r.anchorOffset,
            focusNode: r.focusNode,
            focusOffset: r.focusOffset,
          }),
      gf && mf(gf, r) ||
      (gf = r,
        r = op(Yv, "onSelect"),
        0 < r.length &&
        (e = new Uv("onSelect", "select", null, e, t),
          n.push({ event: e, listeners: r }),
          e.target = au)));
  }
  function tp(n, e) {
    var t = {};
    return t[n.toLowerCase()] = e.toLowerCase(),
      t["Webkit" + n] = "webkit" + e,
      t["Moz" + n] = "moz" + e,
      t;
  }
  var lu = {
      animationend: tp("Animation", "AnimationEnd"),
      animationiteration: tp("Animation", "AnimationIteration"),
      animationstart: tp("Animation", "AnimationStart"),
      transitionend: tp("Transition", "TransitionEnd"),
    },
    Kv = {},
    xE = {};
  Ns && (xE = document.createElement("div").style,
    "AnimationEvent" in window ||
    (delete lu.animationend.animation,
      delete lu.animationiteration.animation,
      delete lu.animationstart.animation),
    "TransitionEvent" in window || delete lu.transitionend.transition);
  function np(n) {
    if (Kv[n]) return Kv[n];
    if (!lu[n]) return n;
    var e = lu[n], t;
    for (t in e) if (e.hasOwnProperty(t) && t in xE) return Kv[n] = e[t];
    return n;
  }
  var _E = np("animationend"),
    SE = np("animationiteration"),
    wE = np("animationstart"),
    ME = np("transitionend"),
    EE = new Map(),
    TE =
      "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel"
        .split(" ");
  function Ro(n, e) {
    EE.set(n, e), Fa(e, [n]);
  }
  for (rp = 0; rp < TE.length; rp++) {
    ip = TE[rp],
      AE = ip.toLowerCase(),
      CE = ip[0].toUpperCase() + ip.slice(1),
      Ro(AE, "on" + CE);
  }
  var ip, AE, CE, rp;
  Ro(_E, "onAnimationEnd");
  Ro(SE, "onAnimationIteration");
  Ro(wE, "onAnimationStart");
  Ro("dblclick", "onDoubleClick");
  Ro("focusin", "onFocus");
  Ro("focusout", "onBlur");
  Ro(ME, "onTransitionEnd");
  Jl("onMouseEnter", ["mouseout", "mouseover"]);
  Jl("onMouseLeave", ["mouseout", "mouseover"]);
  Jl("onPointerEnter", ["pointerout", "pointerover"]);
  Jl("onPointerLeave", ["pointerout", "pointerover"]);
  Fa(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(
      " ",
    ),
  );
  Fa(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange"
      .split(" "),
  );
  Fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  Fa(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" "),
  );
  Fa(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" "),
  );
  Fa(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" "),
  );
  var vf =
      "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting"
        .split(" "),
    kI = new Set(
      "cancel close invalid load scroll toggle".split(" ").concat(vf),
    );
  function bE(n, e, t) {
    var r = n.type || "unknown-event";
    n.currentTarget = t, kP(r, e, void 0, n), n.currentTarget = null;
  }
  function RE(n, e) {
    e = (e & 4) != 0;
    for (var t = 0; t < n.length; t++) {
      var r = n[t], i = r.event;
      r = r.listeners;
      e: {
        var s = void 0;
        if (e) {
          for (var o = r.length - 1; 0 <= o; o--) {
            var a = r[o], u = a.instance, f = a.currentTarget;
            if (a = a.listener, u !== s && i.isPropagationStopped()) break e;
            bE(i, a, f), s = u;
          }
        } else {for (o = 0; o < r.length; o++) {
            if (
              a = r[o],
                u = a.instance,
                f = a.currentTarget,
                a = a.listener,
                u !== s && i.isPropagationStopped()
            ) break e;
            bE(i, a, f), s = u;
          }}
      }
    }
    if (zh) throw n = Lv, zh = !1, Lv = null, n;
  }
  function Gt(n, e) {
    var t = e[iy];
    t === void 0 && (t = e[iy] = new Set());
    var r = n + "__bubble";
    t.has(r) || (LE(e, n, 2, !1), t.add(r));
  }
  function Jv(n, e, t) {
    var r = 0;
    e && (r |= 4), LE(t, n, r, e);
  }
  var sp = "_reactListening" + Math.random().toString(36).slice(2);
  function yf(n) {
    if (!n[sp]) {
      n[sp] = !0,
        cM.forEach(function (t) {
          t !== "selectionchange" && (kI.has(t) || Jv(t, !1, n), Jv(t, !0, n));
        });
      var e = n.nodeType === 9 ? n : n.ownerDocument;
      e === null || e[sp] || (e[sp] = !0, Jv("selectionchange", !1, e));
    }
  }
  function LE(n, e, t, r) {
    switch (QM(e)) {
      case 1:
        var i = JP;
        break;
      case 4:
        i = QP;
        break;
      default:
        i = Ov;
    }
    t = i.bind(null, e, t, n),
      i = void 0,
      !Rv || e !== "touchstart" && e !== "touchmove" && e !== "wheel" ||
      (i = !0),
      r
        ? i !== void 0
          ? n.addEventListener(e, t, { capture: !0, passive: i })
          : n.addEventListener(e, t, !0)
        : i !== void 0
        ? n.addEventListener(e, t, { passive: i })
        : n.addEventListener(e, t, !1);
  }
  function Qv(n, e, t, r, i) {
    var s = r;
    if ((e & 1) == 0 && (e & 2) == 0 && r !== null) {
      e: for (;;) {
        if (r === null) return;
        var o = r.tag;
        if (o === 3 || o === 4) {
          var a = r.stateNode.containerInfo;
          if (a === i || a.nodeType === 8 && a.parentNode === i) break;
          if (o === 4) {
            for (o = r.return; o !== null;) {
              var u = o.tag;
              if (
                (u === 3 || u === 4) &&
                (u = o.stateNode.containerInfo,
                  u === i || u.nodeType === 8 && u.parentNode === i)
              ) return;
              o = o.return;
            }
          }
          for (; a !== null;) {
            if (o = za(a), o === null) return;
            if (u = o.tag, u === 5 || u === 6) {
              r = s = o;
              continue e;
            }
            a = a.parentNode;
          }
        }
        r = r.return;
      }
    }
    DM(function () {
      var f = s, d = Av(t), h = [];
      e: {
        var p = EE.get(n);
        if (p !== void 0) {
          var g = Uv, y = n;
          switch (n) {
            case "keypress":
              if (Zh(t) === 0) break e;
            case "keydown":
            case "keyup":
              g = hI;
              break;
            case "focusin":
              y = "focus", g = Gv;
              break;
            case "focusout":
              y = "blur", g = Gv;
              break;
            case "beforeblur":
            case "afterblur":
              g = Gv;
              break;
            case "click":
              if (t.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              g = tE;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              g = tI;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              g = gI;
              break;
            case _E:
            case SE:
            case wE:
              g = iI;
              break;
            case ME:
              g = yI;
              break;
            case "scroll":
              g = $P;
              break;
            case "wheel":
              g = _I;
              break;
            case "copy":
            case "cut":
            case "paste":
              g = oI;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              g = rE;
          }
          var v = (e & 4) != 0,
            _ = !v && n === "scroll",
            S = v ? p !== null ? p + "Capture" : null : p;
          v = [];
          for (var w = f, M; w !== null;) {
            M = w;
            var T = M.stateNode;
            if (
              M.tag === 5 && T !== null &&
              (M = T,
                S !== null && (T = ef(w, S), T != null && v.push(xf(w, T, M)))),
                _
            ) break;
            w = w.return;
          }
          0 < v.length &&
            (p = new g(p, y, null, t, d), h.push({ event: p, listeners: v }));
        }
      }
      if ((e & 7) == 0) {
        e: {
          if (
            p = n === "mouseover" || n === "pointerover",
              g = n === "mouseout" || n === "pointerout",
              p && t !== Tv && (y = t.relatedTarget || t.fromElement) &&
              (za(y) || y[ks])
          ) break e;
          if (
            (g || p) && (p = d.window === d
              ? d
              : (p = d.ownerDocument)
              ? p.defaultView || p.parentWindow
              : window,
              g
                ? (y = t.relatedTarget || t.toElement,
                  g = f,
                  y = y ? za(y) : null,
                  y !== null &&
                  (_ = Oa(y), y !== _ || y.tag !== 5 && y.tag !== 6) &&
                  (y = null))
                : (g = null, y = f),
              g !== y)
          ) {
            if (
              v = tE,
                T = "onMouseLeave",
                S = "onMouseEnter",
                w = "mouse",
                (n === "pointerout" || n === "pointerover") &&
                (v = rE,
                  T = "onPointerLeave",
                  S = "onPointerEnter",
                  w = "pointer"),
                _ = g == null ? p : fu(g),
                M = y == null ? p : fu(y),
                p = new v(T, w + "leave", g, t, d),
                p.target = _,
                p.relatedTarget = M,
                T = null,
                za(d) === f &&
                (v = new v(S, w + "enter", y, t, d),
                  v.target = M,
                  v.relatedTarget = _,
                  T = v),
                _ = T,
                g && y
            ) {
              t: {
                for (v = g, S = y, w = 0, M = v; M; M = uu(M)) w++;
                for (M = 0, T = S; T; T = uu(T)) M++;
                for (; 0 < w - M;) v = uu(v), w--;
                for (; 0 < M - w;) S = uu(S), M--;
                for (; w--;) {
                  if (v === S || S !== null && v === S.alternate) break t;
                  v = uu(v), S = uu(S);
                }
                v = null;
              }
            } else v = null;
            g !== null && PE(h, p, g, v, !1),
              y !== null && _ !== null && PE(h, _, y, v, !0);
          }
        }
        e: {
          if (
            p = f ? fu(f) : window,
              g = p.nodeName && p.nodeName.toLowerCase(),
              g === "select" || g === "input" && p.type === "file"
          ) { var b = CI; } else if (uE(p)) {
            if (fE) b = PI;
            else {
              b = RI;
              var R = bI;
            }
          } else {(g = p.nodeName) && g.toLowerCase() === "input" &&
              (p.type === "checkbox" || p.type === "radio") && (b = LI);}
          if (b && (b = b(n, f))) {
            cE(h, b, t, d);
            break e;
          }
          R && R(n, p, f),
            n === "focusout" && (R = p._wrapperState) && R.controlled &&
            p.type === "number" && _v(p, "number", p.value);
        }
        switch (R = f ? fu(f) : window, n) {
          case "focusin":
            (uE(R) || R.contentEditable === "true") &&
              (au = R, Yv = f, gf = null);
            break;
          case "focusout":
            gf = Yv = au = null;
            break;
          case "mousedown":
            Zv = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Zv = !1, yE(h, t, d);
            break;
          case "selectionchange":
            if (DI) break;
          case "keydown":
          case "keyup":
            yE(h, t, d);
        }
        var P;
        if (Wv) {
          e: {
            switch (n) {
              case "compositionstart":
                var C = "onCompositionStart";
                break e;
              case "compositionend":
                C = "onCompositionEnd";
                break e;
              case "compositionupdate":
                C = "onCompositionUpdate";
                break e;
            }
            C = void 0;
          }
        } else {ou
            ? aE(n, t) && (C = "onCompositionEnd")
            : n === "keydown" && t.keyCode === 229 &&
              (C = "onCompositionStart");}
        C &&
        (iE && t.locale !== "ko" && (ou || C !== "onCompositionStart"
          ? C === "onCompositionEnd" && ou && (P = $M())
          : (bo = d, Bv = "value" in bo ? bo.value : bo.textContent, ou = !0)),
          R = op(f, C),
          0 < R.length &&
          (C = new nE(C, n, null, t, d),
            h.push({ event: C, listeners: R }),
            P ? C.data = P : (P = lE(t), P !== null && (C.data = P)))),
          (P = wI ? MI(n, t) : EI(n, t)) &&
          (f = op(f, "onBeforeInput"),
            0 < f.length &&
            (d = new nE("onBeforeInput", "beforeinput", null, t, d),
              h.push({ event: d, listeners: f }),
              d.data = P));
      }
      RE(h, e);
    });
  }
  function xf(n, e, t) {
    return { instance: n, listener: e, currentTarget: t };
  }
  function op(n, e) {
    for (var t = e + "Capture", r = []; n !== null;) {
      var i = n, s = i.stateNode;
      i.tag === 5 && s !== null &&
      (i = s,
        s = ef(n, t),
        s != null && r.unshift(xf(n, s, i)),
        s = ef(n, e),
        s != null && r.push(xf(n, s, i))), n = n.return;
    }
    return r;
  }
  function uu(n) {
    if (n === null) return null;
    do n = n.return; while (n && n.tag !== 5);
    return n || null;
  }
  function PE(n, e, t, r, i) {
    for (var s = e._reactName, o = []; t !== null && t !== r;) {
      var a = t, u = a.alternate, f = a.stateNode;
      if (u !== null && u === r) break;
      a.tag === 5 && f !== null &&
      (a = f,
        i
          ? (u = ef(t, s), u != null && o.unshift(xf(t, u, a)))
          : i || (u = ef(t, s), u != null && o.push(xf(t, u, a)))),
        t = t.return;
    }
    o.length !== 0 && n.push({ event: e, listeners: o });
  }
  var FI = /\r\n?/g, OI = /\u0000|\uFFFD/g;
  function IE(n) {
    return (typeof n == "string" ? n : "" + n).replace(
      FI,
      `
`,
    ).replace(OI, "");
  }
  function ap(n, e, t) {
    if (e = IE(e), IE(n) !== e && t) throw Error(he(425));
  }
  function lp() {}
  var $v = null, ey = null;
  function ty(n, e) {
    return n === "textarea" || n === "noscript" ||
      typeof e.children == "string" || typeof e.children == "number" ||
      typeof e.dangerouslySetInnerHTML == "object" &&
        e.dangerouslySetInnerHTML !== null &&
        e.dangerouslySetInnerHTML.__html != null;
  }
  var ny = typeof setTimeout == "function" ? setTimeout : void 0,
    zI = typeof clearTimeout == "function" ? clearTimeout : void 0,
    NE = typeof Promise == "function" ? Promise : void 0,
    BI = typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof NE != "undefined"
      ? function (n) {
        return NE.resolve(null).then(n).catch(UI);
      }
      : ny;
  function UI(n) {
    setTimeout(function () {
      throw n;
    });
  }
  function ry(n, e) {
    var t = e, r = 0;
    do {
      var i = t.nextSibling;
      if (n.removeChild(t), i && i.nodeType === 8) {
        if (t = i.data, t === "/$") {
          if (r === 0) {
            n.removeChild(i), uf(e);
            return;
          }
          r--;
        } else t !== "$" && t !== "$?" && t !== "$!" || r++;
      }
      t = i;
    } while (t);
    uf(e);
  }
  function Lo(n) {
    for (; n != null; n = n.nextSibling) {
      var e = n.nodeType;
      if (e === 1 || e === 3) break;
      if (e === 8) {
        if (e = n.data, e === "$" || e === "$!" || e === "$?") break;
        if (e === "/$") return null;
      }
    }
    return n;
  }
  function DE(n) {
    n = n.previousSibling;
    for (var e = 0; n;) {
      if (n.nodeType === 8) {
        var t = n.data;
        if (t === "$" || t === "$!" || t === "$?") {
          if (e === 0) return n;
          e--;
        } else t === "/$" && e++;
      }
      n = n.previousSibling;
    }
    return null;
  }
  var cu = Math.random().toString(36).slice(2),
    ms = "__reactFiber$" + cu,
    _f = "__reactProps$" + cu,
    ks = "__reactContainer$" + cu,
    iy = "__reactEvents$" + cu,
    VI = "__reactListeners$" + cu,
    HI = "__reactHandles$" + cu;
  function za(n) {
    var e = n[ms];
    if (e) return e;
    for (var t = n.parentNode; t;) {
      if (e = t[ks] || t[ms]) {
        if (
          t = e.alternate, e.child !== null || t !== null && t.child !== null
        ) {
          for (n = DE(n); n !== null;) {
            if (t = n[ms]) return t;
            n = DE(n);
          }
        }
        return e;
      }
      n = t, t = n.parentNode;
    }
    return null;
  }
  function Sf(n) {
    return n = n[ms] || n[ks],
      !n || n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3
        ? null
        : n;
  }
  function fu(n) {
    if (n.tag === 5 || n.tag === 6) return n.stateNode;
    throw Error(he(33));
  }
  function up(n) {
    return n[_f] || null;
  }
  var sy = [], du = -1;
  function Po(n) {
    return { current: n };
  }
  function jt(n) {
    0 > du || (n.current = sy[du], sy[du] = null, du--);
  }
  function Vt(n, e) {
    du++, sy[du] = n.current, n.current = e;
  }
  var Io = {}, $n = Po(Io), Pr = Po(!1), Ba = Io;
  function hu(n, e) {
    var t = n.type.contextTypes;
    if (!t) return Io;
    var r = n.stateNode;
    if (r && r.__reactInternalMemoizedUnmaskedChildContext === e) {
      return r.__reactInternalMemoizedMaskedChildContext;
    }
    var i = {}, s;
    for (s in t) i[s] = e[s];
    return r &&
      (n = n.stateNode,
        n.__reactInternalMemoizedUnmaskedChildContext = e,
        n.__reactInternalMemoizedMaskedChildContext = i),
      i;
  }
  function Ir(n) {
    return n = n.childContextTypes, n != null;
  }
  function cp() {
    jt(Pr), jt($n);
  }
  function kE(n, e, t) {
    if ($n.current !== Io) throw Error(he(168));
    Vt($n, e), Vt(Pr, t);
  }
  function FE(n, e, t) {
    var r = n.stateNode;
    if (e = e.childContextTypes, typeof r.getChildContext != "function") {
      return t;
    }
    r = r.getChildContext();
    for (var i in r) if (!(i in e)) throw Error(he(108, bP(n) || "Unknown", i));
    return sn({}, t, r);
  }
  function fp(n) {
    return n =
      (n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext || Io,
      Ba = $n.current,
      Vt($n, n),
      Vt(Pr, Pr.current),
      !0;
  }
  function OE(n, e, t) {
    var r = n.stateNode;
    if (!r) throw Error(he(169));
    t
      ? (n = FE(n, e, Ba),
        r.__reactInternalMemoizedMergedChildContext = n,
        jt(Pr),
        jt($n),
        Vt($n, n))
      : jt(Pr), Vt(Pr, t);
  }
  var Fs = null, dp = !1, oy = !1;
  function zE(n) {
    Fs === null ? Fs = [n] : Fs.push(n);
  }
  function GI(n) {
    dp = !0, zE(n);
  }
  function No() {
    if (!oy && Fs !== null) {
      oy = !0;
      var n = 0, e = Dt;
      try {
        var t = Fs;
        for (Dt = 1; n < t.length; n++) {
          var r = t[n];
          do r = r(!0); while (r !== null);
        }
        Fs = null, dp = !1;
      } catch (i) {
        throw Fs !== null && (Fs = Fs.slice(n + 1)), BM(Pv, No), i;
      } finally {
        Dt = e, oy = !1;
      }
    }
    return null;
  }
  var pu = [],
    mu = 0,
    hp = null,
    pp = 0,
    vi = [],
    yi = 0,
    Ua = null,
    Os = 1,
    zs = "";
  function Va(n, e) {
    pu[mu++] = pp, pu[mu++] = hp, hp = n, pp = e;
  }
  function BE(n, e, t) {
    vi[yi++] = Os, vi[yi++] = zs, vi[yi++] = Ua, Ua = n;
    var r = Os;
    n = zs;
    var i = 32 - Fi(r) - 1;
    r &= ~(1 << i), t += 1;
    var s = 32 - Fi(e) + i;
    if (30 < s) {
      var o = i - i % 5;
      s = (r & (1 << o) - 1).toString(32),
        r >>= o,
        i -= o,
        Os = 1 << 32 - Fi(e) + i | t << i | r,
        zs = s + n;
    } else Os = 1 << s | t << i | r, zs = n;
  }
  function ay(n) {
    n.return !== null && (Va(n, 1), BE(n, 1, 0));
  }
  function ly(n) {
    for (; n === hp;) {
      hp = pu[--mu], pu[mu] = null, pp = pu[--mu], pu[mu] = null;
    }
    for (; n === Ua;) {
      Ua = vi[--yi],
        vi[yi] = null,
        zs = vi[--yi],
        vi[yi] = null,
        Os = vi[--yi],
        vi[yi] = null;
    }
  }
  var Xr = null, qr = null, Kt = !1, zi = null;
  function UE(n, e) {
    var t = wi(5, null, null, 0);
    t.elementType = "DELETED",
      t.stateNode = e,
      t.return = n,
      e = n.deletions,
      e === null ? (n.deletions = [t], n.flags |= 16) : e.push(t);
  }
  function VE(n, e) {
    switch (n.tag) {
      case 5:
        var t = n.type;
        return e =
          e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e,
          e !== null
            ? (n.stateNode = e, Xr = n, qr = Lo(e.firstChild), !0)
            : !1;
      case 6:
        return e = n.pendingProps === "" || e.nodeType !== 3 ? null : e,
          e !== null ? (n.stateNode = e, Xr = n, qr = null, !0) : !1;
      case 13:
        return e = e.nodeType !== 8 ? null : e,
          e !== null
            ? (t = Ua !== null ? { id: Os, overflow: zs } : null,
              n.memoizedState = {
                dehydrated: e,
                treeContext: t,
                retryLane: 1073741824,
              },
              t = wi(18, null, null, 0),
              t.stateNode = e,
              t.return = n,
              n.child = t,
              Xr = n,
              qr = null,
              !0)
            : !1;
      default:
        return !1;
    }
  }
  function uy(n) {
    return (n.mode & 1) != 0 && (n.flags & 128) == 0;
  }
  function cy(n) {
    if (Kt) {
      var e = qr;
      if (e) {
        var t = e;
        if (!VE(n, e)) {
          if (uy(n)) throw Error(he(418));
          e = Lo(t.nextSibling);
          var r = Xr;
          e && VE(n, e)
            ? UE(r, t)
            : (n.flags = n.flags & -4097 | 2, Kt = !1, Xr = n);
        }
      } else {
        if (uy(n)) throw Error(he(418));
        n.flags = n.flags & -4097 | 2, Kt = !1, Xr = n;
      }
    }
  }
  function HE(n) {
    for (
      n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13;
    ) n = n.return;
    Xr = n;
  }
  function mp(n) {
    if (n !== Xr) return !1;
    if (!Kt) return HE(n), Kt = !0, !1;
    var e;
    if (
      (e = n.tag !== 3) && !(e = n.tag !== 5) &&
      (e = n.type,
        e = e !== "head" && e !== "body" && !ty(n.type, n.memoizedProps)),
        e && (e = qr)
    ) {
      if (uy(n)) throw GE(), Error(he(418));
      for (; e;) UE(n, e), e = Lo(e.nextSibling);
    }
    if (HE(n), n.tag === 13) {
      if (n = n.memoizedState, n = n !== null ? n.dehydrated : null, !n) {
        throw Error(he(317));
      }
      e: {
        for (n = n.nextSibling, e = 0; n;) {
          if (n.nodeType === 8) {
            var t = n.data;
            if (t === "/$") {
              if (e === 0) {
                qr = Lo(n.nextSibling);
                break e;
              }
              e--;
            } else t !== "$" && t !== "$!" && t !== "$?" || e++;
          }
          n = n.nextSibling;
        }
        qr = null;
      }
    } else qr = Xr ? Lo(n.stateNode.nextSibling) : null;
    return !0;
  }
  function GE() {
    for (var n = qr; n;) n = Lo(n.nextSibling);
  }
  function gu() {
    qr = Xr = null, Kt = !1;
  }
  function fy(n) {
    zi === null ? zi = [n] : zi.push(n);
  }
  var jI = Ds.ReactCurrentBatchConfig;
  function Bi(n, e) {
    if (n && n.defaultProps) {
      e = sn({}, e), n = n.defaultProps;
      for (var t in n) e[t] === void 0 && (e[t] = n[t]);
      return e;
    }
    return e;
  }
  var gp = Po(null), vp = null, vu = null, dy = null;
  function hy() {
    dy = vu = vp = null;
  }
  function py(n) {
    var e = gp.current;
    jt(gp), n._currentValue = e;
  }
  function my(n, e, t) {
    for (; n !== null;) {
      var r = n.alternate;
      if (
        (n.childLanes & e) !== e
          ? (n.childLanes |= e, r !== null && (r.childLanes |= e))
          : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e),
          n === t
      ) break;
      n = n.return;
    }
  }
  function yu(n, e) {
    vp = n,
      dy = vu = null,
      n = n.dependencies,
      n !== null && n.firstContext !== null &&
      ((n.lanes & e) != 0 && (Nr = !0), n.firstContext = null);
  }
  function xi(n) {
    var e = n._currentValue;
    if (dy !== n) {
      if (n = { context: n, memoizedValue: e, next: null }, vu === null) {
        if (vp === null) {
          throw Error(he(308));
        }
        vu = n, vp.dependencies = { lanes: 0, firstContext: n };
      } else vu = vu.next = n;
    }
    return e;
  }
  var Ha = null;
  function gy(n) {
    Ha === null ? Ha = [n] : Ha.push(n);
  }
  function jE(n, e, t, r) {
    var i = e.interleaved;
    return i === null ? (t.next = t, gy(e)) : (t.next = i.next, i.next = t),
      e.interleaved = t,
      Bs(n, r);
  }
  function Bs(n, e) {
    n.lanes |= e;
    var t = n.alternate;
    for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null;) {
      n.childLanes |= e,
        t = n.alternate,
        t !== null && (t.childLanes |= e),
        t = n,
        n = n.return;
    }
    return t.tag === 3 ? t.stateNode : null;
  }
  var Do = !1;
  function vy(n) {
    n.updateQueue = {
      baseState: n.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function WE(n, e) {
    n = n.updateQueue,
      e.updateQueue === n &&
      (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects,
      });
  }
  function Us(n, e) {
    return {
      eventTime: n,
      lane: e,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function ko(n, e, t) {
    var r = n.updateQueue;
    if (r === null) return null;
    if (r = r.shared, (vt & 2) != 0) {
      var i = r.pending;
      return i === null ? e.next = e : (e.next = i.next, i.next = e),
        r.pending = e,
        Bs(n, t);
    }
    return i = r.interleaved,
      i === null ? (e.next = e, gy(r)) : (e.next = i.next, i.next = e),
      r.interleaved = e,
      Bs(n, t);
  }
  function yp(n, e, t) {
    if (e = e.updateQueue, e !== null && (e = e.shared, (t & 4194240) != 0)) {
      var r = e.lanes;
      r &= n.pendingLanes, t |= r, e.lanes = t, Dv(n, t);
    }
  }
  function XE(n, e) {
    var t = n.updateQueue, r = n.alternate;
    if (r !== null && (r = r.updateQueue, t === r)) {
      var i = null, s = null;
      if (t = t.firstBaseUpdate, t !== null) {
        do {
          var o = {
            eventTime: t.eventTime,
            lane: t.lane,
            tag: t.tag,
            payload: t.payload,
            callback: t.callback,
            next: null,
          };
          s === null ? i = s = o : s = s.next = o, t = t.next;
        } while (t !== null);
        s === null ? i = s = e : s = s.next = e;
      } else i = s = e;
      t = {
        baseState: r.baseState,
        firstBaseUpdate: i,
        lastBaseUpdate: s,
        shared: r.shared,
        effects: r.effects,
      }, n.updateQueue = t;
      return;
    }
    n = t.lastBaseUpdate,
      n === null ? t.firstBaseUpdate = e : n.next = e,
      t.lastBaseUpdate = e;
  }
  function xp(n, e, t, r) {
    var i = n.updateQueue;
    Do = !1;
    var s = i.firstBaseUpdate, o = i.lastBaseUpdate, a = i.shared.pending;
    if (a !== null) {
      i.shared.pending = null;
      var u = a, f = u.next;
      u.next = null, o === null ? s = f : o.next = f, o = u;
      var d = n.alternate;
      d !== null &&
        (d = d.updateQueue,
          a = d.lastBaseUpdate,
          a !== o &&
          (a === null ? d.firstBaseUpdate = f : a.next = f,
            d.lastBaseUpdate = u));
    }
    if (s !== null) {
      var h = i.baseState;
      o = 0, d = f = u = null, a = s;
      do {
        var p = a.lane, g = a.eventTime;
        if ((r & p) === p) {
          d !== null &&
            (d = d.next = {
              eventTime: g,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            });
          e: {
            var y = n, v = a;
            switch (p = e, g = t, v.tag) {
              case 1:
                if (y = v.payload, typeof y == "function") {
                  h = y.call(g, h, p);
                  break e;
                }
                h = y;
                break e;
              case 3:
                y.flags = y.flags & -65537 | 128;
              case 0:
                if (
                  y = v.payload,
                    p = typeof y == "function" ? y.call(g, h, p) : y,
                    p == null
                ) break e;
                h = sn({}, h, p);
                break e;
              case 2:
                Do = !0;
            }
          }
          a.callback !== null && a.lane !== 0 &&
            (n.flags |= 64,
              p = i.effects,
              p === null ? i.effects = [a] : p.push(a));
        } else {g = {
            eventTime: g,
            lane: p,
            tag: a.tag,
            payload: a.payload,
            callback: a.callback,
            next: null,
          },
            d === null ? (f = d = g, u = h) : d = d.next = g,
            o |= p;}
        if (a = a.next, a === null) {
          if (a = i.shared.pending, a === null) break;
          p = a,
            a = p.next,
            p.next = null,
            i.lastBaseUpdate = p,
            i.shared.pending = null;
        }
      } while (1);
      if (
        d === null && (u = h),
          i.baseState = u,
          i.firstBaseUpdate = f,
          i.lastBaseUpdate = d,
          e = i.shared.interleaved,
          e !== null
      ) {
        i = e;
        do o |= i.lane, i = i.next; while (i !== e);
      } else s === null && (i.shared.lanes = 0);
      Wa |= o, n.lanes = o, n.memoizedState = h;
    }
  }
  function qE(n, e, t) {
    if (n = e.effects, e.effects = null, n !== null) {
      for (e = 0; e < n.length; e++) {
        var r = n[e], i = r.callback;
        if (i !== null) {
          if (r.callback = null, r = t, typeof i != "function") {
            throw Error(he(191, i));
          }
          i.call(r);
        }
      }
    }
  }
  var YE = new uM.Component().refs;
  function yy(n, e, t, r) {
    e = n.memoizedState,
      t = t(r, e),
      t = t == null ? e : sn({}, e, t),
      n.memoizedState = t,
      n.lanes === 0 && (n.updateQueue.baseState = t);
  }
  var _p = {
    isMounted: function (n) {
      return (n = n._reactInternals) ? Oa(n) === n : !1;
    },
    enqueueSetState: function (n, e, t) {
      n = n._reactInternals;
      var r = pr(), i = Bo(n), s = Us(r, i);
      s.payload = e,
        t != null && (s.callback = t),
        e = ko(n, s, i),
        e !== null && (Hi(e, n, i, r), yp(e, n, i));
    },
    enqueueReplaceState: function (n, e, t) {
      n = n._reactInternals;
      var r = pr(), i = Bo(n), s = Us(r, i);
      s.tag = 1,
        s.payload = e,
        t != null && (s.callback = t),
        e = ko(n, s, i),
        e !== null && (Hi(e, n, i, r), yp(e, n, i));
    },
    enqueueForceUpdate: function (n, e) {
      n = n._reactInternals;
      var t = pr(), r = Bo(n), i = Us(t, r);
      i.tag = 2,
        e != null && (i.callback = e),
        e = ko(n, i, r),
        e !== null && (Hi(e, n, r, t), yp(e, n, r));
    },
  };
  function ZE(n, e, t, r, i, s, o) {
    return n = n.stateNode,
      typeof n.shouldComponentUpdate == "function"
        ? n.shouldComponentUpdate(r, s, o)
        : e.prototype && e.prototype.isPureReactComponent
        ? !mf(t, r) || !mf(i, s)
        : !0;
  }
  function KE(n, e, t) {
    var r = !1, i = Io, s = e.contextType;
    return typeof s == "object" && s !== null
      ? s = xi(s)
      : (i = Ir(e) ? Ba : $n.current,
        r = e.contextTypes,
        s = (r = r != null) ? hu(n, i) : Io),
      e = new e(t, s),
      n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null,
      e.updater = _p,
      n.stateNode = e,
      e._reactInternals = n,
      r &&
      (n = n.stateNode,
        n.__reactInternalMemoizedUnmaskedChildContext = i,
        n.__reactInternalMemoizedMaskedChildContext = s),
      e;
  }
  function JE(n, e, t, r) {
    n = e.state,
      typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(t, r),
      typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(t, r),
      e.state !== n && _p.enqueueReplaceState(e, e.state, null);
  }
  function xy(n, e, t, r) {
    var i = n.stateNode;
    i.props = t, i.state = n.memoizedState, i.refs = YE, vy(n);
    var s = e.contextType;
    typeof s == "object" && s !== null
      ? i.context = xi(s)
      : (s = Ir(e) ? Ba : $n.current, i.context = hu(n, s)),
      i.state = n.memoizedState,
      s = e.getDerivedStateFromProps,
      typeof s == "function" && (yy(n, e, s, t), i.state = n.memoizedState),
      typeof e.getDerivedStateFromProps == "function" ||
      typeof i.getSnapshotBeforeUpdate == "function" ||
      typeof i.UNSAFE_componentWillMount != "function" &&
        typeof i.componentWillMount != "function" ||
      (e = i.state,
        typeof i.componentWillMount == "function" && i.componentWillMount(),
        typeof i.UNSAFE_componentWillMount == "function" &&
        i.UNSAFE_componentWillMount(),
        e !== i.state && _p.enqueueReplaceState(i, i.state, null),
        xp(n, t, i, r),
        i.state = n.memoizedState),
      typeof i.componentDidMount == "function" && (n.flags |= 4194308);
  }
  function wf(n, e, t) {
    if (
      n = t.ref, n !== null && typeof n != "function" && typeof n != "object"
    ) {
      if (t._owner) {
        if (t = t._owner, t) {
          if (t.tag !== 1) throw Error(he(309));
          var r = t.stateNode;
        }
        if (!r) throw Error(he(147, n));
        var i = r, s = "" + n;
        return e !== null && e.ref !== null && typeof e.ref == "function" &&
            e.ref._stringRef === s
          ? e.ref
          : (e = function (o) {
            var a = i.refs;
            a === YE && (a = i.refs = {}), o === null ? delete a[s] : a[s] = o;
          },
            e._stringRef = s,
            e);
      }
      if (typeof n != "string") throw Error(he(284));
      if (!t._owner) throw Error(he(290, n));
    }
    return n;
  }
  function Sp(n, e) {
    throw n = Object.prototype.toString.call(e),
      Error(
        he(
          31,
          n === "[object Object]"
            ? "object with keys {" + Object.keys(e).join(", ") + "}"
            : n,
        ),
      );
  }
  function QE(n) {
    var e = n._init;
    return e(n._payload);
  }
  function $E(n) {
    function e(S, w) {
      if (n) {
        var M = S.deletions;
        M === null ? (S.deletions = [w], S.flags |= 16) : M.push(w);
      }
    }
    function t(S, w) {
      if (!n) return null;
      for (; w !== null;) e(S, w), w = w.sibling;
      return null;
    }
    function r(S, w) {
      for (S = new Map(); w !== null;) {
        w.key !== null ? S.set(w.key, w) : S.set(w.index, w), w = w.sibling;
      }
      return S;
    }
    function i(S, w) {
      return S = Vo(S, w), S.index = 0, S.sibling = null, S;
    }
    function s(S, w, M) {
      return S.index = M,
        n
          ? (M = S.alternate,
            M !== null
              ? (M = M.index, M < w ? (S.flags |= 2, w) : M)
              : (S.flags |= 2, w))
          : (S.flags |= 1048576, w);
    }
    function o(S) {
      return n && S.alternate === null && (S.flags |= 2), S;
    }
    function a(S, w, M, T) {
      return w === null || w.tag !== 6
        ? (w = nx(M, S.mode, T), w.return = S, w)
        : (w = i(w, M), w.return = S, w);
    }
    function u(S, w, M, T) {
      var b = M.type;
      return b === $l
        ? d(S, w, M.props.children, T, M.key)
        : w !== null &&
            (w.elementType === b ||
              typeof b == "object" && b !== null && b.$$typeof === wo &&
                QE(b) === w.type)
        ? (T = i(w, M.props), T.ref = wf(S, w, M), T.return = S, T)
        : (T = Up(M.type, M.key, M.props, null, S.mode, T),
          T.ref = wf(S, w, M),
          T.return = S,
          T);
    }
    function f(S, w, M, T) {
      return w === null || w.tag !== 4 ||
          w.stateNode.containerInfo !== M.containerInfo ||
          w.stateNode.implementation !== M.implementation
        ? (w = rx(M, S.mode, T), w.return = S, w)
        : (w = i(w, M.children || []), w.return = S, w);
    }
    function d(S, w, M, T, b) {
      return w === null || w.tag !== 7
        ? (w = Za(M, S.mode, T, b), w.return = S, w)
        : (w = i(w, M), w.return = S, w);
    }
    function h(S, w, M) {
      if (typeof w == "string" && w !== "" || typeof w == "number") {
        return w = nx("" + w, S.mode, M), w.return = S, w;
      }
      if (typeof w == "object" && w !== null) {
        switch (w.$$typeof) {
          case Nh:
            return M = Up(w.type, w.key, w.props, null, S.mode, M),
              M.ref = wf(S, null, w),
              M.return = S,
              M;
          case Ql:
            return w = rx(w, S.mode, M), w.return = S, w;
          case wo:
            var T = w._init;
            return h(S, T(w._payload), M);
        }
        if (Jc(w) || Zc(w)) return w = Za(w, S.mode, M, null), w.return = S, w;
        Sp(S, w);
      }
      return null;
    }
    function p(S, w, M, T) {
      var b = w !== null ? w.key : null;
      if (typeof M == "string" && M !== "" || typeof M == "number") {
        return b !== null ? null : a(S, w, "" + M, T);
      }
      if (typeof M == "object" && M !== null) {
        switch (M.$$typeof) {
          case Nh:
            return M.key === b ? u(S, w, M, T) : null;
          case Ql:
            return M.key === b ? f(S, w, M, T) : null;
          case wo:
            return b = M._init, p(S, w, b(M._payload), T);
        }
        if (Jc(M) || Zc(M)) return b !== null ? null : d(S, w, M, T, null);
        Sp(S, M);
      }
      return null;
    }
    function g(S, w, M, T, b) {
      if (typeof T == "string" && T !== "" || typeof T == "number") {
        return S = S.get(M) || null, a(w, S, "" + T, b);
      }
      if (typeof T == "object" && T !== null) {
        switch (T.$$typeof) {
          case Nh:
            return S = S.get(T.key === null ? M : T.key) || null, u(w, S, T, b);
          case Ql:
            return S = S.get(T.key === null ? M : T.key) || null, f(w, S, T, b);
          case wo:
            var R = T._init;
            return g(S, w, M, R(T._payload), b);
        }
        if (Jc(T) || Zc(T)) return S = S.get(M) || null, d(w, S, T, b, null);
        Sp(w, T);
      }
      return null;
    }
    function y(S, w, M, T) {
      for (
        var b = null, R = null, P = w, C = w = 0, L = null;
        P !== null && C < M.length;
        C++
      ) {
        P.index > C ? (L = P, P = null) : L = P.sibling;
        var k = p(S, P, M[C], T);
        if (k === null) {
          P === null && (P = L);
          break;
        }
        n && P && k.alternate === null && e(S, P),
          w = s(k, w, C),
          R === null ? b = k : R.sibling = k,
          R = k,
          P = L;
      }
      if (C === M.length) return t(S, P), Kt && Va(S, C), b;
      if (P === null) {
        for (; C < M.length; C++) {
          P = h(S, M[C], T),
            P !== null &&
            (w = s(P, w, C), R === null ? b = P : R.sibling = P, R = P);
        }
        return Kt && Va(S, C), b;
      }
      for (P = r(S, P); C < M.length; C++) {
        L = g(P, S, C, M[C], T),
          L !== null &&
          (n && L.alternate !== null && P.delete(L.key === null ? C : L.key),
            w = s(L, w, C),
            R === null ? b = L : R.sibling = L,
            R = L);
      }
      return n && P.forEach(function (z) {
        return e(S, z);
      }),
        Kt && Va(S, C),
        b;
    }
    function v(S, w, M, T) {
      var b = Zc(M);
      if (typeof b != "function") throw Error(he(150));
      if (M = b.call(M), M == null) throw Error(he(151));
      for (
        var R = b = null, P = w, C = w = 0, L = null, k = M.next();
        P !== null && !k.done;
        C++, k = M.next()
      ) {
        P.index > C ? (L = P, P = null) : L = P.sibling;
        var z = p(S, P, k.value, T);
        if (z === null) {
          P === null && (P = L);
          break;
        }
        n && P && z.alternate === null && e(S, P),
          w = s(z, w, C),
          R === null ? b = z : R.sibling = z,
          R = z,
          P = L;
      }
      if (k.done) return t(S, P), Kt && Va(S, C), b;
      if (P === null) {
        for (; !k.done; C++, k = M.next()) {
          k = h(S, k.value, T),
            k !== null &&
            (w = s(k, w, C), R === null ? b = k : R.sibling = k, R = k);
        }
        return Kt && Va(S, C), b;
      }
      for (P = r(S, P); !k.done; C++, k = M.next()) {
        k = g(P, S, C, k.value, T),
          k !== null &&
          (n && k.alternate !== null && P.delete(k.key === null ? C : k.key),
            w = s(k, w, C),
            R === null ? b = k : R.sibling = k,
            R = k);
      }
      return n && P.forEach(function (Y) {
        return e(S, Y);
      }),
        Kt && Va(S, C),
        b;
    }
    function _(S, w, M, T) {
      if (
        typeof M == "object" && M !== null && M.type === $l && M.key === null &&
        (M = M.props.children), typeof M == "object" && M !== null
      ) {
        switch (M.$$typeof) {
          case Nh:
            e: {
              for (var b = M.key, R = w; R !== null;) {
                if (R.key === b) {
                  if (b = M.type, b === $l) {
                    if (R.tag === 7) {
                      t(S, R.sibling),
                        w = i(R, M.props.children),
                        w.return = S,
                        S = w;
                      break e;
                    }
                  } else if (
                    R.elementType === b ||
                    typeof b == "object" && b !== null && b.$$typeof === wo &&
                      QE(b) === R.type
                  ) {
                    t(S, R.sibling),
                      w = i(R, M.props),
                      w.ref = wf(S, R, M),
                      w.return = S,
                      S = w;
                    break e;
                  }
                  t(S, R);
                  break;
                } else e(S, R);
                R = R.sibling;
              }
              M.type === $l
                ? (w = Za(M.props.children, S.mode, T, M.key),
                  w.return = S,
                  S = w)
                : (T = Up(M.type, M.key, M.props, null, S.mode, T),
                  T.ref = wf(S, w, M),
                  T.return = S,
                  S = T);
            }
            return o(S);
          case Ql:
            e: {
              for (R = M.key; w !== null;) {
                if (w.key === R) {
                  if (
                    w.tag === 4 &&
                    w.stateNode.containerInfo === M.containerInfo &&
                    w.stateNode.implementation === M.implementation
                  ) {
                    t(S, w.sibling),
                      w = i(w, M.children || []),
                      w.return = S,
                      S = w;
                    break e;
                  } else {
                    t(S, w);
                    break;
                  }
                } else e(S, w);
                w = w.sibling;
              }
              w = rx(M, S.mode, T), w.return = S, S = w;
            }
            return o(S);
          case wo:
            return R = M._init, _(S, w, R(M._payload), T);
        }
        if (Jc(M)) return y(S, w, M, T);
        if (Zc(M)) return v(S, w, M, T);
        Sp(S, M);
      }
      return typeof M == "string" && M !== "" || typeof M == "number"
        ? (M = "" + M,
          w !== null && w.tag === 6
            ? (t(S, w.sibling), w = i(w, M), w.return = S, S = w)
            : (t(S, w), w = nx(M, S.mode, T), w.return = S, S = w),
          o(S))
        : t(S, w);
    }
    return _;
  }
  var xu = $E(!0), eT = $E(!1), Mf = {}, gs = Po(Mf), Ef = Po(Mf), Tf = Po(Mf);
  function Ga(n) {
    if (n === Mf) throw Error(he(174));
    return n;
  }
  function _y(n, e) {
    switch (Vt(Tf, e), Vt(Ef, n), Vt(gs, Mf), n = e.nodeType, n) {
      case 9:
      case 11:
        e = (e = e.documentElement) ? e.namespaceURI : wv(null, "");
        break;
      default:
        n = n === 8 ? e.parentNode : e,
          e = n.namespaceURI || null,
          n = n.tagName,
          e = wv(e, n);
    }
    jt(gs), Vt(gs, e);
  }
  function _u() {
    jt(gs), jt(Ef), jt(Tf);
  }
  function tT(n) {
    Ga(Tf.current);
    var e = Ga(gs.current), t = wv(e, n.type);
    e !== t && (Vt(Ef, n), Vt(gs, t));
  }
  function Sy(n) {
    Ef.current === n && (jt(gs), jt(Ef));
  }
  var on = Po(0);
  function wp(n) {
    for (var e = n; e !== null;) {
      if (e.tag === 13) {
        var t = e.memoizedState;
        if (
          t !== null &&
          (t = t.dehydrated, t === null || t.data === "$?" || t.data === "$!")
        ) return e;
      } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
        if ((e.flags & 128) != 0) {
          return e;
        }
      } else if (e.child !== null) {
        e.child.return = e, e = e.child;
        continue;
      }
      if (e === n) break;
      for (; e.sibling === null;) {
        if (e.return === null || e.return === n) return null;
        e = e.return;
      }
      e.sibling.return = e.return, e = e.sibling;
    }
    return null;
  }
  var wy = [];
  function My() {
    for (var n = 0; n < wy.length; n++) {
      wy[n]._workInProgressVersionPrimary = null;
    }
    wy.length = 0;
  }
  var Mp = Ds.ReactCurrentDispatcher,
    Ey = Ds.ReactCurrentBatchConfig,
    ja = 0,
    an = null,
    Cn = null,
    On = null,
    Ep = !1,
    Af = !1,
    Cf = 0,
    WI = 0;
  function er() {
    throw Error(he(321));
  }
  function Ty(n, e) {
    if (e === null) return !1;
    for (var t = 0; t < e.length && t < n.length; t++) {
      if (!Oi(n[t], e[t])) return !1;
    }
    return !0;
  }
  function Ay(n, e, t, r, i, s) {
    if (
      ja = s,
        an = e,
        e.memoizedState = null,
        e.updateQueue = null,
        e.lanes = 0,
        Mp.current = n === null || n.memoizedState === null ? ZI : KI,
        n = t(r, i),
        Af
    ) {
      s = 0;
      do {
        if (Af = !1, Cf = 0, 25 <= s) throw Error(he(301));
        s += 1,
          On = Cn = null,
          e.updateQueue = null,
          Mp.current = JI,
          n = t(r, i);
      } while (Af);
    }
    if (
      Mp.current = Cp,
        e = Cn !== null && Cn.next !== null,
        ja = 0,
        On = Cn = an = null,
        Ep = !1,
        e
    ) throw Error(he(300));
    return n;
  }
  function Cy() {
    var n = Cf !== 0;
    return Cf = 0, n;
  }
  function vs() {
    var n = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return On === null ? an.memoizedState = On = n : On = On.next = n, On;
  }
  function _i() {
    if (Cn === null) {
      var n = an.alternate;
      n = n !== null ? n.memoizedState : null;
    } else n = Cn.next;
    var e = On === null ? an.memoizedState : On.next;
    if (e !== null) On = e, Cn = n;
    else {
      if (n === null) throw Error(he(310));
      Cn = n,
        n = {
          memoizedState: Cn.memoizedState,
          baseState: Cn.baseState,
          baseQueue: Cn.baseQueue,
          queue: Cn.queue,
          next: null,
        },
        On === null ? an.memoizedState = On = n : On = On.next = n;
    }
    return On;
  }
  function bf(n, e) {
    return typeof e == "function" ? e(n) : e;
  }
  function by(n) {
    var e = _i(), t = e.queue;
    if (t === null) throw Error(he(311));
    t.lastRenderedReducer = n;
    var r = Cn, i = r.baseQueue, s = t.pending;
    if (s !== null) {
      if (i !== null) {
        var o = i.next;
        i.next = s.next, s.next = o;
      }
      r.baseQueue = i = s, t.pending = null;
    }
    if (i !== null) {
      s = i.next, r = r.baseState;
      var a = o = null, u = null, f = s;
      do {
        var d = f.lane;
        if ((ja & d) === d) {
          u !== null &&
          (u = u.next = {
            lane: 0,
            action: f.action,
            hasEagerState: f.hasEagerState,
            eagerState: f.eagerState,
            next: null,
          }), r = f.hasEagerState ? f.eagerState : n(r, f.action);
        } else {
          var h = {
            lane: d,
            action: f.action,
            hasEagerState: f.hasEagerState,
            eagerState: f.eagerState,
            next: null,
          };
          u === null ? (a = u = h, o = r) : u = u.next = h,
            an.lanes |= d,
            Wa |= d;
        }
        f = f.next;
      } while (f !== null && f !== s);
      u === null ? o = r : u.next = a,
        Oi(r, e.memoizedState) || (Nr = !0),
        e.memoizedState = r,
        e.baseState = o,
        e.baseQueue = u,
        t.lastRenderedState = r;
    }
    if (n = t.interleaved, n !== null) {
      i = n;
      do s = i.lane, an.lanes |= s, Wa |= s, i = i.next; while (i !== n);
    } else i === null && (t.lanes = 0);
    return [e.memoizedState, t.dispatch];
  }
  function Ry(n) {
    var e = _i(), t = e.queue;
    if (t === null) throw Error(he(311));
    t.lastRenderedReducer = n;
    var r = t.dispatch, i = t.pending, s = e.memoizedState;
    if (i !== null) {
      t.pending = null;
      var o = i = i.next;
      do s = n(s, o.action), o = o.next; while (o !== i);
      Oi(s, e.memoizedState) || (Nr = !0),
        e.memoizedState = s,
        e.baseQueue === null && (e.baseState = s),
        t.lastRenderedState = s;
    }
    return [s, r];
  }
  function nT() {}
  function rT(n, e) {
    var t = an, r = _i(), i = e(), s = !Oi(r.memoizedState, i);
    if (
      s && (r.memoizedState = i, Nr = !0),
        r = r.queue,
        Ly(oT.bind(null, t, r, n), [n]),
        r.getSnapshot !== e || s || On !== null && On.memoizedState.tag & 1
    ) {
      if (
        t.flags |= 2048,
          Rf(9, sT.bind(null, t, r, i, e), void 0, null),
          zn === null
      ) throw Error(he(349));
      (ja & 30) != 0 || iT(t, e, i);
    }
    return i;
  }
  function iT(n, e, t) {
    n.flags |= 16384,
      n = { getSnapshot: e, value: t },
      e = an.updateQueue,
      e === null
        ? (e = { lastEffect: null, stores: null },
          an.updateQueue = e,
          e.stores = [n])
        : (t = e.stores, t === null ? e.stores = [n] : t.push(n));
  }
  function sT(n, e, t, r) {
    e.value = t, e.getSnapshot = r, aT(e) && lT(n);
  }
  function oT(n, e, t) {
    return t(function () {
      aT(e) && lT(n);
    });
  }
  function aT(n) {
    var e = n.getSnapshot;
    n = n.value;
    try {
      var t = e();
      return !Oi(n, t);
    } catch {
      return !0;
    }
  }
  function lT(n) {
    var e = Bs(n, 1);
    e !== null && Hi(e, n, 1, -1);
  }
  function uT(n) {
    var e = vs();
    return typeof n == "function" && (n = n()),
      e.memoizedState = e.baseState = n,
      n = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: bf,
        lastRenderedState: n,
      },
      e.queue = n,
      n = n.dispatch = YI.bind(null, an, n),
      [e.memoizedState, n];
  }
  function Rf(n, e, t, r) {
    return n = { tag: n, create: e, destroy: t, deps: r, next: null },
      e = an.updateQueue,
      e === null
        ? (e = { lastEffect: null, stores: null },
          an.updateQueue = e,
          e.lastEffect = n.next = n)
        : (t = e.lastEffect,
          t === null
            ? e.lastEffect = n.next = n
            : (r = t.next, t.next = n, n.next = r, e.lastEffect = n)),
      n;
  }
  function cT() {
    return _i().memoizedState;
  }
  function Tp(n, e, t, r) {
    var i = vs();
    an.flags |= n,
      i.memoizedState = Rf(1 | e, t, void 0, r === void 0 ? null : r);
  }
  function Ap(n, e, t, r) {
    var i = _i();
    r = r === void 0 ? null : r;
    var s = void 0;
    if (Cn !== null) {
      var o = Cn.memoizedState;
      if (s = o.destroy, r !== null && Ty(r, o.deps)) {
        i.memoizedState = Rf(e, t, s, r);
        return;
      }
    }
    an.flags |= n, i.memoizedState = Rf(1 | e, t, s, r);
  }
  function fT(n, e) {
    return Tp(8390656, 8, n, e);
  }
  function Ly(n, e) {
    return Ap(2048, 8, n, e);
  }
  function dT(n, e) {
    return Ap(4, 2, n, e);
  }
  function hT(n, e) {
    return Ap(4, 4, n, e);
  }
  function pT(n, e) {
    if (typeof e == "function") {
      return n = n(), e(n), function () {
        e(null);
      };
    }
    if (e != null) {
      return n = n(), e.current = n, function () {
        e.current = null;
      };
    }
  }
  function mT(n, e, t) {
    return t = t != null ? t.concat([n]) : null,
      Ap(4, 4, pT.bind(null, e, n), t);
  }
  function Py() {}
  function gT(n, e) {
    var t = _i();
    e = e === void 0 ? null : e;
    var r = t.memoizedState;
    return r !== null && e !== null && Ty(e, r[1])
      ? r[0]
      : (t.memoizedState = [n, e], n);
  }
  function vT(n, e) {
    var t = _i();
    e = e === void 0 ? null : e;
    var r = t.memoizedState;
    return r !== null && e !== null && Ty(e, r[1])
      ? r[0]
      : (n = n(), t.memoizedState = [n, e], n);
  }
  function yT(n, e, t) {
    return (ja & 21) == 0
      ? (n.baseState && (n.baseState = !1, Nr = !0), n.memoizedState = t)
      : (Oi(t, e) || (t = GM(), an.lanes |= t, Wa |= t, n.baseState = !0), e);
  }
  function XI(n, e) {
    var t = Dt;
    Dt = t !== 0 && 4 > t ? t : 4, n(!0);
    var r = Ey.transition;
    Ey.transition = {};
    try {
      n(!1), e();
    } finally {
      Dt = t, Ey.transition = r;
    }
  }
  function xT() {
    return _i().memoizedState;
  }
  function qI(n, e, t) {
    var r = Bo(n);
    if (
      t = {
        lane: r,
        action: t,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }, _T(n)
    ) ST(e, t);
    else if (t = jE(n, e, t, r), t !== null) {
      var i = pr();
      Hi(t, n, r, i), wT(t, e, r);
    }
  }
  function YI(n, e, t) {
    var r = Bo(n),
      i = {
        lane: r,
        action: t,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (_T(n)) ST(e, i);
    else {
      var s = n.alternate;
      if (
        n.lanes === 0 && (s === null || s.lanes === 0) &&
        (s = e.lastRenderedReducer, s !== null)
      ) {
        try {
          var o = e.lastRenderedState, a = s(o, t);
          if (i.hasEagerState = !0, i.eagerState = a, Oi(a, o)) {
            var u = e.interleaved;
            u === null ? (i.next = i, gy(e)) : (i.next = u.next, u.next = i),
              e.interleaved = i;
            return;
          }
        } catch {
        } finally {
        }
      }
      t = jE(n, e, i, r), t !== null && (i = pr(), Hi(t, n, r, i), wT(t, e, r));
    }
  }
  function _T(n) {
    var e = n.alternate;
    return n === an || e !== null && e === an;
  }
  function ST(n, e) {
    Af = Ep = !0;
    var t = n.pending;
    t === null ? e.next = e : (e.next = t.next, t.next = e), n.pending = e;
  }
  function wT(n, e, t) {
    if ((t & 4194240) != 0) {
      var r = e.lanes;
      r &= n.pendingLanes, t |= r, e.lanes = t, Dv(n, t);
    }
  }
  var Cp = {
      readContext: xi,
      useCallback: er,
      useContext: er,
      useEffect: er,
      useImperativeHandle: er,
      useInsertionEffect: er,
      useLayoutEffect: er,
      useMemo: er,
      useReducer: er,
      useRef: er,
      useState: er,
      useDebugValue: er,
      useDeferredValue: er,
      useTransition: er,
      useMutableSource: er,
      useSyncExternalStore: er,
      useId: er,
      unstable_isNewReconciler: !1,
    },
    ZI = {
      readContext: xi,
      useCallback: function (n, e) {
        return vs().memoizedState = [n, e === void 0 ? null : e], n;
      },
      useContext: xi,
      useEffect: fT,
      useImperativeHandle: function (n, e, t) {
        return t = t != null ? t.concat([n]) : null,
          Tp(4194308, 4, pT.bind(null, e, n), t);
      },
      useLayoutEffect: function (n, e) {
        return Tp(4194308, 4, n, e);
      },
      useInsertionEffect: function (n, e) {
        return Tp(4, 2, n, e);
      },
      useMemo: function (n, e) {
        var t = vs();
        return e = e === void 0 ? null : e,
          n = n(),
          t.memoizedState = [n, e],
          n;
      },
      useReducer: function (n, e, t) {
        var r = vs();
        return e = t !== void 0 ? t(e) : e,
          r.memoizedState = r.baseState = e,
          n = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: n,
            lastRenderedState: e,
          },
          r.queue = n,
          n = n.dispatch = qI.bind(null, an, n),
          [r.memoizedState, n];
      },
      useRef: function (n) {
        var e = vs();
        return n = { current: n }, e.memoizedState = n;
      },
      useState: uT,
      useDebugValue: Py,
      useDeferredValue: function (n) {
        return vs().memoizedState = n;
      },
      useTransition: function () {
        var n = uT(!1), e = n[0];
        return n = XI.bind(null, n[1]), vs().memoizedState = n, [e, n];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (n, e, t) {
        var r = an, i = vs();
        if (Kt) {
          if (t === void 0) throw Error(he(407));
          t = t();
        } else {
          if (t = e(), zn === null) throw Error(he(349));
          (ja & 30) != 0 || iT(r, e, t);
        }
        i.memoizedState = t;
        var s = { value: t, getSnapshot: e };
        return i.queue = s,
          fT(oT.bind(null, r, s, n), [n]),
          r.flags |= 2048,
          Rf(9, sT.bind(null, r, s, t, e), void 0, null),
          t;
      },
      useId: function () {
        var n = vs(), e = zn.identifierPrefix;
        if (Kt) {
          var t = zs, r = Os;
          t = (r & ~(1 << 32 - Fi(r) - 1)).toString(32) + t,
            e = ":" + e + "R" + t,
            t = Cf++,
            0 < t && (e += "H" + t.toString(32)),
            e += ":";
        } else t = WI++, e = ":" + e + "r" + t.toString(32) + ":";
        return n.memoizedState = e;
      },
      unstable_isNewReconciler: !1,
    },
    KI = {
      readContext: xi,
      useCallback: gT,
      useContext: xi,
      useEffect: Ly,
      useImperativeHandle: mT,
      useInsertionEffect: dT,
      useLayoutEffect: hT,
      useMemo: vT,
      useReducer: by,
      useRef: cT,
      useState: function () {
        return by(bf);
      },
      useDebugValue: Py,
      useDeferredValue: function (n) {
        var e = _i();
        return yT(e, Cn.memoizedState, n);
      },
      useTransition: function () {
        var n = by(bf)[0], e = _i().memoizedState;
        return [n, e];
      },
      useMutableSource: nT,
      useSyncExternalStore: rT,
      useId: xT,
      unstable_isNewReconciler: !1,
    },
    JI = {
      readContext: xi,
      useCallback: gT,
      useContext: xi,
      useEffect: Ly,
      useImperativeHandle: mT,
      useInsertionEffect: dT,
      useLayoutEffect: hT,
      useMemo: vT,
      useReducer: Ry,
      useRef: cT,
      useState: function () {
        return Ry(bf);
      },
      useDebugValue: Py,
      useDeferredValue: function (n) {
        var e = _i();
        return Cn === null ? e.memoizedState = n : yT(e, Cn.memoizedState, n);
      },
      useTransition: function () {
        var n = Ry(bf)[0], e = _i().memoizedState;
        return [n, e];
      },
      useMutableSource: nT,
      useSyncExternalStore: rT,
      useId: xT,
      unstable_isNewReconciler: !1,
    };
  function Su(n, e) {
    try {
      var t = "", r = e;
      do t += CP(r), r = r.return; while (r);
      var i = t;
    } catch (s) {
      i = `
Error generating stack: ` + s.message + `
` + s.stack;
    }
    return { value: n, source: e, stack: i, digest: null };
  }
  function Iy(n, e, t) {
    return { value: n, source: null, stack: t ?? null, digest: e ?? null };
  }
  function Ny(n, e) {
    try {
      console.error(e.value);
    } catch (t) {
      setTimeout(function () {
        throw t;
      });
    }
  }
  var QI = typeof WeakMap == "function" ? WeakMap : Map;
  function MT(n, e, t) {
    t = Us(-1, t), t.tag = 3, t.payload = { element: null };
    var r = e.value;
    return t.callback = function () {
      Dp || (Dp = !0, Yy = r), Ny(n, e);
    },
      t;
  }
  function ET(n, e, t) {
    t = Us(-1, t), t.tag = 3;
    var r = n.type.getDerivedStateFromError;
    if (typeof r == "function") {
      var i = e.value;
      t.payload = function () {
        return r(i);
      },
        t.callback = function () {
          Ny(n, e);
        };
    }
    var s = n.stateNode;
    return s !== null && typeof s.componentDidCatch == "function" &&
      (t.callback = function () {
        Ny(n, e),
          typeof r != "function" &&
          (Oo === null ? Oo = new Set([this]) : Oo.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: o !== null ? o : "",
        });
      }),
      t;
  }
  function TT(n, e, t) {
    var r = n.pingCache;
    if (r === null) {
      r = n.pingCache = new QI();
      var i = new Set();
      r.set(e, i);
    } else i = r.get(e), i === void 0 && (i = new Set(), r.set(e, i));
    i.has(t) || (i.add(t), n = dN.bind(null, n, e, t), e.then(n, n));
  }
  function AT(n) {
    do {
      var e;
      if (
        (e = n.tag === 13) &&
        (e = n.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e
      ) return n;
      n = n.return;
    } while (n !== null);
    return null;
  }
  function CT(n, e, t, r, i) {
    return (n.mode & 1) == 0
      ? (n === e
        ? n.flags |= 65536
        : (n.flags |= 128,
          t.flags |= 131072,
          t.flags &= -52805,
          t.tag === 1 && (t.alternate === null
            ? t.tag = 17
            : (e = Us(-1, 1), e.tag = 2, ko(t, e, 1))),
          t.lanes |= 1),
        n)
      : (n.flags |= 65536, n.lanes = i, n);
  }
  var $I = Ds.ReactCurrentOwner, Nr = !1;
  function hr(n, e, t, r) {
    e.child = n === null ? eT(e, null, t, r) : xu(e, n.child, t, r);
  }
  function bT(n, e, t, r, i) {
    t = t.render;
    var s = e.ref;
    return yu(e, i),
      r = Ay(n, e, t, r, s, i),
      t = Cy(),
      n !== null && !Nr
        ? (e.updateQueue = n.updateQueue,
          e.flags &= -2053,
          n.lanes &= ~i,
          Vs(n, e, i))
        : (Kt && t && ay(e), e.flags |= 1, hr(n, e, r, i), e.child);
  }
  function RT(n, e, t, r, i) {
    if (n === null) {
      var s = t.type;
      return typeof s == "function" && !tx(s) && s.defaultProps === void 0 &&
          t.compare === null && t.defaultProps === void 0
        ? (e.tag = 15, e.type = s, LT(n, e, s, r, i))
        : (n = Up(t.type, null, r, e, e.mode, i),
          n.ref = e.ref,
          n.return = e,
          e.child = n);
    }
    if (s = n.child, (n.lanes & i) == 0) {
      var o = s.memoizedProps;
      if (t = t.compare, t = t !== null ? t : mf, t(o, r) && n.ref === e.ref) {
        return Vs(n, e, i);
      }
    }
    return e.flags |= 1, n = Vo(s, r), n.ref = e.ref, n.return = e, e.child = n;
  }
  function LT(n, e, t, r, i) {
    if (n !== null) {
      var s = n.memoizedProps;
      if (mf(s, r) && n.ref === e.ref) {
        if (Nr = !1, e.pendingProps = r = s, (n.lanes & i) != 0) {
          (n.flags & 131072) != 0 && (Nr = !0);
        } else return e.lanes = n.lanes, Vs(n, e, i);
      }
    }
    return Dy(n, e, t, r, i);
  }
  function PT(n, e, t) {
    var r = e.pendingProps,
      i = r.children,
      s = n !== null ? n.memoizedState : null;
    if (r.mode === "hidden") {
      if ((e.mode & 1) == 0) {
        e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null },
          Vt(Mu, Yr),
          Yr |= t;
      } else {
        if ((t & 1073741824) == 0) {
          return n = s !== null ? s.baseLanes | t : t,
            e.lanes = e.childLanes = 1073741824,
            e.memoizedState = {
              baseLanes: n,
              cachePool: null,
              transitions: null,
            },
            e.updateQueue = null,
            Vt(Mu, Yr),
            Yr |= n,
            null;
        }
        e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null },
          r = s !== null ? s.baseLanes : t,
          Vt(Mu, Yr),
          Yr |= r;
      }
    } else {s !== null ? (r = s.baseLanes | t, e.memoizedState = null) : r = t,
        Vt(Mu, Yr),
        Yr |= r;}
    return hr(n, e, i, t), e.child;
  }
  function IT(n, e) {
    var t = e.ref;
    (n === null && t !== null || n !== null && n.ref !== t) &&
      (e.flags |= 512, e.flags |= 2097152);
  }
  function Dy(n, e, t, r, i) {
    var s = Ir(t) ? Ba : $n.current;
    return s = hu(e, s),
      yu(e, i),
      t = Ay(n, e, t, r, s, i),
      r = Cy(),
      n !== null && !Nr
        ? (e.updateQueue = n.updateQueue,
          e.flags &= -2053,
          n.lanes &= ~i,
          Vs(n, e, i))
        : (Kt && r && ay(e), e.flags |= 1, hr(n, e, t, i), e.child);
  }
  function NT(n, e, t, r, i) {
    if (Ir(t)) {
      var s = !0;
      fp(e);
    } else s = !1;
    if (yu(e, i), e.stateNode === null) {
      Rp(n, e), KE(e, t, r), xy(e, t, r, i), r = !0;
    } else if (n === null) {
      var o = e.stateNode, a = e.memoizedProps;
      o.props = a;
      var u = o.context, f = t.contextType;
      typeof f == "object" && f !== null
        ? f = xi(f)
        : (f = Ir(t) ? Ba : $n.current, f = hu(e, f));
      var d = t.getDerivedStateFromProps,
        h = typeof d == "function" ||
          typeof o.getSnapshotBeforeUpdate == "function";
      h ||
      typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function" ||
      (a !== r || u !== f) && JE(e, o, r, f), Do = !1;
      var p = e.memoizedState;
      o.state = p,
        xp(e, r, o, i),
        u = e.memoizedState,
        a !== r || p !== u || Pr.current || Do
          ? (typeof d == "function" && (yy(e, t, d, r), u = e.memoizedState),
            (a = Do || ZE(e, t, a, r, p, u, f))
              ? (h ||
                typeof o.UNSAFE_componentWillMount != "function" &&
                  typeof o.componentWillMount != "function" ||
                (typeof o.componentWillMount == "function" &&
                  o.componentWillMount(),
                  typeof o.UNSAFE_componentWillMount == "function" &&
                  o.UNSAFE_componentWillMount()),
                typeof o.componentDidMount == "function" &&
                (e.flags |= 4194308))
              : (typeof o.componentDidMount == "function" &&
                (e.flags |= 4194308),
                e.memoizedProps = r,
                e.memoizedState = u),
            o.props = r,
            o.state = u,
            o.context = f,
            r = a)
          : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
            r = !1);
    } else {
      o = e.stateNode,
        WE(n, e),
        a = e.memoizedProps,
        f = e.type === e.elementType ? a : Bi(e.type, a),
        o.props = f,
        h = e.pendingProps,
        p = o.context,
        u = t.contextType,
        typeof u == "object" && u !== null
          ? u = xi(u)
          : (u = Ir(t) ? Ba : $n.current, u = hu(e, u));
      var g = t.getDerivedStateFromProps;
      (d = typeof g == "function" ||
        typeof o.getSnapshotBeforeUpdate == "function") ||
      typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function" ||
      (a !== h || p !== u) && JE(e, o, r, u),
        Do = !1,
        p = e.memoizedState,
        o.state = p,
        xp(e, r, o, i);
      var y = e.memoizedState;
      a !== h || p !== y || Pr.current || Do
        ? (typeof g == "function" && (yy(e, t, g, r), y = e.memoizedState),
          (f = Do || ZE(e, t, f, r, p, y, u) || !1)
            ? (d ||
              typeof o.UNSAFE_componentWillUpdate != "function" &&
                typeof o.componentWillUpdate != "function" ||
              (typeof o.componentWillUpdate == "function" &&
                o.componentWillUpdate(r, y, u),
                typeof o.UNSAFE_componentWillUpdate == "function" &&
                o.UNSAFE_componentWillUpdate(r, y, u)),
              typeof o.componentDidUpdate == "function" && (e.flags |= 4),
              typeof o.getSnapshotBeforeUpdate == "function" &&
              (e.flags |= 1024))
            : (typeof o.componentDidUpdate != "function" ||
              a === n.memoizedProps && p === n.memoizedState || (e.flags |= 4),
              typeof o.getSnapshotBeforeUpdate != "function" ||
              a === n.memoizedProps && p === n.memoizedState ||
              (e.flags |= 1024),
              e.memoizedProps = r,
              e.memoizedState = y),
          o.props = r,
          o.state = y,
          o.context = u,
          r = f)
        : (typeof o.componentDidUpdate != "function" ||
          a === n.memoizedProps && p === n.memoizedState || (e.flags |= 4),
          typeof o.getSnapshotBeforeUpdate != "function" ||
          a === n.memoizedProps && p === n.memoizedState || (e.flags |= 1024),
          r = !1);
    }
    return ky(n, e, t, r, s, i);
  }
  function ky(n, e, t, r, i, s) {
    IT(n, e);
    var o = (e.flags & 128) != 0;
    if (!r && !o) return i && OE(e, t, !1), Vs(n, e, s);
    r = e.stateNode, $I.current = e;
    var a = o && typeof t.getDerivedStateFromError != "function"
      ? null
      : r.render();
    return e.flags |= 1,
      n !== null && o
        ? (e.child = xu(e, n.child, null, s), e.child = xu(e, null, a, s))
        : hr(n, e, a, s),
      e.memoizedState = r.state,
      i && OE(e, t, !0),
      e.child;
  }
  function DT(n) {
    var e = n.stateNode;
    e.pendingContext
      ? kE(n, e.pendingContext, e.pendingContext !== e.context)
      : e.context && kE(n, e.context, !1), _y(n, e.containerInfo);
  }
  function kT(n, e, t, r, i) {
    return gu(), fy(i), e.flags |= 256, hr(n, e, t, r), e.child;
  }
  var Fy = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Oy(n) {
    return { baseLanes: n, cachePool: null, transitions: null };
  }
  function FT(n, e, t) {
    var r = e.pendingProps, i = on.current, s = !1, o = (e.flags & 128) != 0, a;
    if (
      (a = o) ||
      (a = n !== null && n.memoizedState === null ? !1 : (i & 2) != 0),
        a
          ? (s = !0, e.flags &= -129)
          : (n === null || n.memoizedState !== null) && (i |= 1),
        Vt(on, i & 1),
        n === null
    ) {
      return cy(e),
        n = e.memoizedState,
        n !== null && (n = n.dehydrated, n !== null)
          ? ((e.mode & 1) == 0
            ? e.lanes = 1
            : n.data === "$!"
            ? e.lanes = 8
            : e.lanes = 1073741824,
            null)
          : (o = r.children,
            n = r.fallback,
            s
              ? (r = e.mode,
                s = e.child,
                o = { mode: "hidden", children: o },
                (r & 1) == 0 && s !== null
                  ? (s.childLanes = 0, s.pendingProps = o)
                  : s = Vp(o, r, 0, null),
                n = Za(n, r, t, null),
                s.return = e,
                n.return = e,
                s.sibling = n,
                e.child = s,
                e.child.memoizedState = Oy(t),
                e.memoizedState = Fy,
                n)
              : zy(e, o));
    }
    if (i = n.memoizedState, i !== null && (a = i.dehydrated, a !== null)) {
      return eN(n, e, o, r, a, i, t);
    }
    if (s) {
      s = r.fallback, o = e.mode, i = n.child, a = i.sibling;
      var u = { mode: "hidden", children: r.children };
      return (o & 1) == 0 && e.child !== i
        ? (r = e.child,
          r.childLanes = 0,
          r.pendingProps = u,
          e.deletions = null)
        : (r = Vo(i, u), r.subtreeFlags = i.subtreeFlags & 14680064),
        a !== null ? s = Vo(a, s) : (s = Za(s, o, t, null), s.flags |= 2),
        s.return = e,
        r.return = e,
        r.sibling = s,
        e.child = r,
        r = s,
        s = e.child,
        o = n.child.memoizedState,
        o = o === null
          ? Oy(t)
          : {
            baseLanes: o.baseLanes | t,
            cachePool: null,
            transitions: o.transitions,
          },
        s.memoizedState = o,
        s.childLanes = n.childLanes & ~t,
        e.memoizedState = Fy,
        r;
    }
    return s = n.child,
      n = s.sibling,
      r = Vo(s, { mode: "visible", children: r.children }),
      (e.mode & 1) == 0 && (r.lanes = t),
      r.return = e,
      r.sibling = null,
      n !== null &&
      (t = e.deletions,
        t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n)),
      e.child = r,
      e.memoizedState = null,
      r;
  }
  function zy(n, e) {
    return e = Vp({ mode: "visible", children: e }, n.mode, 0, null),
      e.return = n,
      n.child = e;
  }
  function bp(n, e, t, r) {
    return r !== null && fy(r),
      xu(e, n.child, null, t),
      n = zy(e, e.pendingProps.children),
      n.flags |= 2,
      e.memoizedState = null,
      n;
  }
  function eN(n, e, t, r, i, s, o) {
    if (t) {
      return e.flags & 256
        ? (e.flags &= -257, r = Iy(Error(he(422))), bp(n, e, o, r))
        : e.memoizedState !== null
        ? (e.child = n.child, e.flags |= 128, null)
        : (s = r.fallback,
          i = e.mode,
          r = Vp({ mode: "visible", children: r.children }, i, 0, null),
          s = Za(s, i, o, null),
          s.flags |= 2,
          r.return = e,
          s.return = e,
          r.sibling = s,
          e.child = r,
          (e.mode & 1) != 0 && xu(e, n.child, null, o),
          e.child.memoizedState = Oy(o),
          e.memoizedState = Fy,
          s);
    }
    if ((e.mode & 1) == 0) return bp(n, e, o, null);
    if (i.data === "$!") {
      if (r = i.nextSibling && i.nextSibling.dataset, r) { var a = r.dgst; }
      return r = a, s = Error(he(419)), r = Iy(s, r, void 0), bp(n, e, o, r);
    }
    if (a = (o & n.childLanes) != 0, Nr || a) {
      if (r = zn, r !== null) {
        switch (o & -o) {
          case 4:
            i = 2;
            break;
          case 16:
            i = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            i = 32;
            break;
          case 536870912:
            i = 268435456;
            break;
          default:
            i = 0;
        }
        i = (i & (r.suspendedLanes | o)) != 0 ? 0 : i,
          i !== 0 && i !== s.retryLane &&
          (s.retryLane = i, Bs(n, i), Hi(r, n, i, -1));
      }
      return ex(), r = Iy(Error(he(421))), bp(n, e, o, r);
    }
    return i.data === "$?"
      ? (e.flags |= 128,
        e.child = n.child,
        e = hN.bind(null, n),
        i._reactRetry = e,
        null)
      : (n = s.treeContext,
        qr = Lo(i.nextSibling),
        Xr = e,
        Kt = !0,
        zi = null,
        n !== null &&
        (vi[yi++] = Os,
          vi[yi++] = zs,
          vi[yi++] = Ua,
          Os = n.id,
          zs = n.overflow,
          Ua = e),
        e = zy(e, r.children),
        e.flags |= 4096,
        e);
  }
  function OT(n, e, t) {
    n.lanes |= e;
    var r = n.alternate;
    r !== null && (r.lanes |= e), my(n.return, e, t);
  }
  function By(n, e, t, r, i) {
    var s = n.memoizedState;
    s === null
      ? n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: t,
        tailMode: i,
      }
      : (s.isBackwards = e,
        s.rendering = null,
        s.renderingStartTime = 0,
        s.last = r,
        s.tail = t,
        s.tailMode = i);
  }
  function zT(n, e, t) {
    var r = e.pendingProps, i = r.revealOrder, s = r.tail;
    if (hr(n, e, r.children, t), r = on.current, (r & 2) != 0) {
      r = r & 1 | 2, e.flags |= 128;
    } else {
      if (n !== null && (n.flags & 128) != 0) {
        e: for (n = e.child; n !== null;) {
          if (n.tag === 13) {
            n.memoizedState !== null && OT(n, t, e);
          } else if (n.tag === 19) OT(n, t, e);
          else if (n.child !== null) {
            n.child.return = n, n = n.child;
            continue;
          }
          if (n === e) break e;
          for (; n.sibling === null;) {
            if (n.return === null || n.return === e) break e;
            n = n.return;
          }
          n.sibling.return = n.return, n = n.sibling;
        }
      }
      r &= 1;
    }
    if (Vt(on, r), (e.mode & 1) == 0) e.memoizedState = null;
    else {switch (i) {
        case "forwards":
          for (t = e.child, i = null; t !== null;) {
            n = t.alternate,
              n !== null && wp(n) === null && (i = t),
              t = t.sibling;
          }
          t = i,
            t === null
              ? (i = e.child, e.child = null)
              : (i = t.sibling, t.sibling = null),
            By(e, !1, i, t, s);
          break;
        case "backwards":
          for (t = null, i = e.child, e.child = null; i !== null;) {
            if (n = i.alternate, n !== null && wp(n) === null) {
              e.child = i;
              break;
            }
            n = i.sibling, i.sibling = t, t = i, i = n;
          }
          By(e, !0, t, null, s);
          break;
        case "together":
          By(e, !1, null, null, void 0);
          break;
        default:
          e.memoizedState = null;
      }}
    return e.child;
  }
  function Rp(n, e) {
    (e.mode & 1) == 0 && n !== null &&
      (n.alternate = null, e.alternate = null, e.flags |= 2);
  }
  function Vs(n, e, t) {
    if (
      n !== null && (e.dependencies = n.dependencies),
        Wa |= e.lanes,
        (t & e.childLanes) == 0
    ) return null;
    if (n !== null && e.child !== n.child) throw Error(he(153));
    if (e.child !== null) {
      for (
        n = e.child, t = Vo(n, n.pendingProps), e.child = t, t.return = e;
        n.sibling !== null;
      ) n = n.sibling, t = t.sibling = Vo(n, n.pendingProps), t.return = e;
      t.sibling = null;
    }
    return e.child;
  }
  function tN(n, e, t) {
    switch (e.tag) {
      case 3:
        DT(e), gu();
        break;
      case 5:
        tT(e);
        break;
      case 1:
        Ir(e.type) && fp(e);
        break;
      case 4:
        _y(e, e.stateNode.containerInfo);
        break;
      case 10:
        var r = e.type._context, i = e.memoizedProps.value;
        Vt(gp, r._currentValue), r._currentValue = i;
        break;
      case 13:
        if (r = e.memoizedState, r !== null) {
          return r.dehydrated !== null
            ? (Vt(on, on.current & 1), e.flags |= 128, null)
            : (t & e.child.childLanes) != 0
            ? FT(n, e, t)
            : (Vt(on, on.current & 1),
              n = Vs(n, e, t),
              n !== null ? n.sibling : null);
        }
        Vt(on, on.current & 1);
        break;
      case 19:
        if (r = (t & e.childLanes) != 0, (n.flags & 128) != 0) {
          if (r) return zT(n, e, t);
          e.flags |= 128;
        }
        if (
          i = e.memoizedState,
            i !== null &&
            (i.rendering = null, i.tail = null, i.lastEffect = null),
            Vt(on, on.current),
            r
        ) break;
        return null;
      case 22:
      case 23:
        return e.lanes = 0, PT(n, e, t);
    }
    return Vs(n, e, t);
  }
  var BT, Uy, UT, VT;
  BT = function (n, e) {
    for (var t = e.child; t !== null;) {
      if (t.tag === 5 || t.tag === 6) n.appendChild(t.stateNode);
      else if (t.tag !== 4 && t.child !== null) {
        t.child.return = t, t = t.child;
        continue;
      }
      if (t === e) break;
      for (; t.sibling === null;) {
        if (t.return === null || t.return === e) return;
        t = t.return;
      }
      t.sibling.return = t.return, t = t.sibling;
    }
  };
  Uy = function () {};
  UT = function (n, e, t, r) {
    var i = n.memoizedProps;
    if (i !== r) {
      n = e.stateNode, Ga(gs.current);
      var s = null;
      switch (t) {
        case "input":
          i = yv(n, i), r = yv(n, r), s = [];
          break;
        case "select":
          i = sn({}, i, { value: void 0 }),
            r = sn({}, r, { value: void 0 }),
            s = [];
          break;
        case "textarea":
          i = Sv(n, i), r = Sv(n, r), s = [];
          break;
        default:
          typeof i.onClick != "function" && typeof r.onClick == "function" &&
            (n.onclick = lp);
      }
      Mv(t, r);
      var o;
      t = null;
      for (f in i) {
        if (!r.hasOwnProperty(f) && i.hasOwnProperty(f) && i[f] != null) {
          if (f === "style") {
            var a = i[f];
            for (o in a) {
              a.hasOwnProperty(o) && (t || (t = {}), t[o] = "");
            }
          } else {f !== "dangerouslySetInnerHTML" && f !== "children" &&
              f !== "suppressContentEditableWarning" &&
              f !== "suppressHydrationWarning" && f !== "autoFocus" &&
              (Yc.hasOwnProperty(f)
                ? s || (s = [])
                : (s = s || []).push(f, null));}
        }
      }
      for (f in r) {
        var u = r[f];
        if (
          a = i != null ? i[f] : void 0,
            r.hasOwnProperty(f) && u !== a && (u != null || a != null)
        ) {
          if (f === "style") {
            if (a) {
              for (o in a) {
                !a.hasOwnProperty(o) || u && u.hasOwnProperty(o) ||
                  (t || (t = {}), t[o] = "");
              }
              for (o in u) {
                u.hasOwnProperty(o) && a[o] !== u[o] &&
                  (t || (t = {}), t[o] = u[o]);
              }
            } else t || (s || (s = []), s.push(f, t)), t = u;
          } else {f === "dangerouslySetInnerHTML"
              ? (u = u ? u.__html : void 0,
                a = a ? a.__html : void 0,
                u != null && a !== u && (s = s || []).push(f, u))
              : f === "children"
              ? typeof u != "string" && typeof u != "number" ||
                (s = s || []).push(f, "" + u)
              : f !== "suppressContentEditableWarning" &&
                f !== "suppressHydrationWarning" && (Yc.hasOwnProperty(f)
                  ? (u != null && f === "onScroll" && Gt("scroll", n),
                    s || a === u || (s = []))
                  : (s = s || []).push(f, u));}
        }
      }
      t && (s = s || []).push("style", t);
      var f = s;
      (e.updateQueue = f) && (e.flags |= 4);
    }
  };
  VT = function (n, e, t, r) {
    t !== r && (e.flags |= 4);
  };
  function Lf(n, e) {
    if (!Kt) {
      switch (n.tailMode) {
        case "hidden":
          e = n.tail;
          for (var t = null; e !== null;) {
            e.alternate !== null && (t = e), e = e.sibling;
          }
          t === null ? n.tail = null : t.sibling = null;
          break;
        case "collapsed":
          t = n.tail;
          for (var r = null; t !== null;) {
            t.alternate !== null && (r = t), t = t.sibling;
          }
          r === null
            ? e || n.tail === null ? n.tail = null : n.tail.sibling = null
            : r.sibling = null;
      }
    }
  }
  function tr(n) {
    var e = n.alternate !== null && n.alternate.child === n.child, t = 0, r = 0;
    if (e) {
      for (var i = n.child; i !== null;) {
        t |= i.lanes | i.childLanes,
          r |= i.subtreeFlags & 14680064,
          r |= i.flags & 14680064,
          i.return = n,
          i = i.sibling;
      }
    } else {for (i = n.child; i !== null;) {
        t |= i.lanes | i.childLanes,
          r |= i.subtreeFlags,
          r |= i.flags,
          i.return = n,
          i = i.sibling;
      }}
    return n.subtreeFlags |= r, n.childLanes = t, e;
  }
  function nN(n, e, t) {
    var r = e.pendingProps;
    switch (ly(e), e.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return tr(e), null;
      case 1:
        return Ir(e.type) && cp(), tr(e), null;
      case 3:
        return r = e.stateNode,
          _u(),
          jt(Pr),
          jt($n),
          My(),
          r.pendingContext &&
          (r.context = r.pendingContext, r.pendingContext = null),
          (n === null || n.child === null) && (mp(e)
            ? e.flags |= 4
            : n === null ||
              n.memoizedState.isDehydrated && (e.flags & 256) == 0 ||
              (e.flags |= 1024, zi !== null && (Jy(zi), zi = null))),
          Uy(n, e),
          tr(e),
          null;
      case 5:
        Sy(e);
        var i = Ga(Tf.current);
        if (t = e.type, n !== null && e.stateNode != null) {
          UT(n, e, t, r, i),
            n.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152);
        } else {
          if (!r) {
            if (e.stateNode === null) throw Error(he(166));
            return tr(e), null;
          }
          if (n = Ga(gs.current), mp(e)) {
            r = e.stateNode, t = e.type;
            var s = e.memoizedProps;
            switch (r[ms] = e, r[_f] = s, n = (e.mode & 1) != 0, t) {
              case "dialog":
                Gt("cancel", r), Gt("close", r);
                break;
              case "iframe":
              case "object":
              case "embed":
                Gt("load", r);
                break;
              case "video":
              case "audio":
                for (i = 0; i < vf.length; i++) Gt(vf[i], r);
                break;
              case "source":
                Gt("error", r);
                break;
              case "img":
              case "image":
              case "link":
                Gt("error", r), Gt("load", r);
                break;
              case "details":
                Gt("toggle", r);
                break;
              case "input":
                xM(r, s), Gt("invalid", r);
                break;
              case "select":
                r._wrapperState = { wasMultiple: !!s.multiple },
                  Gt("invalid", r);
                break;
              case "textarea":
                wM(r, s), Gt("invalid", r);
            }
            Mv(t, s), i = null;
            for (var o in s) {
              if (s.hasOwnProperty(o)) {
                var a = s[o];
                o === "children"
                  ? typeof a == "string"
                    ? r.textContent !== a &&
                      (s.suppressHydrationWarning !== !0 &&
                        ap(r.textContent, a, n),
                        i = ["children", a])
                    : typeof a == "number" && r.textContent !== "" + a &&
                      (s.suppressHydrationWarning !== !0 &&
                        ap(r.textContent, a, n),
                        i = ["children", "" + a])
                  : Yc.hasOwnProperty(o) && a != null && o === "onScroll" &&
                    Gt("scroll", r);
              }
            }
            switch (t) {
              case "input":
                Dh(r), SM(r, s, !0);
                break;
              case "textarea":
                Dh(r), EM(r);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof s.onClick == "function" && (r.onclick = lp);
            }
            r = i, e.updateQueue = r, r !== null && (e.flags |= 4);
          } else {
            o = i.nodeType === 9 ? i : i.ownerDocument,
              n === "http://www.w3.org/1999/xhtml" && (n = TM(t)),
              n === "http://www.w3.org/1999/xhtml"
                ? t === "script"
                  ? (n = o.createElement("div"),
                    n.innerHTML = "<script><\/script>",
                    n = n.removeChild(n.firstChild))
                  : typeof r.is == "string"
                  ? n = o.createElement(t, { is: r.is })
                  : (n = o.createElement(t),
                    t === "select" &&
                    (o = n,
                      r.multiple
                        ? o.multiple = !0
                        : r.size && (o.size = r.size)))
                : n = o.createElementNS(n, t),
              n[ms] = e,
              n[_f] = r,
              BT(n, e, !1, !1),
              e.stateNode = n;
            e: {
              switch (o = Ev(t, r), t) {
                case "dialog":
                  Gt("cancel", n), Gt("close", n), i = r;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  Gt("load", n), i = r;
                  break;
                case "video":
                case "audio":
                  for (i = 0; i < vf.length; i++) Gt(vf[i], n);
                  i = r;
                  break;
                case "source":
                  Gt("error", n), i = r;
                  break;
                case "img":
                case "image":
                case "link":
                  Gt("error", n), Gt("load", n), i = r;
                  break;
                case "details":
                  Gt("toggle", n), i = r;
                  break;
                case "input":
                  xM(n, r), i = yv(n, r), Gt("invalid", n);
                  break;
                case "option":
                  i = r;
                  break;
                case "select":
                  n._wrapperState = { wasMultiple: !!r.multiple },
                    i = sn({}, r, { value: void 0 }),
                    Gt("invalid", n);
                  break;
                case "textarea":
                  wM(n, r), i = Sv(n, r), Gt("invalid", n);
                  break;
                default:
                  i = r;
              }
              Mv(t, i), a = i;
              for (s in a) {
                if (a.hasOwnProperty(s)) {
                  var u = a[s];
                  s === "style"
                    ? bM(n, u)
                    : s === "dangerouslySetInnerHTML"
                    ? (u = u ? u.__html : void 0, u != null && AM(n, u))
                    : s === "children"
                    ? typeof u == "string"
                      ? (t !== "textarea" || u !== "") && Qc(n, u)
                      : typeof u == "number" && Qc(n, "" + u)
                    : s !== "suppressContentEditableWarning" &&
                      s !== "suppressHydrationWarning" && s !== "autoFocus" &&
                      (Yc.hasOwnProperty(s)
                        ? u != null && s === "onScroll" && Gt("scroll", n)
                        : u != null && av(n, s, u, o));
                }
              }
              switch (t) {
                case "input":
                  Dh(n), SM(n, r, !1);
                  break;
                case "textarea":
                  Dh(n), EM(n);
                  break;
                case "option":
                  r.value != null && n.setAttribute("value", "" + Mo(r.value));
                  break;
                case "select":
                  n.multiple = !!r.multiple,
                    s = r.value,
                    s != null
                      ? eu(n, !!r.multiple, s, !1)
                      : r.defaultValue != null &&
                        eu(n, !!r.multiple, r.defaultValue, !0);
                  break;
                default:
                  typeof i.onClick == "function" && (n.onclick = lp);
              }
              switch (t) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  r = !!r.autoFocus;
                  break e;
                case "img":
                  r = !0;
                  break e;
                default:
                  r = !1;
              }
            }
            r && (e.flags |= 4);
          }
          e.ref !== null && (e.flags |= 512, e.flags |= 2097152);
        }
        return tr(e), null;
      case 6:
        if (n && e.stateNode != null) VT(n, e, n.memoizedProps, r);
        else {
          if (typeof r != "string" && e.stateNode === null) {
            throw Error(he(166));
          }
          if (t = Ga(Tf.current), Ga(gs.current), mp(e)) {
            if (
              r = e.stateNode,
                t = e.memoizedProps,
                r[ms] = e,
                (s = r.nodeValue !== t) && (n = Xr, n !== null)
            ) {
              switch (n.tag) {
                case 3:
                  ap(r.nodeValue, t, (n.mode & 1) != 0);
                  break;
                case 5:
                  n.memoizedProps.suppressHydrationWarning !== !0 &&
                    ap(r.nodeValue, t, (n.mode & 1) != 0);
              }
            }
            s && (e.flags |= 4);
          } else {r = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(
              r,
            ),
              r[ms] = e,
              e.stateNode = r;}
        }
        return tr(e), null;
      case 13:
        if (
          jt(on),
            r = e.memoizedState,
            n === null ||
            n.memoizedState !== null && n.memoizedState.dehydrated !== null
        ) {
          if (Kt && qr !== null && (e.mode & 1) != 0 && (e.flags & 128) == 0) {
            GE(), gu(), e.flags |= 98560, s = !1;
          } else if (s = mp(e), r !== null && r.dehydrated !== null) {
            if (n === null) {
              if (!s) throw Error(he(318));
              if (
                s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s
              ) throw Error(he(317));
              s[ms] = e;
            } else {gu(),
                (e.flags & 128) == 0 && (e.memoizedState = null),
                e.flags |= 4;}
            tr(e), s = !1;
          } else zi !== null && (Jy(zi), zi = null), s = !0;
          if (!s) return e.flags & 65536 ? e : null;
        }
        return (e.flags & 128) != 0 ? (e.lanes = t, e) : (r = r !== null,
          r !== (n !== null && n.memoizedState !== null) && r &&
          (e.child.flags |= 8192,
            (e.mode & 1) != 0 && (n === null || (on.current & 1) != 0
              ? bn === 0 && (bn = 3)
              : ex())),
          e.updateQueue !== null && (e.flags |= 4),
          tr(e),
          null);
      case 4:
        return _u(),
          Uy(n, e),
          n === null && yf(e.stateNode.containerInfo),
          tr(e),
          null;
      case 10:
        return py(e.type._context), tr(e), null;
      case 17:
        return Ir(e.type) && cp(), tr(e), null;
      case 19:
        if (jt(on), s = e.memoizedState, s === null) return tr(e), null;
        if (r = (e.flags & 128) != 0, o = s.rendering, o === null) {
          if (r) Lf(s, !1);
          else {
            if (bn !== 0 || n !== null && (n.flags & 128) != 0) {
              for (n = e.child; n !== null;) {
                if (o = wp(n), o !== null) {
                  for (
                    e.flags |= 128,
                      Lf(s, !1),
                      r = o.updateQueue,
                      r !== null && (e.updateQueue = r, e.flags |= 4),
                      e.subtreeFlags = 0,
                      r = t,
                      t = e.child;
                    t !== null;
                  ) {
                    s = t,
                      n = r,
                      s.flags &= 14680066,
                      o = s.alternate,
                      o === null
                        ? (s.childLanes = 0,
                          s.lanes = n,
                          s.child = null,
                          s.subtreeFlags = 0,
                          s.memoizedProps = null,
                          s.memoizedState = null,
                          s.updateQueue = null,
                          s.dependencies = null,
                          s.stateNode = null)
                        : (s.childLanes = o.childLanes,
                          s.lanes = o.lanes,
                          s.child = o.child,
                          s.subtreeFlags = 0,
                          s.deletions = null,
                          s.memoizedProps = o.memoizedProps,
                          s.memoizedState = o.memoizedState,
                          s.updateQueue = o.updateQueue,
                          s.type = o.type,
                          n = o.dependencies,
                          s.dependencies = n === null
                            ? null
                            : { lanes: n.lanes, firstContext: n.firstContext }),
                      t = t.sibling;
                  }
                  return Vt(on, on.current & 1 | 2), e.child;
                }
                n = n.sibling;
              }
            }
            s.tail !== null && vn() > Eu &&
              (e.flags |= 128, r = !0, Lf(s, !1), e.lanes = 4194304);
          }
        } else {
          if (!r) {
            if (n = wp(o), n !== null) {
              if (
                e.flags |= 128,
                  r = !0,
                  t = n.updateQueue,
                  t !== null && (e.updateQueue = t, e.flags |= 4),
                  Lf(s, !0),
                  s.tail === null && s.tailMode === "hidden" && !o.alternate &&
                  !Kt
              ) return tr(e), null;
            } else {2 * vn() - s.renderingStartTime > Eu && t !== 1073741824 &&
                (e.flags |= 128, r = !0, Lf(s, !1), e.lanes = 4194304);}
          }
          s.isBackwards
            ? (o.sibling = e.child, e.child = o)
            : (t = s.last,
              t !== null ? t.sibling = o : e.child = o,
              s.last = o);
        }
        return s.tail !== null
          ? (e = s.tail,
            s.rendering = e,
            s.tail = e.sibling,
            s.renderingStartTime = vn(),
            e.sibling = null,
            t = on.current,
            Vt(on, r ? t & 1 | 2 : t & 1),
            e)
          : (tr(e), null);
      case 22:
      case 23:
        return $y(),
          r = e.memoizedState !== null,
          n !== null && n.memoizedState !== null !== r && (e.flags |= 8192),
          r && (e.mode & 1) != 0
            ? (Yr & 1073741824) != 0 &&
              (tr(e), e.subtreeFlags & 6 && (e.flags |= 8192))
            : tr(e),
          null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(he(156, e.tag));
  }
  function rN(n, e) {
    switch (ly(e), e.tag) {
      case 1:
        return Ir(e.type) && cp(),
          n = e.flags,
          n & 65536 ? (e.flags = n & -65537 | 128, e) : null;
      case 3:
        return _u(),
          jt(Pr),
          jt($n),
          My(),
          n = e.flags,
          (n & 65536) != 0 && (n & 128) == 0
            ? (e.flags = n & -65537 | 128, e)
            : null;
      case 5:
        return Sy(e), null;
      case 13:
        if (jt(on), n = e.memoizedState, n !== null && n.dehydrated !== null) {
          if (e.alternate === null) throw Error(he(340));
          gu();
        }
        return n = e.flags, n & 65536 ? (e.flags = n & -65537 | 128, e) : null;
      case 19:
        return jt(on), null;
      case 4:
        return _u(), null;
      case 10:
        return py(e.type._context), null;
      case 22:
      case 23:
        return $y(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Lp = !1,
    nr = !1,
    iN = typeof WeakSet == "function" ? WeakSet : Set,
    Le = null;
  function wu(n, e) {
    var t = n.ref;
    if (t !== null) {
      if (typeof t == "function") {
        try {
          t(null);
        } catch (r) {
          dn(n, e, r);
        }
      } else t.current = null;
    }
  }
  function Vy(n, e, t) {
    try {
      t();
    } catch (r) {
      dn(n, e, r);
    }
  }
  var HT = !1;
  function sN(n, e) {
    if ($v = Xh, n = vE(), qv(n)) {
      if ("selectionStart" in n) {
        var t = { start: n.selectionStart, end: n.selectionEnd };
      } else {e: {
          t = (t = n.ownerDocument) && t.defaultView || window;
          var r = t.getSelection && t.getSelection();
          if (r && r.rangeCount !== 0) {
            t = r.anchorNode;
            var i = r.anchorOffset, s = r.focusNode;
            r = r.focusOffset;
            try {
              t.nodeType, s.nodeType;
            } catch {
              t = null;
              break e;
            }
            var o = 0, a = -1, u = -1, f = 0, d = 0, h = n, p = null;
            t: for (;;) {
              for (
                var g;
                h !== t || i !== 0 && h.nodeType !== 3 || (a = o + i),
                  h !== s || r !== 0 && h.nodeType !== 3 || (u = o + r),
                  h.nodeType === 3 && (o += h.nodeValue.length),
                  (g = h.firstChild) !== null;
              ) p = h, h = g;
              for (;;) {
                if (h === n) break t;
                if (
                  p === t && ++f === i && (a = o),
                    p === s && ++d === r && (u = o),
                    (g = h.nextSibling) !== null
                ) break;
                h = p, p = h.parentNode;
              }
              h = g;
            }
            t = a === -1 || u === -1 ? null : { start: a, end: u };
          } else t = null;
        }}
      t = t || { start: 0, end: 0 };
    } else t = null;
    for (
      ey = { focusedElem: n, selectionRange: t }, Xh = !1, Le = e; Le !== null;
    ) {
      if (e = Le, n = e.child, (e.subtreeFlags & 1028) != 0 && n !== null) {
        n.return = e, Le = n;
      } else {for (; Le !== null;) {
          e = Le;
          try {
            var y = e.alternate;
            if ((e.flags & 1024) != 0) {
              switch (e.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (y !== null) {
                    var v = y.memoizedProps,
                      _ = y.memoizedState,
                      S = e.stateNode,
                      w = S.getSnapshotBeforeUpdate(
                        e.elementType === e.type ? v : Bi(e.type, v),
                        _,
                      );
                    S.__reactInternalSnapshotBeforeUpdate = w;
                  }
                  break;
                case 3:
                  var M = e.stateNode.containerInfo;
                  M.nodeType === 1
                    ? M.textContent = ""
                    : M.nodeType === 9 && M.documentElement &&
                      M.removeChild(M.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(he(163));
              }
            }
          } catch (T) {
            dn(e, e.return, T);
          }
          if (n = e.sibling, n !== null) {
            n.return = e.return, Le = n;
            break;
          }
          Le = e.return;
        }}
    }
    return y = HT, HT = !1, y;
  }
  function Pf(n, e, t) {
    var r = e.updateQueue;
    if (r = r !== null ? r.lastEffect : null, r !== null) {
      var i = r = r.next;
      do {
        if ((i.tag & n) === n) {
          var s = i.destroy;
          i.destroy = void 0, s !== void 0 && Vy(e, t, s);
        }
        i = i.next;
      } while (i !== r);
    }
  }
  function Pp(n, e) {
    if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) {
      var t = e = e.next;
      do {
        if ((t.tag & n) === n) {
          var r = t.create;
          t.destroy = r();
        }
        t = t.next;
      } while (t !== e);
    }
  }
  function Hy(n) {
    var e = n.ref;
    if (e !== null) {
      var t = n.stateNode;
      switch (n.tag) {
        case 5:
          n = t;
          break;
        default:
          n = t;
      }
      typeof e == "function" ? e(n) : e.current = n;
    }
  }
  function GT(n) {
    var e = n.alternate;
    e !== null && (n.alternate = null, GT(e)),
      n.child = null,
      n.deletions = null,
      n.sibling = null,
      n.tag === 5 &&
      (e = n.stateNode,
        e !== null &&
        (delete e[ms], delete e[_f], delete e[iy], delete e[VI], delete e[HI])),
      n.stateNode = null,
      n.return = null,
      n.dependencies = null,
      n.memoizedProps = null,
      n.memoizedState = null,
      n.pendingProps = null,
      n.stateNode = null,
      n.updateQueue = null;
  }
  function jT(n) {
    return n.tag === 5 || n.tag === 3 || n.tag === 4;
  }
  function WT(n) {
    e: for (;;) {
      for (; n.sibling === null;) {
        if (n.return === null || jT(n.return)) return null;
        n = n.return;
      }
      for (
        n.sibling.return = n.return, n = n.sibling;
        n.tag !== 5 && n.tag !== 6 && n.tag !== 18;
      ) {
        if (n.flags & 2 || n.child === null || n.tag === 4) continue e;
        n.child.return = n, n = n.child;
      }
      if (!(n.flags & 2)) return n.stateNode;
    }
  }
  function Gy(n, e, t) {
    var r = n.tag;
    if (r === 5 || r === 6) {
      n = n.stateNode,
        e
          ? t.nodeType === 8
            ? t.parentNode.insertBefore(n, e)
            : t.insertBefore(n, e)
          : (t.nodeType === 8
            ? (e = t.parentNode, e.insertBefore(n, t))
            : (e = t, e.appendChild(n)),
            t = t._reactRootContainer,
            t != null || e.onclick !== null || (e.onclick = lp));
    } else if (r !== 4 && (n = n.child, n !== null)) {
      for (Gy(n, e, t), n = n.sibling; n !== null;) {
        Gy(n, e, t), n = n.sibling;
      }
    }
  }
  function jy(n, e, t) {
    var r = n.tag;
    if (r === 5 || r === 6) {
      n = n.stateNode, e ? t.insertBefore(n, e) : t.appendChild(n);
    } else if (r !== 4 && (n = n.child, n !== null)) {
      for (jy(n, e, t), n = n.sibling; n !== null;) {
        jy(n, e, t), n = n.sibling;
      }
    }
  }
  var jn = null, Ui = !1;
  function Fo(n, e, t) {
    for (t = t.child; t !== null;) XT(n, e, t), t = t.sibling;
  }
  function XT(n, e, t) {
    if (ps && typeof ps.onCommitFiberUnmount == "function") {
      try {
        ps.onCommitFiberUnmount(Uh, t);
      } catch {}
    }
    switch (t.tag) {
      case 5:
        nr || wu(t, e);
      case 6:
        var r = jn, i = Ui;
        jn = null,
          Fo(n, e, t),
          jn = r,
          Ui = i,
          jn !== null && (Ui
            ? (n = jn,
              t = t.stateNode,
              n.nodeType === 8
                ? n.parentNode.removeChild(t)
                : n.removeChild(t))
            : jn.removeChild(t.stateNode));
        break;
      case 18:
        jn !== null &&
          (Ui
            ? (n = jn,
              t = t.stateNode,
              n.nodeType === 8
                ? ry(n.parentNode, t)
                : n.nodeType === 1 && ry(n, t),
              uf(n))
            : ry(jn, t.stateNode));
        break;
      case 4:
        r = jn,
          i = Ui,
          jn = t.stateNode.containerInfo,
          Ui = !0,
          Fo(n, e, t),
          jn = r,
          Ui = i;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          !nr &&
          (r = t.updateQueue, r !== null && (r = r.lastEffect, r !== null))
        ) {
          i = r = r.next;
          do {
            var s = i, o = s.destroy;
            s = s.tag,
              o !== void 0 && ((s & 2) != 0 || (s & 4) != 0) && Vy(t, e, o),
              i = i.next;
          } while (i !== r);
        }
        Fo(n, e, t);
        break;
      case 1:
        if (
          !nr &&
          (wu(t, e),
            r = t.stateNode,
            typeof r.componentWillUnmount == "function")
        ) {
          try {
            r.props = t.memoizedProps,
              r.state = t.memoizedState,
              r.componentWillUnmount();
          } catch (a) {
            dn(t, e, a);
          }
        }
        Fo(n, e, t);
        break;
      case 21:
        Fo(n, e, t);
        break;
      case 22:
        t.mode & 1
          ? (nr = (r = nr) || t.memoizedState !== null, Fo(n, e, t), nr = r)
          : Fo(n, e, t);
        break;
      default:
        Fo(n, e, t);
    }
  }
  function qT(n) {
    var e = n.updateQueue;
    if (e !== null) {
      n.updateQueue = null;
      var t = n.stateNode;
      t === null && (t = n.stateNode = new iN()),
        e.forEach(function (r) {
          var i = pN.bind(null, n, r);
          t.has(r) || (t.add(r), r.then(i, i));
        });
    }
  }
  function Vi(n, e) {
    var t = e.deletions;
    if (t !== null) {
      for (var r = 0; r < t.length; r++) {
        var i = t[r];
        try {
          var s = n, o = e, a = o;
          e: for (; a !== null;) {
            switch (a.tag) {
              case 5:
                jn = a.stateNode, Ui = !1;
                break e;
              case 3:
                jn = a.stateNode.containerInfo, Ui = !0;
                break e;
              case 4:
                jn = a.stateNode.containerInfo, Ui = !0;
                break e;
            }
            a = a.return;
          }
          if (jn === null) throw Error(he(160));
          XT(s, o, i), jn = null, Ui = !1;
          var u = i.alternate;
          u !== null && (u.return = null), i.return = null;
        } catch (f) {
          dn(i, e, f);
        }
      }
    }
    if (e.subtreeFlags & 12854) {
      for (e = e.child; e !== null;) YT(e, n), e = e.sibling;
    }
  }
  function YT(n, e) {
    var t = n.alternate, r = n.flags;
    switch (n.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Vi(e, n), ys(n), r & 4) {
          try {
            Pf(3, n, n.return), Pp(3, n);
          } catch (v) {
            dn(n, n.return, v);
          }
          try {
            Pf(5, n, n.return);
          } catch (v) {
            dn(n, n.return, v);
          }
        }
        break;
      case 1:
        Vi(e, n), ys(n), r & 512 && t !== null && wu(t, t.return);
        break;
      case 5:
        if (
          Vi(e, n),
            ys(n),
            r & 512 && t !== null && wu(t, t.return),
            n.flags & 32
        ) {
          var i = n.stateNode;
          try {
            Qc(i, "");
          } catch (v) {
            dn(n, n.return, v);
          }
        }
        if (r & 4 && (i = n.stateNode, i != null)) {
          var s = n.memoizedProps,
            o = t !== null ? t.memoizedProps : s,
            a = n.type,
            u = n.updateQueue;
          if (n.updateQueue = null, u !== null) {
            try {
              a === "input" && s.type === "radio" && s.name != null && _M(i, s),
                Ev(a, o);
              var f = Ev(a, s);
              for (o = 0; o < u.length; o += 2) {
                var d = u[o], h = u[o + 1];
                d === "style"
                  ? bM(i, h)
                  : d === "dangerouslySetInnerHTML"
                  ? AM(i, h)
                  : d === "children"
                  ? Qc(i, h)
                  : av(i, d, h, f);
              }
              switch (a) {
                case "input":
                  xv(i, s);
                  break;
                case "textarea":
                  MM(i, s);
                  break;
                case "select":
                  var p = i._wrapperState.wasMultiple;
                  i._wrapperState.wasMultiple = !!s.multiple;
                  var g = s.value;
                  g != null
                    ? eu(i, !!s.multiple, g, !1)
                    : p !== !!s.multiple && (s.defaultValue != null
                      ? eu(i, !!s.multiple, s.defaultValue, !0)
                      : eu(i, !!s.multiple, s.multiple ? [] : "", !1));
              }
              i[_f] = s;
            } catch (v) {
              dn(n, n.return, v);
            }
          }
        }
        break;
      case 6:
        if (Vi(e, n), ys(n), r & 4) {
          if (n.stateNode === null) throw Error(he(162));
          i = n.stateNode, s = n.memoizedProps;
          try {
            i.nodeValue = s;
          } catch (v) {
            dn(n, n.return, v);
          }
        }
        break;
      case 3:
        if (
          Vi(e, n), ys(n), r & 4 && t !== null && t.memoizedState.isDehydrated
        ) {
          try {
            uf(e.containerInfo);
          } catch (v) {
            dn(n, n.return, v);
          }
        }
        break;
      case 4:
        Vi(e, n), ys(n);
        break;
      case 13:
        Vi(e, n),
          ys(n),
          i = n.child,
          i.flags & 8192 &&
          (s = i.memoizedState !== null,
            i.stateNode.isHidden = s,
            !s || i.alternate !== null && i.alternate.memoizedState !== null ||
            (qy = vn())),
          r & 4 && qT(n);
        break;
      case 22:
        if (
          d = t !== null && t.memoizedState !== null,
            n.mode & 1 ? (nr = (f = nr) || d, Vi(e, n), nr = f) : Vi(e, n),
            ys(n),
            r & 8192
        ) {
          if (
            f = n.memoizedState !== null,
              (n.stateNode.isHidden = f) && !d && (n.mode & 1) != 0
          ) {
            for (Le = n, d = n.child; d !== null;) {
              for (h = Le = d; Le !== null;) {
                switch (p = Le, g = p.child, p.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Pf(4, p, p.return);
                    break;
                  case 1:
                    wu(p, p.return);
                    var y = p.stateNode;
                    if (typeof y.componentWillUnmount == "function") {
                      r = p, t = p.return;
                      try {
                        e = r,
                          y.props = e.memoizedProps,
                          y.state = e.memoizedState,
                          y.componentWillUnmount();
                      } catch (v) {
                        dn(r, t, v);
                      }
                    }
                    break;
                  case 5:
                    wu(p, p.return);
                    break;
                  case 22:
                    if (p.memoizedState !== null) {
                      JT(h);
                      continue;
                    }
                }
                g !== null ? (g.return = p, Le = g) : JT(h);
              }
              d = d.sibling;
            }
          }
          e: for (d = null, h = n;;) {
            if (h.tag === 5) {
              if (d === null) {
                d = h;
                try {
                  i = h.stateNode,
                    f
                      ? (s = i.style,
                        typeof s.setProperty == "function"
                          ? s.setProperty("display", "none", "important")
                          : s.display = "none")
                      : (a = h.stateNode,
                        u = h.memoizedProps.style,
                        o = u != null && u.hasOwnProperty("display")
                          ? u.display
                          : null,
                        a.style.display = CM("display", o));
                } catch (v) {
                  dn(n, n.return, v);
                }
              }
            } else if (h.tag === 6) {
              if (d === null) {
                try {
                  h.stateNode.nodeValue = f ? "" : h.memoizedProps;
                } catch (v) {
                  dn(n, n.return, v);
                }
              }
            } else if (
              (h.tag !== 22 && h.tag !== 23 || h.memoizedState === null ||
                h === n) && h.child !== null
            ) {
              h.child.return = h, h = h.child;
              continue;
            }
            if (h === n) break e;
            for (; h.sibling === null;) {
              if (h.return === null || h.return === n) break e;
              d === h && (d = null), h = h.return;
            }
            d === h && (d = null), h.sibling.return = h.return, h = h.sibling;
          }
        }
        break;
      case 19:
        Vi(e, n), ys(n), r & 4 && qT(n);
        break;
      case 21:
        break;
      default:
        Vi(e, n), ys(n);
    }
  }
  function ys(n) {
    var e = n.flags;
    if (e & 2) {
      try {
        e: {
          for (var t = n.return; t !== null;) {
            if (jT(t)) {
              var r = t;
              break e;
            }
            t = t.return;
          }
          throw Error(he(160));
        }
        switch (r.tag) {
          case 5:
            var i = r.stateNode;
            r.flags & 32 && (Qc(i, ""), r.flags &= -33);
            var s = WT(n);
            jy(n, s, i);
            break;
          case 3:
          case 4:
            var o = r.stateNode.containerInfo, a = WT(n);
            Gy(n, a, o);
            break;
          default:
            throw Error(he(161));
        }
      } catch (u) {
        dn(n, n.return, u);
      }
      n.flags &= -3;
    }
    e & 4096 && (n.flags &= -4097);
  }
  function oN(n, e, t) {
    Le = n, ZT(n, e, t);
  }
  function ZT(n, e, t) {
    for (var r = (n.mode & 1) != 0; Le !== null;) {
      var i = Le, s = i.child;
      if (i.tag === 22 && r) {
        var o = i.memoizedState !== null || Lp;
        if (!o) {
          var a = i.alternate, u = a !== null && a.memoizedState !== null || nr;
          a = Lp;
          var f = nr;
          if (Lp = o, (nr = u) && !f) {
            for (Le = i; Le !== null;) {
              o = Le,
                u = o.child,
                o.tag === 22 && o.memoizedState !== null
                  ? QT(i)
                  : u !== null
                  ? (u.return = o, Le = u)
                  : QT(i);
            }
          }
          for (; s !== null;) Le = s, ZT(s, e, t), s = s.sibling;
          Le = i, Lp = a, nr = f;
        }
        KT(n, e, t);
      } else {(i.subtreeFlags & 8772) != 0 && s !== null
          ? (s.return = i, Le = s)
          : KT(n, e, t);}
    }
  }
  function KT(n) {
    for (; Le !== null;) {
      var e = Le;
      if ((e.flags & 8772) != 0) {
        var t = e.alternate;
        try {
          if ((e.flags & 8772) != 0) {
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                nr || Pp(5, e);
                break;
              case 1:
                var r = e.stateNode;
                if (e.flags & 4 && !nr) {
                  if (t === null) r.componentDidMount();
                  else {
                    var i = e.elementType === e.type
                      ? t.memoizedProps
                      : Bi(e.type, t.memoizedProps);
                    r.componentDidUpdate(
                      i,
                      t.memoizedState,
                      r.__reactInternalSnapshotBeforeUpdate,
                    );
                  }
                }
                var s = e.updateQueue;
                s !== null && qE(e, s, r);
                break;
              case 3:
                var o = e.updateQueue;
                if (o !== null) {
                  if (t = null, e.child !== null) {
                    switch (e.child.tag) {
                      case 5:
                        t = e.child.stateNode;
                        break;
                      case 1:
                        t = e.child.stateNode;
                    }
                  }
                  qE(e, o, t);
                }
                break;
              case 5:
                var a = e.stateNode;
                if (t === null && e.flags & 4) {
                  t = a;
                  var u = e.memoizedProps;
                  switch (e.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      u.autoFocus && t.focus();
                      break;
                    case "img":
                      u.src && (t.src = u.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (e.memoizedState === null) {
                  var f = e.alternate;
                  if (f !== null) {
                    var d = f.memoizedState;
                    if (d !== null) {
                      var h = d.dehydrated;
                      h !== null && uf(h);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(he(163));
            }
          }
          nr || e.flags & 512 && Hy(e);
        } catch (p) {
          dn(e, e.return, p);
        }
      }
      if (e === n) {
        Le = null;
        break;
      }
      if (t = e.sibling, t !== null) {
        t.return = e.return, Le = t;
        break;
      }
      Le = e.return;
    }
  }
  function JT(n) {
    for (; Le !== null;) {
      var e = Le;
      if (e === n) {
        Le = null;
        break;
      }
      var t = e.sibling;
      if (t !== null) {
        t.return = e.return, Le = t;
        break;
      }
      Le = e.return;
    }
  }
  function QT(n) {
    for (; Le !== null;) {
      var e = Le;
      try {
        switch (e.tag) {
          case 0:
          case 11:
          case 15:
            var t = e.return;
            try {
              Pp(4, e);
            } catch (u) {
              dn(e, t, u);
            }
            break;
          case 1:
            var r = e.stateNode;
            if (typeof r.componentDidMount == "function") {
              var i = e.return;
              try {
                r.componentDidMount();
              } catch (u) {
                dn(e, i, u);
              }
            }
            var s = e.return;
            try {
              Hy(e);
            } catch (u) {
              dn(e, s, u);
            }
            break;
          case 5:
            var o = e.return;
            try {
              Hy(e);
            } catch (u) {
              dn(e, o, u);
            }
        }
      } catch (u) {
        dn(e, e.return, u);
      }
      if (e === n) {
        Le = null;
        break;
      }
      var a = e.sibling;
      if (a !== null) {
        a.return = e.return, Le = a;
        break;
      }
      Le = e.return;
    }
  }
  var aN = Math.ceil,
    Ip = Ds.ReactCurrentDispatcher,
    Wy = Ds.ReactCurrentOwner,
    Si = Ds.ReactCurrentBatchConfig,
    vt = 0,
    zn = null,
    wn = null,
    Wn = 0,
    Yr = 0,
    Mu = Po(0),
    bn = 0,
    If = null,
    Wa = 0,
    Np = 0,
    Xy = 0,
    Nf = null,
    Dr = null,
    qy = 0,
    Eu = 1 / 0,
    Hs = null,
    Dp = !1,
    Yy = null,
    Oo = null,
    kp = !1,
    zo = null,
    Fp = 0,
    Df = 0,
    Zy = null,
    Op = -1,
    zp = 0;
  function pr() {
    return (vt & 6) != 0 ? vn() : Op !== -1 ? Op : Op = vn();
  }
  function Bo(n) {
    return (n.mode & 1) == 0
      ? 1
      : (vt & 2) != 0 && Wn !== 0
      ? Wn & -Wn
      : jI.transition !== null
      ? (zp === 0 && (zp = GM()), zp)
      : (n = Dt,
        n !== 0 || (n = window.event, n = n === void 0 ? 16 : QM(n.type)),
        n);
  }
  function Hi(n, e, t, r) {
    if (50 < Df) throw Df = 0, Zy = null, Error(he(185));
    rf(n, t, r),
      ((vt & 2) == 0 || n !== zn) &&
      (n === zn && ((vt & 2) == 0 && (Np |= t), bn === 4 && Uo(n, Wn)),
        kr(n, r),
        t === 1 && vt === 0 && (e.mode & 1) == 0 &&
        (Eu = vn() + 500, dp && No()));
  }
  function kr(n, e) {
    var t = n.callbackNode;
    XP(n, e);
    var r = Gh(n, n === zn ? Wn : 0);
    if (r === 0) {
      t !== null && UM(t), n.callbackNode = null, n.callbackPriority = 0;
    } else if (e = r & -r, n.callbackPriority !== e) {
      if (t != null && UM(t), e === 1) {
        n.tag === 0 ? GI(eA.bind(null, n)) : zE(eA.bind(null, n)),
          BI(function () {
            (vt & 6) == 0 && No();
          }),
          t = null;
      } else {
        switch (jM(r)) {
          case 1:
            t = Pv;
            break;
          case 4:
            t = VM;
            break;
          case 16:
            t = Bh;
            break;
          case 536870912:
            t = HM;
            break;
          default:
            t = Bh;
        }
        t = lA(t, $T.bind(null, n));
      }
      n.callbackPriority = e, n.callbackNode = t;
    }
  }
  function $T(n, e) {
    if (Op = -1, zp = 0, (vt & 6) != 0) throw Error(he(327));
    var t = n.callbackNode;
    if (Tu() && n.callbackNode !== t) return null;
    var r = Gh(n, n === zn ? Wn : 0);
    if (r === 0) return null;
    if ((r & 30) != 0 || (r & n.expiredLanes) != 0 || e) e = Bp(n, r);
    else {
      e = r;
      var i = vt;
      vt |= 2;
      var s = nA();
      (zn !== n || Wn !== e) && (Hs = null, Eu = vn() + 500, qa(n, e));
      do try {
        cN();
        break;
      } catch (a) {
        tA(n, a);
      } while (1);
      hy(),
        Ip.current = s,
        vt = i,
        wn !== null ? e = 0 : (zn = null, Wn = 0, e = bn);
    }
    if (e !== 0) {
      if (e === 2 && (i = Iv(n), i !== 0 && (r = i, e = Ky(n, i))), e === 1) {
        throw t = If, qa(n, 0), Uo(n, r), kr(n, vn()), t;
      }
      if (e === 6) Uo(n, r);
      else {
        if (
          i = n.current.alternate,
            (r & 30) == 0 && !lN(i) &&
            (e = Bp(n, r),
              e === 2 && (s = Iv(n), s !== 0 && (r = s, e = Ky(n, s))),
              e === 1)
        ) throw t = If, qa(n, 0), Uo(n, r), kr(n, vn()), t;
        switch (n.finishedWork = i, n.finishedLanes = r, e) {
          case 0:
          case 1:
            throw Error(he(345));
          case 2:
            Ya(n, Dr, Hs);
            break;
          case 3:
            if (
              Uo(n, r), (r & 130023424) === r && (e = qy + 500 - vn(), 10 < e)
            ) {
              if (Gh(n, 0) !== 0) break;
              if (i = n.suspendedLanes, (i & r) !== r) {
                pr(), n.pingedLanes |= n.suspendedLanes & i;
                break;
              }
              n.timeoutHandle = ny(Ya.bind(null, n, Dr, Hs), e);
              break;
            }
            Ya(n, Dr, Hs);
            break;
          case 4:
            if (Uo(n, r), (r & 4194240) === r) break;
            for (e = n.eventTimes, i = -1; 0 < r;) {
              var o = 31 - Fi(r);
              s = 1 << o, o = e[o], o > i && (i = o), r &= ~s;
            }
            if (
              r = i,
                r = vn() - r,
                r = (120 > r
                  ? 120
                  : 480 > r
                  ? 480
                  : 1080 > r
                  ? 1080
                  : 1920 > r
                  ? 1920
                  : 3e3 > r
                  ? 3e3
                  : 4320 > r
                  ? 4320
                  : 1960 * aN(r / 1960)) - r,
                10 < r
            ) {
              n.timeoutHandle = ny(Ya.bind(null, n, Dr, Hs), r);
              break;
            }
            Ya(n, Dr, Hs);
            break;
          case 5:
            Ya(n, Dr, Hs);
            break;
          default:
            throw Error(he(329));
        }
      }
    }
    return kr(n, vn()), n.callbackNode === t ? $T.bind(null, n) : null;
  }
  function Ky(n, e) {
    var t = Nf;
    return n.current.memoizedState.isDehydrated && (qa(n, e).flags |= 256),
      n = Bp(n, e),
      n !== 2 && (e = Dr, Dr = t, e !== null && Jy(e)),
      n;
  }
  function Jy(n) {
    Dr === null ? Dr = n : Dr.push.apply(Dr, n);
  }
  function lN(n) {
    for (var e = n;;) {
      if (e.flags & 16384) {
        var t = e.updateQueue;
        if (t !== null && (t = t.stores, t !== null)) {
          for (var r = 0; r < t.length; r++) {
            var i = t[r], s = i.getSnapshot;
            i = i.value;
            try {
              if (!Oi(s(), i)) {
                return !1;
              }
            } catch {
              return !1;
            }
          }
        }
      }
      if (t = e.child, e.subtreeFlags & 16384 && t !== null) {
        t.return = e, e = t;
      } else {
        if (e === n) break;
        for (; e.sibling === null;) {
          if (e.return === null || e.return === n) return !0;
          e = e.return;
        }
        e.sibling.return = e.return, e = e.sibling;
      }
    }
    return !0;
  }
  function Uo(n, e) {
    for (
      e &= ~Xy,
        e &= ~Np,
        n.suspendedLanes |= e,
        n.pingedLanes &= ~e,
        n = n.expirationTimes;
      0 < e;
    ) {
      var t = 31 - Fi(e), r = 1 << t;
      n[t] = -1, e &= ~r;
    }
  }
  function eA(n) {
    if ((vt & 6) != 0) throw Error(he(327));
    Tu();
    var e = Gh(n, 0);
    if ((e & 1) == 0) return kr(n, vn()), null;
    var t = Bp(n, e);
    if (n.tag !== 0 && t === 2) {
      var r = Iv(n);
      r !== 0 && (e = r, t = Ky(n, r));
    }
    if (t === 1) throw t = If, qa(n, 0), Uo(n, e), kr(n, vn()), t;
    if (t === 6) throw Error(he(345));
    return n.finishedWork = n.current.alternate,
      n.finishedLanes = e,
      Ya(n, Dr, Hs),
      kr(n, vn()),
      null;
  }
  function Qy(n, e) {
    var t = vt;
    vt |= 1;
    try {
      return n(e);
    } finally {
      vt = t, vt === 0 && (Eu = vn() + 500, dp && No());
    }
  }
  function Xa(n) {
    zo !== null && zo.tag === 0 && (vt & 6) == 0 && Tu();
    var e = vt;
    vt |= 1;
    var t = Si.transition, r = Dt;
    try {
      if (Si.transition = null, Dt = 1, n) return n();
    } finally {
      Dt = r, Si.transition = t, vt = e, (vt & 6) == 0 && No();
    }
  }
  function $y() {
    Yr = Mu.current, jt(Mu);
  }
  function qa(n, e) {
    n.finishedWork = null, n.finishedLanes = 0;
    var t = n.timeoutHandle;
    if (t !== -1 && (n.timeoutHandle = -1, zI(t)), wn !== null) {
      for (t = wn.return; t !== null;) {
        var r = t;
        switch (ly(r), r.tag) {
          case 1:
            r = r.type.childContextTypes, r != null && cp();
            break;
          case 3:
            _u(), jt(Pr), jt($n), My();
            break;
          case 5:
            Sy(r);
            break;
          case 4:
            _u();
            break;
          case 13:
            jt(on);
            break;
          case 19:
            jt(on);
            break;
          case 10:
            py(r.type._context);
            break;
          case 22:
          case 23:
            $y();
        }
        t = t.return;
      }
    }
    if (
      zn = n,
        wn = n = Vo(n.current, null),
        Wn = Yr = e,
        bn = 0,
        If = null,
        Xy = Np = Wa = 0,
        Dr = Nf = null,
        Ha !== null
    ) {
      for (e = 0; e < Ha.length; e++) {
        if (t = Ha[e], r = t.interleaved, r !== null) {
          t.interleaved = null;
          var i = r.next, s = t.pending;
          if (s !== null) {
            var o = s.next;
            s.next = i, r.next = o;
          }
          t.pending = r;
        }
      }
      Ha = null;
    }
    return n;
  }
  function tA(n, e) {
    do {
      var t = wn;
      try {
        if (hy(), Mp.current = Cp, Ep) {
          for (var r = an.memoizedState; r !== null;) {
            var i = r.queue;
            i !== null && (i.pending = null), r = r.next;
          }
          Ep = !1;
        }
        if (
          ja = 0,
            On = Cn = an = null,
            Af = !1,
            Cf = 0,
            Wy.current = null,
            t === null || t.return === null
        ) {
          bn = 1, If = e, wn = null;
          break;
        }
        e: {
          var s = n, o = t.return, a = t, u = e;
          if (
            e = Wn,
              a.flags |= 32768,
              u !== null && typeof u == "object" && typeof u.then == "function"
          ) {
            var f = u, d = a, h = d.tag;
            if ((d.mode & 1) == 0 && (h === 0 || h === 11 || h === 15)) {
              var p = d.alternate;
              p
                ? (d.updateQueue = p.updateQueue,
                  d.memoizedState = p.memoizedState,
                  d.lanes = p.lanes)
                : (d.updateQueue = null, d.memoizedState = null);
            }
            var g = AT(o);
            if (g !== null) {
              g.flags &= -257,
                CT(g, o, a, s, e),
                g.mode & 1 && TT(s, f, e),
                e = g,
                u = f;
              var y = e.updateQueue;
              if (y === null) {
                var v = new Set();
                v.add(u), e.updateQueue = v;
              } else y.add(u);
              break e;
            } else {
              if ((e & 1) == 0) {
                TT(s, f, e), ex();
                break e;
              }
              u = Error(he(426));
            }
          } else if (Kt && a.mode & 1) {
            var _ = AT(o);
            if (_ !== null) {
              (_.flags & 65536) == 0 && (_.flags |= 256),
                CT(_, o, a, s, e),
                fy(Su(u, a));
              break e;
            }
          }
          s = u = Su(u, a),
            bn !== 4 && (bn = 2),
            Nf === null ? Nf = [s] : Nf.push(s),
            s = o;
          do {
            switch (s.tag) {
              case 3:
                s.flags |= 65536, e &= -e, s.lanes |= e;
                var S = MT(s, u, e);
                XE(s, S);
                break e;
              case 1:
                a = u;
                var w = s.type, M = s.stateNode;
                if (
                  (s.flags & 128) == 0 &&
                  (typeof w.getDerivedStateFromError == "function" ||
                    M !== null && typeof M.componentDidCatch == "function" &&
                      (Oo === null || !Oo.has(M)))
                ) {
                  s.flags |= 65536, e &= -e, s.lanes |= e;
                  var T = ET(s, a, e);
                  XE(s, T);
                  break e;
                }
            }
            s = s.return;
          } while (s !== null);
        }
        iA(t);
      } catch (b) {
        e = b, wn === t && t !== null && (wn = t = t.return);
        continue;
      }
      break;
    } while (1);
  }
  function nA() {
    var n = Ip.current;
    return Ip.current = Cp, n === null ? Cp : n;
  }
  function ex() {
    (bn === 0 || bn === 3 || bn === 2) && (bn = 4),
      zn === null || (Wa & 268435455) == 0 && (Np & 268435455) == 0 ||
      Uo(zn, Wn);
  }
  function Bp(n, e) {
    var t = vt;
    vt |= 2;
    var r = nA();
    (zn !== n || Wn !== e) && (Hs = null, qa(n, e));
    do try {
      uN();
      break;
    } catch (i) {
      tA(n, i);
    } while (1);
    if (hy(), vt = t, Ip.current = r, wn !== null) throw Error(he(261));
    return zn = null, Wn = 0, bn;
  }
  function uN() {
    for (; wn !== null;) rA(wn);
  }
  function cN() {
    for (; wn !== null && !OP();) rA(wn);
  }
  function rA(n) {
    var e = aA(n.alternate, n, Yr);
    n.memoizedProps = n.pendingProps,
      e === null ? iA(n) : wn = e,
      Wy.current = null;
  }
  function iA(n) {
    var e = n;
    do {
      var t = e.alternate;
      if (n = e.return, (e.flags & 32768) == 0) {
        if (t = nN(t, e, Yr), t !== null) {
          wn = t;
          return;
        }
      } else {
        if (t = rN(t, e), t !== null) {
          t.flags &= 32767, wn = t;
          return;
        }
        if (n !== null) {
          n.flags |= 32768, n.subtreeFlags = 0, n.deletions = null;
        } else {
          bn = 6, wn = null;
          return;
        }
      }
      if (e = e.sibling, e !== null) {
        wn = e;
        return;
      }
      wn = e = n;
    } while (e !== null);
    bn === 0 && (bn = 5);
  }
  function Ya(n, e, t) {
    var r = Dt, i = Si.transition;
    try {
      Si.transition = null, Dt = 1, fN(n, e, t, r);
    } finally {
      Si.transition = i, Dt = r;
    }
    return null;
  }
  function fN(n, e, t, r) {
    do Tu(); while (zo !== null);
    if ((vt & 6) != 0) throw Error(he(327));
    t = n.finishedWork;
    var i = n.finishedLanes;
    if (t === null) return null;
    if (n.finishedWork = null, n.finishedLanes = 0, t === n.current) {
      throw Error(he(177));
    }
    n.callbackNode = null, n.callbackPriority = 0;
    var s = t.lanes | t.childLanes;
    if (
      qP(n, s),
        n === zn && (wn = zn = null, Wn = 0),
        (t.subtreeFlags & 2064) == 0 && (t.flags & 2064) == 0 || kp ||
        (kp = !0,
          lA(Bh, function () {
            return Tu(), null;
          })),
        s = (t.flags & 15990) != 0,
        (t.subtreeFlags & 15990) != 0 || s
    ) {
      s = Si.transition, Si.transition = null;
      var o = Dt;
      Dt = 1;
      var a = vt;
      vt |= 4,
        Wy.current = null,
        sN(n, t),
        YT(t, n),
        NI(ey),
        Xh = !!$v,
        ey = $v = null,
        n.current = t,
        oN(t, n, i),
        zP(),
        vt = a,
        Dt = o,
        Si.transition = s;
    } else n.current = t;
    if (
      kp && (kp = !1, zo = n, Fp = i),
        s = n.pendingLanes,
        s === 0 && (Oo = null),
        VP(t.stateNode, r),
        kr(n, vn()),
        e !== null
    ) {
      for (r = n.onRecoverableError, t = 0; t < e.length; t++) {
        i = e[t], r(i.value, { componentStack: i.stack, digest: i.digest });
      }
    }
    if (Dp) throw Dp = !1, n = Yy, Yy = null, n;
    return (Fp & 1) != 0 && n.tag !== 0 && Tu(),
      s = n.pendingLanes,
      (s & 1) != 0 ? n === Zy ? Df++ : (Df = 0, Zy = n) : Df = 0,
      No(),
      null;
  }
  function Tu() {
    if (zo !== null) {
      var n = jM(Fp), e = Si.transition, t = Dt;
      try {
        if (Si.transition = null, Dt = 16 > n ? 16 : n, zo === null) {
          var r = !1;
        } else {
          if (n = zo, zo = null, Fp = 0, (vt & 6) != 0) throw Error(he(331));
          var i = vt;
          for (vt |= 4, Le = n.current; Le !== null;) {
            var s = Le, o = s.child;
            if ((Le.flags & 16) != 0) {
              var a = s.deletions;
              if (a !== null) {
                for (var u = 0; u < a.length; u++) {
                  var f = a[u];
                  for (Le = f; Le !== null;) {
                    var d = Le;
                    switch (d.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pf(8, d, s);
                    }
                    var h = d.child;
                    if (h !== null) h.return = d, Le = h;
                    else {for (; Le !== null;) {
                        d = Le;
                        var p = d.sibling, g = d.return;
                        if (GT(d), d === f) {
                          Le = null;
                          break;
                        }
                        if (p !== null) {
                          p.return = g, Le = p;
                          break;
                        }
                        Le = g;
                      }}
                  }
                }
                var y = s.alternate;
                if (y !== null) {
                  var v = y.child;
                  if (v !== null) {
                    y.child = null;
                    do {
                      var _ = v.sibling;
                      v.sibling = null, v = _;
                    } while (v !== null);
                  }
                }
                Le = s;
              }
            }
            if ((s.subtreeFlags & 2064) != 0 && o !== null) {
              o.return = s, Le = o;
            } else {e: for (; Le !== null;) {
                if (s = Le, (s.flags & 2048) != 0) {
                  switch (s.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pf(9, s, s.return);
                  }
                }
                var S = s.sibling;
                if (S !== null) {
                  S.return = s.return, Le = S;
                  break e;
                }
                Le = s.return;
              }}
          }
          var w = n.current;
          for (Le = w; Le !== null;) {
            o = Le;
            var M = o.child;
            if ((o.subtreeFlags & 2064) != 0 && M !== null) {
              M.return = o, Le = M;
            } else {e: for (o = w; Le !== null;) {
                if (a = Le, (a.flags & 2048) != 0) {
                  try {
                    switch (a.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pp(9, a);
                    }
                  } catch (b) {
                    dn(a, a.return, b);
                  }
                }
                if (a === o) {
                  Le = null;
                  break e;
                }
                var T = a.sibling;
                if (T !== null) {
                  T.return = a.return, Le = T;
                  break e;
                }
                Le = a.return;
              }}
          }
          if (
            vt = i, No(), ps && typeof ps.onPostCommitFiberRoot == "function"
          ) {
            try {
              ps.onPostCommitFiberRoot(Uh, n);
            } catch {}
          }
          r = !0;
        }
        return r;
      } finally {
        Dt = t, Si.transition = e;
      }
    }
    return !1;
  }
  function sA(n, e, t) {
    e = Su(t, e),
      e = MT(n, e, 1),
      n = ko(n, e, 1),
      e = pr(),
      n !== null && (rf(n, 1, e), kr(n, e));
  }
  function dn(n, e, t) {
    if (n.tag === 3) sA(n, n, t);
    else {for (; e !== null;) {
        if (e.tag === 3) {
          sA(e, n, t);
          break;
        } else if (e.tag === 1) {
          var r = e.stateNode;
          if (
            typeof e.type.getDerivedStateFromError == "function" ||
            typeof r.componentDidCatch == "function" &&
              (Oo === null || !Oo.has(r))
          ) {
            n = Su(t, n),
              n = ET(e, n, 1),
              e = ko(e, n, 1),
              n = pr(),
              e !== null && (rf(e, 1, n), kr(e, n));
            break;
          }
        }
        e = e.return;
      }}
  }
  function dN(n, e, t) {
    var r = n.pingCache;
    r !== null && r.delete(e),
      e = pr(),
      n.pingedLanes |= n.suspendedLanes & t,
      zn === n && (Wn & t) === t &&
      (bn === 4 || bn === 3 && (Wn & 130023424) === Wn && 500 > vn() - qy
        ? qa(n, 0)
        : Xy |= t),
      kr(n, e);
  }
  function oA(n, e) {
    e === 0 &&
      ((n.mode & 1) == 0
        ? e = 1
        : (e = Hh, Hh <<= 1, (Hh & 130023424) == 0 && (Hh = 4194304)));
    var t = pr();
    n = Bs(n, e), n !== null && (rf(n, e, t), kr(n, t));
  }
  function hN(n) {
    var e = n.memoizedState, t = 0;
    e !== null && (t = e.retryLane), oA(n, t);
  }
  function pN(n, e) {
    var t = 0;
    switch (n.tag) {
      case 13:
        var r = n.stateNode, i = n.memoizedState;
        i !== null && (t = i.retryLane);
        break;
      case 19:
        r = n.stateNode;
        break;
      default:
        throw Error(he(314));
    }
    r !== null && r.delete(e), oA(n, t);
  }
  var aA;
  aA = function (n, e, t) {
    if (n !== null) {
      if (n.memoizedProps !== e.pendingProps || Pr.current) Nr = !0;
      else {
        if ((n.lanes & t) == 0 && (e.flags & 128) == 0) {
          return Nr = !1, tN(n, e, t);
        }
        Nr = (n.flags & 131072) != 0;
      }
    } else Nr = !1, Kt && (e.flags & 1048576) != 0 && BE(e, pp, e.index);
    switch (e.lanes = 0, e.tag) {
      case 2:
        var r = e.type;
        Rp(n, e), n = e.pendingProps;
        var i = hu(e, $n.current);
        yu(e, t), i = Ay(null, e, r, n, i, t);
        var s = Cy();
        return e.flags |= 1,
          typeof i == "object" && i !== null && typeof i.render == "function" &&
            i.$$typeof === void 0
            ? (e.tag = 1,
              e.memoizedState = null,
              e.updateQueue = null,
              Ir(r) ? (s = !0, fp(e)) : s = !1,
              e.memoizedState = i.state !== null && i.state !== void 0
                ? i.state
                : null,
              vy(e),
              i.updater = _p,
              e.stateNode = i,
              i._reactInternals = e,
              xy(e, r, n, t),
              e = ky(null, e, r, !0, s, t))
            : (e.tag = 0, Kt && s && ay(e), hr(null, e, i, t), e = e.child),
          e;
      case 16:
        r = e.elementType;
        e: {
          switch (
            Rp(n, e),
              n = e.pendingProps,
              i = r._init,
              r = i(r._payload),
              e.type = r,
              i = e.tag = gN(r),
              n = Bi(r, n),
              i
          ) {
            case 0:
              e = Dy(null, e, r, n, t);
              break e;
            case 1:
              e = NT(null, e, r, n, t);
              break e;
            case 11:
              e = bT(null, e, r, n, t);
              break e;
            case 14:
              e = RT(null, e, r, Bi(r.type, n), t);
              break e;
          }
          throw Error(he(306, r, ""));
        }
        return e;
      case 0:
        return r = e.type,
          i = e.pendingProps,
          i = e.elementType === r ? i : Bi(r, i),
          Dy(n, e, r, i, t);
      case 1:
        return r = e.type,
          i = e.pendingProps,
          i = e.elementType === r ? i : Bi(r, i),
          NT(n, e, r, i, t);
      case 3:
        e: {
          if (DT(e), n === null) throw Error(he(387));
          r = e.pendingProps,
            s = e.memoizedState,
            i = s.element,
            WE(n, e),
            xp(e, r, null, t);
          var o = e.memoizedState;
          if (r = o.element, s.isDehydrated) {
            if (
              s = {
                element: r,
                isDehydrated: !1,
                cache: o.cache,
                pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                transitions: o.transitions,
              },
                e.updateQueue.baseState = s,
                e.memoizedState = s,
                e.flags & 256
            ) {
              i = Su(Error(he(423)), e), e = kT(n, e, r, t, i);
              break e;
            } else if (r !== i) {
              i = Su(Error(he(424)), e), e = kT(n, e, r, t, i);
              break e;
            } else {for (
                qr = Lo(e.stateNode.containerInfo.firstChild),
                  Xr = e,
                  Kt = !0,
                  zi = null,
                  t = eT(e, null, r, t),
                  e.child = t;
                t;
              ) t.flags = t.flags & -3 | 4096, t = t.sibling;}
          } else {
            if (gu(), r === i) {
              e = Vs(n, e, t);
              break e;
            }
            hr(n, e, r, t);
          }
          e = e.child;
        }
        return e;
      case 5:
        return tT(e),
          n === null && cy(e),
          r = e.type,
          i = e.pendingProps,
          s = n !== null ? n.memoizedProps : null,
          o = i.children,
          ty(r, i) ? o = null : s !== null && ty(r, s) && (e.flags |= 32),
          IT(n, e),
          hr(n, e, o, t),
          e.child;
      case 6:
        return n === null && cy(e), null;
      case 13:
        return FT(n, e, t);
      case 4:
        return _y(e, e.stateNode.containerInfo),
          r = e.pendingProps,
          n === null ? e.child = xu(e, null, r, t) : hr(n, e, r, t),
          e.child;
      case 11:
        return r = e.type,
          i = e.pendingProps,
          i = e.elementType === r ? i : Bi(r, i),
          bT(n, e, r, i, t);
      case 7:
        return hr(n, e, e.pendingProps, t), e.child;
      case 8:
        return hr(n, e, e.pendingProps.children, t), e.child;
      case 12:
        return hr(n, e, e.pendingProps.children, t), e.child;
      case 10:
        e: {
          if (
            r = e.type._context,
              i = e.pendingProps,
              s = e.memoizedProps,
              o = i.value,
              Vt(gp, r._currentValue),
              r._currentValue = o,
              s !== null
          ) {
            if (Oi(s.value, o)) {
              if (s.children === i.children && !Pr.current) {
                e = Vs(n, e, t);
                break e;
              }
            } else {for (
                s = e.child, s !== null && (s.return = e); s !== null;
              ) {
                var a = s.dependencies;
                if (a !== null) {
                  o = s.child;
                  for (var u = a.firstContext; u !== null;) {
                    if (u.context === r) {
                      if (s.tag === 1) {
                        u = Us(-1, t & -t), u.tag = 2;
                        var f = s.updateQueue;
                        if (f !== null) {
                          f = f.shared;
                          var d = f.pending;
                          d === null
                            ? u.next = u
                            : (u.next = d.next, d.next = u), f.pending = u;
                        }
                      }
                      s.lanes |= t,
                        u = s.alternate,
                        u !== null && (u.lanes |= t),
                        my(s.return, t, e),
                        a.lanes |= t;
                      break;
                    }
                    u = u.next;
                  }
                } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
                else if (s.tag === 18) {
                  if (o = s.return, o === null) throw Error(he(341));
                  o.lanes |= t,
                    a = o.alternate,
                    a !== null && (a.lanes |= t),
                    my(o, t, e),
                    o = s.sibling;
                } else o = s.child;
                if (o !== null) o.return = s;
                else {for (o = s; o !== null;) {
                    if (o === e) {
                      o = null;
                      break;
                    }
                    if (s = o.sibling, s !== null) {
                      s.return = o.return, o = s;
                      break;
                    }
                    o = o.return;
                  }}
                s = o;
              }}
          }
          hr(n, e, i.children, t), e = e.child;
        }
        return e;
      case 9:
        return i = e.type,
          r = e.pendingProps.children,
          yu(e, t),
          i = xi(i),
          r = r(i),
          e.flags |= 1,
          hr(n, e, r, t),
          e.child;
      case 14:
        return r = e.type,
          i = Bi(r, e.pendingProps),
          i = Bi(r.type, i),
          RT(n, e, r, i, t);
      case 15:
        return LT(n, e, e.type, e.pendingProps, t);
      case 17:
        return r = e.type,
          i = e.pendingProps,
          i = e.elementType === r ? i : Bi(r, i),
          Rp(n, e),
          e.tag = 1,
          Ir(r) ? (n = !0, fp(e)) : n = !1,
          yu(e, t),
          KE(e, r, i),
          xy(e, r, i, t),
          ky(null, e, r, !0, n, t);
      case 19:
        return zT(n, e, t);
      case 22:
        return PT(n, e, t);
    }
    throw Error(he(156, e.tag));
  };
  function lA(n, e) {
    return BM(n, e);
  }
  function mN(n, e, t, r) {
    this.tag = n,
      this.key = t,
      this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null,
      this.index = 0,
      this.ref = null,
      this.pendingProps = e,
      this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null,
      this.mode = r,
      this.subtreeFlags = this.flags = 0,
      this.deletions = null,
      this.childLanes = this.lanes = 0,
      this.alternate = null;
  }
  function wi(n, e, t, r) {
    return new mN(n, e, t, r);
  }
  function tx(n) {
    return n = n.prototype, !(!n || !n.isReactComponent);
  }
  function gN(n) {
    if (typeof n == "function") return tx(n) ? 1 : 0;
    if (n != null) {
      if (n = n.$$typeof, n === cv) return 11;
      if (n === hv) return 14;
    }
    return 2;
  }
  function Vo(n, e) {
    var t = n.alternate;
    return t === null
      ? (t = wi(n.tag, e, n.key, n.mode),
        t.elementType = n.elementType,
        t.type = n.type,
        t.stateNode = n.stateNode,
        t.alternate = n,
        n.alternate = t)
      : (t.pendingProps = e,
        t.type = n.type,
        t.flags = 0,
        t.subtreeFlags = 0,
        t.deletions = null),
      t.flags = n.flags & 14680064,
      t.childLanes = n.childLanes,
      t.lanes = n.lanes,
      t.child = n.child,
      t.memoizedProps = n.memoizedProps,
      t.memoizedState = n.memoizedState,
      t.updateQueue = n.updateQueue,
      e = n.dependencies,
      t.dependencies = e === null
        ? null
        : { lanes: e.lanes, firstContext: e.firstContext },
      t.sibling = n.sibling,
      t.index = n.index,
      t.ref = n.ref,
      t;
  }
  function Up(n, e, t, r, i, s) {
    var o = 2;
    if (r = n, typeof n == "function") tx(n) && (o = 1);
    else if (typeof n == "string") o = 5;
    else {e: switch (n) {
        case $l:
          return Za(t.children, i, s, e);
        case lv:
          o = 8, i |= 8;
          break;
        case uv:
          return n = wi(12, t, e, i | 2), n.elementType = uv, n.lanes = s, n;
        case fv:
          return n = wi(13, t, e, i), n.elementType = fv, n.lanes = s, n;
        case dv:
          return n = wi(19, t, e, i), n.elementType = dv, n.lanes = s, n;
        case mM:
          return Vp(t, i, s, e);
        default:
          if (typeof n == "object" && n !== null) {
            switch (n.$$typeof) {
              case hM:
                o = 10;
                break e;
              case pM:
                o = 9;
                break e;
              case cv:
                o = 11;
                break e;
              case hv:
                o = 14;
                break e;
              case wo:
                o = 16, r = null;
                break e;
            }
          }
          throw Error(he(130, n == null ? n : typeof n, ""));
      }}
    return e = wi(o, t, e, i), e.elementType = n, e.type = r, e.lanes = s, e;
  }
  function Za(n, e, t, r) {
    return n = wi(7, n, r, e), n.lanes = t, n;
  }
  function Vp(n, e, t, r) {
    return n = wi(22, n, r, e),
      n.elementType = mM,
      n.lanes = t,
      n.stateNode = { isHidden: !1 },
      n;
  }
  function nx(n, e, t) {
    return n = wi(6, n, null, e), n.lanes = t, n;
  }
  function rx(n, e, t) {
    return e = wi(4, n.children !== null ? n.children : [], n.key, e),
      e.lanes = t,
      e.stateNode = {
        containerInfo: n.containerInfo,
        pendingChildren: null,
        implementation: n.implementation,
      },
      e;
  }
  function vN(n, e, t, r, i) {
    this.tag = e,
      this.containerInfo = n,
      this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null,
      this.timeoutHandle = -1,
      this.callbackNode = this.pendingContext = this.context = null,
      this.callbackPriority = 0,
      this.eventTimes = Nv(0),
      this.expirationTimes = Nv(-1),
      this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0,
      this.entanglements = Nv(0),
      this.identifierPrefix = r,
      this.onRecoverableError = i,
      this.mutableSourceEagerHydrationData = null;
  }
  function ix(n, e, t, r, i, s, o, a, u) {
    return n = new vN(n, e, t, a, u),
      e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0,
      s = wi(3, null, null, e),
      n.current = s,
      s.stateNode = n,
      s.memoizedState = {
        element: r,
        isDehydrated: t,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null,
      },
      vy(s),
      n;
  }
  function yN(n, e, t) {
    var r = 3 < arguments.length && arguments[3] !== void 0
      ? arguments[3]
      : null;
    return {
      $$typeof: Ql,
      key: r == null ? null : "" + r,
      children: n,
      containerInfo: e,
      implementation: t,
    };
  }
  function uA(n) {
    if (!n) return Io;
    n = n._reactInternals;
    e: {
      if (Oa(n) !== n || n.tag !== 1) throw Error(he(170));
      var e = n;
      do {
        switch (e.tag) {
          case 3:
            e = e.stateNode.context;
            break e;
          case 1:
            if (Ir(e.type)) {
              e = e.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        e = e.return;
      } while (e !== null);
      throw Error(he(171));
    }
    if (n.tag === 1) {
      var t = n.type;
      if (Ir(t)) return FE(n, t, e);
    }
    return e;
  }
  function cA(n, e, t, r, i, s, o, a, u) {
    return n = ix(t, r, !0, n, i, s, o, a, u),
      n.context = uA(null),
      t = n.current,
      r = pr(),
      i = Bo(t),
      s = Us(r, i),
      s.callback = e ?? null,
      ko(t, s, i),
      n.current.lanes = i,
      rf(n, i, r),
      kr(n, r),
      n;
  }
  function Hp(n, e, t, r) {
    var i = e.current, s = pr(), o = Bo(i);
    return t = uA(t),
      e.context === null ? e.context = t : e.pendingContext = t,
      e = Us(s, o),
      e.payload = { element: n },
      r = r === void 0 ? null : r,
      r !== null && (e.callback = r),
      n = ko(i, e, o),
      n !== null && (Hi(n, i, o, s), yp(n, i, o)),
      o;
  }
  function Gp(n) {
    if (n = n.current, !n.child) return null;
    switch (n.child.tag) {
      case 5:
        return n.child.stateNode;
      default:
        return n.child.stateNode;
    }
  }
  function fA(n, e) {
    if (n = n.memoizedState, n !== null && n.dehydrated !== null) {
      var t = n.retryLane;
      n.retryLane = t !== 0 && t < e ? t : e;
    }
  }
  function sx(n, e) {
    fA(n, e), (n = n.alternate) && fA(n, e);
  }
  function xN() {
    return null;
  }
  var dA = typeof reportError == "function" ? reportError : function (n) {
    console.error(n);
  };
  function ox(n) {
    this._internalRoot = n;
  }
  jp.prototype.render = ox.prototype.render = function (n) {
    var e = this._internalRoot;
    if (e === null) throw Error(he(409));
    Hp(n, e, null, null);
  };
  jp.prototype.unmount = ox.prototype.unmount = function () {
    var n = this._internalRoot;
    if (n !== null) {
      this._internalRoot = null;
      var e = n.containerInfo;
      Xa(function () {
        Hp(null, n, null, null);
      }), e[ks] = null;
    }
  };
  function jp(n) {
    this._internalRoot = n;
  }
  jp.prototype.unstable_scheduleHydration = function (n) {
    if (n) {
      var e = qM();
      n = { blockedOn: null, target: n, priority: e };
      for (var t = 0; t < Co.length && e !== 0 && e < Co[t].priority; t++);
      Co.splice(t, 0, n), t === 0 && KM(n);
    }
  };
  function ax(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11);
  }
  function Wp(n) {
    return !(!n ||
      n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11 &&
        (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "));
  }
  function hA() {}
  function _N(n, e, t, r, i) {
    if (i) {
      if (typeof r == "function") {
        var s = r;
        r = function () {
          var f = Gp(o);
          s.call(f);
        };
      }
      var o = cA(e, r, n, 0, null, !1, !1, "", hA);
      return n._reactRootContainer = o,
        n[ks] = o.current,
        yf(n.nodeType === 8 ? n.parentNode : n),
        Xa(),
        o;
    }
    for (; i = n.lastChild;) n.removeChild(i);
    if (typeof r == "function") {
      var a = r;
      r = function () {
        var f = Gp(u);
        a.call(f);
      };
    }
    var u = ix(n, 0, !1, null, null, !1, !1, "", hA);
    return n._reactRootContainer = u,
      n[ks] = u.current,
      yf(n.nodeType === 8 ? n.parentNode : n),
      Xa(function () {
        Hp(e, u, t, r);
      }),
      u;
  }
  function Xp(n, e, t, r, i) {
    var s = t._reactRootContainer;
    if (s) {
      var o = s;
      if (typeof i == "function") {
        var a = i;
        i = function () {
          var u = Gp(o);
          a.call(u);
        };
      }
      Hp(e, o, n, i);
    } else o = _N(t, e, n, i, r);
    return Gp(o);
  }
  WM = function (n) {
    switch (n.tag) {
      case 3:
        var e = n.stateNode;
        if (e.current.memoizedState.isDehydrated) {
          var t = nf(e.pendingLanes);
          t !== 0 &&
            (Dv(e, t | 1),
              kr(e, vn()),
              (vt & 6) == 0 && (Eu = vn() + 500, No()));
        }
        break;
      case 13:
        Xa(function () {
          var r = Bs(n, 1);
          if (r !== null) {
            var i = pr();
            Hi(r, n, 1, i);
          }
        }), sx(n, 1);
    }
  };
  kv = function (n) {
    if (n.tag === 13) {
      var e = Bs(n, 134217728);
      if (e !== null) {
        var t = pr();
        Hi(e, n, 134217728, t);
      }
      sx(n, 134217728);
    }
  };
  XM = function (n) {
    if (n.tag === 13) {
      var e = Bo(n), t = Bs(n, e);
      if (t !== null) {
        var r = pr();
        Hi(t, n, e, r);
      }
      sx(n, e);
    }
  };
  qM = function () {
    return Dt;
  };
  YM = function (n, e) {
    var t = Dt;
    try {
      return Dt = n, e();
    } finally {
      Dt = t;
    }
  };
  Cv = function (n, e, t) {
    switch (e) {
      case "input":
        if (xv(n, t), e = t.name, t.type === "radio" && e != null) {
          for (t = n; t.parentNode;) t = t.parentNode;
          for (
            t = t.querySelectorAll(
              "input[name=" + JSON.stringify("" + e) + '][type="radio"]',
            ), e = 0;
            e < t.length;
            e++
          ) {
            var r = t[e];
            if (r !== n && r.form === n.form) {
              var i = up(r);
              if (!i) throw Error(he(90));
              yM(r), xv(r, i);
            }
          }
        }
        break;
      case "textarea":
        MM(n, t);
        break;
      case "select":
        e = t.value, e != null && eu(n, !!t.multiple, e, !1);
    }
  };
  IM = Qy;
  NM = Xa;
  var SN = { usingClientEntryPoint: !1, Events: [Sf, fu, up, LM, PM, Qy] },
    kf = {
      findFiberByHostInstance: za,
      bundleType: 0,
      version: "18.2.0",
      rendererPackageName: "react-dom",
    },
    wN = {
      bundleType: kf.bundleType,
      version: kf.version,
      rendererPackageName: kf.rendererPackageName,
      rendererConfig: kf.rendererConfig,
      overrideHookState: null,
      overrideHookStateDeletePath: null,
      overrideHookStateRenamePath: null,
      overrideProps: null,
      overridePropsDeletePath: null,
      overridePropsRenamePath: null,
      setErrorHandler: null,
      setSuspenseHandler: null,
      scheduleUpdate: null,
      currentDispatcherRef: Ds.ReactCurrentDispatcher,
      findHostInstanceByFiber: function (n) {
        return n = OM(n), n === null ? null : n.stateNode;
      },
      findFiberByHostInstance: kf.findFiberByHostInstance || xN,
      findHostInstancesForRefresh: null,
      scheduleRefresh: null,
      scheduleRoot: null,
      setRefreshHandler: null,
      getCurrentFiber: null,
      reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
    };
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ != "undefined" &&
    (Ff = __REACT_DEVTOOLS_GLOBAL_HOOK__, !Ff.isDisabled && Ff.supportsFiber)
  ) {
    try {
      Uh = Ff.inject(wN), ps = Ff;
    } catch {}
  }
  var Ff;
  Zr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = SN;
  Zr.createPortal = function (n, e) {
    var t = 2 < arguments.length && arguments[2] !== void 0
      ? arguments[2]
      : null;
    if (!ax(e)) throw Error(he(200));
    return yN(n, e, null, t);
  };
  Zr.createRoot = function (n, e) {
    if (!ax(n)) throw Error(he(299));
    var t = !1, r = "", i = dA;
    return e != null &&
      (e.unstable_strictMode === !0 && (t = !0),
        e.identifierPrefix !== void 0 && (r = e.identifierPrefix),
        e.onRecoverableError !== void 0 && (i = e.onRecoverableError)),
      e = ix(n, 1, !1, null, null, t, !1, r, i),
      n[ks] = e.current,
      yf(n.nodeType === 8 ? n.parentNode : n),
      new ox(e);
  };
  Zr.findDOMNode = function (n) {
    if (n == null) return null;
    if (n.nodeType === 1) return n;
    var e = n._reactInternals;
    if (e === void 0) {
      throw typeof n.render == "function"
        ? Error(he(188))
        : (n = Object.keys(n).join(","), Error(he(268, n)));
    }
    return n = OM(e), n = n === null ? null : n.stateNode, n;
  };
  Zr.flushSync = function (n) {
    return Xa(n);
  };
  Zr.hydrate = function (n, e, t) {
    if (!Wp(e)) throw Error(he(200));
    return Xp(null, n, e, !0, t);
  };
  Zr.hydrateRoot = function (n, e, t) {
    if (!ax(n)) throw Error(he(405));
    var r = t != null && t.hydratedSources || null, i = !1, s = "", o = dA;
    if (
      t != null &&
      (t.unstable_strictMode === !0 && (i = !0),
        t.identifierPrefix !== void 0 && (s = t.identifierPrefix),
        t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
        e = cA(e, null, n, 1, t ?? null, i, !1, s, o),
        n[ks] = e.current,
        yf(n),
        r
    ) {
      for (n = 0; n < r.length; n++) {
        t = r[n],
          i = t._getVersion,
          i = i(t._source),
          e.mutableSourceEagerHydrationData == null
            ? e.mutableSourceEagerHydrationData = [t, i]
            : e.mutableSourceEagerHydrationData.push(t, i);
      }
    }
    return new jp(e);
  };
  Zr.render = function (n, e, t) {
    if (!Wp(e)) throw Error(he(200));
    return Xp(null, n, e, !1, t);
  };
  Zr.unmountComponentAtNode = function (n) {
    if (!Wp(n)) throw Error(he(40));
    return n._reactRootContainer
      ? (Xa(function () {
        Xp(null, null, n, !1, function () {
          n._reactRootContainer = null, n[ks] = null;
        });
      }),
        !0)
      : !1;
  };
  Zr.unstable_batchedUpdates = Qy;
  Zr.unstable_renderSubtreeIntoContainer = function (n, e, t, r) {
    if (!Wp(t)) throw Error(he(200));
    if (n == null || n._reactInternals === void 0) throw Error(he(38));
    return Xp(n, e, t, !1, r);
  };
  Zr.version = "18.2.0-next-9e3b772b8-20220608";
});
var vA = cr((AU, gA) => {
  "use strict";
  function mA() {
    if (
      !(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ == "undefined" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")
    ) {
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(mA);
      } catch (n) {
        console.error(n);
      }
    }
  }
  mA(), gA.exports = pA();
});
var MN = cr((lx) => {
  "use strict";
  var yA = vA();
  lx.createRoot = yA.createRoot, lx.hydrateRoot = yA.hydrateRoot;
  var CU;
});
var m3 = cr((Ll) => {
  "use strict";
  Ll.ConcurrentRoot = 1;
  Ll.ContinuousEventPriority = 4;
  Ll.DefaultEventPriority = 16;
  Ll.DiscreteEventPriority = 1;
  Ll.IdleEventPriority = 536870912;
  Ll.LegacyRoot = 0;
});
var pS = cr((IU, g3) => {
  "use strict";
  g3.exports = m3();
});
var b3 = cr((Ht) => {
  "use strict";
  function mS(n, e) {
    var t = n.length;
    n.push(e);
    e: for (; 0 < t;) {
      var r = t - 1 >>> 1, i = n[r];
      if (0 < xg(i, e)) n[r] = e, n[t] = i, t = r;
      else break e;
    }
  }
  function ts(n) {
    return n.length === 0 ? null : n[0];
  }
  function yg(n) {
    if (n.length === 0) return null;
    var e = n[0], t = n.pop();
    if (t !== e) {
      n[0] = t;
      e: for (var r = 0, i = n.length, s = i >>> 1; r < s;) {
        var o = 2 * (r + 1) - 1, a = n[o], u = o + 1, f = n[u];
        if (0 > xg(a, t)) {
          u < i && 0 > xg(f, a)
            ? (n[r] = f, n[u] = t, r = u)
            : (n[r] = a, n[o] = t, r = o);
        } else if (u < i && 0 > xg(f, t)) n[r] = f, n[u] = t, r = u;
        else break e;
      }
    }
    return e;
  }
  function xg(n, e) {
    var t = n.sortIndex - e.sortIndex;
    return t !== 0 ? t : n.id - e.id;
  }
  typeof performance == "object" && typeof performance.now == "function"
    ? (x3 = performance,
      Ht.unstable_now = function () {
        return x3.now();
      })
    : (gS = Date,
      _3 = gS.now(),
      Ht.unstable_now = function () {
        return gS.now() - _3;
      });
  var x3,
    gS,
    _3,
    Ms = [],
    _a = [],
    tB = 1,
    Pi = null,
    ar = 3,
    _g = !1,
    Pl = !1,
    vd = !1,
    S3 = typeof setTimeout == "function" ? setTimeout : null,
    w3 = typeof clearTimeout == "function" ? clearTimeout : null,
    M3 = typeof setImmediate != "undefined" ? setImmediate : null;
  typeof navigator != "undefined" && navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function vS(n) {
    for (var e = ts(_a); e !== null;) {
      if (e.callback === null) yg(_a);
      else if (e.startTime <= n) {
        yg(_a), e.sortIndex = e.expirationTime, mS(Ms, e);
      } else break;
      e = ts(_a);
    }
  }
  function yS(n) {
    if (vd = !1, vS(n), !Pl) {
      if (ts(Ms) !== null) Pl = !0, wS(xS);
      else {
        var e = ts(_a);
        e !== null && MS(yS, e.startTime - n);
      }
    }
  }
  function xS(n, e) {
    Pl = !1, vd && (vd = !1, w3(yd), yd = -1), _g = !0;
    var t = ar;
    try {
      for (
        vS(e), Pi = ts(Ms);
        Pi !== null && (!(Pi.expirationTime > e) || n && !A3());
      ) {
        var r = Pi.callback;
        if (typeof r == "function") {
          Pi.callback = null, ar = Pi.priorityLevel;
          var i = r(Pi.expirationTime <= e);
          e = Ht.unstable_now(),
            typeof i == "function" ? Pi.callback = i : Pi === ts(Ms) && yg(Ms),
            vS(e);
        } else yg(Ms);
        Pi = ts(Ms);
      }
      if (Pi !== null) { var s = !0; }
      else {
        var o = ts(_a);
        o !== null && MS(yS, o.startTime - e), s = !1;
      }
      return s;
    } finally {
      Pi = null, ar = t, _g = !1;
    }
  }
  var Sg = !1, wg = null, yd = -1, E3 = 5, T3 = -1;
  function A3() {
    return !(Ht.unstable_now() - T3 < E3);
  }
  function _S() {
    if (wg !== null) {
      var n = Ht.unstable_now();
      T3 = n;
      var e = !0;
      try {
        e = wg(!0, n);
      } finally {
        e ? xd() : (Sg = !1, wg = null);
      }
    } else Sg = !1;
  }
  var xd;
  typeof M3 == "function"
    ? xd = function () {
      M3(_S);
    }
    : typeof MessageChannel != "undefined"
    ? (SS = new MessageChannel(),
      C3 = SS.port2,
      SS.port1.onmessage = _S,
      xd = function () {
        C3.postMessage(null);
      })
    : xd = function () {
      S3(_S, 0);
    };
  var SS, C3;
  function wS(n) {
    wg = n, Sg || (Sg = !0, xd());
  }
  function MS(n, e) {
    yd = S3(function () {
      n(Ht.unstable_now());
    }, e);
  }
  Ht.unstable_IdlePriority = 5;
  Ht.unstable_ImmediatePriority = 1;
  Ht.unstable_LowPriority = 4;
  Ht.unstable_NormalPriority = 3;
  Ht.unstable_Profiling = null;
  Ht.unstable_UserBlockingPriority = 2;
  Ht.unstable_cancelCallback = function (n) {
    n.callback = null;
  };
  Ht.unstable_continueExecution = function () {
    Pl || _g || (Pl = !0, wS(xS));
  };
  Ht.unstable_forceFrameRate = function (n) {
    0 > n || 125 < n
      ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported",
      )
      : E3 = 0 < n ? Math.floor(1e3 / n) : 5;
  };
  Ht.unstable_getCurrentPriorityLevel = function () {
    return ar;
  };
  Ht.unstable_getFirstCallbackNode = function () {
    return ts(Ms);
  };
  Ht.unstable_next = function (n) {
    switch (ar) {
      case 1:
      case 2:
      case 3:
        var e = 3;
        break;
      default:
        e = ar;
    }
    var t = ar;
    ar = e;
    try {
      return n();
    } finally {
      ar = t;
    }
  };
  Ht.unstable_pauseExecution = function () {};
  Ht.unstable_requestPaint = function () {};
  Ht.unstable_runWithPriority = function (n, e) {
    switch (n) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        n = 3;
    }
    var t = ar;
    ar = n;
    try {
      return e();
    } finally {
      ar = t;
    }
  };
  Ht.unstable_scheduleCallback = function (n, e, t) {
    var r = Ht.unstable_now();
    switch (
      typeof t == "object" && t !== null
        ? (t = t.delay, t = typeof t == "number" && 0 < t ? r + t : r)
        : t = r, n
    ) {
      case 1:
        var i = -1;
        break;
      case 2:
        i = 250;
        break;
      case 5:
        i = 1073741823;
        break;
      case 4:
        i = 1e4;
        break;
      default:
        i = 5e3;
    }
    return i = t + i,
      n = {
        id: tB++,
        callback: e,
        priorityLevel: n,
        startTime: t,
        expirationTime: i,
        sortIndex: -1,
      },
      t > r
        ? (n.sortIndex = t,
          mS(_a, n),
          ts(Ms) === null && n === ts(_a) &&
          (vd ? (w3(yd), yd = -1) : vd = !0, MS(yS, t - r)))
        : (n.sortIndex = i, mS(Ms, n), Pl || _g || (Pl = !0, wS(xS))),
      n;
  };
  Ht.unstable_shouldYield = A3;
  Ht.unstable_wrapCallback = function (n) {
    var e = ar;
    return function () {
      var t = ar;
      ar = e;
      try {
        return n.apply(this, arguments);
      } finally {
        ar = t;
      }
    };
  };
});
var Mg = cr((kU, R3) => {
  "use strict";
  R3.exports = b3();
});
var P3 = cr((FU, L3) => {
  L3.exports = function (e) {
    var t = {}, r = An(), i = Mg(), s = Object.assign;
    function o(l) {
      for (
        var c = "https://reactjs.org/docs/error-decoder.html?invariant=" + l,
          m = 1;
        m < arguments.length;
        m++
      ) c += "&args[]=" + encodeURIComponent(arguments[m]);
      return "Minified React error #" + l + "; visit " + c +
        " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
      u = Symbol.for("react.element"),
      f = Symbol.for("react.portal"),
      d = Symbol.for("react.fragment"),
      h = Symbol.for("react.strict_mode"),
      p = Symbol.for("react.profiler"),
      g = Symbol.for("react.provider"),
      y = Symbol.for("react.context"),
      v = Symbol.for("react.forward_ref"),
      _ = Symbol.for("react.suspense"),
      S = Symbol.for("react.suspense_list"),
      w = Symbol.for("react.memo"),
      M = Symbol.for("react.lazy");
    Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode");
    var T = Symbol.for("react.offscreen");
    Symbol.for("react.legacy_hidden"),
      Symbol.for("react.cache"),
      Symbol.for("react.tracing_marker");
    var b = Symbol.iterator;
    function R(l) {
      return l === null || typeof l != "object"
        ? null
        : (l = b && l[b] || l["@@iterator"], typeof l == "function" ? l : null);
    }
    function P(l) {
      if (l == null) return null;
      if (typeof l == "function") return l.displayName || l.name || null;
      if (typeof l == "string") return l;
      switch (l) {
        case d:
          return "Fragment";
        case f:
          return "Portal";
        case p:
          return "Profiler";
        case h:
          return "StrictMode";
        case _:
          return "Suspense";
        case S:
          return "SuspenseList";
      }
      if (typeof l == "object") {
        switch (l.$$typeof) {
          case y:
            return (l.displayName || "Context") + ".Consumer";
          case g:
            return (l._context.displayName || "Context") + ".Provider";
          case v:
            var c = l.render;
            return l = l.displayName,
              l ||
              (l = c.displayName || c.name || "",
                l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef"),
              l;
          case w:
            return c = l.displayName || null,
              c !== null ? c : P(l.type) || "Memo";
          case M:
            c = l._payload, l = l._init;
            try {
              return P(l(c));
            } catch {}
        }
      }
      return null;
    }
    function C(l) {
      var c = l.type;
      switch (l.tag) {
        case 24:
          return "Cache";
        case 9:
          return (c.displayName || "Context") + ".Consumer";
        case 10:
          return (c._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return l = c.render,
            l = l.displayName || l.name || "",
            c.displayName ||
            (l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return c;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return P(c);
        case 8:
          return c === h ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if (typeof c == "function") return c.displayName || c.name || null;
          if (typeof c == "string") return c;
      }
      return null;
    }
    function L(l) {
      var c = l, m = l;
      if (l.alternate) { for (; c.return;) c = c.return; }
      else {
        l = c;
        do c = l, (c.flags & 4098) != 0 && (m = c.return), l = c.return; while (
          l
        );
      }
      return c.tag === 3 ? m : null;
    }
    function k(l) {
      if (L(l) !== l) throw Error(o(188));
    }
    function z(l) {
      var c = l.alternate;
      if (!c) {
        if (c = L(l), c === null) throw Error(o(188));
        return c !== l ? null : l;
      }
      for (var m = l, x = c;;) {
        var E = m.return;
        if (E === null) break;
        var A = E.alternate;
        if (A === null) {
          if (x = E.return, x !== null) {
            m = x;
            continue;
          }
          break;
        }
        if (E.child === A.child) {
          for (A = E.child; A;) {
            if (A === m) return k(E), l;
            if (A === x) return k(E), c;
            A = A.sibling;
          }
          throw Error(o(188));
        }
        if (m.return !== x.return) m = E, x = A;
        else {
          for (var F = !1, U = E.child; U;) {
            if (U === m) {
              F = !0, m = E, x = A;
              break;
            }
            if (U === x) {
              F = !0, x = E, m = A;
              break;
            }
            U = U.sibling;
          }
          if (!F) {
            for (U = A.child; U;) {
              if (U === m) {
                F = !0, m = A, x = E;
                break;
              }
              if (U === x) {
                F = !0, x = A, m = E;
                break;
              }
              U = U.sibling;
            }
            if (!F) throw Error(o(189));
          }
        }
        if (m.alternate !== x) throw Error(o(190));
      }
      if (m.tag !== 3) throw Error(o(188));
      return m.stateNode.current === m ? l : c;
    }
    function Y(l) {
      return l = z(l), l !== null ? le(l) : null;
    }
    function le(l) {
      if (l.tag === 5 || l.tag === 6) return l;
      for (l = l.child; l !== null;) {
        var c = le(l);
        if (c !== null) return c;
        l = l.sibling;
      }
      return null;
    }
    function V(l) {
      if (l.tag === 5 || l.tag === 6) return l;
      for (l = l.child; l !== null;) {
        if (l.tag !== 4) {
          var c = V(l);
          if (c !== null) return c;
        }
        l = l.sibling;
      }
      return null;
    }
    var W = Array.isArray,
      G = e.getPublicInstance,
      re = e.getRootHostContext,
      ie = e.getChildHostContext,
      X = e.prepareForCommit,
      $ = e.resetAfterCommit,
      ae = e.createInstance,
      fe = e.appendInitialChild,
      pe = e.finalizeInitialChildren,
      Pe = e.prepareUpdate,
      Oe = e.shouldSetTextContent,
      oe = e.createTextInstance,
      Et = e.scheduleTimeout,
      $e = e.cancelTimeout,
      Ze = e.noTimeout,
      Se = e.isPrimaryRenderer,
      je = e.supportsMutation,
      ue = e.supportsPersistence,
      ne = e.supportsHydration,
      _e = e.getInstanceFromNode,
      Fe = e.preparePortalMount,
      Ae = e.getCurrentEventPriority,
      et = e.detachDeletedInstance,
      We = e.supportsMicrotasks,
      Ve = e.scheduleMicrotask,
      Tt = e.supportsTestSelectors,
      Nt = e.findFiberRoot,
      O = e.getBoundingRect,
      N = e.getTextContent,
      J = e.isHiddenSubtree,
      me = e.matchAccessibilityRole,
      xe = e.setFocusIfFocusable,
      Ce = e.setupIntersectionObserver,
      Ke = e.appendChild,
      ee = e.appendChildToContainer,
      Be = e.commitTextUpdate,
      Ie = e.commitMount,
      Re = e.commitUpdate,
      B = e.insertBefore,
      Me = e.insertInContainerBefore,
      we = e.removeChild,
      Xe = e.removeChildFromContainer,
      Ne = e.resetTextContent,
      Je = e.hideInstance,
      ye = e.hideTextInstance,
      Qe = e.unhideInstance,
      At = e.unhideTextInstance,
      Ct = e.clearContainer,
      Vn = e.cloneInstance,
      Br = e.createContainerChildSet,
      Ec = e.appendChildToContainerChildSet,
      Og = e.finalizeContainerChildren,
      Ea = e.replaceContainerChildren,
      bd = e.cloneHiddenInstance,
      Fl = e.cloneHiddenTextInstance,
      Rd = e.canHydrateInstance,
      zg = e.canHydrateTextInstance,
      Bg = e.canHydrateSuspenseInstance,
      Ld = e.isSuspenseInstancePending,
      D = e.isSuspenseInstanceFallback,
      q = e.registerSuspenseInstanceRetry,
      Q = e.getNextHydratableSibling,
      Z = e.getFirstHydratableChild,
      de = e.getFirstHydratableChildWithinContainer,
      qe = e.getFirstHydratableChildWithinSuspenseInstance,
      tt = e.hydrateInstance,
      ot = e.hydrateTextInstance,
      it = e.hydrateSuspenseInstance,
      bt = e.getNextHydratableInstanceAfterSuspenseInstance,
      dt = e.commitHydratedContainer,
      mt = e.commitHydratedSuspenseInstance,
      Xt = e.clearSuspenseBoundary,
      Ts = e.clearSuspenseBoundaryFromContainer,
      co = e.shouldDeleteUnhydratedTailInstances,
      fo = e.didNotMatchHydratedContainerTextInstance,
      oi = e.didNotMatchHydratedTextInstance,
      gt;
    function ai(l) {
      if (gt === void 0) {
        try {
          throw Error();
        } catch (m) {
          var c = m.stack.trim().match(/\n( *(at )?)/);
          gt = c && c[1] || "";
        }
      }
      return `
` + gt + l;
    }
    var qt = !1;
    function Tr(l, c) {
      if (!l || qt) return "";
      qt = !0;
      var m = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (c) {
          if (
            c = function () {
              throw Error();
            },
              Object.defineProperty(c.prototype, "props", {
                set: function () {
                  throw Error();
                },
              }),
              typeof Reflect == "object" && Reflect.construct
          ) {
            try {
              Reflect.construct(c, []);
            } catch (ge) {
              var x = ge;
            }
            Reflect.construct(l, [], c);
          } else {
            try {
              c.call();
            } catch (ge) {
              x = ge;
            }
            l.call(c.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (ge) {
            x = ge;
          }
          l();
        }
      } catch (ge) {
        if (ge && x && typeof ge.stack == "string") {
          for (
            var E = ge.stack.split(`
`),
              A = x.stack.split(`
`),
              F = E.length - 1,
              U = A.length - 1;
            1 <= F && 0 <= U && E[F] !== A[U];
          ) U--;
          for (; 1 <= F && 0 <= U; F--, U--) {
            if (E[F] !== A[U]) {
              if (F !== 1 || U !== 1) {
                do if (F--, U--, 0 > U || E[F] !== A[U]) {
                  var te = `
` + E[F].replace(" at new ", " at ");
                  return l.displayName && te.includes("<anonymous>") &&
                    (te = te.replace("<anonymous>", l.displayName)),
                    te;
                } while (1 <= F && 0 <= U);
              }
              break;
            }
          }
        }
      } finally {
        qt = !1, Error.prepareStackTrace = m;
      }
      return (l = l ? l.displayName || l.name : "") ? ai(l) : "";
    }
    var is = Object.prototype.hasOwnProperty, As = [], ss = -1;
    function Yt(l) {
      return { current: l };
    }
    function Rt(l) {
      0 > ss || (l.current = As[ss], As[ss] = null, ss--);
    }
    function Pt(l, c) {
      ss++, As[ss] = l.current, l.current = c;
    }
    var En = {}, qn = Yt(En), Ar = Yt(!1), Ta = En;
    function Ol(l, c) {
      var m = l.type.contextTypes;
      if (!m) return En;
      var x = l.stateNode;
      if (x && x.__reactInternalMemoizedUnmaskedChildContext === c) {
        return x.__reactInternalMemoizedMaskedChildContext;
      }
      var E = {}, A;
      for (A in m) E[A] = c[A];
      return x &&
        (l = l.stateNode,
          l.__reactInternalMemoizedUnmaskedChildContext = c,
          l.__reactInternalMemoizedMaskedChildContext = E),
        E;
    }
    function Cr(l) {
      return l = l.childContextTypes, l != null;
    }
    function Pd() {
      Rt(Ar), Rt(qn);
    }
    function i1(l, c, m) {
      if (qn.current !== En) throw Error(o(168));
      Pt(qn, c), Pt(Ar, m);
    }
    function s1(l, c, m) {
      var x = l.stateNode;
      if (c = c.childContextTypes, typeof x.getChildContext != "function") {
        return m;
      }
      x = x.getChildContext();
      for (var E in x) if (!(E in c)) throw Error(o(108, C(l) || "Unknown", E));
      return s({}, m, x);
    }
    function Id(l) {
      return l =
        (l = l.stateNode) && l.__reactInternalMemoizedMergedChildContext || En,
        Ta = qn.current,
        Pt(qn, l),
        Pt(Ar, Ar.current),
        !0;
    }
    function o1(l, c, m) {
      var x = l.stateNode;
      if (!x) throw Error(o(169));
      m
        ? (l = s1(l, c, Ta),
          x.__reactInternalMemoizedMergedChildContext = l,
          Rt(Ar),
          Rt(qn),
          Pt(qn, l))
        : Rt(Ar), Pt(Ar, m);
    }
    var Ii = Math.clz32 ? Math.clz32 : vL, mL = Math.log, gL = Math.LN2;
    function vL(l) {
      return l >>>= 0, l === 0 ? 32 : 31 - (mL(l) / gL | 0) | 0;
    }
    var Nd = 64, Dd = 4194304;
    function Tc(l) {
      switch (l & -l) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return l & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return l & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return l;
      }
    }
    function kd(l, c) {
      var m = l.pendingLanes;
      if (m === 0) return 0;
      var x = 0, E = l.suspendedLanes, A = l.pingedLanes, F = m & 268435455;
      if (F !== 0) {
        var U = F & ~E;
        U !== 0 ? x = Tc(U) : (A &= F, A !== 0 && (x = Tc(A)));
      } else F = m & ~E, F !== 0 ? x = Tc(F) : A !== 0 && (x = Tc(A));
      if (x === 0) return 0;
      if (
        c !== 0 && c !== x && (c & E) == 0 &&
        (E = x & -x, A = c & -c, E >= A || E === 16 && (A & 4194240) != 0)
      ) return c;
      if ((x & 4) != 0 && (x |= m & 16), c = l.entangledLanes, c !== 0) {
        for (l = l.entanglements, c &= x; 0 < c;) {
          m = 31 - Ii(c), E = 1 << m, x |= l[m], c &= ~E;
        }
      }
      return x;
    }
    function yL(l, c) {
      switch (l) {
        case 1:
        case 2:
        case 4:
          return c + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return c + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function xL(l, c) {
      for (
        var m = l.suspendedLanes,
          x = l.pingedLanes,
          E = l.expirationTimes,
          A = l.pendingLanes;
        0 < A;
      ) {
        var F = 31 - Ii(A), U = 1 << F, te = E[F];
        te === -1
          ? ((U & m) == 0 || (U & x) != 0) && (E[F] = yL(U, c))
          : te <= c && (l.expiredLanes |= U), A &= ~U;
      }
    }
    function Ug(l) {
      return l = l.pendingLanes & -1073741825,
        l !== 0 ? l : l & 1073741824 ? 1073741824 : 0;
    }
    function Vg(l) {
      for (var c = [], m = 0; 31 > m; m++) c.push(l);
      return c;
    }
    function Ac(l, c, m) {
      l.pendingLanes |= c,
        c !== 536870912 && (l.suspendedLanes = 0, l.pingedLanes = 0),
        l = l.eventTimes,
        c = 31 - Ii(c),
        l[c] = m;
    }
    function _L(l, c) {
      var m = l.pendingLanes & ~c;
      l.pendingLanes = c,
        l.suspendedLanes = 0,
        l.pingedLanes = 0,
        l.expiredLanes &= c,
        l.mutableReadLanes &= c,
        l.entangledLanes &= c,
        c = l.entanglements;
      var x = l.eventTimes;
      for (l = l.expirationTimes; 0 < m;) {
        var E = 31 - Ii(m), A = 1 << E;
        c[E] = 0, x[E] = -1, l[E] = -1, m &= ~A;
      }
    }
    function Hg(l, c) {
      var m = l.entangledLanes |= c;
      for (l = l.entanglements; m;) {
        var x = 31 - Ii(m), E = 1 << x;
        E & c | l[x] & c && (l[x] |= c), m &= ~E;
      }
    }
    var _t = 0;
    function a1(l) {
      return l &= -l,
        1 < l ? 4 < l ? (l & 268435455) != 0 ? 16 : 536870912 : 4 : 1;
    }
    var Gg = i.unstable_scheduleCallback,
      l1 = i.unstable_cancelCallback,
      SL = i.unstable_shouldYield,
      wL = i.unstable_requestPaint,
      Dn = i.unstable_now,
      jg = i.unstable_ImmediatePriority,
      ML = i.unstable_UserBlockingPriority,
      Wg = i.unstable_NormalPriority,
      EL = i.unstable_IdlePriority,
      Fd = null,
      os = null;
    function TL(l) {
      if (os && typeof os.onCommitFiberRoot == "function") {
        try {
          os.onCommitFiberRoot(Fd, l, void 0, (l.current.flags & 128) == 128);
        } catch {}
      }
    }
    function AL(l, c) {
      return l === c && (l !== 0 || 1 / l == 1 / c) || l !== l && c !== c;
    }
    var as = typeof Object.is == "function" ? Object.is : AL,
      Cs = null,
      Od = !1,
      Xg = !1;
    function u1(l) {
      Cs === null ? Cs = [l] : Cs.push(l);
    }
    function CL(l) {
      Od = !0, u1(l);
    }
    function ls() {
      if (!Xg && Cs !== null) {
        Xg = !0;
        var l = 0, c = _t;
        try {
          var m = Cs;
          for (_t = 1; l < m.length; l++) {
            var x = m[l];
            do x = x(!0); while (x !== null);
          }
          Cs = null, Od = !1;
        } catch (E) {
          throw Cs !== null && (Cs = Cs.slice(l + 1)), Gg(jg, ls), E;
        } finally {
          _t = c, Xg = !1;
        }
      }
      return null;
    }
    var bL = a.ReactCurrentBatchConfig;
    function zd(l, c) {
      if (as(l, c)) return !0;
      if (
        typeof l != "object" || l === null || typeof c != "object" || c === null
      ) return !1;
      var m = Object.keys(l), x = Object.keys(c);
      if (m.length !== x.length) return !1;
      for (x = 0; x < m.length; x++) {
        var E = m[x];
        if (!is.call(c, E) || !as(l[E], c[E])) return !1;
      }
      return !0;
    }
    function RL(l) {
      switch (l.tag) {
        case 5:
          return ai(l.type);
        case 16:
          return ai("Lazy");
        case 13:
          return ai("Suspense");
        case 19:
          return ai("SuspenseList");
        case 0:
        case 2:
        case 15:
          return l = Tr(l.type, !1), l;
        case 11:
          return l = Tr(l.type.render, !1), l;
        case 1:
          return l = Tr(l.type, !0), l;
        default:
          return "";
      }
    }
    function Ni(l, c) {
      if (l && l.defaultProps) {
        c = s({}, c), l = l.defaultProps;
        for (var m in l) c[m] === void 0 && (c[m] = l[m]);
        return c;
      }
      return c;
    }
    var Bd = Yt(null), Ud = null, zl = null, qg = null;
    function Yg() {
      qg = zl = Ud = null;
    }
    function c1(l, c, m) {
      Se
        ? (Pt(Bd, c._currentValue), c._currentValue = m)
        : (Pt(Bd, c._currentValue2), c._currentValue2 = m);
    }
    function Zg(l) {
      var c = Bd.current;
      Rt(Bd), Se ? l._currentValue = c : l._currentValue2 = c;
    }
    function Kg(l, c, m) {
      for (; l !== null;) {
        var x = l.alternate;
        if (
          (l.childLanes & c) !== c
            ? (l.childLanes |= c, x !== null && (x.childLanes |= c))
            : x !== null && (x.childLanes & c) !== c && (x.childLanes |= c),
            l === m
        ) break;
        l = l.return;
      }
    }
    function Bl(l, c) {
      Ud = l,
        qg = zl = null,
        l = l.dependencies,
        l !== null && l.firstContext !== null &&
        ((l.lanes & c) != 0 && (Hr = !0), l.firstContext = null);
    }
    function li(l) {
      var c = Se ? l._currentValue : l._currentValue2;
      if (qg !== l) {
        if (l = { context: l, memoizedValue: c, next: null }, zl === null) {
          if (Ud === null) {
            throw Error(o(308));
          }
          zl = l, Ud.dependencies = { lanes: 0, firstContext: l };
        } else zl = zl.next = l;
      }
      return c;
    }
    var us = null, ho = !1;
    function Jg(l) {
      l.updateQueue = {
        baseState: l.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, interleaved: null, lanes: 0 },
        effects: null,
      };
    }
    function f1(l, c) {
      l = l.updateQueue,
        c.updateQueue === l &&
        (c.updateQueue = {
          baseState: l.baseState,
          firstBaseUpdate: l.firstBaseUpdate,
          lastBaseUpdate: l.lastBaseUpdate,
          shared: l.shared,
          effects: l.effects,
        });
    }
    function bs(l, c) {
      return {
        eventTime: l,
        lane: c,
        tag: 0,
        payload: null,
        callback: null,
        next: null,
      };
    }
    function po(l, c) {
      var m = l.updateQueue;
      m !== null && (m = m.shared,
        _n !== null && (l.mode & 1) != 0 && (lt & 2) == 0
          ? (l = m.interleaved,
            l === null
              ? (c.next = c, us === null ? us = [m] : us.push(m))
              : (c.next = l.next, l.next = c),
            m.interleaved = c)
          : (l = m.pending,
            l === null ? c.next = c : (c.next = l.next, l.next = c),
            m.pending = c));
    }
    function Vd(l, c, m) {
      if (c = c.updateQueue, c !== null && (c = c.shared, (m & 4194240) != 0)) {
        var x = c.lanes;
        x &= l.pendingLanes, m |= x, c.lanes = m, Hg(l, m);
      }
    }
    function d1(l, c) {
      var m = l.updateQueue, x = l.alternate;
      if (x !== null && (x = x.updateQueue, m === x)) {
        var E = null, A = null;
        if (m = m.firstBaseUpdate, m !== null) {
          do {
            var F = {
              eventTime: m.eventTime,
              lane: m.lane,
              tag: m.tag,
              payload: m.payload,
              callback: m.callback,
              next: null,
            };
            A === null ? E = A = F : A = A.next = F, m = m.next;
          } while (m !== null);
          A === null ? E = A = c : A = A.next = c;
        } else E = A = c;
        m = {
          baseState: x.baseState,
          firstBaseUpdate: E,
          lastBaseUpdate: A,
          shared: x.shared,
          effects: x.effects,
        }, l.updateQueue = m;
        return;
      }
      l = m.lastBaseUpdate,
        l === null ? m.firstBaseUpdate = c : l.next = c,
        m.lastBaseUpdate = c;
    }
    function Hd(l, c, m, x) {
      var E = l.updateQueue;
      ho = !1;
      var A = E.firstBaseUpdate, F = E.lastBaseUpdate, U = E.shared.pending;
      if (U !== null) {
        E.shared.pending = null;
        var te = U, ge = te.next;
        te.next = null, F === null ? A = ge : F.next = ge, F = te;
        var De = l.alternate;
        De !== null &&
          (De = De.updateQueue,
            U = De.lastBaseUpdate,
            U !== F &&
            (U === null ? De.firstBaseUpdate = ge : U.next = ge,
              De.lastBaseUpdate = te));
      }
      if (A !== null) {
        var nt = E.baseState;
        F = 0, De = ge = te = null, U = A;
        do {
          var He = U.lane, Bt = U.eventTime;
          if ((x & He) === He) {
            De !== null &&
              (De = De.next = {
                eventTime: Bt,
                lane: 0,
                tag: U.tag,
                payload: U.payload,
                callback: U.callback,
                next: null,
              });
            e: {
              var Ue = l, Jn = U;
              switch (He = c, Bt = m, Jn.tag) {
                case 1:
                  if (Ue = Jn.payload, typeof Ue == "function") {
                    nt = Ue.call(Bt, nt, He);
                    break e;
                  }
                  nt = Ue;
                  break e;
                case 3:
                  Ue.flags = Ue.flags & -65537 | 128;
                case 0:
                  if (
                    Ue = Jn.payload,
                      He = typeof Ue == "function" ? Ue.call(Bt, nt, He) : Ue,
                      He == null
                  ) break e;
                  nt = s({}, nt, He);
                  break e;
                case 2:
                  ho = !0;
              }
            }
            U.callback !== null && U.lane !== 0 &&
              (l.flags |= 64,
                He = E.effects,
                He === null ? E.effects = [U] : He.push(U));
          } else {Bt = {
              eventTime: Bt,
              lane: He,
              tag: U.tag,
              payload: U.payload,
              callback: U.callback,
              next: null,
            },
              De === null ? (ge = De = Bt, te = nt) : De = De.next = Bt,
              F |= He;}
          if (U = U.next, U === null) {
            if (U = E.shared.pending, U === null) break;
            He = U,
              U = He.next,
              He.next = null,
              E.lastBaseUpdate = He,
              E.shared.pending = null;
          }
        } while (1);
        if (
          De === null && (te = nt),
            E.baseState = te,
            E.firstBaseUpdate = ge,
            E.lastBaseUpdate = De,
            c = E.shared.interleaved,
            c !== null
        ) {
          E = c;
          do F |= E.lane, E = E.next; while (E !== c);
        } else A === null && (E.shared.lanes = 0);
        Yl |= F, l.lanes = F, l.memoizedState = nt;
      }
    }
    function h1(l, c, m) {
      if (l = c.effects, c.effects = null, l !== null) {
        for (c = 0; c < l.length; c++) {
          var x = l[c], E = x.callback;
          if (E !== null) {
            if (x.callback = null, x = m, typeof E != "function") {
              throw Error(o(191, E));
            }
            E.call(x);
          }
        }
      }
    }
    var p1 = new r.Component().refs;
    function Qg(l, c, m, x) {
      c = l.memoizedState,
        m = m(x, c),
        m = m == null ? c : s({}, c, m),
        l.memoizedState = m,
        l.lanes === 0 && (l.updateQueue.baseState = m);
    }
    var Gd = {
      isMounted: function (l) {
        return (l = l._reactInternals) ? L(l) === l : !1;
      },
      enqueueSetState: function (l, c, m) {
        l = l._reactInternals;
        var x = ur(), E = vo(l), A = bs(x, E);
        A.payload = c,
          m != null && (A.callback = m),
          po(l, A),
          c = hi(l, E, x),
          c !== null && Vd(c, l, E);
      },
      enqueueReplaceState: function (l, c, m) {
        l = l._reactInternals;
        var x = ur(), E = vo(l), A = bs(x, E);
        A.tag = 1,
          A.payload = c,
          m != null && (A.callback = m),
          po(l, A),
          c = hi(l, E, x),
          c !== null && Vd(c, l, E);
      },
      enqueueForceUpdate: function (l, c) {
        l = l._reactInternals;
        var m = ur(), x = vo(l), E = bs(m, x);
        E.tag = 2,
          c != null && (E.callback = c),
          po(l, E),
          c = hi(l, x, m),
          c !== null && Vd(c, l, x);
      },
    };
    function m1(l, c, m, x, E, A, F) {
      return l = l.stateNode,
        typeof l.shouldComponentUpdate == "function"
          ? l.shouldComponentUpdate(x, A, F)
          : c.prototype && c.prototype.isPureReactComponent
          ? !zd(m, x) || !zd(E, A)
          : !0;
    }
    function g1(l, c, m) {
      var x = !1, E = En, A = c.contextType;
      return typeof A == "object" && A !== null
        ? A = li(A)
        : (E = Cr(c) ? Ta : qn.current,
          x = c.contextTypes,
          A = (x = x != null) ? Ol(l, E) : En),
        c = new c(m, A),
        l.memoizedState = c.state !== null && c.state !== void 0
          ? c.state
          : null,
        c.updater = Gd,
        l.stateNode = c,
        c._reactInternals = l,
        x &&
        (l = l.stateNode,
          l.__reactInternalMemoizedUnmaskedChildContext = E,
          l.__reactInternalMemoizedMaskedChildContext = A),
        c;
    }
    function v1(l, c, m, x) {
      l = c.state,
        typeof c.componentWillReceiveProps == "function" &&
        c.componentWillReceiveProps(m, x),
        typeof c.UNSAFE_componentWillReceiveProps == "function" &&
        c.UNSAFE_componentWillReceiveProps(m, x),
        c.state !== l && Gd.enqueueReplaceState(c, c.state, null);
    }
    function $g(l, c, m, x) {
      var E = l.stateNode;
      E.props = m, E.state = l.memoizedState, E.refs = p1, Jg(l);
      var A = c.contextType;
      typeof A == "object" && A !== null
        ? E.context = li(A)
        : (A = Cr(c) ? Ta : qn.current, E.context = Ol(l, A)),
        E.state = l.memoizedState,
        A = c.getDerivedStateFromProps,
        typeof A == "function" && (Qg(l, c, A, m), E.state = l.memoizedState),
        typeof c.getDerivedStateFromProps == "function" ||
        typeof E.getSnapshotBeforeUpdate == "function" ||
        typeof E.UNSAFE_componentWillMount != "function" &&
          typeof E.componentWillMount != "function" ||
        (c = E.state,
          typeof E.componentWillMount == "function" && E.componentWillMount(),
          typeof E.UNSAFE_componentWillMount == "function" &&
          E.UNSAFE_componentWillMount(),
          c !== E.state && Gd.enqueueReplaceState(E, E.state, null),
          Hd(l, m, E, x),
          E.state = l.memoizedState),
        typeof E.componentDidMount == "function" && (l.flags |= 4194308);
    }
    var Ul = [],
      Vl = 0,
      jd = null,
      Wd = 0,
      ui = [],
      ci = 0,
      Aa = null,
      Rs = 1,
      Ls = "";
    function Ca(l, c) {
      Ul[Vl++] = Wd, Ul[Vl++] = jd, jd = l, Wd = c;
    }
    function y1(l, c, m) {
      ui[ci++] = Rs, ui[ci++] = Ls, ui[ci++] = Aa, Aa = l;
      var x = Rs;
      l = Ls;
      var E = 32 - Ii(x) - 1;
      x &= ~(1 << E), m += 1;
      var A = 32 - Ii(c) + E;
      if (30 < A) {
        var F = E - E % 5;
        A = (x & (1 << F) - 1).toString(32),
          x >>= F,
          E -= F,
          Rs = 1 << 32 - Ii(c) + E | m << E | x,
          Ls = A + l;
      } else Rs = 1 << A | m << E | x, Ls = l;
    }
    function e0(l) {
      l.return !== null && (Ca(l, 1), y1(l, 1, 0));
    }
    function t0(l) {
      for (; l === jd;) {
        jd = Ul[--Vl], Ul[Vl] = null, Wd = Ul[--Vl], Ul[Vl] = null;
      }
      for (; l === Aa;) {
        Aa = ui[--ci],
          ui[ci] = null,
          Ls = ui[--ci],
          ui[ci] = null,
          Rs = ui[--ci],
          ui[ci] = null;
      }
    }
    var Ur = null, Vr = null, Zt = !1, Cc = !1, Di = null;
    function x1(l, c) {
      var m = pi(5, null, null, 0);
      m.elementType = "DELETED",
        m.stateNode = c,
        m.return = l,
        c = l.deletions,
        c === null ? (l.deletions = [m], l.flags |= 16) : c.push(m);
    }
    function _1(l, c) {
      switch (l.tag) {
        case 5:
          return c = Rd(c, l.type, l.pendingProps),
            c !== null ? (l.stateNode = c, Ur = l, Vr = Z(c), !0) : !1;
        case 6:
          return c = zg(c, l.pendingProps),
            c !== null ? (l.stateNode = c, Ur = l, Vr = null, !0) : !1;
        case 13:
          if (c = Bg(c), c !== null) {
            var m = Aa !== null ? { id: Rs, overflow: Ls } : null;
            return l.memoizedState = {
              dehydrated: c,
              treeContext: m,
              retryLane: 1073741824,
            },
              m = pi(18, null, null, 0),
              m.stateNode = c,
              m.return = l,
              l.child = m,
              Ur = l,
              Vr = null,
              !0;
          }
          return !1;
        default:
          return !1;
      }
    }
    function n0(l) {
      return (l.mode & 1) != 0 && (l.flags & 128) == 0;
    }
    function r0(l) {
      if (Zt) {
        var c = Vr;
        if (c) {
          var m = c;
          if (!_1(l, c)) {
            if (n0(l)) throw Error(o(418));
            c = Q(m);
            var x = Ur;
            c && _1(l, c)
              ? x1(x, m)
              : (l.flags = l.flags & -4097 | 2, Zt = !1, Ur = l);
          }
        } else {
          if (n0(l)) throw Error(o(418));
          l.flags = l.flags & -4097 | 2, Zt = !1, Ur = l;
        }
      }
    }
    function S1(l) {
      for (
        l = l.return; l !== null && l.tag !== 5 && l.tag !== 3 && l.tag !== 13;
      ) l = l.return;
      Ur = l;
    }
    function bc(l) {
      if (!ne || l !== Ur) return !1;
      if (!Zt) return S1(l), Zt = !0, !1;
      if (
        l.tag !== 3 &&
        (l.tag !== 5 || co(l.type) && !Oe(l.type, l.memoizedProps))
      ) {
        var c = Vr;
        if (c) {
          if (n0(l)) {
            for (l = Vr; l;) l = Q(l);
            throw Error(o(418));
          }
          for (; c;) x1(l, c), c = Q(c);
        }
      }
      if (S1(l), l.tag === 13) {
        if (!ne) throw Error(o(316));
        if (l = l.memoizedState, l = l !== null ? l.dehydrated : null, !l) {
          throw Error(o(317));
        }
        Vr = bt(l);
      } else Vr = Ur ? Q(l.stateNode) : null;
      return !0;
    }
    function Hl() {
      ne && (Vr = Ur = null, Cc = Zt = !1);
    }
    function i0(l) {
      Di === null ? Di = [l] : Di.push(l);
    }
    function Rc(l, c, m) {
      if (
        l = m.ref, l !== null && typeof l != "function" && typeof l != "object"
      ) {
        if (m._owner) {
          if (m = m._owner, m) {
            if (m.tag !== 1) throw Error(o(309));
            var x = m.stateNode;
          }
          if (!x) throw Error(o(147, l));
          var E = x, A = "" + l;
          return c !== null && c.ref !== null && typeof c.ref == "function" &&
              c.ref._stringRef === A
            ? c.ref
            : (c = function (F) {
              var U = E.refs;
              U === p1 && (U = E.refs = {}),
                F === null ? delete U[A] : U[A] = F;
            },
              c._stringRef = A,
              c);
        }
        if (typeof l != "string") throw Error(o(284));
        if (!m._owner) throw Error(o(290, l));
      }
      return l;
    }
    function Xd(l, c) {
      throw l = Object.prototype.toString.call(c),
        Error(
          o(
            31,
            l === "[object Object]"
              ? "object with keys {" + Object.keys(c).join(", ") + "}"
              : l,
          ),
        );
    }
    function w1(l) {
      var c = l._init;
      return c(l._payload);
    }
    function M1(l) {
      function c(j, H) {
        if (l) {
          var K = j.deletions;
          K === null ? (j.deletions = [H], j.flags |= 16) : K.push(H);
        }
      }
      function m(j, H) {
        if (!l) return null;
        for (; H !== null;) c(j, H), H = H.sibling;
        return null;
      }
      function x(j, H) {
        for (j = new Map(); H !== null;) {
          H.key !== null ? j.set(H.key, H) : j.set(H.index, H), H = H.sibling;
        }
        return j;
      }
      function E(j, H) {
        return j = xo(j, H), j.index = 0, j.sibling = null, j;
      }
      function A(j, H, K) {
        return j.index = K,
          l
            ? (K = j.alternate,
              K !== null
                ? (K = K.index, K < H ? (j.flags |= 2, H) : K)
                : (j.flags |= 2, H))
            : (j.flags |= 1048576, H);
      }
      function F(j) {
        return l && j.alternate === null && (j.flags |= 2), j;
      }
      function U(j, H, K, be) {
        return H === null || H.tag !== 6
          ? (H = V0(K, j.mode, be), H.return = j, H)
          : (H = E(H, K), H.return = j, H);
      }
      function te(j, H, K, be) {
        var ze = K.type;
        return ze === d
          ? De(j, H, K.props.children, be, K.key)
          : H !== null &&
              (H.elementType === ze ||
                typeof ze == "object" && ze !== null && ze.$$typeof === M &&
                  w1(ze) === H.type)
          ? (be = E(H, K.props), be.ref = Rc(j, H, K), be.return = j, be)
          : (be = Mh(K.type, K.key, K.props, null, j.mode, be),
            be.ref = Rc(j, H, K),
            be.return = j,
            be);
      }
      function ge(j, H, K, be) {
        return H === null || H.tag !== 4 ||
            H.stateNode.containerInfo !== K.containerInfo ||
            H.stateNode.implementation !== K.implementation
          ? (H = H0(K, j.mode, be), H.return = j, H)
          : (H = E(H, K.children || []), H.return = j, H);
      }
      function De(j, H, K, be, ze) {
        return H === null || H.tag !== 7
          ? (H = Da(K, j.mode, be, ze), H.return = j, H)
          : (H = E(H, K), H.return = j, H);
      }
      function nt(j, H, K) {
        if (typeof H == "string" && H !== "" || typeof H == "number") {
          return H = V0("" + H, j.mode, K), H.return = j, H;
        }
        if (typeof H == "object" && H !== null) {
          switch (H.$$typeof) {
            case u:
              return K = Mh(H.type, H.key, H.props, null, j.mode, K),
                K.ref = Rc(j, null, H),
                K.return = j,
                K;
            case f:
              return H = H0(H, j.mode, K), H.return = j, H;
            case M:
              var be = H._init;
              return nt(j, be(H._payload), K);
          }
          if (W(H) || R(H)) return H = Da(H, j.mode, K, null), H.return = j, H;
          Xd(j, H);
        }
        return null;
      }
      function He(j, H, K, be) {
        var ze = H !== null ? H.key : null;
        if (typeof K == "string" && K !== "" || typeof K == "number") {
          return ze !== null ? null : U(j, H, "" + K, be);
        }
        if (typeof K == "object" && K !== null) {
          switch (K.$$typeof) {
            case u:
              return K.key === ze ? te(j, H, K, be) : null;
            case f:
              return K.key === ze ? ge(j, H, K, be) : null;
            case M:
              return ze = K._init, He(j, H, ze(K._payload), be);
          }
          if (W(K) || R(K)) return ze !== null ? null : De(j, H, K, be, null);
          Xd(j, K);
        }
        return null;
      }
      function Bt(j, H, K, be, ze) {
        if (typeof be == "string" && be !== "" || typeof be == "number") {
          return j = j.get(K) || null, U(H, j, "" + be, ze);
        }
        if (typeof be == "object" && be !== null) {
          switch (be.$$typeof) {
            case u:
              return j = j.get(be.key === null ? K : be.key) || null,
                te(H, j, be, ze);
            case f:
              return j = j.get(be.key === null ? K : be.key) || null,
                ge(H, j, be, ze);
            case M:
              var at = be._init;
              return Bt(j, H, K, at(be._payload), ze);
          }
          if (W(be) || R(be)) {
            return j = j.get(K) || null, De(H, j, be, ze, null);
          }
          Xd(H, be);
        }
        return null;
      }
      function Ue(j, H, K, be) {
        for (
          var ze = null, at = null, rt = H, St = H = 0, Fn = null;
          rt !== null && St < K.length;
          St++
        ) {
          rt.index > St ? (Fn = rt, rt = null) : Fn = rt.sibling;
          var wt = He(j, rt, K[St], be);
          if (wt === null) {
            rt === null && (rt = Fn);
            break;
          }
          l && rt && wt.alternate === null && c(j, rt),
            H = A(wt, H, St),
            at === null ? ze = wt : at.sibling = wt,
            at = wt,
            rt = Fn;
        }
        if (St === K.length) return m(j, rt), Zt && Ca(j, St), ze;
        if (rt === null) {
          for (; St < K.length; St++) {
            rt = nt(j, K[St], be),
              rt !== null &&
              (H = A(rt, H, St),
                at === null ? ze = rt : at.sibling = rt,
                at = rt);
          }
          return Zt && Ca(j, St), ze;
        }
        for (rt = x(j, rt); St < K.length; St++) {
          Fn = Bt(rt, j, St, K[St], be),
            Fn !== null &&
            (l && Fn.alternate !== null &&
              rt.delete(Fn.key === null ? St : Fn.key),
              H = A(Fn, H, St),
              at === null ? ze = Fn : at.sibling = Fn,
              at = Fn);
        }
        return l && rt.forEach(function (_o) {
          return c(j, _o);
        }),
          Zt && Ca(j, St),
          ze;
      }
      function Jn(j, H, K, be) {
        var ze = R(K);
        if (typeof ze != "function") throw Error(o(150));
        if (K = ze.call(K), K == null) throw Error(o(151));
        for (
          var at = ze = null, rt = H, St = H = 0, Fn = null, wt = K.next();
          rt !== null && !wt.done;
          St++, wt = K.next()
        ) {
          rt.index > St ? (Fn = rt, rt = null) : Fn = rt.sibling;
          var _o = He(j, rt, wt.value, be);
          if (_o === null) {
            rt === null && (rt = Fn);
            break;
          }
          l && rt && _o.alternate === null && c(j, rt),
            H = A(_o, H, St),
            at === null ? ze = _o : at.sibling = _o,
            at = _o,
            rt = Fn;
        }
        if (wt.done) return m(j, rt), Zt && Ca(j, St), ze;
        if (rt === null) {
          for (; !wt.done; St++, wt = K.next()) {
            wt = nt(j, wt.value, be),
              wt !== null &&
              (H = A(wt, H, St),
                at === null ? ze = wt : at.sibling = wt,
                at = wt);
          }
          return Zt && Ca(j, St), ze;
        }
        for (rt = x(j, rt); !wt.done; St++, wt = K.next()) {
          wt = Bt(rt, j, St, wt.value, be),
            wt !== null &&
            (l && wt.alternate !== null &&
              rt.delete(wt.key === null ? St : wt.key),
              H = A(wt, H, St),
              at === null ? ze = wt : at.sibling = wt,
              at = wt);
        }
        return l && rt.forEach(function (sP) {
          return c(j, sP);
        }),
          Zt && Ca(j, St),
          ze;
      }
      function mi(j, H, K, be) {
        if (
          typeof K == "object" && K !== null && K.type === d &&
          K.key === null && (K = K.props.children),
            typeof K == "object" && K !== null
        ) {
          switch (K.$$typeof) {
            case u:
              e: {
                for (var ze = K.key, at = H; at !== null;) {
                  if (at.key === ze) {
                    if (ze = K.type, ze === d) {
                      if (at.tag === 7) {
                        m(j, at.sibling),
                          H = E(at, K.props.children),
                          H.return = j,
                          j = H;
                        break e;
                      }
                    } else if (
                      at.elementType === ze ||
                      typeof ze == "object" && ze !== null &&
                        ze.$$typeof === M && w1(ze) === at.type
                    ) {
                      m(j, at.sibling),
                        H = E(at, K.props),
                        H.ref = Rc(j, at, K),
                        H.return = j,
                        j = H;
                      break e;
                    }
                    m(j, at);
                    break;
                  } else c(j, at);
                  at = at.sibling;
                }
                K.type === d
                  ? (H = Da(K.props.children, j.mode, be, K.key),
                    H.return = j,
                    j = H)
                  : (be = Mh(K.type, K.key, K.props, null, j.mode, be),
                    be.ref = Rc(j, H, K),
                    be.return = j,
                    j = be);
              }
              return F(j);
            case f:
              e: {
                for (at = K.key; H !== null;) {
                  if (H.key === at) {
                    if (
                      H.tag === 4 &&
                      H.stateNode.containerInfo === K.containerInfo &&
                      H.stateNode.implementation === K.implementation
                    ) {
                      m(j, H.sibling),
                        H = E(H, K.children || []),
                        H.return = j,
                        j = H;
                      break e;
                    } else {
                      m(j, H);
                      break;
                    }
                  } else c(j, H);
                  H = H.sibling;
                }
                H = H0(K, j.mode, be), H.return = j, j = H;
              }
              return F(j);
            case M:
              return at = K._init, mi(j, H, at(K._payload), be);
          }
          if (W(K)) return Ue(j, H, K, be);
          if (R(K)) return Jn(j, H, K, be);
          Xd(j, K);
        }
        return typeof K == "string" && K !== "" || typeof K == "number"
          ? (K = "" + K,
            H !== null && H.tag === 6
              ? (m(j, H.sibling), H = E(H, K), H.return = j, j = H)
              : (m(j, H), H = V0(K, j.mode, be), H.return = j, j = H),
            F(j))
          : m(j, H);
      }
      return mi;
    }
    var Gl = M1(!0),
      E1 = M1(!1),
      Lc = {},
      fi = Yt(Lc),
      Pc = Yt(Lc),
      jl = Yt(Lc);
    function cs(l) {
      if (l === Lc) throw Error(o(174));
      return l;
    }
    function s0(l, c) {
      Pt(jl, c), Pt(Pc, l), Pt(fi, Lc), l = re(c), Rt(fi), Pt(fi, l);
    }
    function Wl() {
      Rt(fi), Rt(Pc), Rt(jl);
    }
    function T1(l) {
      var c = cs(jl.current), m = cs(fi.current);
      c = ie(m, l.type, c), m !== c && (Pt(Pc, l), Pt(fi, c));
    }
    function o0(l) {
      Pc.current === l && (Rt(fi), Rt(Pc));
    }
    var nn = Yt(0);
    function qd(l) {
      for (var c = l; c !== null;) {
        if (c.tag === 13) {
          var m = c.memoizedState;
          if (m !== null && (m = m.dehydrated, m === null || Ld(m) || D(m))) {
            return c;
          }
        } else if (c.tag === 19 && c.memoizedProps.revealOrder !== void 0) {
          if ((c.flags & 128) != 0) {
            return c;
          }
        } else if (c.child !== null) {
          c.child.return = c, c = c.child;
          continue;
        }
        if (c === l) break;
        for (; c.sibling === null;) {
          if (c.return === null || c.return === l) return null;
          c = c.return;
        }
        c.sibling.return = c.return, c = c.sibling;
      }
      return null;
    }
    var a0 = [];
    function l0() {
      for (var l = 0; l < a0.length; l++) {
        var c = a0[l];
        Se
          ? c._workInProgressVersionPrimary = null
          : c._workInProgressVersionSecondary = null;
      }
      a0.length = 0;
    }
    var Yd = a.ReactCurrentDispatcher,
      di = a.ReactCurrentBatchConfig,
      Xl = 0,
      fn = null,
      Yn = null,
      kn = null,
      Zd = !1,
      Ic = !1,
      Nc = 0,
      LL = 0;
    function Zn() {
      throw Error(o(321));
    }
    function u0(l, c) {
      if (c === null) return !1;
      for (var m = 0; m < c.length && m < l.length; m++) {
        if (!as(l[m], c[m])) return !1;
      }
      return !0;
    }
    function c0(l, c, m, x, E, A) {
      if (
        Xl = A,
          fn = c,
          c.memoizedState = null,
          c.updateQueue = null,
          c.lanes = 0,
          Yd.current = l === null || l.memoizedState === null ? DL : kL,
          l = m(x, E),
          Ic
      ) {
        A = 0;
        do {
          if (Ic = !1, Nc = 0, 25 <= A) throw Error(o(301));
          A += 1,
            kn = Yn = null,
            c.updateQueue = null,
            Yd.current = FL,
            l = m(x, E);
        } while (Ic);
      }
      if (
        Yd.current = eh,
          c = Yn !== null && Yn.next !== null,
          Xl = 0,
          kn = Yn = fn = null,
          Zd = !1,
          c
      ) throw Error(o(300));
      return l;
    }
    function f0() {
      var l = Nc !== 0;
      return Nc = 0, l;
    }
    function Ps() {
      var l = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null,
      };
      return kn === null ? fn.memoizedState = kn = l : kn = kn.next = l, kn;
    }
    function fs() {
      if (Yn === null) {
        var l = fn.alternate;
        l = l !== null ? l.memoizedState : null;
      } else l = Yn.next;
      var c = kn === null ? fn.memoizedState : kn.next;
      if (c !== null) kn = c, Yn = l;
      else {
        if (l === null) throw Error(o(310));
        Yn = l,
          l = {
            memoizedState: Yn.memoizedState,
            baseState: Yn.baseState,
            baseQueue: Yn.baseQueue,
            queue: Yn.queue,
            next: null,
          },
          kn === null ? fn.memoizedState = kn = l : kn = kn.next = l;
      }
      return kn;
    }
    function ba(l, c) {
      return typeof c == "function" ? c(l) : c;
    }
    function Kd(l) {
      var c = fs(), m = c.queue;
      if (m === null) throw Error(o(311));
      m.lastRenderedReducer = l;
      var x = Yn, E = x.baseQueue, A = m.pending;
      if (A !== null) {
        if (E !== null) {
          var F = E.next;
          E.next = A.next, A.next = F;
        }
        x.baseQueue = E = A, m.pending = null;
      }
      if (E !== null) {
        A = E.next, x = x.baseState;
        var U = F = null, te = null, ge = A;
        do {
          var De = ge.lane;
          if ((Xl & De) === De) {
            te !== null &&
            (te = te.next = {
              lane: 0,
              action: ge.action,
              hasEagerState: ge.hasEagerState,
              eagerState: ge.eagerState,
              next: null,
            }),
              x = ge.hasEagerState ? ge.eagerState : l(x, ge.action);
          } else {
            var nt = {
              lane: De,
              action: ge.action,
              hasEagerState: ge.hasEagerState,
              eagerState: ge.eagerState,
              next: null,
            };
            te === null ? (U = te = nt, F = x) : te = te.next = nt,
              fn.lanes |= De,
              Yl |= De;
          }
          ge = ge.next;
        } while (ge !== null && ge !== A);
        te === null ? F = x : te.next = U,
          as(x, c.memoizedState) || (Hr = !0),
          c.memoizedState = x,
          c.baseState = F,
          c.baseQueue = te,
          m.lastRenderedState = x;
      }
      if (l = m.interleaved, l !== null) {
        E = l;
        do A = E.lane, fn.lanes |= A, Yl |= A, E = E.next; while (E !== l);
      } else E === null && (m.lanes = 0);
      return [c.memoizedState, m.dispatch];
    }
    function Jd(l) {
      var c = fs(), m = c.queue;
      if (m === null) throw Error(o(311));
      m.lastRenderedReducer = l;
      var x = m.dispatch, E = m.pending, A = c.memoizedState;
      if (E !== null) {
        m.pending = null;
        var F = E = E.next;
        do A = l(A, F.action), F = F.next; while (F !== E);
        as(A, c.memoizedState) || (Hr = !0),
          c.memoizedState = A,
          c.baseQueue === null && (c.baseState = A),
          m.lastRenderedState = A;
      }
      return [A, x];
    }
    function A1() {}
    function C1(l, c) {
      var m = fn, x = fs(), E = c(), A = !as(x.memoizedState, E);
      if (
        A && (x.memoizedState = E, Hr = !0),
          x = x.queue,
          kc(L1.bind(null, m, x, l), [l]),
          x.getSnapshot !== c || A || kn !== null && kn.memoizedState.tag & 1
      ) {
        if (
          m.flags |= 2048,
            Dc(9, R1.bind(null, m, x, E, c), void 0, null),
            _n === null
        ) throw Error(o(349));
        (Xl & 30) != 0 || b1(m, c, E);
      }
      return E;
    }
    function b1(l, c, m) {
      l.flags |= 16384,
        l = { getSnapshot: c, value: m },
        c = fn.updateQueue,
        c === null
          ? (c = { lastEffect: null, stores: null },
            fn.updateQueue = c,
            c.stores = [l])
          : (m = c.stores, m === null ? c.stores = [l] : m.push(l));
    }
    function R1(l, c, m, x) {
      c.value = m, c.getSnapshot = x, P1(c) && hi(l, 1, -1);
    }
    function L1(l, c, m) {
      return m(function () {
        P1(c) && hi(l, 1, -1);
      });
    }
    function P1(l) {
      var c = l.getSnapshot;
      l = l.value;
      try {
        var m = c();
        return !as(l, m);
      } catch {
        return !0;
      }
    }
    function d0(l) {
      var c = Ps();
      return typeof l == "function" && (l = l()),
        c.memoizedState = c.baseState = l,
        l = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: ba,
          lastRenderedState: l,
        },
        c.queue = l,
        l = l.dispatch = NL.bind(null, fn, l),
        [c.memoizedState, l];
    }
    function Dc(l, c, m, x) {
      return l = { tag: l, create: c, destroy: m, deps: x, next: null },
        c = fn.updateQueue,
        c === null
          ? (c = { lastEffect: null, stores: null },
            fn.updateQueue = c,
            c.lastEffect = l.next = l)
          : (m = c.lastEffect,
            m === null
              ? c.lastEffect = l.next = l
              : (x = m.next, m.next = l, l.next = x, c.lastEffect = l)),
        l;
    }
    function I1() {
      return fs().memoizedState;
    }
    function Qd(l, c, m, x) {
      var E = Ps();
      fn.flags |= l,
        E.memoizedState = Dc(1 | c, m, void 0, x === void 0 ? null : x);
    }
    function $d(l, c, m, x) {
      var E = fs();
      x = x === void 0 ? null : x;
      var A = void 0;
      if (Yn !== null) {
        var F = Yn.memoizedState;
        if (A = F.destroy, x !== null && u0(x, F.deps)) {
          E.memoizedState = Dc(c, m, A, x);
          return;
        }
      }
      fn.flags |= l, E.memoizedState = Dc(1 | c, m, A, x);
    }
    function h0(l, c) {
      return Qd(8390656, 8, l, c);
    }
    function kc(l, c) {
      return $d(2048, 8, l, c);
    }
    function N1(l, c) {
      return $d(4, 2, l, c);
    }
    function D1(l, c) {
      return $d(4, 4, l, c);
    }
    function k1(l, c) {
      if (typeof c == "function") {
        return l = l(), c(l), function () {
          c(null);
        };
      }
      if (c != null) {
        return l = l(), c.current = l, function () {
          c.current = null;
        };
      }
    }
    function F1(l, c, m) {
      return m = m != null ? m.concat([l]) : null,
        $d(4, 4, k1.bind(null, c, l), m);
    }
    function p0() {}
    function O1(l, c) {
      var m = fs();
      c = c === void 0 ? null : c;
      var x = m.memoizedState;
      return x !== null && c !== null && u0(c, x[1])
        ? x[0]
        : (m.memoizedState = [l, c], l);
    }
    function z1(l, c) {
      var m = fs();
      c = c === void 0 ? null : c;
      var x = m.memoizedState;
      return x !== null && c !== null && u0(c, x[1])
        ? x[0]
        : (l = l(), m.memoizedState = [l, c], l);
    }
    function PL(l, c) {
      var m = _t;
      _t = m !== 0 && 4 > m ? m : 4, l(!0);
      var x = di.transition;
      di.transition = {};
      try {
        l(!1), c();
      } finally {
        _t = m, di.transition = x;
      }
    }
    function B1() {
      return fs().memoizedState;
    }
    function IL(l, c, m) {
      var x = vo(l);
      m = {
        lane: x,
        action: m,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      },
        U1(l)
          ? V1(c, m)
          : (H1(l, c, m), m = ur(), l = hi(l, x, m), l !== null && G1(l, c, x));
    }
    function NL(l, c, m) {
      var x = vo(l),
        E = {
          lane: x,
          action: m,
          hasEagerState: !1,
          eagerState: null,
          next: null,
        };
      if (U1(l)) V1(c, E);
      else {
        H1(l, c, E);
        var A = l.alternate;
        if (
          l.lanes === 0 && (A === null || A.lanes === 0) &&
          (A = c.lastRenderedReducer, A !== null)
        ) {
          try {
            var F = c.lastRenderedState, U = A(F, m);
            if (E.hasEagerState = !0, E.eagerState = U, as(U, F)) return;
          } catch {
          } finally {
          }
        }
        m = ur(), l = hi(l, x, m), l !== null && G1(l, c, x);
      }
    }
    function U1(l) {
      var c = l.alternate;
      return l === fn || c !== null && c === fn;
    }
    function V1(l, c) {
      Ic = Zd = !0;
      var m = l.pending;
      m === null ? c.next = c : (c.next = m.next, m.next = c), l.pending = c;
    }
    function H1(l, c, m) {
      _n !== null && (l.mode & 1) != 0 && (lt & 2) == 0
        ? (l = c.interleaved,
          l === null
            ? (m.next = m, us === null ? us = [c] : us.push(c))
            : (m.next = l.next, l.next = m),
          c.interleaved = m)
        : (l = c.pending,
          l === null ? m.next = m : (m.next = l.next, l.next = m),
          c.pending = m);
    }
    function G1(l, c, m) {
      if ((m & 4194240) != 0) {
        var x = c.lanes;
        x &= l.pendingLanes, m |= x, c.lanes = m, Hg(l, m);
      }
    }
    var eh = {
        readContext: li,
        useCallback: Zn,
        useContext: Zn,
        useEffect: Zn,
        useImperativeHandle: Zn,
        useInsertionEffect: Zn,
        useLayoutEffect: Zn,
        useMemo: Zn,
        useReducer: Zn,
        useRef: Zn,
        useState: Zn,
        useDebugValue: Zn,
        useDeferredValue: Zn,
        useTransition: Zn,
        useMutableSource: Zn,
        useSyncExternalStore: Zn,
        useId: Zn,
        unstable_isNewReconciler: !1,
      },
      DL = {
        readContext: li,
        useCallback: function (l, c) {
          return Ps().memoizedState = [l, c === void 0 ? null : c], l;
        },
        useContext: li,
        useEffect: h0,
        useImperativeHandle: function (l, c, m) {
          return m = m != null ? m.concat([l]) : null,
            Qd(4194308, 4, k1.bind(null, c, l), m);
        },
        useLayoutEffect: function (l, c) {
          return Qd(4194308, 4, l, c);
        },
        useInsertionEffect: function (l, c) {
          return Qd(4, 2, l, c);
        },
        useMemo: function (l, c) {
          var m = Ps();
          return c = c === void 0 ? null : c,
            l = l(),
            m.memoizedState = [l, c],
            l;
        },
        useReducer: function (l, c, m) {
          var x = Ps();
          return c = m !== void 0 ? m(c) : c,
            x.memoizedState = x.baseState = c,
            l = {
              pending: null,
              interleaved: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: l,
              lastRenderedState: c,
            },
            x.queue = l,
            l = l.dispatch = IL.bind(null, fn, l),
            [x.memoizedState, l];
        },
        useRef: function (l) {
          var c = Ps();
          return l = { current: l }, c.memoizedState = l;
        },
        useState: d0,
        useDebugValue: p0,
        useDeferredValue: function (l) {
          var c = d0(l), m = c[0], x = c[1];
          return h0(function () {
            var E = di.transition;
            di.transition = {};
            try {
              x(l);
            } finally {
              di.transition = E;
            }
          }, [l]),
            m;
        },
        useTransition: function () {
          var l = d0(!1), c = l[0];
          return l = PL.bind(null, l[1]), Ps().memoizedState = l, [c, l];
        },
        useMutableSource: function () {},
        useSyncExternalStore: function (l, c, m) {
          var x = fn, E = Ps();
          if (Zt) {
            if (m === void 0) throw Error(o(407));
            m = m();
          } else {
            if (m = c(), _n === null) throw Error(o(349));
            (Xl & 30) != 0 || b1(x, c, m);
          }
          E.memoizedState = m;
          var A = { value: m, getSnapshot: c };
          return E.queue = A,
            h0(L1.bind(null, x, A, l), [l]),
            x.flags |= 2048,
            Dc(9, R1.bind(null, x, A, m, c), void 0, null),
            m;
        },
        useId: function () {
          var l = Ps(), c = _n.identifierPrefix;
          if (Zt) {
            var m = Ls, x = Rs;
            m = (x & ~(1 << 32 - Ii(x) - 1)).toString(32) + m,
              c = ":" + c + "R" + m,
              m = Nc++,
              0 < m && (c += "H" + m.toString(32)),
              c += ":";
          } else m = LL++, c = ":" + c + "r" + m.toString(32) + ":";
          return l.memoizedState = c;
        },
        unstable_isNewReconciler: !1,
      },
      kL = {
        readContext: li,
        useCallback: O1,
        useContext: li,
        useEffect: kc,
        useImperativeHandle: F1,
        useInsertionEffect: N1,
        useLayoutEffect: D1,
        useMemo: z1,
        useReducer: Kd,
        useRef: I1,
        useState: function () {
          return Kd(ba);
        },
        useDebugValue: p0,
        useDeferredValue: function (l) {
          var c = Kd(ba), m = c[0], x = c[1];
          return kc(function () {
            var E = di.transition;
            di.transition = {};
            try {
              x(l);
            } finally {
              di.transition = E;
            }
          }, [l]),
            m;
        },
        useTransition: function () {
          var l = Kd(ba)[0], c = fs().memoizedState;
          return [l, c];
        },
        useMutableSource: A1,
        useSyncExternalStore: C1,
        useId: B1,
        unstable_isNewReconciler: !1,
      },
      FL = {
        readContext: li,
        useCallback: O1,
        useContext: li,
        useEffect: kc,
        useImperativeHandle: F1,
        useInsertionEffect: N1,
        useLayoutEffect: D1,
        useMemo: z1,
        useReducer: Jd,
        useRef: I1,
        useState: function () {
          return Jd(ba);
        },
        useDebugValue: p0,
        useDeferredValue: function (l) {
          var c = Jd(ba), m = c[0], x = c[1];
          return kc(function () {
            var E = di.transition;
            di.transition = {};
            try {
              x(l);
            } finally {
              di.transition = E;
            }
          }, [l]),
            m;
        },
        useTransition: function () {
          var l = Jd(ba)[0], c = fs().memoizedState;
          return [l, c];
        },
        useMutableSource: A1,
        useSyncExternalStore: C1,
        useId: B1,
        unstable_isNewReconciler: !1,
      };
    function m0(l, c) {
      try {
        var m = "", x = c;
        do m += RL(x), x = x.return; while (x);
        var E = m;
      } catch (A) {
        E = `
Error generating stack: ` + A.message + `
` + A.stack;
      }
      return { value: l, source: c, stack: E };
    }
    function g0(l, c) {
      try {
        console.error(c.value);
      } catch (m) {
        setTimeout(function () {
          throw m;
        });
      }
    }
    var OL = typeof WeakMap == "function" ? WeakMap : Map;
    function j1(l, c, m) {
      m = bs(-1, m), m.tag = 3, m.payload = { element: null };
      var x = c.value;
      return m.callback = function () {
        gh || (gh = !0, D0 = x), g0(l, c);
      },
        m;
    }
    function W1(l, c, m) {
      m = bs(-1, m), m.tag = 3;
      var x = l.type.getDerivedStateFromError;
      if (typeof x == "function") {
        var E = c.value;
        m.payload = function () {
          return x(E);
        },
          m.callback = function () {
            g0(l, c);
          };
      }
      var A = l.stateNode;
      return A !== null && typeof A.componentDidCatch == "function" &&
        (m.callback = function () {
          g0(l, c),
            typeof x != "function" &&
            (mo === null ? mo = new Set([this]) : mo.add(this));
          var F = c.stack;
          this.componentDidCatch(c.value, {
            componentStack: F !== null ? F : "",
          });
        }),
        m;
    }
    function X1(l, c, m) {
      var x = l.pingCache;
      if (x === null) {
        x = l.pingCache = new OL();
        var E = new Set();
        x.set(c, E);
      } else E = x.get(c), E === void 0 && (E = new Set(), x.set(c, E));
      E.has(m) || (E.add(m), l = JL.bind(null, l, c, m), c.then(l, l));
    }
    function q1(l) {
      do {
        var c;
        if (
          (c = l.tag === 13) &&
          (c = l.memoizedState, c = c !== null ? c.dehydrated !== null : !0), c
        ) return l;
        l = l.return;
      } while (l !== null);
      return null;
    }
    function Y1(l, c, m, x, E) {
      return (l.mode & 1) == 0
        ? (l === c
          ? l.flags |= 65536
          : (l.flags |= 128,
            m.flags |= 131072,
            m.flags &= -52805,
            m.tag === 1 && (m.alternate === null
              ? m.tag = 17
              : (c = bs(-1, 1), c.tag = 2, po(m, c))),
            m.lanes |= 1),
          l)
        : (l.flags |= 65536, l.lanes = E, l);
    }
    function ds(l) {
      l.flags |= 4;
    }
    function Z1(l, c) {
      if (l !== null && l.child === c.child) return !0;
      if ((c.flags & 16) != 0) return !1;
      for (l = c.child; l !== null;) {
        if ((l.flags & 12854) != 0 || (l.subtreeFlags & 12854) != 0) return !1;
        l = l.sibling;
      }
      return !0;
    }
    var Fc, Oc, th, nh;
    if (je) {
      Fc = function (l, c) {
        for (var m = c.child; m !== null;) {
          if (m.tag === 5 || m.tag === 6) fe(l, m.stateNode);
          else if (m.tag !== 4 && m.child !== null) {
            m.child.return = m, m = m.child;
            continue;
          }
          if (m === c) break;
          for (; m.sibling === null;) {
            if (m.return === null || m.return === c) return;
            m = m.return;
          }
          m.sibling.return = m.return, m = m.sibling;
        }
      },
        Oc = function () {},
        th = function (l, c, m, x, E) {
          if (l = l.memoizedProps, l !== x) {
            var A = c.stateNode, F = cs(fi.current);
            m = Pe(A, m, l, x, E, F), (c.updateQueue = m) && ds(c);
          }
        },
        nh = function (l, c, m, x) {
          m !== x && ds(c);
        };
    } else if (ue) {
      Fc = function (l, c, m, x) {
        for (var E = c.child; E !== null;) {
          if (E.tag === 5) {
            var A = E.stateNode;
            m && x && (A = bd(A, E.type, E.memoizedProps, E)), fe(l, A);
          } else if (E.tag === 6) {
            A = E.stateNode,
              m && x && (A = Fl(A, E.memoizedProps, E)),
              fe(l, A);
          } else if (E.tag !== 4) {
            if (E.tag === 22 && E.memoizedState !== null) {
              A = E.child, A !== null && (A.return = E), Fc(l, E, !0, !0);
            } else if (E.child !== null) {
              E.child.return = E, E = E.child;
              continue;
            }
          }
          if (E === c) break;
          for (; E.sibling === null;) {
            if (E.return === null || E.return === c) return;
            E = E.return;
          }
          E.sibling.return = E.return, E = E.sibling;
        }
      };
      var K1 = function (l, c, m, x) {
        for (var E = c.child; E !== null;) {
          if (E.tag === 5) {
            var A = E.stateNode;
            m && x && (A = bd(A, E.type, E.memoizedProps, E)), Ec(l, A);
          } else if (E.tag === 6) {
            A = E.stateNode,
              m && x && (A = Fl(A, E.memoizedProps, E)),
              Ec(l, A);
          } else if (E.tag !== 4) {
            if (E.tag === 22 && E.memoizedState !== null) {
              A = E.child, A !== null && (A.return = E), K1(l, E, !0, !0);
            } else if (E.child !== null) {
              E.child.return = E, E = E.child;
              continue;
            }
          }
          if (E === c) break;
          for (; E.sibling === null;) {
            if (E.return === null || E.return === c) return;
            E = E.return;
          }
          E.sibling.return = E.return, E = E.sibling;
        }
      };
      Oc = function (l, c) {
        var m = c.stateNode;
        if (!Z1(l, c)) {
          l = m.containerInfo;
          var x = Br(l);
          K1(x, c, !1, !1), m.pendingChildren = x, ds(c), Og(l, x);
        }
      },
        th = function (l, c, m, x, E) {
          var A = l.stateNode, F = l.memoizedProps;
          if ((l = Z1(l, c)) && F === x) c.stateNode = A;
          else {
            var U = c.stateNode, te = cs(fi.current), ge = null;
            F !== x && (ge = Pe(U, m, F, x, E, te)),
              l && ge === null
                ? c.stateNode = A
                : (A = Vn(A, ge, m, F, x, c, l, U),
                  pe(A, m, x, E, te) && ds(c),
                  c.stateNode = A,
                  l ? ds(c) : Fc(A, c, !1, !1));
          }
        },
        nh = function (l, c, m, x) {
          m !== x
            ? (l = cs(jl.current),
              m = cs(fi.current),
              c.stateNode = oe(x, l, m, c),
              ds(c))
            : c.stateNode = l.stateNode;
        };
    } else Oc = function () {}, th = function () {}, nh = function () {};
    function zc(l, c) {
      if (!Zt) {
        switch (l.tailMode) {
          case "hidden":
            c = l.tail;
            for (var m = null; c !== null;) {
              c.alternate !== null && (m = c), c = c.sibling;
            }
            m === null ? l.tail = null : m.sibling = null;
            break;
          case "collapsed":
            m = l.tail;
            for (var x = null; m !== null;) {
              m.alternate !== null && (x = m), m = m.sibling;
            }
            x === null
              ? c || l.tail === null ? l.tail = null : l.tail.sibling = null
              : x.sibling = null;
        }
      }
    }
    function Kn(l) {
      var c = l.alternate !== null && l.alternate.child === l.child,
        m = 0,
        x = 0;
      if (c) {
        for (var E = l.child; E !== null;) {
          m |= E.lanes | E.childLanes,
            x |= E.subtreeFlags & 14680064,
            x |= E.flags & 14680064,
            E.return = l,
            E = E.sibling;
        }
      } else {for (E = l.child; E !== null;) {
          m |= E.lanes | E.childLanes,
            x |= E.subtreeFlags,
            x |= E.flags,
            E.return = l,
            E = E.sibling;
        }}
      return l.subtreeFlags |= x, l.childLanes = m, c;
    }
    function zL(l, c, m) {
      var x = c.pendingProps;
      switch (t0(c), c.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return Kn(c), null;
        case 1:
          return Cr(c.type) && Pd(), Kn(c), null;
        case 3:
          return x = c.stateNode,
            Wl(),
            Rt(Ar),
            Rt(qn),
            l0(),
            x.pendingContext &&
            (x.context = x.pendingContext, x.pendingContext = null),
            (l === null || l.child === null) && (bc(c)
              ? ds(c)
              : l === null ||
                l.memoizedState.isDehydrated && (c.flags & 256) == 0 ||
                (c.flags |= 1024, Di !== null && (O0(Di), Di = null))),
            Oc(l, c),
            Kn(c),
            null;
        case 5:
          o0(c), m = cs(jl.current);
          var E = c.type;
          if (l !== null && c.stateNode != null) {
            th(l, c, E, x, m),
              l.ref !== c.ref && (c.flags |= 512, c.flags |= 2097152);
          } else {
            if (!x) {
              if (c.stateNode === null) throw Error(o(166));
              return Kn(c), null;
            }
            if (l = cs(fi.current), bc(c)) {
              if (!ne) throw Error(o(175));
              l = tt(c.stateNode, c.type, c.memoizedProps, m, l, c, !Cc),
                c.updateQueue = l,
                l !== null && ds(c);
            } else {
              var A = ae(E, x, m, l, c);
              Fc(A, c, !1, !1), c.stateNode = A, pe(A, E, x, m, l) && ds(c);
            }
            c.ref !== null && (c.flags |= 512, c.flags |= 2097152);
          }
          return Kn(c), null;
        case 6:
          if (l && c.stateNode != null) nh(l, c, l.memoizedProps, x);
          else {
            if (typeof x != "string" && c.stateNode === null) {
              throw Error(o(166));
            }
            if (l = cs(jl.current), m = cs(fi.current), bc(c)) {
              if (!ne) throw Error(o(176));
              if (
                l = c.stateNode,
                  x = c.memoizedProps,
                  (m = ot(l, x, c, !Cc)) && (E = Ur, E !== null)
              ) {
                switch (A = (E.mode & 1) != 0, E.tag) {
                  case 3:
                    fo(E.stateNode.containerInfo, l, x, A);
                    break;
                  case 5:
                    oi(E.type, E.memoizedProps, E.stateNode, l, x, A);
                }
              }
              m && ds(c);
            } else c.stateNode = oe(x, l, m, c);
          }
          return Kn(c), null;
        case 13:
          if (
            Rt(nn),
              x = c.memoizedState,
              Zt && Vr !== null && (c.mode & 1) != 0 && (c.flags & 128) == 0
          ) {
            for (l = Vr; l;) l = Q(l);
            return Hl(), c.flags |= 98560, c;
          }
          if (x !== null && x.dehydrated !== null) {
            if (x = bc(c), l === null) {
              if (!x) throw Error(o(318));
              if (!ne) throw Error(o(344));
              if (
                l = c.memoizedState, l = l !== null ? l.dehydrated : null, !l
              ) throw Error(o(317));
              it(l, c);
            } else {Hl(),
                (c.flags & 128) == 0 && (c.memoizedState = null),
                c.flags |= 4;}
            return Kn(c), null;
          }
          return Di !== null && (O0(Di), Di = null),
            (c.flags & 128) != 0 ? (c.lanes = m, c) : (x = x !== null,
              m = !1,
              l === null ? bc(c) : m = l.memoizedState !== null,
              x && !m &&
              (c.child.flags |= 8192,
                (c.mode & 1) != 0 && (l === null || (nn.current & 1) != 0
                  ? Tn === 0 && (Tn = 3)
                  : B0())),
              c.updateQueue !== null && (c.flags |= 4),
              Kn(c),
              null);
        case 4:
          return Wl(),
            Oc(l, c),
            l === null && Fe(c.stateNode.containerInfo),
            Kn(c),
            null;
        case 10:
          return Zg(c.type._context), Kn(c), null;
        case 17:
          return Cr(c.type) && Pd(), Kn(c), null;
        case 19:
          if (Rt(nn), E = c.memoizedState, E === null) return Kn(c), null;
          if (x = (c.flags & 128) != 0, A = E.rendering, A === null) {
            if (x) zc(E, !1);
            else {
              if (Tn !== 0 || l !== null && (l.flags & 128) != 0) {
                for (l = c.child; l !== null;) {
                  if (A = qd(l), A !== null) {
                    for (
                      c.flags |= 128,
                        zc(E, !1),
                        l = A.updateQueue,
                        l !== null && (c.updateQueue = l, c.flags |= 4),
                        c.subtreeFlags = 0,
                        l = m,
                        x = c.child;
                      x !== null;
                    ) {
                      m = x,
                        E = l,
                        m.flags &= 14680066,
                        A = m.alternate,
                        A === null
                          ? (m.childLanes = 0,
                            m.lanes = E,
                            m.child = null,
                            m.subtreeFlags = 0,
                            m.memoizedProps = null,
                            m.memoizedState = null,
                            m.updateQueue = null,
                            m.dependencies = null,
                            m.stateNode = null)
                          : (m.childLanes = A.childLanes,
                            m.lanes = A.lanes,
                            m.child = A.child,
                            m.subtreeFlags = 0,
                            m.deletions = null,
                            m.memoizedProps = A.memoizedProps,
                            m.memoizedState = A.memoizedState,
                            m.updateQueue = A.updateQueue,
                            m.type = A.type,
                            E = A.dependencies,
                            m.dependencies = E === null
                              ? null
                              : {
                                lanes: E.lanes,
                                firstContext: E.firstContext,
                              }),
                        x = x.sibling;
                    }
                    return Pt(nn, nn.current & 1 | 2), c.child;
                  }
                  l = l.sibling;
                }
              }
              E.tail !== null && Dn() > N0 &&
                (c.flags |= 128, x = !0, zc(E, !1), c.lanes = 4194304);
            }
          } else {
            if (!x) {
              if (l = qd(A), l !== null) {
                if (
                  c.flags |= 128,
                    x = !0,
                    l = l.updateQueue,
                    l !== null && (c.updateQueue = l, c.flags |= 4),
                    zc(E, !0),
                    E.tail === null && E.tailMode === "hidden" &&
                    !A.alternate && !Zt
                ) return Kn(c), null;
              } else {2 * Dn() - E.renderingStartTime > N0 &&
                  m !== 1073741824 &&
                  (c.flags |= 128, x = !0, zc(E, !1), c.lanes = 4194304);}
            }
            E.isBackwards
              ? (A.sibling = c.child, c.child = A)
              : (l = E.last,
                l !== null ? l.sibling = A : c.child = A,
                E.last = A);
          }
          return E.tail !== null
            ? (c = E.tail,
              E.rendering = c,
              E.tail = c.sibling,
              E.renderingStartTime = Dn(),
              c.sibling = null,
              l = nn.current,
              Pt(nn, x ? l & 1 | 2 : l & 1),
              c)
            : (Kn(c), null);
        case 22:
        case 23:
          return z0(),
            x = c.memoizedState !== null,
            l !== null && l.memoizedState !== null !== x && (c.flags |= 8192),
            x && (c.mode & 1) != 0
              ? (Gr & 1073741824) != 0 &&
                (Kn(c), je && c.subtreeFlags & 6 && (c.flags |= 8192))
              : Kn(c),
            null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(o(156, c.tag));
    }
    var BL = a.ReactCurrentOwner, Hr = !1;
    function lr(l, c, m, x) {
      c.child = l === null ? E1(c, null, m, x) : Gl(c, l.child, m, x);
    }
    function J1(l, c, m, x, E) {
      m = m.render;
      var A = c.ref;
      return Bl(c, E),
        x = c0(l, c, m, x, A, E),
        m = f0(),
        l !== null && !Hr
          ? (c.updateQueue = l.updateQueue,
            c.flags &= -2053,
            l.lanes &= ~E,
            Is(l, c, E))
          : (Zt && m && e0(c), c.flags |= 1, lr(l, c, x, E), c.child);
    }
    function Q1(l, c, m, x, E) {
      if (l === null) {
        var A = m.type;
        return typeof A == "function" && !U0(A) && A.defaultProps === void 0 &&
            m.compare === null && m.defaultProps === void 0
          ? (c.tag = 15, c.type = A, $1(l, c, A, x, E))
          : (l = Mh(m.type, null, x, c, c.mode, E),
            l.ref = c.ref,
            l.return = c,
            c.child = l);
      }
      if (A = l.child, (l.lanes & E) == 0) {
        var F = A.memoizedProps;
        if (
          m = m.compare, m = m !== null ? m : zd, m(F, x) && l.ref === c.ref
        ) return Is(l, c, E);
      }
      return c.flags |= 1,
        l = xo(A, x),
        l.ref = c.ref,
        l.return = c,
        c.child = l;
    }
    function $1(l, c, m, x, E) {
      if (l !== null && zd(l.memoizedProps, x) && l.ref === c.ref) {
        if (Hr = !1, (l.lanes & E) != 0) {
          (l.flags & 131072) != 0 && (Hr = !0);
        } else return c.lanes = l.lanes, Is(l, c, E);
      }
      return v0(l, c, m, x, E);
    }
    function ew(l, c, m) {
      var x = c.pendingProps,
        E = x.children,
        A = l !== null ? l.memoizedState : null;
      if (x.mode === "hidden") {
        if ((c.mode & 1) == 0) {
          c.memoizedState = { baseLanes: 0, cachePool: null },
            Pt(ql, Gr),
            Gr |= m;
        } else if ((m & 1073741824) != 0) {
          c.memoizedState = { baseLanes: 0, cachePool: null },
            x = A !== null ? A.baseLanes : m,
            Pt(ql, Gr),
            Gr |= x;
        } else {return l = A !== null ? A.baseLanes | m : m,
            c.lanes = c.childLanes = 1073741824,
            c.memoizedState = { baseLanes: l, cachePool: null },
            c.updateQueue = null,
            Pt(ql, Gr),
            Gr |= l,
            null;}
      } else {A !== null
          ? (x = A.baseLanes | m, c.memoizedState = null)
          : x = m,
          Pt(ql, Gr),
          Gr |= x;}
      return lr(l, c, E, m), c.child;
    }
    function tw(l, c) {
      var m = c.ref;
      (l === null && m !== null || l !== null && l.ref !== m) &&
        (c.flags |= 512, c.flags |= 2097152);
    }
    function v0(l, c, m, x, E) {
      var A = Cr(m) ? Ta : qn.current;
      return A = Ol(c, A),
        Bl(c, E),
        m = c0(l, c, m, x, A, E),
        x = f0(),
        l !== null && !Hr
          ? (c.updateQueue = l.updateQueue,
            c.flags &= -2053,
            l.lanes &= ~E,
            Is(l, c, E))
          : (Zt && x && e0(c), c.flags |= 1, lr(l, c, m, E), c.child);
    }
    function nw(l, c, m, x, E) {
      if (Cr(m)) {
        var A = !0;
        Id(c);
      } else A = !1;
      if (Bl(c, E), c.stateNode === null) {
        l !== null && (l.alternate = null, c.alternate = null, c.flags |= 2),
          g1(c, m, x),
          $g(c, m, x, E),
          x = !0;
      } else if (l === null) {
        var F = c.stateNode, U = c.memoizedProps;
        F.props = U;
        var te = F.context, ge = m.contextType;
        typeof ge == "object" && ge !== null
          ? ge = li(ge)
          : (ge = Cr(m) ? Ta : qn.current, ge = Ol(c, ge));
        var De = m.getDerivedStateFromProps,
          nt = typeof De == "function" ||
            typeof F.getSnapshotBeforeUpdate == "function";
        nt ||
        typeof F.UNSAFE_componentWillReceiveProps != "function" &&
          typeof F.componentWillReceiveProps != "function" ||
        (U !== x || te !== ge) && v1(c, F, x, ge), ho = !1;
        var He = c.memoizedState;
        F.state = He,
          Hd(c, x, F, E),
          te = c.memoizedState,
          U !== x || He !== te || Ar.current || ho
            ? (typeof De == "function" &&
              (Qg(c, m, De, x), te = c.memoizedState),
              (U = ho || m1(c, m, U, x, He, te, ge))
                ? (nt ||
                  typeof F.UNSAFE_componentWillMount != "function" &&
                    typeof F.componentWillMount != "function" ||
                  (typeof F.componentWillMount == "function" &&
                    F.componentWillMount(),
                    typeof F.UNSAFE_componentWillMount == "function" &&
                    F.UNSAFE_componentWillMount()),
                  typeof F.componentDidMount == "function" &&
                  (c.flags |= 4194308))
                : (typeof F.componentDidMount == "function" &&
                  (c.flags |= 4194308),
                  c.memoizedProps = x,
                  c.memoizedState = te),
              F.props = x,
              F.state = te,
              F.context = ge,
              x = U)
            : (typeof F.componentDidMount == "function" && (c.flags |= 4194308),
              x = !1);
      } else {
        F = c.stateNode,
          f1(l, c),
          U = c.memoizedProps,
          ge = c.type === c.elementType ? U : Ni(c.type, U),
          F.props = ge,
          nt = c.pendingProps,
          He = F.context,
          te = m.contextType,
          typeof te == "object" && te !== null
            ? te = li(te)
            : (te = Cr(m) ? Ta : qn.current, te = Ol(c, te));
        var Bt = m.getDerivedStateFromProps;
        (De = typeof Bt == "function" ||
          typeof F.getSnapshotBeforeUpdate == "function") ||
        typeof F.UNSAFE_componentWillReceiveProps != "function" &&
          typeof F.componentWillReceiveProps != "function" ||
        (U !== nt || He !== te) && v1(c, F, x, te),
          ho = !1,
          He = c.memoizedState,
          F.state = He,
          Hd(c, x, F, E);
        var Ue = c.memoizedState;
        U !== nt || He !== Ue || Ar.current || ho
          ? (typeof Bt == "function" && (Qg(c, m, Bt, x), Ue = c.memoizedState),
            (ge = ho || m1(c, m, ge, x, He, Ue, te) || !1)
              ? (De ||
                typeof F.UNSAFE_componentWillUpdate != "function" &&
                  typeof F.componentWillUpdate != "function" ||
                (typeof F.componentWillUpdate == "function" &&
                  F.componentWillUpdate(x, Ue, te),
                  typeof F.UNSAFE_componentWillUpdate == "function" &&
                  F.UNSAFE_componentWillUpdate(x, Ue, te)),
                typeof F.componentDidUpdate == "function" && (c.flags |= 4),
                typeof F.getSnapshotBeforeUpdate == "function" &&
                (c.flags |= 1024))
              : (typeof F.componentDidUpdate != "function" ||
                U === l.memoizedProps && He === l.memoizedState ||
                (c.flags |= 4),
                typeof F.getSnapshotBeforeUpdate != "function" ||
                U === l.memoizedProps && He === l.memoizedState ||
                (c.flags |= 1024),
                c.memoizedProps = x,
                c.memoizedState = Ue),
            F.props = x,
            F.state = Ue,
            F.context = te,
            x = ge)
          : (typeof F.componentDidUpdate != "function" ||
            U === l.memoizedProps && He === l.memoizedState || (c.flags |= 4),
            typeof F.getSnapshotBeforeUpdate != "function" ||
            U === l.memoizedProps && He === l.memoizedState ||
            (c.flags |= 1024),
            x = !1);
      }
      return y0(l, c, m, x, A, E);
    }
    function y0(l, c, m, x, E, A) {
      tw(l, c);
      var F = (c.flags & 128) != 0;
      if (!x && !F) return E && o1(c, m, !1), Is(l, c, A);
      x = c.stateNode, BL.current = c;
      var U = F && typeof m.getDerivedStateFromError != "function"
        ? null
        : x.render();
      return c.flags |= 1,
        l !== null && F
          ? (c.child = Gl(c, l.child, null, A), c.child = Gl(c, null, U, A))
          : lr(l, c, U, A),
        c.memoizedState = x.state,
        E && o1(c, m, !0),
        c.child;
    }
    function rw(l) {
      var c = l.stateNode;
      c.pendingContext
        ? i1(l, c.pendingContext, c.pendingContext !== c.context)
        : c.context && i1(l, c.context, !1), s0(l, c.containerInfo);
    }
    function iw(l, c, m, x, E) {
      return Hl(), i0(E), c.flags |= 256, lr(l, c, m, x), c.child;
    }
    var rh = { dehydrated: null, treeContext: null, retryLane: 0 };
    function ih(l) {
      return { baseLanes: l, cachePool: null };
    }
    function sw(l, c, m) {
      var x = c.pendingProps,
        E = nn.current,
        A = !1,
        F = (c.flags & 128) != 0,
        U;
      if (
        (U = F) ||
        (U = l !== null && l.memoizedState === null ? !1 : (E & 2) != 0),
          U
            ? (A = !0, c.flags &= -129)
            : (l === null || l.memoizedState !== null) && (E |= 1),
          Pt(nn, E & 1),
          l === null
      ) {
        return r0(c),
          l = c.memoizedState,
          l !== null && (l = l.dehydrated, l !== null)
            ? ((c.mode & 1) == 0
              ? c.lanes = 1
              : D(l)
              ? c.lanes = 8
              : c.lanes = 1073741824,
              null)
            : (E = x.children,
              l = x.fallback,
              A
                ? (x = c.mode,
                  A = c.child,
                  E = { mode: "hidden", children: E },
                  (x & 1) == 0 && A !== null
                    ? (A.childLanes = 0, A.pendingProps = E)
                    : A = Eh(E, x, 0, null),
                  l = Da(l, x, m, null),
                  A.return = c,
                  l.return = c,
                  A.sibling = l,
                  c.child = A,
                  c.child.memoizedState = ih(m),
                  c.memoizedState = rh,
                  l)
                : x0(c, E));
      }
      if (E = l.memoizedState, E !== null) {
        if (U = E.dehydrated, U !== null) {
          if (F) {
            return c.flags & 256
              ? (c.flags &= -257, sh(l, c, m, Error(o(422))))
              : c.memoizedState !== null
              ? (c.child = l.child, c.flags |= 128, null)
              : (A = x.fallback,
                E = c.mode,
                x = Eh({ mode: "visible", children: x.children }, E, 0, null),
                A = Da(A, E, m, null),
                A.flags |= 2,
                x.return = c,
                A.return = c,
                x.sibling = A,
                c.child = x,
                (c.mode & 1) != 0 && Gl(c, l.child, null, m),
                c.child.memoizedState = ih(m),
                c.memoizedState = rh,
                A);
          }
          if ((c.mode & 1) == 0) c = sh(l, c, m, null);
          else if (D(U)) c = sh(l, c, m, Error(o(419)));
          else if (x = (m & l.childLanes) != 0, Hr || x) {
            if (x = _n, x !== null) {
              switch (m & -m) {
                case 4:
                  A = 2;
                  break;
                case 16:
                  A = 8;
                  break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                  A = 32;
                  break;
                case 536870912:
                  A = 268435456;
                  break;
                default:
                  A = 0;
              }
              x = (A & (x.suspendedLanes | m)) != 0 ? 0 : A,
                x !== 0 && x !== E.retryLane && (E.retryLane = x, hi(l, x, -1));
            }
            B0(), c = sh(l, c, m, Error(o(421)));
          } else {Ld(U)
              ? (c.flags |= 128,
                c.child = l.child,
                c = QL.bind(null, l),
                q(U, c),
                c = null)
              : (m = E.treeContext,
                ne &&
                (Vr = qe(U),
                  Ur = c,
                  Zt = !0,
                  Di = null,
                  Cc = !1,
                  m !== null &&
                  (ui[ci++] = Rs,
                    ui[ci++] = Ls,
                    ui[ci++] = Aa,
                    Rs = m.id,
                    Ls = m.overflow,
                    Aa = c)),
                c = x0(c, c.pendingProps.children),
                c.flags |= 4096);}
          return c;
        }
        return A
          ? (x = aw(l, c, x.children, x.fallback, m),
            A = c.child,
            E = l.child.memoizedState,
            A.memoizedState = E === null
              ? ih(m)
              : { baseLanes: E.baseLanes | m, cachePool: null },
            A.childLanes = l.childLanes & ~m,
            c.memoizedState = rh,
            x)
          : (m = ow(l, c, x.children, m), c.memoizedState = null, m);
      }
      return A
        ? (x = aw(l, c, x.children, x.fallback, m),
          A = c.child,
          E = l.child.memoizedState,
          A.memoizedState = E === null
            ? ih(m)
            : { baseLanes: E.baseLanes | m, cachePool: null },
          A.childLanes = l.childLanes & ~m,
          c.memoizedState = rh,
          x)
        : (m = ow(l, c, x.children, m), c.memoizedState = null, m);
    }
    function x0(l, c) {
      return c = Eh({ mode: "visible", children: c }, l.mode, 0, null),
        c.return = l,
        l.child = c;
    }
    function ow(l, c, m, x) {
      var E = l.child;
      return l = E.sibling,
        m = xo(E, { mode: "visible", children: m }),
        (c.mode & 1) == 0 && (m.lanes = x),
        m.return = c,
        m.sibling = null,
        l !== null &&
        (x = c.deletions,
          x === null ? (c.deletions = [l], c.flags |= 16) : x.push(l)),
        c.child = m;
    }
    function aw(l, c, m, x, E) {
      var A = c.mode;
      l = l.child;
      var F = l.sibling, U = { mode: "hidden", children: m };
      return (A & 1) == 0 && c.child !== l
        ? (m = c.child,
          m.childLanes = 0,
          m.pendingProps = U,
          c.deletions = null)
        : (m = xo(l, U), m.subtreeFlags = l.subtreeFlags & 14680064),
        F !== null ? x = xo(F, x) : (x = Da(x, A, E, null), x.flags |= 2),
        x.return = c,
        m.return = c,
        m.sibling = x,
        c.child = m,
        x;
    }
    function sh(l, c, m, x) {
      return x !== null && i0(x),
        Gl(c, l.child, null, m),
        l = x0(c, c.pendingProps.children),
        l.flags |= 2,
        c.memoizedState = null,
        l;
    }
    function lw(l, c, m) {
      l.lanes |= c;
      var x = l.alternate;
      x !== null && (x.lanes |= c), Kg(l.return, c, m);
    }
    function _0(l, c, m, x, E) {
      var A = l.memoizedState;
      A === null
        ? l.memoizedState = {
          isBackwards: c,
          rendering: null,
          renderingStartTime: 0,
          last: x,
          tail: m,
          tailMode: E,
        }
        : (A.isBackwards = c,
          A.rendering = null,
          A.renderingStartTime = 0,
          A.last = x,
          A.tail = m,
          A.tailMode = E);
    }
    function uw(l, c, m) {
      var x = c.pendingProps, E = x.revealOrder, A = x.tail;
      if (lr(l, c, x.children, m), x = nn.current, (x & 2) != 0) {
        x = x & 1 | 2, c.flags |= 128;
      } else {
        if (l !== null && (l.flags & 128) != 0) {
          e: for (l = c.child; l !== null;) {
            if (l.tag === 13) {
              l.memoizedState !== null && lw(l, m, c);
            } else if (l.tag === 19) lw(l, m, c);
            else if (l.child !== null) {
              l.child.return = l, l = l.child;
              continue;
            }
            if (l === c) break e;
            for (; l.sibling === null;) {
              if (l.return === null || l.return === c) break e;
              l = l.return;
            }
            l.sibling.return = l.return, l = l.sibling;
          }
        }
        x &= 1;
      }
      if (Pt(nn, x), (c.mode & 1) == 0) c.memoizedState = null;
      else {switch (E) {
          case "forwards":
            for (m = c.child, E = null; m !== null;) {
              l = m.alternate,
                l !== null && qd(l) === null && (E = m),
                m = m.sibling;
            }
            m = E,
              m === null
                ? (E = c.child, c.child = null)
                : (E = m.sibling, m.sibling = null),
              _0(c, !1, E, m, A);
            break;
          case "backwards":
            for (m = null, E = c.child, c.child = null; E !== null;) {
              if (l = E.alternate, l !== null && qd(l) === null) {
                c.child = E;
                break;
              }
              l = E.sibling, E.sibling = m, m = E, E = l;
            }
            _0(c, !0, m, null, A);
            break;
          case "together":
            _0(c, !1, null, null, void 0);
            break;
          default:
            c.memoizedState = null;
        }}
      return c.child;
    }
    function Is(l, c, m) {
      if (
        l !== null && (c.dependencies = l.dependencies),
          Yl |= c.lanes,
          (m & c.childLanes) == 0
      ) return null;
      if (l !== null && c.child !== l.child) throw Error(o(153));
      if (c.child !== null) {
        for (
          l = c.child, m = xo(l, l.pendingProps), c.child = m, m.return = c;
          l.sibling !== null;
        ) l = l.sibling, m = m.sibling = xo(l, l.pendingProps), m.return = c;
        m.sibling = null;
      }
      return c.child;
    }
    function UL(l, c, m) {
      switch (c.tag) {
        case 3:
          rw(c), Hl();
          break;
        case 5:
          T1(c);
          break;
        case 1:
          Cr(c.type) && Id(c);
          break;
        case 4:
          s0(c, c.stateNode.containerInfo);
          break;
        case 10:
          c1(c, c.type._context, c.memoizedProps.value);
          break;
        case 13:
          var x = c.memoizedState;
          if (x !== null) {
            return x.dehydrated !== null
              ? (Pt(nn, nn.current & 1), c.flags |= 128, null)
              : (m & c.child.childLanes) != 0
              ? sw(l, c, m)
              : (Pt(nn, nn.current & 1),
                l = Is(l, c, m),
                l !== null ? l.sibling : null);
          }
          Pt(nn, nn.current & 1);
          break;
        case 19:
          if (x = (m & c.childLanes) != 0, (l.flags & 128) != 0) {
            if (x) return uw(l, c, m);
            c.flags |= 128;
          }
          var E = c.memoizedState;
          if (
            E !== null &&
            (E.rendering = null, E.tail = null, E.lastEffect = null),
              Pt(nn, nn.current),
              x
          ) break;
          return null;
        case 22:
        case 23:
          return c.lanes = 0, ew(l, c, m);
      }
      return Is(l, c, m);
    }
    function VL(l, c) {
      switch (t0(c), c.tag) {
        case 1:
          return Cr(c.type) && Pd(),
            l = c.flags,
            l & 65536 ? (c.flags = l & -65537 | 128, c) : null;
        case 3:
          return Wl(),
            Rt(Ar),
            Rt(qn),
            l0(),
            l = c.flags,
            (l & 65536) != 0 && (l & 128) == 0
              ? (c.flags = l & -65537 | 128, c)
              : null;
        case 5:
          return o0(c), null;
        case 13:
          if (
            Rt(nn), l = c.memoizedState, l !== null && l.dehydrated !== null
          ) {
            if (c.alternate === null) throw Error(o(340));
            Hl();
          }
          return l = c.flags,
            l & 65536 ? (c.flags = l & -65537 | 128, c) : null;
        case 19:
          return Rt(nn), null;
        case 4:
          return Wl(), null;
        case 10:
          return Zg(c.type._context), null;
        case 22:
        case 23:
          return z0(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var oh = !1,
      Ra = !1,
      HL = typeof WeakSet == "function" ? WeakSet : Set,
      Te = null;
    function ah(l, c) {
      var m = l.ref;
      if (m !== null) {
        if (typeof m == "function") {
          try {
            m(null);
          } catch (x) {
            Lr(l, c, x);
          }
        } else m.current = null;
      }
    }
    function S0(l, c, m) {
      try {
        m();
      } catch (x) {
        Lr(l, c, x);
      }
    }
    var cw = !1;
    function GL(l, c) {
      for (X(l.containerInfo), Te = c; Te !== null;) {
        if (l = Te, c = l.child, (l.subtreeFlags & 1028) != 0 && c !== null) {
          c.return = l, Te = c;
        } else {for (; Te !== null;) {
            l = Te;
            try {
              var m = l.alternate;
              if ((l.flags & 1024) != 0) {
                switch (l.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (m !== null) {
                      var x = m.memoizedProps,
                        E = m.memoizedState,
                        A = l.stateNode,
                        F = A.getSnapshotBeforeUpdate(
                          l.elementType === l.type ? x : Ni(l.type, x),
                          E,
                        );
                      A.__reactInternalSnapshotBeforeUpdate = F;
                    }
                    break;
                  case 3:
                    je && Ct(l.stateNode.containerInfo);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(o(163));
                }
              }
            } catch (U) {
              Lr(l, l.return, U);
            }
            if (c = l.sibling, c !== null) {
              c.return = l.return, Te = c;
              break;
            }
            Te = l.return;
          }}
      }
      return m = cw, cw = !1, m;
    }
    function La(l, c, m) {
      var x = c.updateQueue;
      if (x = x !== null ? x.lastEffect : null, x !== null) {
        var E = x = x.next;
        do {
          if ((E.tag & l) === l) {
            var A = E.destroy;
            E.destroy = void 0, A !== void 0 && S0(c, m, A);
          }
          E = E.next;
        } while (E !== x);
      }
    }
    function Bc(l, c) {
      if (c = c.updateQueue, c = c !== null ? c.lastEffect : null, c !== null) {
        var m = c = c.next;
        do {
          if ((m.tag & l) === l) {
            var x = m.create;
            m.destroy = x();
          }
          m = m.next;
        } while (m !== c);
      }
    }
    function w0(l) {
      var c = l.ref;
      if (c !== null) {
        var m = l.stateNode;
        switch (l.tag) {
          case 5:
            l = G(m);
            break;
          default:
            l = m;
        }
        typeof c == "function" ? c(l) : c.current = l;
      }
    }
    function fw(l, c, m) {
      if (os && typeof os.onCommitFiberUnmount == "function") {
        try {
          os.onCommitFiberUnmount(Fd, c);
        } catch {}
      }
      switch (c.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          if (l = c.updateQueue, l !== null && (l = l.lastEffect, l !== null)) {
            var x = l = l.next;
            do {
              var E = x, A = E.destroy;
              E = E.tag,
                A !== void 0 && ((E & 2) != 0 || (E & 4) != 0) && S0(c, m, A),
                x = x.next;
            } while (x !== l);
          }
          break;
        case 1:
          if (
            ah(c, m),
              l = c.stateNode,
              typeof l.componentWillUnmount == "function"
          ) {
            try {
              l.props = c.memoizedProps,
                l.state = c.memoizedState,
                l.componentWillUnmount();
            } catch (F) {
              Lr(c, m, F);
            }
          }
          break;
        case 5:
          ah(c, m);
          break;
        case 4:
          je
            ? vw(l, c, m)
            : ue && ue && (c = c.stateNode.containerInfo, m = Br(c), Ea(c, m));
      }
    }
    function dw(l, c, m) {
      for (var x = c;;) {
        if (fw(l, x, m), x.child === null || je && x.tag === 4) {
          if (x === c) break;
          for (; x.sibling === null;) {
            if (x.return === null || x.return === c) return;
            x = x.return;
          }
          x.sibling.return = x.return, x = x.sibling;
        } else x.child.return = x, x = x.child;
      }
    }
    function hw(l) {
      var c = l.alternate;
      c !== null && (l.alternate = null, hw(c)),
        l.child = null,
        l.deletions = null,
        l.sibling = null,
        l.tag === 5 && (c = l.stateNode, c !== null && et(c)),
        l.stateNode = null,
        l.return = null,
        l.dependencies = null,
        l.memoizedProps = null,
        l.memoizedState = null,
        l.pendingProps = null,
        l.stateNode = null,
        l.updateQueue = null;
    }
    function pw(l) {
      return l.tag === 5 || l.tag === 3 || l.tag === 4;
    }
    function mw(l) {
      e: for (;;) {
        for (; l.sibling === null;) {
          if (l.return === null || pw(l.return)) return null;
          l = l.return;
        }
        for (
          l.sibling.return = l.return, l = l.sibling;
          l.tag !== 5 && l.tag !== 6 && l.tag !== 18;
        ) {
          if (l.flags & 2 || l.child === null || l.tag === 4) continue e;
          l.child.return = l, l = l.child;
        }
        if (!(l.flags & 2)) return l.stateNode;
      }
    }
    function gw(l) {
      if (je) {
        e: {
          for (var c = l.return; c !== null;) {
            if (pw(c)) break e;
            c = c.return;
          }
          throw Error(o(160));
        }
        var m = c;
        switch (m.tag) {
          case 5:
            c = m.stateNode,
              m.flags & 32 && (Ne(c), m.flags &= -33),
              m = mw(l),
              E0(l, m, c);
            break;
          case 3:
          case 4:
            c = m.stateNode.containerInfo, m = mw(l), M0(l, m, c);
            break;
          default:
            throw Error(o(161));
        }
      }
    }
    function M0(l, c, m) {
      var x = l.tag;
      if (x === 5 || x === 6) l = l.stateNode, c ? Me(m, l, c) : ee(m, l);
      else if (x !== 4 && (l = l.child, l !== null)) {
        for (M0(l, c, m), l = l.sibling; l !== null;) {
          M0(l, c, m), l = l.sibling;
        }
      }
    }
    function E0(l, c, m) {
      var x = l.tag;
      if (x === 5 || x === 6) l = l.stateNode, c ? B(m, l, c) : Ke(m, l);
      else if (x !== 4 && (l = l.child, l !== null)) {
        for (E0(l, c, m), l = l.sibling; l !== null;) {
          E0(l, c, m), l = l.sibling;
        }
      }
    }
    function vw(l, c, m) {
      for (var x = c, E = !1, A, F;;) {
        if (!E) {
          E = x.return;
          e: for (;;) {
            if (E === null) throw Error(o(160));
            switch (A = E.stateNode, E.tag) {
              case 5:
                F = !1;
                break e;
              case 3:
                A = A.containerInfo, F = !0;
                break e;
              case 4:
                A = A.containerInfo, F = !0;
                break e;
            }
            E = E.return;
          }
          E = !0;
        }
        if (x.tag === 5 || x.tag === 6) {
          dw(l, x, m), F ? Xe(A, x.stateNode) : we(A, x.stateNode);
        } else if (x.tag === 18) F ? Ts(A, x.stateNode) : Xt(A, x.stateNode);
        else if (x.tag === 4) {
          if (x.child !== null) {
            A = x.stateNode.containerInfo,
              F = !0,
              x.child.return = x,
              x = x.child;
            continue;
          }
        } else if (fw(l, x, m), x.child !== null) {
          x.child.return = x, x = x.child;
          continue;
        }
        if (x === c) break;
        for (; x.sibling === null;) {
          if (x.return === null || x.return === c) return;
          x = x.return, x.tag === 4 && (E = !1);
        }
        x.sibling.return = x.return, x = x.sibling;
      }
    }
    function T0(l, c) {
      if (je) {
        switch (c.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            La(3, c, c.return), Bc(3, c), La(5, c, c.return);
            return;
          case 1:
            return;
          case 5:
            var m = c.stateNode;
            if (m != null) {
              var x = c.memoizedProps;
              l = l !== null ? l.memoizedProps : x;
              var E = c.type, A = c.updateQueue;
              c.updateQueue = null, A !== null && Re(m, A, E, l, x, c);
            }
            return;
          case 6:
            if (c.stateNode === null) throw Error(o(162));
            m = c.memoizedProps,
              Be(c.stateNode, l !== null ? l.memoizedProps : m, m);
            return;
          case 3:
            ne && l !== null && l.memoizedState.isDehydrated &&
              dt(c.stateNode.containerInfo);
            return;
          case 12:
            return;
          case 13:
            lh(c);
            return;
          case 19:
            lh(c);
            return;
          case 17:
            return;
        }
        throw Error(o(163));
      }
      switch (c.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          La(3, c, c.return), Bc(3, c), La(5, c, c.return);
          return;
        case 12:
          return;
        case 13:
          lh(c);
          return;
        case 19:
          lh(c);
          return;
        case 3:
          ne && l !== null && l.memoizedState.isDehydrated &&
            dt(c.stateNode.containerInfo);
          break;
        case 22:
        case 23:
          return;
      }
      e: if (ue) {
        switch (c.tag) {
          case 1:
          case 5:
          case 6:
            break e;
          case 3:
          case 4:
            c = c.stateNode, Ea(c.containerInfo, c.pendingChildren);
            break e;
        }
        throw Error(o(163));
      }
    }
    function lh(l) {
      var c = l.updateQueue;
      if (c !== null) {
        l.updateQueue = null;
        var m = l.stateNode;
        m === null && (m = l.stateNode = new HL()),
          c.forEach(function (x) {
            var E = $L.bind(null, l, x);
            m.has(x) || (m.add(x), x.then(E, E));
          });
      }
    }
    function jL(l, c) {
      for (Te = c; Te !== null;) {
        c = Te;
        var m = c.deletions;
        if (m !== null) {
          for (var x = 0; x < m.length; x++) {
            var E = m[x];
            try {
              var A = l;
              je ? vw(A, E, c) : dw(A, E, c);
              var F = E.alternate;
              F !== null && (F.return = null), E.return = null;
            } catch (ze) {
              Lr(E, c, ze);
            }
          }
        }
        if (m = c.child, (c.subtreeFlags & 12854) != 0 && m !== null) {
          m.return = c, Te = m;
        } else {for (; Te !== null;) {
            c = Te;
            try {
              var U = c.flags;
              if (U & 32 && je && Ne(c.stateNode), U & 512) {
                var te = c.alternate;
                if (te !== null) {
                  var ge = te.ref;
                  ge !== null &&
                    (typeof ge == "function" ? ge(null) : ge.current = null);
                }
              }
              if (U & 8192) {
                switch (c.tag) {
                  case 13:
                    if (c.memoizedState !== null) {
                      var De = c.alternate;
                      (De === null || De.memoizedState === null) && (I0 = Dn());
                    }
                    break;
                  case 22:
                    var nt = c.memoizedState !== null,
                      He = c.alternate,
                      Bt = He !== null && He.memoizedState !== null;
                    if (m = c, je) {
                      e: if (x = m, E = nt, A = null, je) {
                        for (var Ue = x;;) {
                          if (Ue.tag === 5) {
                            if (A === null) {
                              A = Ue;
                              var Jn = Ue.stateNode;
                              E ? Je(Jn) : Qe(Ue.stateNode, Ue.memoizedProps);
                            }
                          } else if (Ue.tag === 6) {
                            if (A === null) {
                              var mi = Ue.stateNode;
                              E ? ye(mi) : At(mi, Ue.memoizedProps);
                            }
                          } else if (
                            (Ue.tag !== 22 && Ue.tag !== 23 ||
                              Ue.memoizedState === null || Ue === x) &&
                            Ue.child !== null
                          ) {
                            Ue.child.return = Ue, Ue = Ue.child;
                            continue;
                          }
                          if (Ue === x) break;
                          for (; Ue.sibling === null;) {
                            if (
                              Ue.return === null || Ue.return === x
                            ) break e;
                            A === Ue && (A = null), Ue = Ue.return;
                          }
                          A === Ue && (A = null),
                            Ue.sibling.return = Ue.return,
                            Ue = Ue.sibling;
                        }
                      }
                    }
                    if (nt && !Bt && (m.mode & 1) != 0) {
                      Te = m;
                      for (var j = m.child; j !== null;) {
                        for (m = Te = j; Te !== null;) {
                          x = Te;
                          var H = x.child;
                          switch (x.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                              La(4, x, x.return);
                              break;
                            case 1:
                              ah(x, x.return);
                              var K = x.stateNode;
                              if (typeof K.componentWillUnmount == "function") {
                                var be = x.return;
                                try {
                                  K.props = x.memoizedProps,
                                    K.state = x.memoizedState,
                                    K.componentWillUnmount();
                                } catch (ze) {
                                  Lr(x, be, ze);
                                }
                              }
                              break;
                            case 5:
                              ah(x, x.return);
                              break;
                            case 22:
                              if (x.memoizedState !== null) {
                                _w(m);
                                continue;
                              }
                          }
                          H !== null ? (H.return = x, Te = H) : _w(m);
                        }
                        j = j.sibling;
                      }
                    }
                }
              }
              switch (U & 4102) {
                case 2:
                  gw(c), c.flags &= -3;
                  break;
                case 6:
                  gw(c), c.flags &= -3, T0(c.alternate, c);
                  break;
                case 4096:
                  c.flags &= -4097;
                  break;
                case 4100:
                  c.flags &= -4097, T0(c.alternate, c);
                  break;
                case 4:
                  T0(c.alternate, c);
              }
            } catch (ze) {
              Lr(c, c.return, ze);
            }
            if (m = c.sibling, m !== null) {
              m.return = c.return, Te = m;
              break;
            }
            Te = c.return;
          }}
      }
    }
    function WL(l, c, m) {
      Te = l, yw(l, c, m);
    }
    function yw(l, c, m) {
      for (var x = (l.mode & 1) != 0; Te !== null;) {
        var E = Te, A = E.child;
        if (E.tag === 22 && x) {
          var F = E.memoizedState !== null || oh;
          if (!F) {
            var U = E.alternate,
              te = U !== null && U.memoizedState !== null || Ra;
            U = oh;
            var ge = Ra;
            if (oh = F, (Ra = te) && !ge) {
              for (Te = E; Te !== null;) {
                F = Te,
                  te = F.child,
                  F.tag === 22 && F.memoizedState !== null
                    ? Sw(E)
                    : te !== null
                    ? (te.return = F, Te = te)
                    : Sw(E);
              }
            }
            for (; A !== null;) Te = A, yw(A, c, m), A = A.sibling;
            Te = E, oh = U, Ra = ge;
          }
          xw(l, c, m);
        } else {(E.subtreeFlags & 8772) != 0 && A !== null
            ? (A.return = E, Te = A)
            : xw(l, c, m);}
      }
    }
    function xw(l) {
      for (; Te !== null;) {
        var c = Te;
        if ((c.flags & 8772) != 0) {
          var m = c.alternate;
          try {
            if ((c.flags & 8772) != 0) {
              switch (c.tag) {
                case 0:
                case 11:
                case 15:
                  Ra || Bc(5, c);
                  break;
                case 1:
                  var x = c.stateNode;
                  if (c.flags & 4 && !Ra) {
                    if (m === null) x.componentDidMount();
                    else {
                      var E = c.elementType === c.type
                        ? m.memoizedProps
                        : Ni(c.type, m.memoizedProps);
                      x.componentDidUpdate(
                        E,
                        m.memoizedState,
                        x.__reactInternalSnapshotBeforeUpdate,
                      );
                    }
                  }
                  var A = c.updateQueue;
                  A !== null && h1(c, A, x);
                  break;
                case 3:
                  var F = c.updateQueue;
                  if (F !== null) {
                    if (m = null, c.child !== null) {
                      switch (c.child.tag) {
                        case 5:
                          m = G(c.child.stateNode);
                          break;
                        case 1:
                          m = c.child.stateNode;
                      }
                    }
                    h1(c, F, m);
                  }
                  break;
                case 5:
                  var U = c.stateNode;
                  m === null && c.flags & 4 &&
                    Ie(U, c.type, c.memoizedProps, c);
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (ne && c.memoizedState === null) {
                    var te = c.alternate;
                    if (te !== null) {
                      var ge = te.memoizedState;
                      if (ge !== null) {
                        var De = ge.dehydrated;
                        De !== null && mt(De);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                  break;
                default:
                  throw Error(o(163));
              }
            }
            Ra || c.flags & 512 && w0(c);
          } catch (nt) {
            Lr(c, c.return, nt);
          }
        }
        if (c === l) {
          Te = null;
          break;
        }
        if (m = c.sibling, m !== null) {
          m.return = c.return, Te = m;
          break;
        }
        Te = c.return;
      }
    }
    function _w(l) {
      for (; Te !== null;) {
        var c = Te;
        if (c === l) {
          Te = null;
          break;
        }
        var m = c.sibling;
        if (m !== null) {
          m.return = c.return, Te = m;
          break;
        }
        Te = c.return;
      }
    }
    function Sw(l) {
      for (; Te !== null;) {
        var c = Te;
        try {
          switch (c.tag) {
            case 0:
            case 11:
            case 15:
              var m = c.return;
              try {
                Bc(4, c);
              } catch (te) {
                Lr(c, m, te);
              }
              break;
            case 1:
              var x = c.stateNode;
              if (typeof x.componentDidMount == "function") {
                var E = c.return;
                try {
                  x.componentDidMount();
                } catch (te) {
                  Lr(c, E, te);
                }
              }
              var A = c.return;
              try {
                w0(c);
              } catch (te) {
                Lr(c, A, te);
              }
              break;
            case 5:
              var F = c.return;
              try {
                w0(c);
              } catch (te) {
                Lr(c, F, te);
              }
          }
        } catch (te) {
          Lr(c, c.return, te);
        }
        if (c === l) {
          Te = null;
          break;
        }
        var U = c.sibling;
        if (U !== null) {
          U.return = c.return, Te = U;
          break;
        }
        Te = c.return;
      }
    }
    var uh = 0, ch = 1, fh = 2, dh = 3, hh = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var Uc = Symbol.for;
      uh = Uc("selector.component"),
        ch = Uc("selector.has_pseudo_class"),
        fh = Uc("selector.role"),
        dh = Uc("selector.test_id"),
        hh = Uc("selector.text");
    }
    function A0(l) {
      var c = _e(l);
      if (c != null) {
        if (typeof c.memoizedProps["data-testname"] != "string") {
          throw Error(o(364));
        }
        return c;
      }
      if (l = Nt(l), l === null) throw Error(o(362));
      return l.stateNode.current;
    }
    function C0(l, c) {
      switch (c.$$typeof) {
        case uh:
          if (l.type === c.value) return !0;
          break;
        case ch:
          e: {
            c = c.value, l = [l, 0];
            for (var m = 0; m < l.length;) {
              var x = l[m++], E = l[m++], A = c[E];
              if (x.tag !== 5 || !J(x)) {
                for (; A != null && C0(x, A);) E++, A = c[E];
                if (E === c.length) {
                  c = !0;
                  break e;
                } else {for (x = x.child; x !== null;) {
                    l.push(x, E), x = x.sibling;
                  }}
              }
            }
            c = !1;
          }
          return c;
        case fh:
          if (l.tag === 5 && me(l.stateNode, c.value)) return !0;
          break;
        case hh:
          if (
            (l.tag === 5 || l.tag === 6) &&
            (l = N(l), l !== null && 0 <= l.indexOf(c.value))
          ) return !0;
          break;
        case dh:
          if (
            l.tag === 5 &&
            (l = l.memoizedProps["data-testname"],
              typeof l == "string" && l.toLowerCase() === c.value.toLowerCase())
          ) return !0;
          break;
        default:
          throw Error(o(365));
      }
      return !1;
    }
    function b0(l) {
      switch (l.$$typeof) {
        case uh:
          return "<" + (P(l.value) || "Unknown") + ">";
        case ch:
          return ":has(" + (b0(l) || "") + ")";
        case fh:
          return '[role="' + l.value + '"]';
        case hh:
          return '"' + l.value + '"';
        case dh:
          return '[data-testname="' + l.value + '"]';
        default:
          throw Error(o(365));
      }
    }
    function ww(l, c) {
      var m = [];
      l = [l, 0];
      for (var x = 0; x < l.length;) {
        var E = l[x++], A = l[x++], F = c[A];
        if (E.tag !== 5 || !J(E)) {
          for (; F != null && C0(E, F);) A++, F = c[A];
          if (A === c.length) m.push(E);
          else for (E = E.child; E !== null;) l.push(E, A), E = E.sibling;
        }
      }
      return m;
    }
    function R0(l, c) {
      if (!Tt) throw Error(o(363));
      l = A0(l), l = ww(l, c), c = [], l = Array.from(l);
      for (var m = 0; m < l.length;) {
        var x = l[m++];
        if (x.tag === 5) J(x) || c.push(x.stateNode);
        else for (x = x.child; x !== null;) l.push(x), x = x.sibling;
      }
      return c;
    }
    var XL = Math.ceil,
      ph = a.ReactCurrentDispatcher,
      L0 = a.ReactCurrentOwner,
      gn = a.ReactCurrentBatchConfig,
      lt = 0,
      _n = null,
      Sn = null,
      Hn = 0,
      Gr = 0,
      ql = Yt(0),
      Tn = 0,
      Vc = null,
      Yl = 0,
      mh = 0,
      P0 = 0,
      Hc = null,
      br = null,
      I0 = 0,
      N0 = 1 / 0;
    function Zl() {
      N0 = Dn() + 500;
    }
    var gh = !1,
      D0 = null,
      mo = null,
      vh = !1,
      go = null,
      yh = 0,
      Gc = 0,
      k0 = null,
      xh = -1,
      _h = 0;
    function ur() {
      return (lt & 6) != 0 ? Dn() : xh !== -1 ? xh : xh = Dn();
    }
    function vo(l) {
      return (l.mode & 1) == 0
        ? 1
        : (lt & 2) != 0 && Hn !== 0
        ? Hn & -Hn
        : bL.transition !== null
        ? (_h === 0 &&
          (l = Nd, Nd <<= 1, (Nd & 4194240) == 0 && (Nd = 64), _h = l),
          _h)
        : (l = _t, l !== 0 ? l : Ae());
    }
    function hi(l, c, m) {
      if (50 < Gc) throw Gc = 0, k0 = null, Error(o(185));
      var x = Sh(l, c);
      return x === null
        ? null
        : (Ac(x, c, m),
          ((lt & 2) == 0 || x !== _n) &&
          (x === _n && ((lt & 2) == 0 && (mh |= c), Tn === 4 && yo(x, Hn)),
            Rr(x, m),
            c === 1 && lt === 0 && (l.mode & 1) == 0 && (Zl(), Od && ls())),
          x);
    }
    function Sh(l, c) {
      l.lanes |= c;
      var m = l.alternate;
      for (m !== null && (m.lanes |= c), m = l, l = l.return; l !== null;) {
        l.childLanes |= c,
          m = l.alternate,
          m !== null && (m.childLanes |= c),
          m = l,
          l = l.return;
      }
      return m.tag === 3 ? m.stateNode : null;
    }
    function Rr(l, c) {
      var m = l.callbackNode;
      xL(l, c);
      var x = kd(l, l === _n ? Hn : 0);
      if (x === 0) {
        m !== null && l1(m), l.callbackNode = null, l.callbackPriority = 0;
      } else if (c = x & -x, l.callbackPriority !== c) {
        if (m != null && l1(m), c === 1) {
          l.tag === 0 ? CL(Ew.bind(null, l)) : u1(Ew.bind(null, l)),
            We
              ? Ve(function () {
                lt === 0 && ls();
              })
              : Gg(jg, ls),
            m = null;
        } else {
          switch (a1(x)) {
            case 1:
              m = jg;
              break;
            case 4:
              m = ML;
              break;
            case 16:
              m = Wg;
              break;
            case 536870912:
              m = EL;
              break;
            default:
              m = Wg;
          }
          m = Nw(m, Mw.bind(null, l));
        }
        l.callbackPriority = c, l.callbackNode = m;
      }
    }
    function Mw(l, c) {
      if (xh = -1, _h = 0, (lt & 6) != 0) throw Error(o(327));
      var m = l.callbackNode;
      if (Na() && l.callbackNode !== m) return null;
      var x = kd(l, l === _n ? Hn : 0);
      if (x === 0) return null;
      if ((x & 30) != 0 || (x & l.expiredLanes) != 0 || c) c = wh(l, x);
      else {
        c = x;
        var E = lt;
        lt |= 2;
        var A = Cw();
        (_n !== l || Hn !== c) && (Zl(), Pa(l, c));
        do try {
          ZL();
          break;
        } catch (U) {
          Aw(l, U);
        } while (1);
        Yg(),
          ph.current = A,
          lt = E,
          Sn !== null ? c = 0 : (_n = null, Hn = 0, c = Tn);
      }
      if (c !== 0) {
        if (c === 2 && (E = Ug(l), E !== 0 && (x = E, c = F0(l, E))), c === 1) {
          throw m = Vc, Pa(l, 0), yo(l, x), Rr(l, Dn()), m;
        }
        if (c === 6) yo(l, x);
        else {
          if (
            E = l.current.alternate,
              (x & 30) == 0 && !qL(E) &&
              (c = wh(l, x),
                c === 2 && (A = Ug(l), A !== 0 && (x = A, c = F0(l, A))),
                c === 1)
          ) throw m = Vc, Pa(l, 0), yo(l, x), Rr(l, Dn()), m;
          switch (l.finishedWork = E, l.finishedLanes = x, c) {
            case 0:
            case 1:
              throw Error(o(345));
            case 2:
              Ia(l, br);
              break;
            case 3:
              if (
                yo(l, x), (x & 130023424) === x && (c = I0 + 500 - Dn(), 10 < c)
              ) {
                if (kd(l, 0) !== 0) break;
                if (E = l.suspendedLanes, (E & x) !== x) {
                  ur(), l.pingedLanes |= l.suspendedLanes & E;
                  break;
                }
                l.timeoutHandle = Et(Ia.bind(null, l, br), c);
                break;
              }
              Ia(l, br);
              break;
            case 4:
              if (yo(l, x), (x & 4194240) === x) break;
              for (c = l.eventTimes, E = -1; 0 < x;) {
                var F = 31 - Ii(x);
                A = 1 << F, F = c[F], F > E && (E = F), x &= ~A;
              }
              if (
                x = E,
                  x = Dn() - x,
                  x = (120 > x
                    ? 120
                    : 480 > x
                    ? 480
                    : 1080 > x
                    ? 1080
                    : 1920 > x
                    ? 1920
                    : 3e3 > x
                    ? 3e3
                    : 4320 > x
                    ? 4320
                    : 1960 * XL(x / 1960)) - x,
                  10 < x
              ) {
                l.timeoutHandle = Et(Ia.bind(null, l, br), x);
                break;
              }
              Ia(l, br);
              break;
            case 5:
              Ia(l, br);
              break;
            default:
              throw Error(o(329));
          }
        }
      }
      return Rr(l, Dn()), l.callbackNode === m ? Mw.bind(null, l) : null;
    }
    function F0(l, c) {
      var m = Hc;
      return l.current.memoizedState.isDehydrated && (Pa(l, c).flags |= 256),
        l = wh(l, c),
        l !== 2 && (c = br, br = m, c !== null && O0(c)),
        l;
    }
    function O0(l) {
      br === null ? br = l : br.push.apply(br, l);
    }
    function qL(l) {
      for (var c = l;;) {
        if (c.flags & 16384) {
          var m = c.updateQueue;
          if (m !== null && (m = m.stores, m !== null)) {
            for (var x = 0; x < m.length; x++) {
              var E = m[x], A = E.getSnapshot;
              E = E.value;
              try {
                if (!as(A(), E)) {
                  return !1;
                }
              } catch {
                return !1;
              }
            }
          }
        }
        if (m = c.child, c.subtreeFlags & 16384 && m !== null) {
          m.return = c, c = m;
        } else {
          if (c === l) break;
          for (; c.sibling === null;) {
            if (c.return === null || c.return === l) return !0;
            c = c.return;
          }
          c.sibling.return = c.return, c = c.sibling;
        }
      }
      return !0;
    }
    function yo(l, c) {
      for (
        c &= ~P0,
          c &= ~mh,
          l.suspendedLanes |= c,
          l.pingedLanes &= ~c,
          l = l.expirationTimes;
        0 < c;
      ) {
        var m = 31 - Ii(c), x = 1 << m;
        l[m] = -1, c &= ~x;
      }
    }
    function Ew(l) {
      if ((lt & 6) != 0) throw Error(o(327));
      Na();
      var c = kd(l, 0);
      if ((c & 1) == 0) return Rr(l, Dn()), null;
      var m = wh(l, c);
      if (l.tag !== 0 && m === 2) {
        var x = Ug(l);
        x !== 0 && (c = x, m = F0(l, x));
      }
      if (m === 1) throw m = Vc, Pa(l, 0), yo(l, c), Rr(l, Dn()), m;
      if (m === 6) throw Error(o(345));
      return l.finishedWork = l.current.alternate,
        l.finishedLanes = c,
        Ia(l, br),
        Rr(l, Dn()),
        null;
    }
    function Tw(l) {
      go !== null && go.tag === 0 && (lt & 6) == 0 && Na();
      var c = lt;
      lt |= 1;
      var m = gn.transition, x = _t;
      try {
        if (gn.transition = null, _t = 1, l) return l();
      } finally {
        _t = x, gn.transition = m, lt = c, (lt & 6) == 0 && ls();
      }
    }
    function z0() {
      Gr = ql.current, Rt(ql);
    }
    function Pa(l, c) {
      l.finishedWork = null, l.finishedLanes = 0;
      var m = l.timeoutHandle;
      if (m !== Ze && (l.timeoutHandle = Ze, $e(m)), Sn !== null) {
        for (m = Sn.return; m !== null;) {
          var x = m;
          switch (t0(x), x.tag) {
            case 1:
              x = x.type.childContextTypes, x != null && Pd();
              break;
            case 3:
              Wl(), Rt(Ar), Rt(qn), l0();
              break;
            case 5:
              o0(x);
              break;
            case 4:
              Wl();
              break;
            case 13:
              Rt(nn);
              break;
            case 19:
              Rt(nn);
              break;
            case 10:
              Zg(x.type._context);
              break;
            case 22:
            case 23:
              z0();
          }
          m = m.return;
        }
      }
      if (
        _n = l,
          Sn = l = xo(l.current, null),
          Hn = Gr = c,
          Tn = 0,
          Vc = null,
          P0 = mh = Yl = 0,
          br = Hc = null,
          us !== null
      ) {
        for (c = 0; c < us.length; c++) {
          if (m = us[c], x = m.interleaved, x !== null) {
            m.interleaved = null;
            var E = x.next, A = m.pending;
            if (A !== null) {
              var F = A.next;
              A.next = E, x.next = F;
            }
            m.pending = x;
          }
        }
        us = null;
      }
      return l;
    }
    function Aw(l, c) {
      do {
        var m = Sn;
        try {
          if (Yg(), Yd.current = eh, Zd) {
            for (var x = fn.memoizedState; x !== null;) {
              var E = x.queue;
              E !== null && (E.pending = null), x = x.next;
            }
            Zd = !1;
          }
          if (
            Xl = 0,
              kn = Yn = fn = null,
              Ic = !1,
              Nc = 0,
              L0.current = null,
              m === null || m.return === null
          ) {
            Tn = 1, Vc = c, Sn = null;
            break;
          }
          e: {
            var A = l, F = m.return, U = m, te = c;
            if (
              c = Hn,
                U.flags |= 32768,
                te !== null && typeof te == "object" &&
                typeof te.then == "function"
            ) {
              var ge = te, De = U, nt = De.tag;
              if ((De.mode & 1) == 0 && (nt === 0 || nt === 11 || nt === 15)) {
                var He = De.alternate;
                He
                  ? (De.updateQueue = He.updateQueue,
                    De.memoizedState = He.memoizedState,
                    De.lanes = He.lanes)
                  : (De.updateQueue = null, De.memoizedState = null);
              }
              var Bt = q1(F);
              if (Bt !== null) {
                Bt.flags &= -257,
                  Y1(Bt, F, U, A, c),
                  Bt.mode & 1 && X1(A, ge, c),
                  c = Bt,
                  te = ge;
                var Ue = c.updateQueue;
                if (Ue === null) {
                  var Jn = new Set();
                  Jn.add(te), c.updateQueue = Jn;
                } else Ue.add(te);
                break e;
              } else {
                if ((c & 1) == 0) {
                  X1(A, ge, c), B0();
                  break e;
                }
                te = Error(o(426));
              }
            } else if (Zt && U.mode & 1) {
              var mi = q1(F);
              if (mi !== null) {
                (mi.flags & 65536) == 0 && (mi.flags |= 256),
                  Y1(mi, F, U, A, c),
                  i0(te);
                break e;
              }
            }
            A = te,
              Tn !== 4 && (Tn = 2),
              Hc === null ? Hc = [A] : Hc.push(A),
              te = m0(te, U),
              U = F;
            do {
              switch (U.tag) {
                case 3:
                  U.flags |= 65536, c &= -c, U.lanes |= c;
                  var j = j1(U, te, c);
                  d1(U, j);
                  break e;
                case 1:
                  A = te;
                  var H = U.type, K = U.stateNode;
                  if (
                    (U.flags & 128) == 0 &&
                    (typeof H.getDerivedStateFromError == "function" ||
                      K !== null && typeof K.componentDidCatch == "function" &&
                        (mo === null || !mo.has(K)))
                  ) {
                    U.flags |= 65536, c &= -c, U.lanes |= c;
                    var be = W1(U, A, c);
                    d1(U, be);
                    break e;
                  }
              }
              U = U.return;
            } while (U !== null);
          }
          Rw(m);
        } catch (ze) {
          c = ze, Sn === m && m !== null && (Sn = m = m.return);
          continue;
        }
        break;
      } while (1);
    }
    function Cw() {
      var l = ph.current;
      return ph.current = eh, l === null ? eh : l;
    }
    function B0() {
      (Tn === 0 || Tn === 3 || Tn === 2) && (Tn = 4),
        _n === null || (Yl & 268435455) == 0 && (mh & 268435455) == 0 ||
        yo(_n, Hn);
    }
    function wh(l, c) {
      var m = lt;
      lt |= 2;
      var x = Cw();
      _n === l && Hn === c || Pa(l, c);
      do try {
        YL();
        break;
      } catch (E) {
        Aw(l, E);
      } while (1);
      if (Yg(), lt = m, ph.current = x, Sn !== null) throw Error(o(261));
      return _n = null, Hn = 0, Tn;
    }
    function YL() {
      for (; Sn !== null;) bw(Sn);
    }
    function ZL() {
      for (; Sn !== null && !SL();) bw(Sn);
    }
    function bw(l) {
      var c = Iw(l.alternate, l, Gr);
      l.memoizedProps = l.pendingProps,
        c === null ? Rw(l) : Sn = c,
        L0.current = null;
    }
    function Rw(l) {
      var c = l;
      do {
        var m = c.alternate;
        if (l = c.return, (c.flags & 32768) == 0) {
          if (m = zL(m, c, Gr), m !== null) {
            Sn = m;
            return;
          }
        } else {
          if (m = VL(m, c), m !== null) {
            m.flags &= 32767, Sn = m;
            return;
          }
          if (l !== null) {
            l.flags |= 32768, l.subtreeFlags = 0, l.deletions = null;
          } else {
            Tn = 6, Sn = null;
            return;
          }
        }
        if (c = c.sibling, c !== null) {
          Sn = c;
          return;
        }
        Sn = c = l;
      } while (c !== null);
      Tn === 0 && (Tn = 5);
    }
    function Ia(l, c) {
      var m = _t, x = gn.transition;
      try {
        gn.transition = null, _t = 1, KL(l, c, m);
      } finally {
        gn.transition = x, _t = m;
      }
      return null;
    }
    function KL(l, c, m) {
      do Na(); while (go !== null);
      if ((lt & 6) != 0) throw Error(o(327));
      var x = l.finishedWork, E = l.finishedLanes;
      if (x === null) return null;
      if (l.finishedWork = null, l.finishedLanes = 0, x === l.current) {
        throw Error(o(177));
      }
      l.callbackNode = null, l.callbackPriority = 0;
      var A = x.lanes | x.childLanes;
      if (
        _L(l, A),
          l === _n && (Sn = _n = null, Hn = 0),
          (x.subtreeFlags & 2064) == 0 && (x.flags & 2064) == 0 || vh ||
          (vh = !0,
            Nw(Wg, function () {
              return Na(), null;
            })),
          A = (x.flags & 15990) != 0,
          (x.subtreeFlags & 15990) != 0 || A
      ) {
        A = gn.transition, gn.transition = null;
        var F = _t;
        _t = 1;
        var U = lt;
        lt |= 4,
          L0.current = null,
          GL(l, x),
          jL(l, x, E),
          $(l.containerInfo),
          l.current = x,
          WL(x, l, E),
          wL(),
          lt = U,
          _t = F,
          gn.transition = A;
      } else l.current = x;
      if (
        vh && (vh = !1, go = l, yh = E),
          A = l.pendingLanes,
          A === 0 && (mo = null),
          TL(x.stateNode, m),
          Rr(l, Dn()),
          c !== null
      ) { for (m = l.onRecoverableError, x = 0; x < c.length; x++) m(c[x]); }
      if (gh) throw gh = !1, l = D0, D0 = null, l;
      return (yh & 1) != 0 && l.tag !== 0 && Na(),
        A = l.pendingLanes,
        (A & 1) != 0 ? l === k0 ? Gc++ : (Gc = 0, k0 = l) : Gc = 0,
        ls(),
        null;
    }
    function Na() {
      if (go !== null) {
        var l = a1(yh), c = gn.transition, m = _t;
        try {
          if (gn.transition = null, _t = 16 > l ? 16 : l, go === null) {
            var x = !1;
          } else {
            if (l = go, go = null, yh = 0, (lt & 6) != 0) throw Error(o(331));
            var E = lt;
            for (lt |= 4, Te = l.current; Te !== null;) {
              var A = Te, F = A.child;
              if ((Te.flags & 16) != 0) {
                var U = A.deletions;
                if (U !== null) {
                  for (var te = 0; te < U.length; te++) {
                    var ge = U[te];
                    for (Te = ge; Te !== null;) {
                      var De = Te;
                      switch (De.tag) {
                        case 0:
                        case 11:
                        case 15:
                          La(8, De, A);
                      }
                      var nt = De.child;
                      if (nt !== null) nt.return = De, Te = nt;
                      else {for (; Te !== null;) {
                          De = Te;
                          var He = De.sibling, Bt = De.return;
                          if (hw(De), De === ge) {
                            Te = null;
                            break;
                          }
                          if (He !== null) {
                            He.return = Bt, Te = He;
                            break;
                          }
                          Te = Bt;
                        }}
                    }
                  }
                  var Ue = A.alternate;
                  if (Ue !== null) {
                    var Jn = Ue.child;
                    if (Jn !== null) {
                      Ue.child = null;
                      do {
                        var mi = Jn.sibling;
                        Jn.sibling = null, Jn = mi;
                      } while (Jn !== null);
                    }
                  }
                  Te = A;
                }
              }
              if ((A.subtreeFlags & 2064) != 0 && F !== null) {
                F.return = A, Te = F;
              } else {e: for (; Te !== null;) {
                  if (A = Te, (A.flags & 2048) != 0) {
                    switch (A.tag) {
                      case 0:
                      case 11:
                      case 15:
                        La(9, A, A.return);
                    }
                  }
                  var j = A.sibling;
                  if (j !== null) {
                    j.return = A.return, Te = j;
                    break e;
                  }
                  Te = A.return;
                }}
            }
            var H = l.current;
            for (Te = H; Te !== null;) {
              F = Te;
              var K = F.child;
              if ((F.subtreeFlags & 2064) != 0 && K !== null) {
                K.return = F, Te = K;
              } else {e: for (F = H; Te !== null;) {
                  if (U = Te, (U.flags & 2048) != 0) {
                    try {
                      switch (U.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Bc(9, U);
                      }
                    } catch (ze) {
                      Lr(U, U.return, ze);
                    }
                  }
                  if (U === F) {
                    Te = null;
                    break e;
                  }
                  var be = U.sibling;
                  if (be !== null) {
                    be.return = U.return, Te = be;
                    break e;
                  }
                  Te = U.return;
                }}
            }
            if (
              lt = E, ls(), os && typeof os.onPostCommitFiberRoot == "function"
            ) {
              try {
                os.onPostCommitFiberRoot(Fd, l);
              } catch {}
            }
            x = !0;
          }
          return x;
        } finally {
          _t = m, gn.transition = c;
        }
      }
      return !1;
    }
    function Lw(l, c, m) {
      c = m0(m, c),
        c = j1(l, c, 1),
        po(l, c),
        c = ur(),
        l = Sh(l, 1),
        l !== null && (Ac(l, 1, c), Rr(l, c));
    }
    function Lr(l, c, m) {
      if (l.tag === 3) Lw(l, l, m);
      else {for (; c !== null;) {
          if (c.tag === 3) {
            Lw(c, l, m);
            break;
          } else if (c.tag === 1) {
            var x = c.stateNode;
            if (
              typeof c.type.getDerivedStateFromError == "function" ||
              typeof x.componentDidCatch == "function" &&
                (mo === null || !mo.has(x))
            ) {
              l = m0(m, l),
                l = W1(c, l, 1),
                po(c, l),
                l = ur(),
                c = Sh(c, 1),
                c !== null && (Ac(c, 1, l), Rr(c, l));
              break;
            }
          }
          c = c.return;
        }}
    }
    function JL(l, c, m) {
      var x = l.pingCache;
      x !== null && x.delete(c),
        c = ur(),
        l.pingedLanes |= l.suspendedLanes & m,
        _n === l && (Hn & m) === m &&
        (Tn === 4 || Tn === 3 && (Hn & 130023424) === Hn && 500 > Dn() - I0
          ? Pa(l, 0)
          : P0 |= m),
        Rr(l, c);
    }
    function Pw(l, c) {
      c === 0 &&
        ((l.mode & 1) == 0
          ? c = 1
          : (c = Dd, Dd <<= 1, (Dd & 130023424) == 0 && (Dd = 4194304)));
      var m = ur();
      l = Sh(l, c), l !== null && (Ac(l, c, m), Rr(l, m));
    }
    function QL(l) {
      var c = l.memoizedState, m = 0;
      c !== null && (m = c.retryLane), Pw(l, m);
    }
    function $L(l, c) {
      var m = 0;
      switch (l.tag) {
        case 13:
          var x = l.stateNode, E = l.memoizedState;
          E !== null && (m = E.retryLane);
          break;
        case 19:
          x = l.stateNode;
          break;
        default:
          throw Error(o(314));
      }
      x !== null && x.delete(c), Pw(l, m);
    }
    var Iw;
    Iw = function (l, c, m) {
      if (l !== null) {
        if (l.memoizedProps !== c.pendingProps || Ar.current) Hr = !0;
        else {
          if ((l.lanes & m) == 0 && (c.flags & 128) == 0) {
            return Hr = !1, UL(l, c, m);
          }
          Hr = (l.flags & 131072) != 0;
        }
      } else Hr = !1, Zt && (c.flags & 1048576) != 0 && y1(c, Wd, c.index);
      switch (c.lanes = 0, c.tag) {
        case 2:
          var x = c.type;
          l !== null && (l.alternate = null, c.alternate = null, c.flags |= 2),
            l = c.pendingProps;
          var E = Ol(c, qn.current);
          Bl(c, m), E = c0(null, c, x, l, E, m);
          var A = f0();
          return c.flags |= 1,
            typeof E == "object" && E !== null &&
              typeof E.render == "function" && E.$$typeof === void 0
              ? (c.tag = 1,
                c.memoizedState = null,
                c.updateQueue = null,
                Cr(x) ? (A = !0, Id(c)) : A = !1,
                c.memoizedState = E.state !== null && E.state !== void 0
                  ? E.state
                  : null,
                Jg(c),
                E.updater = Gd,
                c.stateNode = E,
                E._reactInternals = c,
                $g(c, x, l, m),
                c = y0(null, c, x, !0, A, m))
              : (c.tag = 0, Zt && A && e0(c), lr(null, c, E, m), c = c.child),
            c;
        case 16:
          x = c.elementType;
          e: {
            switch (
              l !== null &&
              (l.alternate = null, c.alternate = null, c.flags |= 2),
                l = c.pendingProps,
                E = x._init,
                x = E(x._payload),
                c.type = x,
                E = c.tag = tP(x),
                l = Ni(x, l),
                E
            ) {
              case 0:
                c = v0(null, c, x, l, m);
                break e;
              case 1:
                c = nw(null, c, x, l, m);
                break e;
              case 11:
                c = J1(null, c, x, l, m);
                break e;
              case 14:
                c = Q1(null, c, x, Ni(x.type, l), m);
                break e;
            }
            throw Error(o(306, x, ""));
          }
          return c;
        case 0:
          return x = c.type,
            E = c.pendingProps,
            E = c.elementType === x ? E : Ni(x, E),
            v0(l, c, x, E, m);
        case 1:
          return x = c.type,
            E = c.pendingProps,
            E = c.elementType === x ? E : Ni(x, E),
            nw(l, c, x, E, m);
        case 3:
          e: {
            if (rw(c), l === null) throw Error(o(387));
            x = c.pendingProps,
              A = c.memoizedState,
              E = A.element,
              f1(l, c),
              Hd(c, x, null, m);
            var F = c.memoizedState;
            if (x = F.element, ne && A.isDehydrated) {
              if (
                A = {
                  element: x,
                  isDehydrated: !1,
                  cache: F.cache,
                  transitions: F.transitions,
                },
                  c.updateQueue.baseState = A,
                  c.memoizedState = A,
                  c.flags & 256
              ) {
                E = Error(o(423)), c = iw(l, c, x, m, E);
                break e;
              } else if (x !== E) {
                E = Error(o(424)), c = iw(l, c, x, m, E);
                break e;
              } else {for (
                  ne &&
                  (Vr = de(c.stateNode.containerInfo),
                    Ur = c,
                    Zt = !0,
                    Di = null,
                    Cc = !1),
                    m = E1(c, null, x, m),
                    c.child = m;
                  m;
                ) m.flags = m.flags & -3 | 4096, m = m.sibling;}
            } else {
              if (Hl(), x === E) {
                c = Is(l, c, m);
                break e;
              }
              lr(l, c, x, m);
            }
            c = c.child;
          }
          return c;
        case 5:
          return T1(c),
            l === null && r0(c),
            x = c.type,
            E = c.pendingProps,
            A = l !== null ? l.memoizedProps : null,
            F = E.children,
            Oe(x, E) ? F = null : A !== null && Oe(x, A) && (c.flags |= 32),
            tw(l, c),
            lr(l, c, F, m),
            c.child;
        case 6:
          return l === null && r0(c), null;
        case 13:
          return sw(l, c, m);
        case 4:
          return s0(c, c.stateNode.containerInfo),
            x = c.pendingProps,
            l === null ? c.child = Gl(c, null, x, m) : lr(l, c, x, m),
            c.child;
        case 11:
          return x = c.type,
            E = c.pendingProps,
            E = c.elementType === x ? E : Ni(x, E),
            J1(l, c, x, E, m);
        case 7:
          return lr(l, c, c.pendingProps, m), c.child;
        case 8:
          return lr(l, c, c.pendingProps.children, m), c.child;
        case 12:
          return lr(l, c, c.pendingProps.children, m), c.child;
        case 10:
          e: {
            if (
              x = c.type._context,
                E = c.pendingProps,
                A = c.memoizedProps,
                F = E.value,
                c1(c, x, F),
                A !== null
            ) {
              if (as(A.value, F)) {
                if (A.children === E.children && !Ar.current) {
                  c = Is(l, c, m);
                  break e;
                }
              } else {for (
                  A = c.child, A !== null && (A.return = c); A !== null;
                ) {
                  var U = A.dependencies;
                  if (U !== null) {
                    F = A.child;
                    for (var te = U.firstContext; te !== null;) {
                      if (te.context === x) {
                        if (A.tag === 1) {
                          te = bs(-1, m & -m), te.tag = 2;
                          var ge = A.updateQueue;
                          if (ge !== null) {
                            ge = ge.shared;
                            var De = ge.pending;
                            De === null
                              ? te.next = te
                              : (te.next = De.next, De.next = te),
                              ge.pending = te;
                          }
                        }
                        A.lanes |= m,
                          te = A.alternate,
                          te !== null && (te.lanes |= m),
                          Kg(A.return, m, c),
                          U.lanes |= m;
                        break;
                      }
                      te = te.next;
                    }
                  } else if (A.tag === 10) {
                    F = A.type === c.type
                      ? null
                      : A.child;
                  } else if (A.tag === 18) {
                    if (F = A.return, F === null) throw Error(o(341));
                    F.lanes |= m,
                      U = F.alternate,
                      U !== null && (U.lanes |= m),
                      Kg(F, m, c),
                      F = A.sibling;
                  } else F = A.child;
                  if (F !== null) F.return = A;
                  else {for (F = A; F !== null;) {
                      if (F === c) {
                        F = null;
                        break;
                      }
                      if (A = F.sibling, A !== null) {
                        A.return = F.return, F = A;
                        break;
                      }
                      F = F.return;
                    }}
                  A = F;
                }}
            }
            lr(l, c, E.children, m), c = c.child;
          }
          return c;
        case 9:
          return E = c.type,
            x = c.pendingProps.children,
            Bl(c, m),
            E = li(E),
            x = x(E),
            c.flags |= 1,
            lr(l, c, x, m),
            c.child;
        case 14:
          return x = c.type,
            E = Ni(x, c.pendingProps),
            E = Ni(x.type, E),
            Q1(l, c, x, E, m);
        case 15:
          return $1(l, c, c.type, c.pendingProps, m);
        case 17:
          return x = c.type,
            E = c.pendingProps,
            E = c.elementType === x ? E : Ni(x, E),
            l !== null &&
            (l.alternate = null, c.alternate = null, c.flags |= 2),
            c.tag = 1,
            Cr(x) ? (l = !0, Id(c)) : l = !1,
            Bl(c, m),
            g1(c, x, E),
            $g(c, x, E, m),
            y0(null, c, x, !0, l, m);
        case 19:
          return uw(l, c, m);
        case 22:
          return ew(l, c, m);
      }
      throw Error(o(156, c.tag));
    };
    function Nw(l, c) {
      return Gg(l, c);
    }
    function eP(l, c, m, x) {
      this.tag = l,
        this.key = m,
        this.sibling =
          this.child =
          this.return =
          this.stateNode =
          this.type =
          this.elementType =
            null,
        this.index = 0,
        this.ref = null,
        this.pendingProps = c,
        this.dependencies =
          this.memoizedState =
          this.updateQueue =
          this.memoizedProps =
            null,
        this.mode = x,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null;
    }
    function pi(l, c, m, x) {
      return new eP(l, c, m, x);
    }
    function U0(l) {
      return l = l.prototype, !(!l || !l.isReactComponent);
    }
    function tP(l) {
      if (typeof l == "function") return U0(l) ? 1 : 0;
      if (l != null) {
        if (l = l.$$typeof, l === v) return 11;
        if (l === w) return 14;
      }
      return 2;
    }
    function xo(l, c) {
      var m = l.alternate;
      return m === null
        ? (m = pi(l.tag, c, l.key, l.mode),
          m.elementType = l.elementType,
          m.type = l.type,
          m.stateNode = l.stateNode,
          m.alternate = l,
          l.alternate = m)
        : (m.pendingProps = c,
          m.type = l.type,
          m.flags = 0,
          m.subtreeFlags = 0,
          m.deletions = null),
        m.flags = l.flags & 14680064,
        m.childLanes = l.childLanes,
        m.lanes = l.lanes,
        m.child = l.child,
        m.memoizedProps = l.memoizedProps,
        m.memoizedState = l.memoizedState,
        m.updateQueue = l.updateQueue,
        c = l.dependencies,
        m.dependencies = c === null
          ? null
          : { lanes: c.lanes, firstContext: c.firstContext },
        m.sibling = l.sibling,
        m.index = l.index,
        m.ref = l.ref,
        m;
    }
    function Mh(l, c, m, x, E, A) {
      var F = 2;
      if (x = l, typeof l == "function") U0(l) && (F = 1);
      else if (typeof l == "string") F = 5;
      else {e: switch (l) {
          case d:
            return Da(m.children, E, A, c);
          case h:
            F = 8, E |= 8;
            break;
          case p:
            return l = pi(12, m, c, E | 2), l.elementType = p, l.lanes = A, l;
          case _:
            return l = pi(13, m, c, E), l.elementType = _, l.lanes = A, l;
          case S:
            return l = pi(19, m, c, E), l.elementType = S, l.lanes = A, l;
          case T:
            return Eh(m, E, A, c);
          default:
            if (typeof l == "object" && l !== null) {
              switch (l.$$typeof) {
                case g:
                  F = 10;
                  break e;
                case y:
                  F = 9;
                  break e;
                case v:
                  F = 11;
                  break e;
                case w:
                  F = 14;
                  break e;
                case M:
                  F = 16, x = null;
                  break e;
              }
            }
            throw Error(o(130, l == null ? l : typeof l, ""));
        }}
      return c = pi(F, m, c, E), c.elementType = l, c.type = x, c.lanes = A, c;
    }
    function Da(l, c, m, x) {
      return l = pi(7, l, x, c), l.lanes = m, l;
    }
    function Eh(l, c, m, x) {
      return l = pi(22, l, x, c),
        l.elementType = T,
        l.lanes = m,
        l.stateNode = {},
        l;
    }
    function V0(l, c, m) {
      return l = pi(6, l, null, c), l.lanes = m, l;
    }
    function H0(l, c, m) {
      return c = pi(4, l.children !== null ? l.children : [], l.key, c),
        c.lanes = m,
        c.stateNode = {
          containerInfo: l.containerInfo,
          pendingChildren: null,
          implementation: l.implementation,
        },
        c;
    }
    function nP(l, c, m, x, E) {
      this.tag = c,
        this.containerInfo = l,
        this.finishedWork =
          this.pingCache =
          this.current =
          this.pendingChildren =
            null,
        this.timeoutHandle = Ze,
        this.callbackNode = this.pendingContext = this.context = null,
        this.callbackPriority = 0,
        this.eventTimes = Vg(0),
        this.expirationTimes = Vg(-1),
        this.entangledLanes =
          this.finishedLanes =
          this.mutableReadLanes =
          this.expiredLanes =
          this.pingedLanes =
          this.suspendedLanes =
          this.pendingLanes =
            0,
        this.entanglements = Vg(0),
        this.identifierPrefix = x,
        this.onRecoverableError = E,
        ne && (this.mutableSourceEagerHydrationData = null);
    }
    function Dw(l, c, m, x, E, A, F, U, te) {
      return l = new nP(l, c, m, U, te),
        c === 1 ? (c = 1, A === !0 && (c |= 8)) : c = 0,
        A = pi(3, null, null, c),
        l.current = A,
        A.stateNode = l,
        A.memoizedState = {
          element: x,
          isDehydrated: m,
          cache: null,
          transitions: null,
        },
        Jg(A),
        l;
    }
    function kw(l) {
      if (!l) return En;
      l = l._reactInternals;
      e: {
        if (L(l) !== l || l.tag !== 1) throw Error(o(170));
        var c = l;
        do {
          switch (c.tag) {
            case 3:
              c = c.stateNode.context;
              break e;
            case 1:
              if (Cr(c.type)) {
                c = c.stateNode.__reactInternalMemoizedMergedChildContext;
                break e;
              }
          }
          c = c.return;
        } while (c !== null);
        throw Error(o(171));
      }
      if (l.tag === 1) {
        var m = l.type;
        if (Cr(m)) return s1(l, m, c);
      }
      return c;
    }
    function Fw(l) {
      var c = l._reactInternals;
      if (c === void 0) {
        throw typeof l.render == "function"
          ? Error(o(188))
          : (l = Object.keys(l).join(","), Error(o(268, l)));
      }
      return l = Y(c), l === null ? null : l.stateNode;
    }
    function Ow(l, c) {
      if (l = l.memoizedState, l !== null && l.dehydrated !== null) {
        var m = l.retryLane;
        l.retryLane = m !== 0 && m < c ? m : c;
      }
    }
    function G0(l, c) {
      Ow(l, c), (l = l.alternate) && Ow(l, c);
    }
    function rP(l) {
      return l = Y(l), l === null ? null : l.stateNode;
    }
    function iP() {
      return null;
    }
    return t.attemptContinuousHydration = function (l) {
      if (l.tag === 13) {
        var c = ur();
        hi(l, 134217728, c), G0(l, 134217728);
      }
    },
      t.attemptHydrationAtCurrentPriority = function (l) {
        if (l.tag === 13) {
          var c = ur(), m = vo(l);
          hi(l, m, c), G0(l, m);
        }
      },
      t.attemptSynchronousHydration = function (l) {
        switch (l.tag) {
          case 3:
            var c = l.stateNode;
            if (c.current.memoizedState.isDehydrated) {
              var m = Tc(c.pendingLanes);
              m !== 0 &&
                (Hg(c, m | 1), Rr(c, Dn()), (lt & 6) == 0 && (Zl(), ls()));
            }
            break;
          case 13:
            var x = ur();
            Tw(function () {
              return hi(l, 1, x);
            }), G0(l, 1);
        }
      },
      t.batchedUpdates = function (l, c) {
        var m = lt;
        lt |= 1;
        try {
          return l(c);
        } finally {
          lt = m, lt === 0 && (Zl(), Od && ls());
        }
      },
      t.createComponentSelector = function (l) {
        return { $$typeof: uh, value: l };
      },
      t.createContainer = function (l, c, m, x, E, A, F) {
        return Dw(l, c, !1, null, m, x, E, A, F);
      },
      t.createHasPseudoClassSelector = function (l) {
        return { $$typeof: ch, value: l };
      },
      t.createHydrationContainer = function (l, c, m, x, E, A, F, U, te) {
        return l = Dw(m, x, !0, l, E, A, F, U, te),
          l.context = kw(null),
          m = l.current,
          x = ur(),
          E = vo(m),
          A = bs(x, E),
          A.callback = c ?? null,
          po(m, A),
          l.current.lanes = E,
          Ac(l, E, x),
          Rr(l, x),
          l;
      },
      t.createPortal = function (l, c, m) {
        var x = 3 < arguments.length && arguments[3] !== void 0
          ? arguments[3]
          : null;
        return {
          $$typeof: f,
          key: x == null ? null : "" + x,
          children: l,
          containerInfo: c,
          implementation: m,
        };
      },
      t.createRoleSelector = function (l) {
        return { $$typeof: fh, value: l };
      },
      t.createTestNameSelector = function (l) {
        return { $$typeof: dh, value: l };
      },
      t.createTextSelector = function (l) {
        return { $$typeof: hh, value: l };
      },
      t.deferredUpdates = function (l) {
        var c = _t, m = gn.transition;
        try {
          return gn.transition = null, _t = 16, l();
        } finally {
          _t = c, gn.transition = m;
        }
      },
      t.discreteUpdates = function (l, c, m, x, E) {
        var A = _t, F = gn.transition;
        try {
          return gn.transition = null, _t = 1, l(c, m, x, E);
        } finally {
          _t = A, gn.transition = F, lt === 0 && Zl();
        }
      },
      t.findAllNodes = R0,
      t.findBoundingRects = function (l, c) {
        if (!Tt) throw Error(o(363));
        c = R0(l, c), l = [];
        for (var m = 0; m < c.length; m++) l.push(O(c[m]));
        for (c = l.length - 1; 0 < c; c--) {
          m = l[c];
          for (
            var x = m.x, E = x + m.width, A = m.y, F = A + m.height, U = c - 1;
            0 <= U;
            U--
          ) {
            if (c !== U) {
              var te = l[U],
                ge = te.x,
                De = ge + te.width,
                nt = te.y,
                He = nt + te.height;
              if (x >= ge && A >= nt && E <= De && F <= He) {
                l.splice(c, 1);
                break;
              } else if (
                x !== ge || m.width !== te.width || He < A || nt > F
              ) {
                if (!(A !== nt || m.height !== te.height || De < x || ge > E)) {
                  ge > x && (te.width += ge - x, te.x = x),
                    De < E && (te.width = E - ge),
                    l.splice(c, 1);
                  break;
                }
              } else {
                nt > A && (te.height += nt - A, te.y = A),
                  He < F && (te.height = F - nt),
                  l.splice(c, 1);
                break;
              }
            }
          }
        }
        return l;
      },
      t.findHostInstance = Fw,
      t.findHostInstanceWithNoPortals = function (l) {
        return l = z(l),
          l = l !== null ? V(l) : null,
          l === null ? null : l.stateNode;
      },
      t.findHostInstanceWithWarning = function (l) {
        return Fw(l);
      },
      t.flushControlled = function (l) {
        var c = lt;
        lt |= 1;
        var m = gn.transition, x = _t;
        try {
          gn.transition = null, _t = 1, l();
        } finally {
          _t = x, gn.transition = m, lt = c, lt === 0 && (Zl(), ls());
        }
      },
      t.flushPassiveEffects = Na,
      t.flushSync = Tw,
      t.focusWithin = function (l, c) {
        if (!Tt) throw Error(o(363));
        for (l = A0(l), c = ww(l, c), c = Array.from(c), l = 0; l < c.length;) {
          var m = c[l++];
          if (!J(m)) {
            if (m.tag === 5 && xe(m.stateNode)) return !0;
            for (m = m.child; m !== null;) c.push(m), m = m.sibling;
          }
        }
        return !1;
      },
      t.getCurrentUpdatePriority = function () {
        return _t;
      },
      t.getFindAllNodesFailureDescription = function (l, c) {
        if (!Tt) throw Error(o(363));
        var m = 0, x = [];
        l = [A0(l), 0];
        for (var E = 0; E < l.length;) {
          var A = l[E++], F = l[E++], U = c[F];
          if (
            (A.tag !== 5 || !J(A)) &&
            (C0(A, U) && (x.push(b0(U)), F++, F > m && (m = F)), F < c.length)
          ) { for (A = A.child; A !== null;) l.push(A, F), A = A.sibling; }
        }
        if (m < c.length) {
          for (l = []; m < c.length; m++) l.push(b0(c[m]));
          return `findAllNodes was able to match part of the selector:
  ` + (x.join(" > ") + `

No matching component was found for:
  `) + l.join(" > ");
        }
        return null;
      },
      t.getPublicRootInstance = function (l) {
        if (l = l.current, !l.child) return null;
        switch (l.child.tag) {
          case 5:
            return G(l.child.stateNode);
          default:
            return l.child.stateNode;
        }
      },
      t.injectIntoDevTools = function (l) {
        if (
          l = {
            bundleType: l.bundleType,
            version: l.version,
            rendererPackageName: l.rendererPackageName,
            rendererConfig: l.rendererConfig,
            overrideHookState: null,
            overrideHookStateDeletePath: null,
            overrideHookStateRenamePath: null,
            overrideProps: null,
            overridePropsDeletePath: null,
            overridePropsRenamePath: null,
            setErrorHandler: null,
            setSuspenseHandler: null,
            scheduleUpdate: null,
            currentDispatcherRef: a.ReactCurrentDispatcher,
            findHostInstanceByFiber: rP,
            findFiberByHostInstance: l.findFiberByHostInstance || iP,
            findHostInstancesForRefresh: null,
            scheduleRefresh: null,
            scheduleRoot: null,
            setRefreshHandler: null,
            getCurrentFiber: null,
            reconcilerVersion: "18.0.0-fc46dba67-20220329",
          },
            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ == "undefined"
        ) l = !1;
        else {
          var c = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (c.isDisabled || !c.supportsFiber) l = !0;
          else {
            try {
              Fd = c.inject(l), os = c;
            } catch {}
            l = !!c.checkDCE;
          }
        }
        return l;
      },
      t.isAlreadyRendering = function () {
        return !1;
      },
      t.observeVisibleRects = function (l, c, m, x) {
        if (!Tt) throw Error(o(363));
        l = R0(l, c);
        var E = Ce(l, m, x).disconnect;
        return {
          disconnect: function () {
            E();
          },
        };
      },
      t.registerMutableSourceForHydration = function (l, c) {
        var m = c._getVersion;
        m = m(c._source),
          l.mutableSourceEagerHydrationData == null
            ? l.mutableSourceEagerHydrationData = [c, m]
            : l.mutableSourceEagerHydrationData.push(c, m);
      },
      t.runWithPriority = function (l, c) {
        var m = _t;
        try {
          return _t = l, c();
        } finally {
          _t = m;
        }
      },
      t.shouldError = function () {
        return null;
      },
      t.shouldSuspend = function () {
        return !1;
      },
      t.updateContainer = function (l, c, m, x) {
        var E = c.current, A = ur(), F = vo(E);
        return m = kw(m),
          c.context === null ? c.context = m : c.pendingContext = m,
          c = bs(A, F),
          c.payload = { element: l },
          x = x === void 0 ? null : x,
          x !== null && (c.callback = x),
          po(E, c),
          l = hi(E, F, A),
          l !== null && Vd(l, E, F),
          F;
      },
      t;
  };
});
var ES = cr((OU, I3) => {
  "use strict";
  I3.exports = P3();
});
var eR = cr((GU, $3) => {
  function GS(n, e, t) {
    var r, i, s, o, a;
    e == null && (e = 100);
    function u() {
      var d = Date.now() - o;
      d < e && d >= 0
        ? r = setTimeout(u, e - d)
        : (r = null, t || (a = n.apply(s, i), s = i = null));
    }
    var f = function () {
      s = this, i = arguments, o = Date.now();
      var d = t && !r;
      return r || (r = setTimeout(u, e)),
        d && (a = n.apply(s, i), s = i = null),
        a;
    };
    return f.clear = function () {
      r && (clearTimeout(r), r = null);
    },
      f.flush = function () {
        r && (a = n.apply(s, i), s = i = null, clearTimeout(r), r = null);
      },
      f;
  }
  GS.debounce = GS;
  $3.exports = GS;
});
var _U = cr((_V, r1) => {
  function hL(n) {
    var e, t, r = "";
    if (typeof n == "string" || typeof n == "number") r += n;
    else if (typeof n == "object") {
      if (Array.isArray(n)) {
        for (e = 0; e < n.length; e++) {
          n[e] && (t = hL(n[e])) && (r && (r += " "), r += t);
        }
      } else for (e in n) n[e] && (r && (r += " "), r += e);
    }
    return r;
  }
  function pL() {
    for (var n, e, t = 0, r = ""; t < arguments.length;) {
      (n = arguments[t++]) && (e = hL(n)) && (r && (r += " "), r += e);
    }
    return r;
  }
  r1.exports = pL, r1.exports.clsx = pL;
});
var Li = rn(An());
var Rl = {};
oP(Rl, {
  ACESFilmicToneMapping: () => vx,
  AddEquation: () => Qa,
  AddOperation: () => GA,
  AdditiveAnimationBlendMode: () => Ux,
  AdditiveBlending: () => cx,
  AlphaFormat: () => $A,
  AlwaysDepth: () => FA,
  AlwaysStencilFunc: () => mC,
  AmbientLight: () => eS,
  AmbientLightProbe: () => p2,
  AnimationClip: () => va,
  AnimationLoader: () => Qb,
  AnimationMixer: () => C2,
  AnimationObjectGroup: () => T2,
  AnimationUtils: () => Wt,
  ArcCurve: () => P_,
  ArrayCamera: () => __,
  ArrowHelper: () => t3,
  Audio: () => oS,
  AudioAnalyser: () => M2,
  AudioContext: () => sS,
  AudioListener: () => _2,
  AudioLoader: () => d2,
  AxesHelper: () => n3,
  BackSide: () => mr,
  BasicDepthPacking: () => dC,
  BasicShadowMap: () => SA,
  Bone: () => $u,
  BooleanKeyframeTrack: () => ha,
  Box2: () => D2,
  Box3: () => Yi,
  Box3Helper: () => Q2,
  BoxBufferGeometry: () => ei,
  BoxGeometry: () => ei,
  BoxHelper: () => J2,
  BufferAttribute: () => pt,
  BufferGeometry: () => Ye,
  BufferGeometryLoader: () => iS,
  ByteType: () => YA,
  Cache: () => Ml,
  Camera: () => oa,
  CameraHelper: () => K2,
  CanvasTexture: () => Vb,
  CapsuleBufferGeometry: () => nc,
  CapsuleGeometry: () => nc,
  CatmullRomCurve3: () => F_,
  CineonToneMapping: () => XA,
  CircleBufferGeometry: () => rc,
  CircleGeometry: () => rc,
  ClampToEdgeWrapping: () => Rn,
  Clock: () => cg,
  Color: () => ve,
  ColorKeyframeTrack: () => ig,
  ColorManagement: () => Ei,
  CompressedTexture: () => L_,
  CompressedTextureLoader: () => $b,
  ConeBufferGeometry: () => ic,
  ConeGeometry: () => ic,
  CubeCamera: () => f_,
  CubeReflectionMapping: () => Ho,
  CubeRefractionMapping: () => Go,
  CubeTexture: () => Gu,
  CubeTextureLoader: () => e2,
  CubeUVReflectionMapping: () => Au,
  CubicBezierCurve: () => qm,
  CubicBezierCurve3: () => O_,
  CubicInterpolant: () => Z_,
  CullFaceBack: () => ux,
  CullFaceFront: () => _A,
  CullFaceFrontBack: () => TN,
  CullFaceNone: () => xA,
  Curve: () => Ci,
  CurvePath: () => U_,
  CustomBlending: () => MA,
  CustomToneMapping: () => qA,
  CylinderBufferGeometry: () => ua,
  CylinderGeometry: () => ua,
  Cylindrical: () => I2,
  Data3DTexture: () => qf,
  DataArrayTexture: () => Ru,
  DataTexture: () => ml,
  DataTexture2DArray: () => u3,
  DataTexture3D: () => c3,
  DataTextureLoader: () => t2,
  DataUtils: () => Z4,
  DecrementStencilOp: () => FN,
  DecrementWrapStencilOp: () => zN,
  DefaultLoadingManager: () => Jb,
  DepthFormat: () => Zo,
  DepthStencilFormat: () => tl,
  DepthTexture: () => S_,
  DirectionalLight: () => ao,
  DirectionalLightHelper: () => Z2,
  DiscreteInterpolant: () => K_,
  DodecahedronBufferGeometry: () => sc,
  DodecahedronGeometry: () => sc,
  DoubleSide: () => Gi,
  DstAlphaFactor: () => LA,
  DstColorFactor: () => IA,
  DynamicCopyUsage: () => $N,
  DynamicDrawUsage: () => qN,
  DynamicReadUsage: () => KN,
  EdgesGeometry: () => H_,
  EllipseCurve: () => od,
  EqualDepth: () => zA,
  EqualStencilFunc: () => HN,
  EquirectangularReflectionMapping: () => Uf,
  EquirectangularRefractionMapping: () => Vf,
  Euler: () => ul,
  EventDispatcher: () => Xi,
  ExtrudeBufferGeometry: () => ac,
  ExtrudeGeometry: () => ac,
  FileLoader: () => ni,
  FlatShading: () => wA,
  Float16BufferAttribute: () => zC,
  Float32BufferAttribute: () => ke,
  Float64BufferAttribute: () => BC,
  FloatType: () => Xs,
  Fog: () => td,
  FogExp2: () => ed,
  Font: () => J4,
  FontLoader: () => K4,
  FramebufferTexture: () => Ub,
  FrontSide: () => Gs,
  Frustum: () => Jf,
  GLBufferAttribute: () => R2,
  GLSL1: () => tD,
  GLSL3: () => Hx,
  GreaterDepth: () => UA,
  GreaterEqualDepth: () => BA,
  GreaterEqualStencilFunc: () => XN,
  GreaterStencilFunc: () => jN,
  GridHelper: () => W2,
  Group: () => ti,
  HalfFloatType: () => Yo,
  HemisphereLight: () => Q_,
  HemisphereLightHelper: () => j2,
  HemisphereLightProbe: () => h2,
  IcosahedronBufferGeometry: () => lc,
  IcosahedronGeometry: () => lc,
  ImageBitmapLoader: () => lg,
  ImageLoader: () => gc,
  ImageUtils: () => fm,
  ImmediateRenderObject: () => Q4,
  IncrementStencilOp: () => kN,
  IncrementWrapStencilOp: () => ON,
  InstancedBufferAttribute: () => vl,
  InstancedBufferGeometry: () => rS,
  InstancedInterleavedBuffer: () => b2,
  InstancedMesh: () => C_,
  Int16BufferAttribute: () => FC,
  Int32BufferAttribute: () => OC,
  Int8BufferAttribute: () => NC,
  IntType: () => KA,
  InterleavedBuffer: () => pl,
  InterleavedBufferAttribute: () => Ai,
  Interpolant: () => da,
  InterpolateDiscrete: () => qs,
  InterpolateLinear: () => xs,
  InterpolateSmooth: () => tm,
  InvertStencilOp: () => BN,
  KeepStencilOp: () => im,
  KeyframeTrack: () => bi,
  LOD: () => A_,
  LatheBufferGeometry: () => xl,
  LatheGeometry: () => xl,
  Layers: () => na,
  LessDepth: () => OA,
  LessEqualDepth: () => Zp,
  LessEqualStencilFunc: () => GN,
  LessStencilFunc: () => VN,
  Light: () => so,
  LightProbe: () => md,
  Line: () => Fr,
  Line3: () => F2,
  LineBasicMaterial: () => Un,
  LineCurve: () => ud,
  LineCurve3: () => z_,
  LineDashedMaterial: () => Y_,
  LineLoop: () => yl,
  LineSegments: () => wr,
  LinearEncoding: () => Ys,
  LinearFilter: () => kt,
  LinearInterpolant: () => rg,
  LinearMipMapLinearFilter: () => LN,
  LinearMipMapNearestFilter: () => RN,
  LinearMipmapLinearFilter: () => Mi,
  LinearMipmapNearestFilter: () => $a,
  LinearSRGBColorSpace: () => Ko,
  LinearToneMapping: () => jA,
  Loader: () => or,
  LoaderUtils: () => Ri,
  LoadingManager: () => sg,
  LoopOnce: () => uC,
  LoopPingPong: () => fC,
  LoopRepeat: () => cC,
  LuminanceAlphaFormat: () => nC,
  LuminanceFormat: () => tC,
  MOUSE: () => Of,
  Material: () => $t,
  MaterialLoader: () => gd,
  MathUtils: () => Wf,
  Matrix3: () => vr,
  Matrix4: () => Ge,
  MaxEquation: () => px,
  Mesh: () => Ot,
  MeshBasicMaterial: () => en,
  MeshDepthMaterial: () => Yu,
  MeshDistanceMaterial: () => km,
  MeshLambertMaterial: () => wl,
  MeshMatcapMaterial: () => hd,
  MeshNormalMaterial: () => mc,
  MeshPhongMaterial: () => ro,
  MeshPhysicalMaterial: () => Xn,
  MeshStandardMaterial: () => In,
  MeshToonMaterial: () => Sl,
  MinEquation: () => hx,
  MirroredRepeatWrapping: () => Ws,
  MixOperation: () => HA,
  MultiplyBlending: () => dx,
  MultiplyOperation: () => Bf,
  NearestFilter: () => Jt,
  NearestMipMapLinearFilter: () => bN,
  NearestMipMapNearestFilter: () => CN,
  NearestMipmapLinearFilter: () => Wo,
  NearestMipmapNearestFilter: () => jo,
  NeverDepth: () => kA,
  NeverStencilFunc: () => UN,
  NoBlending: () => js,
  NoColorSpace: () => IN,
  NoToneMapping: () => ji,
  NormalAnimationBlendMode: () => nm,
  NormalBlending: () => Ja,
  NotEqualDepth: () => VA,
  NotEqualStencilFunc: () => WN,
  NumberKeyframeTrack: () => pa,
  Object3D: () => ct,
  ObjectLoader: () => u2,
  ObjectSpaceNormalMap: () => pC,
  OctahedronBufferGeometry: () => _l,
  OctahedronGeometry: () => _l,
  OneFactor: () => CA,
  OneMinusDstAlphaFactor: () => PA,
  OneMinusDstColorFactor: () => NA,
  OneMinusSrcAlphaFactor: () => gx,
  OneMinusSrcColorFactor: () => RA,
  OrthographicCamera: () => $i,
  PCFShadowMap: () => Yp,
  PCFSoftShadowMap: () => zf,
  PMREMGenerator: () => Im,
  ParametricGeometry: () => o3,
  Path: () => tc,
  PerspectiveCamera: () => ln,
  Plane: () => to,
  PlaneBufferGeometry: () => cl,
  PlaneGeometry: () => cl,
  PlaneHelper: () => $2,
  PointLight: () => oo,
  PointLightHelper: () => V2,
  Points: () => la,
  PointsMaterial: () => ec,
  PolarGridHelper: () => X2,
  PolyhedronBufferGeometry: () => Ss,
  PolyhedronGeometry: () => Ss,
  PositionalAudio: () => w2,
  PropertyBinding: () => st,
  PropertyMixer: () => aS,
  QuadraticBezierCurve: () => Ym,
  QuadraticBezierCurve3: () => Zm,
  Quaternion: () => Pn,
  QuaternionKeyframeTrack: () => ws,
  QuaternionLinearInterpolant: () => J_,
  REVISION: () => qp,
  RGBADepthPacking: () => hC,
  RGBAFormat: () => gr,
  RGBAIntegerFormat: () => aC,
  RGBA_ASTC_10x10_Format: () => Fx,
  RGBA_ASTC_10x5_Format: () => Nx,
  RGBA_ASTC_10x6_Format: () => Dx,
  RGBA_ASTC_10x8_Format: () => kx,
  RGBA_ASTC_12x10_Format: () => Ox,
  RGBA_ASTC_12x12_Format: () => zx,
  RGBA_ASTC_4x4_Format: () => Tx,
  RGBA_ASTC_5x4_Format: () => Ax,
  RGBA_ASTC_5x5_Format: () => Cx,
  RGBA_ASTC_6x5_Format: () => bx,
  RGBA_ASTC_6x6_Format: () => Rx,
  RGBA_ASTC_8x5_Format: () => Lx,
  RGBA_ASTC_8x6_Format: () => Px,
  RGBA_ASTC_8x8_Format: () => Ix,
  RGBA_BPTC_Format: () => Bx,
  RGBA_ETC2_EAC_Format: () => Ex,
  RGBA_PVRTC_2BPPV1_Format: () => wx,
  RGBA_PVRTC_4BPPV1_Format: () => Sx,
  RGBA_S3TC_DXT1_Format: () => Qp,
  RGBA_S3TC_DXT3_Format: () => $p,
  RGBA_S3TC_DXT5_Format: () => em,
  RGBFormat: () => eC,
  RGB_ETC1_Format: () => lC,
  RGB_ETC2_Format: () => Mx,
  RGB_PVRTC_2BPPV1_Format: () => _x,
  RGB_PVRTC_4BPPV1_Format: () => xx,
  RGB_S3TC_DXT1_Format: () => Jp,
  RGFormat: () => sC,
  RGIntegerFormat: () => oC,
  RawShaderMaterial: () => q_,
  Ray: () => Nu,
  Raycaster: () => cS,
  RectAreaLight: () => tS,
  RedFormat: () => rC,
  RedIntegerFormat: () => iC,
  ReinhardToneMapping: () => WA,
  RepeatWrapping: () => Wi,
  ReplaceStencilOp: () => DN,
  ReverseSubtractEquation: () => TA,
  RingBufferGeometry: () => uc,
  RingGeometry: () => uc,
  SRGBColorSpace: () => _s,
  Scene: () => hl,
  ShaderChunk: () => ut,
  ShaderLib: () => Qi,
  ShaderMaterial: () => sr,
  ShadowMaterial: () => X_,
  Shape: () => ca,
  ShapeBufferGeometry: () => cc,
  ShapeGeometry: () => cc,
  ShapePath: () => r3,
  ShapeUtils: () => es,
  ShortType: () => ZA,
  Skeleton: () => gl,
  SkeletonHelper: () => B2,
  SkinnedMesh: () => aa,
  SmoothShading: () => AN,
  Source: () => Jo,
  Sphere: () => Zi,
  SphereBufferGeometry: () => no,
  SphereGeometry: () => no,
  Spherical: () => P2,
  SphericalHarmonics3: () => nS,
  SplineCurve: () => Km,
  SpotLight: () => ya,
  SpotLightHelper: () => z2,
  Sprite: () => T_,
  SpriteMaterial: () => Om,
  SrcAlphaFactor: () => mx,
  SrcAlphaSaturateFactor: () => DA,
  SrcColorFactor: () => bA,
  StaticCopyUsage: () => QN,
  StaticDrawUsage: () => sm,
  StaticReadUsage: () => ZN,
  StereoCamera: () => v2,
  StreamCopyUsage: () => eD,
  StreamDrawUsage: () => YN,
  StreamReadUsage: () => JN,
  StringKeyframeTrack: () => ma,
  SubtractEquation: () => EA,
  SubtractiveBlending: () => fx,
  TOUCH: () => EN,
  TangentSpaceNormalMap: () => Zs,
  TetrahedronBufferGeometry: () => fc,
  TetrahedronGeometry: () => fc,
  TextGeometry: () => a3,
  Texture: () => Qt,
  TextureLoader: () => og,
  TorusBufferGeometry: () => dc,
  TorusGeometry: () => dc,
  TorusKnotBufferGeometry: () => hc,
  TorusKnotGeometry: () => hc,
  Triangle: () => Qr,
  TriangleFanDrawMode: () => rm,
  TriangleStripDrawMode: () => Vx,
  TrianglesDrawMode: () => PN,
  TubeBufferGeometry: () => pc,
  TubeGeometry: () => pc,
  UVMapping: () => Kp,
  Uint16BufferAttribute: () => _m,
  Uint32BufferAttribute: () => Sm,
  Uint8BufferAttribute: () => DC,
  Uint8ClampedBufferAttribute: () => kC,
  Uniform: () => fg,
  UniformsLib: () => Ee,
  UniformsUtils: () => Lm,
  UnsignedByteType: () => Xo,
  UnsignedInt248Type: () => el,
  UnsignedIntType: () => qo,
  UnsignedShort4444Type: () => JA,
  UnsignedShort5551Type: () => QA,
  UnsignedShortType: () => yx,
  VSMShadowMap: () => Ka,
  Vector2: () => se,
  Vector3: () => I,
  Vector4: () => Lt,
  VectorKeyframeTrack: () => ga,
  VideoTexture: () => Bb,
  WebGL1Renderer: () => M_,
  WebGL3DRenderTarget: () => SC,
  WebGLArrayRenderTarget: () => _C,
  WebGLCubeRenderTarget: () => d_,
  WebGLMultipleRenderTargets: () => wC,
  WebGLMultisampleRenderTarget: () => l3,
  WebGLRenderTarget: () => yr,
  WebGLRenderer: () => w_,
  WebGLUtils: () => xb,
  WireframeGeometry: () => W_,
  WrapAroundEnding: () => Hf,
  ZeroCurvatureEnding: () => nl,
  ZeroFactor: () => AA,
  ZeroSlopeEnding: () => rl,
  ZeroStencilOp: () => NN,
  _SRGBAFormat: () => om,
  sRGBEncoding: () => yt,
});
var qp = "142",
  Of = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  EN = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  xA = 0,
  ux = 1,
  _A = 2,
  TN = 3,
  SA = 0,
  Yp = 1,
  zf = 2,
  Ka = 3,
  Gs = 0,
  mr = 1,
  Gi = 2,
  wA = 1,
  AN = 2,
  js = 0,
  Ja = 1,
  cx = 2,
  fx = 3,
  dx = 4,
  MA = 5,
  Qa = 100,
  EA = 101,
  TA = 102,
  hx = 103,
  px = 104,
  AA = 200,
  CA = 201,
  bA = 202,
  RA = 203,
  mx = 204,
  gx = 205,
  LA = 206,
  PA = 207,
  IA = 208,
  NA = 209,
  DA = 210,
  kA = 0,
  FA = 1,
  OA = 2,
  Zp = 3,
  zA = 4,
  BA = 5,
  UA = 6,
  VA = 7,
  Bf = 0,
  HA = 1,
  GA = 2,
  ji = 0,
  jA = 1,
  WA = 2,
  XA = 3,
  vx = 4,
  qA = 5,
  Kp = 300,
  Ho = 301,
  Go = 302,
  Uf = 303,
  Vf = 304,
  Au = 306,
  Wi = 1e3,
  Rn = 1001,
  Ws = 1002,
  Jt = 1003,
  jo = 1004,
  CN = 1004,
  Wo = 1005,
  bN = 1005,
  kt = 1006,
  $a = 1007,
  RN = 1007,
  Mi = 1008,
  LN = 1008,
  Xo = 1009,
  YA = 1010,
  ZA = 1011,
  yx = 1012,
  KA = 1013,
  qo = 1014,
  Xs = 1015,
  Yo = 1016,
  JA = 1017,
  QA = 1018,
  el = 1020,
  $A = 1021,
  eC = 1022,
  gr = 1023,
  tC = 1024,
  nC = 1025,
  Zo = 1026,
  tl = 1027,
  rC = 1028,
  iC = 1029,
  sC = 1030,
  oC = 1031,
  aC = 1033,
  Jp = 33776,
  Qp = 33777,
  $p = 33778,
  em = 33779,
  xx = 35840,
  _x = 35841,
  Sx = 35842,
  wx = 35843,
  lC = 36196,
  Mx = 37492,
  Ex = 37496,
  Tx = 37808,
  Ax = 37809,
  Cx = 37810,
  bx = 37811,
  Rx = 37812,
  Lx = 37813,
  Px = 37814,
  Ix = 37815,
  Nx = 37816,
  Dx = 37817,
  kx = 37818,
  Fx = 37819,
  Ox = 37820,
  zx = 37821,
  Bx = 36492,
  uC = 2200,
  cC = 2201,
  fC = 2202,
  qs = 2300,
  xs = 2301,
  tm = 2302,
  nl = 2400,
  rl = 2401,
  Hf = 2402,
  nm = 2500,
  Ux = 2501,
  PN = 0,
  Vx = 1,
  rm = 2,
  Ys = 3e3,
  yt = 3001,
  dC = 3200,
  hC = 3201,
  Zs = 0,
  pC = 1,
  IN = "",
  _s = "srgb",
  Ko = "srgb-linear",
  NN = 0,
  im = 7680,
  DN = 7681,
  kN = 7682,
  FN = 7683,
  ON = 34055,
  zN = 34056,
  BN = 5386,
  UN = 512,
  VN = 513,
  HN = 514,
  GN = 515,
  jN = 516,
  WN = 517,
  XN = 518,
  mC = 519,
  sm = 35044,
  qN = 35048,
  YN = 35040,
  ZN = 35045,
  KN = 35049,
  JN = 35041,
  QN = 35046,
  $N = 35050,
  eD = 35042,
  tD = "100",
  Hx = "300 es",
  om = 1035,
  Xi = class {
    addEventListener(e, t) {
      this._listeners === void 0 && (this._listeners = {});
      let r = this._listeners;
      r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
    }
    hasEventListener(e, t) {
      if (this._listeners === void 0) return !1;
      let r = this._listeners;
      return r[e] !== void 0 && r[e].indexOf(t) !== -1;
    }
    removeEventListener(e, t) {
      if (this._listeners === void 0) return;
      let i = this._listeners[e];
      if (i !== void 0) {
        let s = i.indexOf(t);
        s !== -1 && i.splice(s, 1);
      }
    }
    dispatchEvent(e) {
      if (this._listeners === void 0) return;
      let r = this._listeners[e.type];
      if (r !== void 0) {
        e.target = this;
        let i = r.slice(0);
        for (let s = 0, o = i.length; s < o; s++) i[s].call(this, e);
        e.target = null;
      }
    }
  },
  rr = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0a",
    "0b",
    "0c",
    "0d",
    "0e",
    "0f",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1a",
    "1b",
    "1c",
    "1d",
    "1e",
    "1f",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2a",
    "2b",
    "2c",
    "2d",
    "2e",
    "2f",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3a",
    "3b",
    "3c",
    "3d",
    "3e",
    "3f",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4a",
    "4b",
    "4c",
    "4d",
    "4e",
    "4f",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5a",
    "5b",
    "5c",
    "5d",
    "5e",
    "5f",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6a",
    "6b",
    "6c",
    "6d",
    "6e",
    "6f",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7a",
    "7b",
    "7c",
    "7d",
    "7e",
    "7f",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8a",
    "8b",
    "8c",
    "8d",
    "8e",
    "8f",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9a",
    "9b",
    "9c",
    "9d",
    "9e",
    "9f",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "a8",
    "a9",
    "aa",
    "ab",
    "ac",
    "ad",
    "ae",
    "af",
    "b0",
    "b1",
    "b2",
    "b3",
    "b4",
    "b5",
    "b6",
    "b7",
    "b8",
    "b9",
    "ba",
    "bb",
    "bc",
    "bd",
    "be",
    "bf",
    "c0",
    "c1",
    "c2",
    "c3",
    "c4",
    "c5",
    "c6",
    "c7",
    "c8",
    "c9",
    "ca",
    "cb",
    "cc",
    "cd",
    "ce",
    "cf",
    "d0",
    "d1",
    "d2",
    "d3",
    "d4",
    "d5",
    "d6",
    "d7",
    "d8",
    "d9",
    "da",
    "db",
    "dc",
    "dd",
    "de",
    "df",
    "e0",
    "e1",
    "e2",
    "e3",
    "e4",
    "e5",
    "e6",
    "e7",
    "e8",
    "e9",
    "ea",
    "eb",
    "ec",
    "ed",
    "ee",
    "ef",
    "f0",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "fa",
    "fb",
    "fc",
    "fd",
    "fe",
    "ff",
  ],
  gC = 1234567,
  il = Math.PI / 180,
  Gf = 180 / Math.PI;
function Kr() {
  let n = Math.random() * 4294967295 | 0,
    e = Math.random() * 4294967295 | 0,
    t = Math.random() * 4294967295 | 0,
    r = Math.random() * 4294967295 | 0;
  return (rr[n & 255] + rr[n >> 8 & 255] + rr[n >> 16 & 255] +
    rr[n >> 24 & 255] + "-" + rr[e & 255] + rr[e >> 8 & 255] + "-" +
    rr[e >> 16 & 15 | 64] + rr[e >> 24 & 255] + "-" + rr[t & 63 | 128] +
    rr[t >> 8 & 255] + "-" + rr[t >> 16 & 255] + rr[t >> 24 & 255] +
    rr[r & 255] + rr[r >> 8 & 255] + rr[r >> 16 & 255] + rr[r >> 24 & 255])
    .toLowerCase();
}
function yn(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function Gx(n, e) {
  return (n % e + e) % e;
}
function nD(n, e, t, r, i) {
  return r + (n - e) * (i - r) / (t - e);
}
function rD(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function jf(n, e, t) {
  return (1 - t) * n + t * e;
}
function iD(n, e, t, r) {
  return jf(n, e, 1 - Math.exp(-t * r));
}
function sD(n, e = 1) {
  return e - Math.abs(Gx(n, e * 2) - e);
}
function oD(n, e, t) {
  return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * (3 - 2 * n));
}
function aD(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : (n = (n - e) / (t - e), n * n * n * (n * (n * 6 - 15) + 10));
}
function lD(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function uD(n, e) {
  return n + Math.random() * (e - n);
}
function cD(n) {
  return n * (.5 - Math.random());
}
function fD(n) {
  n !== void 0 && (gC = n);
  let e = gC += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1),
    e ^= e + Math.imul(e ^ e >>> 7, e | 61),
    ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function dD(n) {
  return n * il;
}
function hD(n) {
  return n * Gf;
}
function jx(n) {
  return (n & n - 1) == 0 && n !== 0;
}
function vC(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function am(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function pD(n, e, t, r, i) {
  let s = Math.cos,
    o = Math.sin,
    a = s(t / 2),
    u = o(t / 2),
    f = s((e + r) / 2),
    d = o((e + r) / 2),
    h = s((e - r) / 2),
    p = o((e - r) / 2),
    g = s((r - e) / 2),
    y = o((r - e) / 2);
  switch (i) {
    case "XYX":
      n.set(a * d, u * h, u * p, a * f);
      break;
    case "YZY":
      n.set(u * p, a * d, u * h, a * f);
      break;
    case "ZXZ":
      n.set(u * h, u * p, a * d, a * f);
      break;
    case "XZX":
      n.set(a * d, u * y, u * g, a * f);
      break;
    case "YXY":
      n.set(u * g, a * d, u * y, a * f);
      break;
    case "ZYZ":
      n.set(u * y, u * g, a * d, a * f);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          i,
      );
  }
}
function mD(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function gD(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
var Wf = Object.freeze({
    __proto__: null,
    DEG2RAD: il,
    RAD2DEG: Gf,
    generateUUID: Kr,
    clamp: yn,
    euclideanModulo: Gx,
    mapLinear: nD,
    inverseLerp: rD,
    lerp: jf,
    damp: iD,
    pingpong: sD,
    smoothstep: oD,
    smootherstep: aD,
    randInt: lD,
    randFloat: uD,
    randFloatSpread: cD,
    seededRandom: fD,
    degToRad: dD,
    radToDeg: hD,
    isPowerOfTwo: jx,
    ceilPowerOfTwo: vC,
    floorPowerOfTwo: am,
    setQuaternionFromProperEuler: pD,
    normalize: gD,
    denormalize: mD,
  }),
  se = class {
    constructor(e = 0, t = 0) {
      se.prototype.isVector2 = !0, this.x = e, this.y = t;
    }
    get width() {
      return this.x;
    }
    set width(e) {
      this.x = e;
    }
    get height() {
      return this.y;
    }
    set height(e) {
      this.y = e;
    }
    set(e, t) {
      return this.x = e, this.y = t, this;
    }
    setScalar(e) {
      return this.x = e, this.y = e, this;
    }
    setX(e) {
      return this.x = e, this;
    }
    setY(e) {
      return this.y = e, this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(e) {
      return this.x = e.x, this.y = e.y, this;
    }
    add(e, t) {
      return t !== void 0
        ? (console.warn(
          "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.",
        ),
          this.addVectors(e, t))
        : (this.x += e.x, this.y += e.y, this);
    }
    addScalar(e) {
      return this.x += e, this.y += e, this;
    }
    addVectors(e, t) {
      return this.x = e.x + t.x, this.y = e.y + t.y, this;
    }
    addScaledVector(e, t) {
      return this.x += e.x * t, this.y += e.y * t, this;
    }
    sub(e, t) {
      return t !== void 0
        ? (console.warn(
          "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.",
        ),
          this.subVectors(e, t))
        : (this.x -= e.x, this.y -= e.y, this);
    }
    subScalar(e) {
      return this.x -= e, this.y -= e, this;
    }
    subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this;
    }
    multiply(e) {
      return this.x *= e.x, this.y *= e.y, this;
    }
    multiplyScalar(e) {
      return this.x *= e, this.y *= e, this;
    }
    divide(e) {
      return this.x /= e.x, this.y /= e.y, this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    applyMatrix3(e) {
      let t = this.x, r = this.y, i = e.elements;
      return this.x = i[0] * t + i[3] * r + i[6],
        this.y = i[1] * t + i[4] * r + i[7],
        this;
    }
    min(e) {
      return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this;
    }
    max(e) {
      return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this;
    }
    clamp(e, t) {
      return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this;
    }
    clampScalar(e, t) {
      return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this;
    }
    clampLength(e, t) {
      let r = this.length();
      return this.divideScalar(r || 1).multiplyScalar(
        Math.max(e, Math.min(t, r)),
      );
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y;
    }
    cross(e) {
      return this.x * e.y - this.y * e.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
      let t = this.x - e.x, r = this.y - e.y;
      return t * t + r * r;
    }
    manhattanDistanceTo(e) {
      return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
    }
    lerpVectors(e, t, r) {
      return this.x = e.x + (t.x - e.x) * r,
        this.y = e.y + (t.y - e.y) * r,
        this;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y;
    }
    fromArray(e, t = 0) {
      return this.x = e[t], this.y = e[t + 1], this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e;
    }
    fromBufferAttribute(e, t, r) {
      return r !== void 0 &&
        console.warn(
          "THREE.Vector2: offset has been removed from .fromBufferAttribute().",
        ),
        this.x = e.getX(t),
        this.y = e.getY(t),
        this;
    }
    rotateAround(e, t) {
      let r = Math.cos(t), i = Math.sin(t), s = this.x - e.x, o = this.y - e.y;
      return this.x = s * r - o * i + e.x, this.y = s * i + o * r + e.y, this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  },
  vr = class {
    constructor() {
      vr.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        arguments.length > 0 &&
        console.error(
          "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.",
        );
    }
    set(e, t, r, i, s, o, a, u, f) {
      let d = this.elements;
      return d[0] = e,
        d[1] = i,
        d[2] = a,
        d[3] = t,
        d[4] = s,
        d[5] = u,
        d[6] = r,
        d[7] = o,
        d[8] = f,
        this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(e) {
      let t = this.elements, r = e.elements;
      return t[0] = r[0],
        t[1] = r[1],
        t[2] = r[2],
        t[3] = r[3],
        t[4] = r[4],
        t[5] = r[5],
        t[6] = r[6],
        t[7] = r[7],
        t[8] = r[8],
        this;
    }
    extractBasis(e, t, r) {
      return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        r.setFromMatrix3Column(this, 2),
        this;
    }
    setFromMatrix4(e) {
      let t = e.elements;
      return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this;
    }
    multiply(e) {
      return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
      let r = e.elements,
        i = t.elements,
        s = this.elements,
        o = r[0],
        a = r[3],
        u = r[6],
        f = r[1],
        d = r[4],
        h = r[7],
        p = r[2],
        g = r[5],
        y = r[8],
        v = i[0],
        _ = i[3],
        S = i[6],
        w = i[1],
        M = i[4],
        T = i[7],
        b = i[2],
        R = i[5],
        P = i[8];
      return s[0] = o * v + a * w + u * b,
        s[3] = o * _ + a * M + u * R,
        s[6] = o * S + a * T + u * P,
        s[1] = f * v + d * w + h * b,
        s[4] = f * _ + d * M + h * R,
        s[7] = f * S + d * T + h * P,
        s[2] = p * v + g * w + y * b,
        s[5] = p * _ + g * M + y * R,
        s[8] = p * S + g * T + y * P,
        this;
    }
    multiplyScalar(e) {
      let t = this.elements;
      return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this;
    }
    determinant() {
      let e = this.elements,
        t = e[0],
        r = e[1],
        i = e[2],
        s = e[3],
        o = e[4],
        a = e[5],
        u = e[6],
        f = e[7],
        d = e[8];
      return t * o * d - t * a * f - r * s * d + r * a * u + i * s * f -
        i * o * u;
    }
    invert() {
      let e = this.elements,
        t = e[0],
        r = e[1],
        i = e[2],
        s = e[3],
        o = e[4],
        a = e[5],
        u = e[6],
        f = e[7],
        d = e[8],
        h = d * o - a * f,
        p = a * u - d * s,
        g = f * s - o * u,
        y = t * h + r * p + i * g;
      if (y === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      let v = 1 / y;
      return e[0] = h * v,
        e[1] = (i * f - d * r) * v,
        e[2] = (a * r - i * o) * v,
        e[3] = p * v,
        e[4] = (d * t - i * u) * v,
        e[5] = (i * s - a * t) * v,
        e[6] = g * v,
        e[7] = (r * u - f * t) * v,
        e[8] = (o * t - r * s) * v,
        this;
    }
    transpose() {
      let e, t = this.elements;
      return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this;
    }
    getNormalMatrix(e) {
      return this.setFromMatrix4(e).invert().transpose();
    }
    transposeIntoArray(e) {
      let t = this.elements;
      return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this;
    }
    setUvTransform(e, t, r, i, s, o, a) {
      let u = Math.cos(s), f = Math.sin(s);
      return this.set(
        r * u,
        r * f,
        -r * (u * o + f * a) + o + e,
        -i * f,
        i * u,
        -i * (-f * o + u * a) + a + t,
        0,
        0,
        1,
      ),
        this;
    }
    scale(e, t) {
      let r = this.elements;
      return r[0] *= e,
        r[3] *= e,
        r[6] *= e,
        r[1] *= t,
        r[4] *= t,
        r[7] *= t,
        this;
    }
    rotate(e) {
      let t = Math.cos(e),
        r = Math.sin(e),
        i = this.elements,
        s = i[0],
        o = i[3],
        a = i[6],
        u = i[1],
        f = i[4],
        d = i[7];
      return i[0] = t * s + r * u,
        i[3] = t * o + r * f,
        i[6] = t * a + r * d,
        i[1] = -r * s + t * u,
        i[4] = -r * o + t * f,
        i[7] = -r * a + t * d,
        this;
    }
    translate(e, t) {
      let r = this.elements;
      return r[0] += e * r[2],
        r[3] += e * r[5],
        r[6] += e * r[8],
        r[1] += t * r[2],
        r[4] += t * r[5],
        r[7] += t * r[8],
        this;
    }
    equals(e) {
      let t = this.elements, r = e.elements;
      for (let i = 0; i < 9; i++) if (t[i] !== r[i]) return !1;
      return !0;
    }
    fromArray(e, t = 0) {
      for (let r = 0; r < 9; r++) this.elements[r] = e[r + t];
      return this;
    }
    toArray(e = [], t = 0) {
      let r = this.elements;
      return e[t] = r[0],
        e[t + 1] = r[1],
        e[t + 2] = r[2],
        e[t + 3] = r[3],
        e[t + 4] = r[4],
        e[t + 5] = r[5],
        e[t + 6] = r[6],
        e[t + 7] = r[7],
        e[t + 8] = r[8],
        e;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  };
function yC(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] > 65535) return !0;
  return !1;
}
var vD = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function Cu(n, e) {
  return new vD[n](e);
}
function Xf(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function sl(n) {
  return n < .04045
    ? n * .0773993808
    : Math.pow(n * .9478672986 + .0521327014, 2.4);
}
function lm(n) {
  return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055;
}
var Wx = { [_s]: { [Ko]: sl }, [Ko]: { [_s]: lm } },
  Ei = {
    legacyMode: !0,
    get workingColorSpace() {
      return Ko;
    },
    set workingColorSpace(n) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function (n, e, t) {
      if (this.legacyMode || e === t || !e || !t) return n;
      if (Wx[e] && Wx[e][t] !== void 0) {
        let r = Wx[e][t];
        return n.r = r(n.r), n.g = r(n.g), n.b = r(n.b), n;
      }
      throw new Error("Unsupported color space conversion.");
    },
    fromWorkingColorSpace: function (n, e) {
      return this.convert(n, this.workingColorSpace, e);
    },
    toWorkingColorSpace: function (n, e) {
      return this.convert(n, e, this.workingColorSpace);
    },
  },
  xC = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Ln = { r: 0, g: 0, b: 0 },
  qi = { h: 0, s: 0, l: 0 },
  um = { h: 0, s: 0, l: 0 };
function Xx(n, e, t) {
  return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * 6 * (2 / 3 - t)
      : n;
}
function cm(n, e) {
  return e.r = n.r, e.g = n.g, e.b = n.b, e;
}
var ve = class {
  constructor(e, t, r) {
    return this.isColor = !0,
      this.r = 1,
      this.g = 1,
      this.b = 1,
      t === void 0 && r === void 0 ? this.set(e) : this.setRGB(e, t, r);
  }
  set(e) {
    return e && e.isColor
      ? this.copy(e)
      : typeof e == "number"
      ? this.setHex(e)
      : typeof e == "string" && this.setStyle(e),
      this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = _s) {
    return e = Math.floor(e),
      this.r = (e >> 16 & 255) / 255,
      this.g = (e >> 8 & 255) / 255,
      this.b = (e & 255) / 255,
      Ei.toWorkingColorSpace(this, t),
      this;
  }
  setRGB(e, t, r, i = Ko) {
    return this.r = e,
      this.g = t,
      this.b = r,
      Ei.toWorkingColorSpace(this, i),
      this;
  }
  setHSL(e, t, r, i = Ko) {
    if (e = Gx(e, 1), t = yn(t, 0, 1), r = yn(r, 0, 1), t === 0) {
      this.r = this.g = this.b = r;
    } else {
      let s = r <= .5 ? r * (1 + t) : r + t - r * t, o = 2 * r - s;
      this.r = Xx(o, s, e + 1 / 3),
        this.g = Xx(o, s, e),
        this.b = Xx(o, s, e - 1 / 3);
    }
    return Ei.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = _s) {
    function r(s) {
      s !== void 0 && parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored.",
        );
    }
    let i;
    if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
      let s, o = i[1], a = i[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (
            s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/
              .exec(a)
          ) {
            return this.r = Math.min(255, parseInt(s[1], 10)) / 255,
              this.g = Math.min(255, parseInt(s[2], 10)) / 255,
              this.b = Math.min(255, parseInt(s[3], 10)) / 255,
              Ei.toWorkingColorSpace(this, t),
              r(s[4]),
              this;
          }
          if (
            s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/
                .exec(a)
          ) {
            return this.r = Math.min(100, parseInt(s[1], 10)) / 100,
              this.g = Math.min(100, parseInt(s[2], 10)) / 100,
              this.b = Math.min(100, parseInt(s[3], 10)) / 100,
              Ei.toWorkingColorSpace(this, t),
              r(s[4]),
              this;
          }
          break;
        case "hsl":
        case "hsla":
          if (
            s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/
                .exec(a)
          ) {
            let u = parseFloat(s[1]) / 360,
              f = parseInt(s[2], 10) / 100,
              d = parseInt(s[3], 10) / 100;
            return r(s[4]), this.setHSL(u, f, d, t);
          }
          break;
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      let s = i[1], o = s.length;
      if (o === 3) {
        return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255,
          this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255,
          this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255,
          Ei.toWorkingColorSpace(this, t),
          this;
      }
      if (o === 6) {
        return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255,
          this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255,
          this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255,
          Ei.toWorkingColorSpace(this, t),
          this;
      }
    }
    return e && e.length > 0 ? this.setColorName(e, t) : this;
  }
  setColorName(e, t = _s) {
    let r = xC[e.toLowerCase()];
    return r !== void 0
      ? this.setHex(r, t)
      : console.warn("THREE.Color: Unknown color " + e),
      this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = sl(e.r), this.g = sl(e.g), this.b = sl(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = lm(e.r), this.g = lm(e.g), this.b = lm(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = _s) {
    return Ei.fromWorkingColorSpace(cm(this, Ln), e),
      yn(Ln.r * 255, 0, 255) << 16 ^ yn(Ln.g * 255, 0, 255) << 8 ^
      yn(Ln.b * 255, 0, 255) << 0;
  }
  getHexString(e = _s) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Ko) {
    Ei.fromWorkingColorSpace(cm(this, Ln), t);
    let r = Ln.r,
      i = Ln.g,
      s = Ln.b,
      o = Math.max(r, i, s),
      a = Math.min(r, i, s),
      u,
      f,
      d = (a + o) / 2;
    if (a === o) u = 0, f = 0;
    else {
      let h = o - a;
      switch (f = d <= .5 ? h / (o + a) : h / (2 - o - a), o) {
        case r:
          u = (i - s) / h + (i < s ? 6 : 0);
          break;
        case i:
          u = (s - r) / h + 2;
          break;
        case s:
          u = (r - i) / h + 4;
          break;
      }
      u /= 6;
    }
    return e.h = u, e.s = f, e.l = d, e;
  }
  getRGB(e, t = Ko) {
    return Ei.fromWorkingColorSpace(cm(this, Ln), t),
      e.r = Ln.r,
      e.g = Ln.g,
      e.b = Ln.b,
      e;
  }
  getStyle(e = _s) {
    return Ei.fromWorkingColorSpace(cm(this, Ln), e),
      e !== _s
        ? `color(${e} ${Ln.r} ${Ln.g} ${Ln.b})`
        : `rgb(${Ln.r * 255 | 0},${Ln.g * 255 | 0},${Ln.b * 255 | 0})`;
  }
  offsetHSL(e, t, r) {
    return this.getHSL(qi),
      qi.h += e,
      qi.s += t,
      qi.l += r,
      this.setHSL(qi.h, qi.s, qi.l),
      this;
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r),
      this.g = Math.max(0, this.g - e.g),
      this.b = Math.max(0, this.b - e.b),
      this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t,
      this.g += (e.g - this.g) * t,
      this.b += (e.b - this.b) * t,
      this;
  }
  lerpColors(e, t, r) {
    return this.r = e.r + (t.r - e.r) * r,
      this.g = e.g + (t.g - e.g) * r,
      this.b = e.b + (t.b - e.b) * r,
      this;
  }
  lerpHSL(e, t) {
    this.getHSL(qi), e.getHSL(um);
    let r = jf(qi.h, um.h, t), i = jf(qi.s, um.s, t), s = jf(qi.l, um.l, t);
    return this.setHSL(r, i, s), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t),
      this.g = e.getY(t),
      this.b = e.getZ(t),
      e.normalized === !0 && (this.r /= 255, this.g /= 255, this.b /= 255),
      this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
ve.NAMES = xC;
var bu,
  fm = class {
    static getDataURL(e) {
      if (/^data:/i.test(e.src) || typeof HTMLCanvasElement == "undefined") {
        return e.src;
      }
      let t;
      if (e instanceof HTMLCanvasElement) t = e;
      else {
        bu === void 0 && (bu = Xf("canvas")),
          bu.width = e.width,
          bu.height = e.height;
        let r = bu.getContext("2d");
        e instanceof ImageData
          ? r.putImageData(e, 0, 0)
          : r.drawImage(e, 0, 0, e.width, e.height), t = bu;
      }
      return t.width > 2048 || t.height > 2048
        ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e,
        ),
          t.toDataURL("image/jpeg", .6))
        : t.toDataURL("image/png");
    }
    static sRGBToLinear(e) {
      if (
        typeof HTMLImageElement != "undefined" &&
          e instanceof HTMLImageElement ||
        typeof HTMLCanvasElement != "undefined" &&
          e instanceof HTMLCanvasElement ||
        typeof ImageBitmap != "undefined" && e instanceof ImageBitmap
      ) {
        let t = Xf("canvas");
        t.width = e.width, t.height = e.height;
        let r = t.getContext("2d");
        r.drawImage(e, 0, 0, e.width, e.height);
        let i = r.getImageData(0, 0, e.width, e.height), s = i.data;
        for (let o = 0; o < s.length; o++) s[o] = sl(s[o] / 255) * 255;
        return r.putImageData(i, 0, 0), t;
      } else if (e.data) {
        let t = e.data.slice(0);
        for (let r = 0; r < t.length; r++) {
          t instanceof Uint8Array || t instanceof Uint8ClampedArray
            ? t[r] = Math.floor(sl(t[r] / 255) * 255)
            : t[r] = sl(t[r]);
        }
        return { data: t, width: e.width, height: e.height };
      } else {return console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.",
        ),
          e;}
    }
  },
  Jo = class {
    constructor(e = null) {
      this.isSource = !0, this.uuid = Kr(), this.data = e, this.version = 0;
    }
    set needsUpdate(e) {
      e === !0 && this.version++;
    }
    toJSON(e) {
      let t = e === void 0 || typeof e == "string";
      if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
      let r = { uuid: this.uuid, url: "" }, i = this.data;
      if (i !== null) {
        let s;
        if (Array.isArray(i)) {
          s = [];
          for (let o = 0, a = i.length; o < a; o++) {
            i[o].isDataTexture
              ? s.push(qx(i[o].image))
              : s.push(qx(i[o]));
          }
        } else s = qx(i);
        r.url = s;
      }
      return t || (e.images[this.uuid] = r), r;
    }
  };
function qx(n) {
  return typeof HTMLImageElement != "undefined" &&
        n instanceof HTMLImageElement ||
      typeof HTMLCanvasElement != "undefined" &&
        n instanceof HTMLCanvasElement ||
      typeof ImageBitmap != "undefined" && n instanceof ImageBitmap
    ? fm.getDataURL(n)
    : n.data
    ? {
      data: Array.from(n.data),
      width: n.width,
      height: n.height,
      type: n.data.constructor.name,
    }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
var yD = 0,
  Qt = class extends Xi {
    constructor(
      e = Qt.DEFAULT_IMAGE,
      t = Qt.DEFAULT_MAPPING,
      r = Rn,
      i = Rn,
      s = kt,
      o = Mi,
      a = gr,
      u = Xo,
      f = 1,
      d = Ys,
    ) {
      super();
      this.isTexture = !0,
        Object.defineProperty(this, "id", { value: yD++ }),
        this.uuid = Kr(),
        this.name = "",
        this.source = new Jo(e),
        this.mipmaps = [],
        this.mapping = t,
        this.wrapS = r,
        this.wrapT = i,
        this.magFilter = s,
        this.minFilter = o,
        this.anisotropy = f,
        this.format = a,
        this.internalFormat = null,
        this.type = u,
        this.offset = new se(0, 0),
        this.repeat = new se(1, 1),
        this.center = new se(0, 0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new vr(),
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = d,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.needsPMREMUpdate = !1;
    }
    get image() {
      return this.source.data;
    }
    set image(e) {
      this.source.data = e;
    }
    updateMatrix() {
      this.matrix.setUvTransform(
        this.offset.x,
        this.offset.y,
        this.repeat.x,
        this.repeat.y,
        this.rotation,
        this.center.x,
        this.center.y,
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.encoding = e.encoding,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this;
    }
    toJSON(e) {
      let t = e === void 0 || typeof e == "string";
      if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
      let r = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON",
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(e).uuid,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment,
      };
      return JSON.stringify(this.userData) !== "{}" &&
        (r.userData = this.userData),
        t || (e.textures[this.uuid] = r),
        r;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(e) {
      if (this.mapping !== Kp) return e;
      if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) {
        switch (this.wrapS) {
          case Wi:
            e.x = e.x - Math.floor(e.x);
            break;
          case Rn:
            e.x = e.x < 0 ? 0 : 1;
            break;
          case Ws:
            Math.abs(Math.floor(e.x) % 2) === 1
              ? e.x = Math.ceil(e.x) - e.x
              : e.x = e.x - Math.floor(e.x);
            break;
        }
      }
      if (e.y < 0 || e.y > 1) {
        switch (this.wrapT) {
          case Wi:
            e.y = e.y - Math.floor(e.y);
            break;
          case Rn:
            e.y = e.y < 0 ? 0 : 1;
            break;
          case Ws:
            Math.abs(Math.floor(e.y) % 2) === 1
              ? e.y = Math.ceil(e.y) - e.y
              : e.y = e.y - Math.floor(e.y);
            break;
        }
      }
      return this.flipY && (e.y = 1 - e.y), e;
    }
    set needsUpdate(e) {
      e === !0 && (this.version++, this.source.needsUpdate = !0);
    }
  };
Qt.DEFAULT_IMAGE = null;
Qt.DEFAULT_MAPPING = Kp;
var Lt = class {
    constructor(e = 0, t = 0, r = 0, i = 1) {
      Lt.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = r,
        this.w = i;
    }
    get width() {
      return this.z;
    }
    set width(e) {
      this.z = e;
    }
    get height() {
      return this.w;
    }
    set height(e) {
      this.w = e;
    }
    set(e, t, r, i) {
      return this.x = e, this.y = t, this.z = r, this.w = i, this;
    }
    setScalar(e) {
      return this.x = e, this.y = e, this.z = e, this.w = e, this;
    }
    setX(e) {
      return this.x = e, this;
    }
    setY(e) {
      return this.y = e, this;
    }
    setZ(e) {
      return this.z = e, this;
    }
    setW(e) {
      return this.w = e, this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        case 2:
          this.z = t;
          break;
        case 3:
          this.w = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(e) {
      return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this;
    }
    add(e, t) {
      return t !== void 0
        ? (console.warn(
          "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.",
        ),
          this.addVectors(e, t))
        : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this);
    }
    addScalar(e) {
      return this.x += e, this.y += e, this.z += e, this.w += e, this;
    }
    addVectors(e, t) {
      return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this;
    }
    addScaledVector(e, t) {
      return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this;
    }
    sub(e, t) {
      return t !== void 0
        ? (console.warn(
          "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.",
        ),
          this.subVectors(e, t))
        : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this);
    }
    subScalar(e) {
      return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
    }
    subVectors(e, t) {
      return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this;
    }
    multiply(e) {
      return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
    }
    multiplyScalar(e) {
      return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
    }
    applyMatrix4(e) {
      let t = this.x, r = this.y, i = this.z, s = this.w, o = e.elements;
      return this.x = o[0] * t + o[4] * r + o[8] * i + o[12] * s,
        this.y = o[1] * t + o[5] * r + o[9] * i + o[13] * s,
        this.z = o[2] * t + o[6] * r + o[10] * i + o[14] * s,
        this.w = o[3] * t + o[7] * r + o[11] * i + o[15] * s,
        this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    setAxisAngleFromQuaternion(e) {
      this.w = 2 * Math.acos(e.w);
      let t = Math.sqrt(1 - e.w * e.w);
      return t < 1e-4
        ? (this.x = 1, this.y = 0, this.z = 0)
        : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t),
        this;
    }
    setAxisAngleFromRotationMatrix(e) {
      let t,
        r,
        i,
        s,
        o = .01,
        a = .1,
        u = e.elements,
        f = u[0],
        d = u[4],
        h = u[8],
        p = u[1],
        g = u[5],
        y = u[9],
        v = u[2],
        _ = u[6],
        S = u[10];
      if (Math.abs(d - p) < o && Math.abs(h - v) < o && Math.abs(y - _) < o) {
        if (
          Math.abs(d + p) < a && Math.abs(h + v) < a && Math.abs(y + _) < a &&
          Math.abs(f + g + S - 3) < a
        ) return this.set(1, 0, 0, 0), this;
        t = Math.PI;
        let M = (f + 1) / 2,
          T = (g + 1) / 2,
          b = (S + 1) / 2,
          R = (d + p) / 4,
          P = (h + v) / 4,
          C = (y + _) / 4;
        return M > T && M > b
          ? M < o
            ? (r = 0, i = .707106781, s = .707106781)
            : (r = Math.sqrt(M), i = R / r, s = P / r)
          : T > b
          ? T < o
            ? (r = .707106781, i = 0, s = .707106781)
            : (i = Math.sqrt(T), r = R / i, s = C / i)
          : b < o
          ? (r = .707106781, i = .707106781, s = 0)
          : (s = Math.sqrt(b), r = P / s, i = C / s),
          this.set(r, i, s, t),
          this;
      }
      let w = Math.sqrt(
        (_ - y) * (_ - y) + (h - v) * (h - v) + (p - d) * (p - d),
      );
      return Math.abs(w) < .001 && (w = 1),
        this.x = (_ - y) / w,
        this.y = (h - v) / w,
        this.z = (p - d) / w,
        this.w = Math.acos((f + g + S - 1) / 2),
        this;
    }
    min(e) {
      return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this;
    }
    max(e) {
      return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this;
    }
    clamp(e, t) {
      return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this;
    }
    clampScalar(e, t) {
      return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this;
    }
    clampLength(e, t) {
      let r = this.length();
      return this.divideScalar(r || 1).multiplyScalar(
        Math.max(e, Math.min(t, r)),
      );
    }
    floor() {
      return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this;
    }
    ceil() {
      return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this;
    }
    round() {
      return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
        this;
    }
    negate() {
      return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z +
        this.w * this.w;
    }
    length() {
      return Math.sqrt(
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w,
      );
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) +
        Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this;
    }
    lerpVectors(e, t, r) {
      return this.x = e.x + (t.x - e.x) * r,
        this.y = e.y + (t.y - e.y) * r,
        this.z = e.z + (t.z - e.z) * r,
        this.w = e.w + (t.w - e.w) * r,
        this;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y && e.z === this.z &&
        e.w === this.w;
    }
    fromArray(e, t = 0) {
      return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e;
    }
    fromBufferAttribute(e, t, r) {
      return r !== void 0 &&
        console.warn(
          "THREE.Vector4: offset has been removed from .fromBufferAttribute().",
        ),
        this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this;
    }
    random() {
      return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w;
    }
  },
  yr = class extends Xi {
    constructor(e, t, r = {}) {
      super();
      this.isWebGLRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new Lt(0, 0, e, t),
        this.scissorTest = !1,
        this.viewport = new Lt(0, 0, e, t);
      let i = { width: e, height: t, depth: 1 };
      this.texture = new Qt(
        i,
        r.mapping,
        r.wrapS,
        r.wrapT,
        r.magFilter,
        r.minFilter,
        r.format,
        r.type,
        r.anisotropy,
        r.encoding,
      ),
        this.texture.isRenderTargetTexture = !0,
        this.texture.flipY = !1,
        this.texture.generateMipmaps = r.generateMipmaps !== void 0
          ? r.generateMipmaps
          : !1,
        this.texture.internalFormat = r.internalFormat !== void 0
          ? r.internalFormat
          : null,
        this.texture.minFilter = r.minFilter !== void 0 ? r.minFilter : kt,
        this.depthBuffer = r.depthBuffer !== void 0 ? r.depthBuffer : !0,
        this.stencilBuffer = r.stencilBuffer !== void 0 ? r.stencilBuffer : !1,
        this.depthTexture = r.depthTexture !== void 0 ? r.depthTexture : null,
        this.samples = r.samples !== void 0 ? r.samples : 0;
    }
    setSize(e, t, r = 1) {
      (this.width !== e || this.height !== t || this.depth !== r) &&
      (this.width = e,
        this.height = t,
        this.depth = r,
        this.texture.image.width = e,
        this.texture.image.height = t,
        this.texture.image.depth = r,
        this.dispose()),
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.viewport.copy(e.viewport),
        this.texture = e.texture.clone(),
        this.texture.isRenderTargetTexture = !0;
      let t = Object.assign({}, e.texture.image);
      return this.texture.source = new Jo(t),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  },
  Ru = class extends Qt {
    constructor(e = null, t = 1, r = 1, i = 1) {
      super(null);
      this.isDataArrayTexture = !0,
        this.image = { data: e, width: t, height: r, depth: i },
        this.magFilter = Jt,
        this.minFilter = Jt,
        this.wrapR = Rn,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1;
    }
  },
  _C = class extends yr {
    constructor(e, t, r) {
      super(e, t);
      this.isWebGLArrayRenderTarget = !0,
        this.depth = r,
        this.texture = new Ru(null, e, t, r),
        this.texture.isRenderTargetTexture = !0;
    }
  },
  qf = class extends Qt {
    constructor(e = null, t = 1, r = 1, i = 1) {
      super(null);
      this.isData3DTexture = !0,
        this.image = { data: e, width: t, height: r, depth: i },
        this.magFilter = Jt,
        this.minFilter = Jt,
        this.wrapR = Rn,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1;
    }
  },
  SC = class extends yr {
    constructor(e, t, r) {
      super(e, t);
      this.isWebGL3DRenderTarget = !0,
        this.depth = r,
        this.texture = new qf(null, e, t, r),
        this.texture.isRenderTargetTexture = !0;
    }
  },
  wC = class extends yr {
    constructor(e, t, r, i = {}) {
      super(e, t, i);
      this.isWebGLMultipleRenderTargets = !0;
      let s = this.texture;
      this.texture = [];
      for (let o = 0; o < r; o++) {
        this.texture[o] = s.clone(), this.texture[o].isRenderTargetTexture = !0;
      }
    }
    setSize(e, t, r = 1) {
      if (this.width !== e || this.height !== t || this.depth !== r) {
        this.width = e, this.height = t, this.depth = r;
        for (let i = 0, s = this.texture.length; i < s; i++) {
          this.texture[i].image.width = e,
            this.texture[i].image.height = t,
            this.texture[i].image.depth = r;
        }
        this.dispose();
      }
      return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
    }
    copy(e) {
      this.dispose(),
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.viewport.set(0, 0, this.width, this.height),
        this.scissor.set(0, 0, this.width, this.height),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.texture.length = 0;
      for (let t = 0, r = e.texture.length; t < r; t++) {
        this.texture[t] = e.texture[t].clone(),
          this.texture[t].isRenderTargetTexture = !0;
      }
      return this;
    }
  },
  Pn = class {
    constructor(e = 0, t = 0, r = 0, i = 1) {
      this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = r,
        this._w = i;
    }
    static slerp(e, t, r, i) {
      return console.warn(
        "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.",
      ),
        r.slerpQuaternions(e, t, i);
    }
    static slerpFlat(e, t, r, i, s, o, a) {
      let u = r[i + 0],
        f = r[i + 1],
        d = r[i + 2],
        h = r[i + 3],
        p = s[o + 0],
        g = s[o + 1],
        y = s[o + 2],
        v = s[o + 3];
      if (a === 0) {
        e[t + 0] = u, e[t + 1] = f, e[t + 2] = d, e[t + 3] = h;
        return;
      }
      if (a === 1) {
        e[t + 0] = p, e[t + 1] = g, e[t + 2] = y, e[t + 3] = v;
        return;
      }
      if (h !== v || u !== p || f !== g || d !== y) {
        let _ = 1 - a,
          S = u * p + f * g + d * y + h * v,
          w = S >= 0 ? 1 : -1,
          M = 1 - S * S;
        if (M > Number.EPSILON) {
          let b = Math.sqrt(M), R = Math.atan2(b, S * w);
          _ = Math.sin(_ * R) / b, a = Math.sin(a * R) / b;
        }
        let T = a * w;
        if (
          u = u * _ + p * T,
            f = f * _ + g * T,
            d = d * _ + y * T,
            h = h * _ + v * T,
            _ === 1 - a
        ) {
          let b = 1 / Math.sqrt(u * u + f * f + d * d + h * h);
          u *= b, f *= b, d *= b, h *= b;
        }
      }
      e[t] = u, e[t + 1] = f, e[t + 2] = d, e[t + 3] = h;
    }
    static multiplyQuaternionsFlat(e, t, r, i, s, o) {
      let a = r[i],
        u = r[i + 1],
        f = r[i + 2],
        d = r[i + 3],
        h = s[o],
        p = s[o + 1],
        g = s[o + 2],
        y = s[o + 3];
      return e[t] = a * y + d * h + u * g - f * p,
        e[t + 1] = u * y + d * p + f * h - a * g,
        e[t + 2] = f * y + d * g + a * p - u * h,
        e[t + 3] = d * y - a * h - u * p - f * g,
        e;
    }
    get x() {
      return this._x;
    }
    set x(e) {
      this._x = e, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e) {
      this._y = e, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e) {
      this._z = e, this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(e) {
      this._w = e, this._onChangeCallback();
    }
    set(e, t, r, i) {
      return this._x = e,
        this._y = t,
        this._z = r,
        this._w = i,
        this._onChangeCallback(),
        this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(e) {
      return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this;
    }
    setFromEuler(e, t) {
      if (!(e && e.isEuler)) {
        throw new Error(
          "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.",
        );
      }
      let r = e._x,
        i = e._y,
        s = e._z,
        o = e._order,
        a = Math.cos,
        u = Math.sin,
        f = a(r / 2),
        d = a(i / 2),
        h = a(s / 2),
        p = u(r / 2),
        g = u(i / 2),
        y = u(s / 2);
      switch (o) {
        case "XYZ":
          this._x = p * d * h + f * g * y,
            this._y = f * g * h - p * d * y,
            this._z = f * d * y + p * g * h,
            this._w = f * d * h - p * g * y;
          break;
        case "YXZ":
          this._x = p * d * h + f * g * y,
            this._y = f * g * h - p * d * y,
            this._z = f * d * y - p * g * h,
            this._w = f * d * h + p * g * y;
          break;
        case "ZXY":
          this._x = p * d * h - f * g * y,
            this._y = f * g * h + p * d * y,
            this._z = f * d * y + p * g * h,
            this._w = f * d * h - p * g * y;
          break;
        case "ZYX":
          this._x = p * d * h - f * g * y,
            this._y = f * g * h + p * d * y,
            this._z = f * d * y - p * g * h,
            this._w = f * d * h + p * g * y;
          break;
        case "YZX":
          this._x = p * d * h + f * g * y,
            this._y = f * g * h + p * d * y,
            this._z = f * d * y - p * g * h,
            this._w = f * d * h - p * g * y;
          break;
        case "XZY":
          this._x = p * d * h - f * g * y,
            this._y = f * g * h - p * d * y,
            this._z = f * d * y + p * g * h,
            this._w = f * d * h + p * g * y;
          break;
        default:
          console.warn(
            "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
              o,
          );
      }
      return t !== !1 && this._onChangeCallback(), this;
    }
    setFromAxisAngle(e, t) {
      let r = t / 2, i = Math.sin(r);
      return this._x = e.x * i,
        this._y = e.y * i,
        this._z = e.z * i,
        this._w = Math.cos(r),
        this._onChangeCallback(),
        this;
    }
    setFromRotationMatrix(e) {
      let t = e.elements,
        r = t[0],
        i = t[4],
        s = t[8],
        o = t[1],
        a = t[5],
        u = t[9],
        f = t[2],
        d = t[6],
        h = t[10],
        p = r + a + h;
      if (p > 0) {
        let g = .5 / Math.sqrt(p + 1);
        this._w = .25 / g,
          this._x = (d - u) * g,
          this._y = (s - f) * g,
          this._z = (o - i) * g;
      } else if (r > a && r > h) {
        let g = 2 * Math.sqrt(1 + r - a - h);
        this._w = (d - u) / g,
          this._x = .25 * g,
          this._y = (i + o) / g,
          this._z = (s + f) / g;
      } else if (a > h) {
        let g = 2 * Math.sqrt(1 + a - r - h);
        this._w = (s - f) / g,
          this._x = (i + o) / g,
          this._y = .25 * g,
          this._z = (u + d) / g;
      } else {
        let g = 2 * Math.sqrt(1 + h - r - a);
        this._w = (o - i) / g,
          this._x = (s + f) / g,
          this._y = (u + d) / g,
          this._z = .25 * g;
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(e, t) {
      let r = e.dot(t) + 1;
      return r < Number.EPSILON
        ? (r = 0,
          Math.abs(e.x) > Math.abs(e.z)
            ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = r)
            : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = r))
        : (this._x = e.y * t.z - e.z * t.y,
          this._y = e.z * t.x - e.x * t.z,
          this._z = e.x * t.y - e.y * t.x,
          this._w = r),
        this.normalize();
    }
    angleTo(e) {
      return 2 * Math.acos(Math.abs(yn(this.dot(e), -1, 1)));
    }
    rotateTowards(e, t) {
      let r = this.angleTo(e);
      if (r === 0) return this;
      let i = Math.min(1, t / r);
      return this.slerp(e, i), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this;
    }
    dot(e) {
      return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z +
        this._w * this._w;
    }
    length() {
      return Math.sqrt(
        this._x * this._x + this._y * this._y + this._z * this._z +
          this._w * this._w,
      );
    }
    normalize() {
      let e = this.length();
      return e === 0
        ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1)
        : (e = 1 / e,
          this._x = this._x * e,
          this._y = this._y * e,
          this._z = this._z * e,
          this._w = this._w * e),
        this._onChangeCallback(),
        this;
    }
    multiply(e, t) {
      return t !== void 0
        ? (console.warn(
          "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.",
        ),
          this.multiplyQuaternions(e, t))
        : this.multiplyQuaternions(this, e);
    }
    premultiply(e) {
      return this.multiplyQuaternions(e, this);
    }
    multiplyQuaternions(e, t) {
      let r = e._x,
        i = e._y,
        s = e._z,
        o = e._w,
        a = t._x,
        u = t._y,
        f = t._z,
        d = t._w;
      return this._x = r * d + o * a + i * f - s * u,
        this._y = i * d + o * u + s * a - r * f,
        this._z = s * d + o * f + r * u - i * a,
        this._w = o * d - r * a - i * u - s * f,
        this._onChangeCallback(),
        this;
    }
    slerp(e, t) {
      if (t === 0) return this;
      if (t === 1) return this.copy(e);
      let r = this._x,
        i = this._y,
        s = this._z,
        o = this._w,
        a = o * e._w + r * e._x + i * e._y + s * e._z;
      if (
        a < 0
          ? (this._w = -e._w,
            this._x = -e._x,
            this._y = -e._y,
            this._z = -e._z,
            a = -a)
          : this.copy(e), a >= 1
      ) return this._w = o, this._x = r, this._y = i, this._z = s, this;
      let u = 1 - a * a;
      if (u <= Number.EPSILON) {
        let g = 1 - t;
        return this._w = g * o + t * this._w,
          this._x = g * r + t * this._x,
          this._y = g * i + t * this._y,
          this._z = g * s + t * this._z,
          this.normalize(),
          this._onChangeCallback(),
          this;
      }
      let f = Math.sqrt(u),
        d = Math.atan2(f, a),
        h = Math.sin((1 - t) * d) / f,
        p = Math.sin(t * d) / f;
      return this._w = o * h + this._w * p,
        this._x = r * h + this._x * p,
        this._y = i * h + this._y * p,
        this._z = s * h + this._z * p,
        this._onChangeCallback(),
        this;
    }
    slerpQuaternions(e, t, r) {
      return this.copy(e).slerp(t, r);
    }
    random() {
      let e = Math.random(),
        t = Math.sqrt(1 - e),
        r = Math.sqrt(e),
        i = 2 * Math.PI * Math.random(),
        s = 2 * Math.PI * Math.random();
      return this.set(
        t * Math.cos(i),
        r * Math.sin(s),
        r * Math.cos(s),
        t * Math.sin(i),
      );
    }
    equals(e) {
      return e._x === this._x && e._y === this._y && e._z === this._z &&
        e._w === this._w;
    }
    fromArray(e, t = 0) {
      return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e;
    }
    fromBufferAttribute(e, t) {
      return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this;
    }
    _onChange(e) {
      return this._onChangeCallback = e, this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._w;
    }
  },
  I = class {
    constructor(e = 0, t = 0, r = 0) {
      I.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = r;
    }
    set(e, t, r) {
      return r === void 0 && (r = this.z),
        this.x = e,
        this.y = t,
        this.z = r,
        this;
    }
    setScalar(e) {
      return this.x = e, this.y = e, this.z = e, this;
    }
    setX(e) {
      return this.x = e, this;
    }
    setY(e) {
      return this.y = e, this;
    }
    setZ(e) {
      return this.z = e, this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        case 2:
          this.z = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(e) {
      return this.x = e.x, this.y = e.y, this.z = e.z, this;
    }
    add(e, t) {
      return t !== void 0
        ? (console.warn(
          "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.",
        ),
          this.addVectors(e, t))
        : (this.x += e.x, this.y += e.y, this.z += e.z, this);
    }
    addScalar(e) {
      return this.x += e, this.y += e, this.z += e, this;
    }
    addVectors(e, t) {
      return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
    }
    addScaledVector(e, t) {
      return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
    }
    sub(e, t) {
      return t !== void 0
        ? (console.warn(
          "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.",
        ),
          this.subVectors(e, t))
        : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this);
    }
    subScalar(e) {
      return this.x -= e, this.y -= e, this.z -= e, this;
    }
    subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
    }
    multiply(e, t) {
      return t !== void 0
        ? (console.warn(
          "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.",
        ),
          this.multiplyVectors(e, t))
        : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this);
    }
    multiplyScalar(e) {
      return this.x *= e, this.y *= e, this.z *= e, this;
    }
    multiplyVectors(e, t) {
      return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
    }
    applyEuler(e) {
      return e && e.isEuler ||
        console.error(
          "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.",
        ),
        this.applyQuaternion(MC.setFromEuler(e));
    }
    applyAxisAngle(e, t) {
      return this.applyQuaternion(MC.setFromAxisAngle(e, t));
    }
    applyMatrix3(e) {
      let t = this.x, r = this.y, i = this.z, s = e.elements;
      return this.x = s[0] * t + s[3] * r + s[6] * i,
        this.y = s[1] * t + s[4] * r + s[7] * i,
        this.z = s[2] * t + s[5] * r + s[8] * i,
        this;
    }
    applyNormalMatrix(e) {
      return this.applyMatrix3(e).normalize();
    }
    applyMatrix4(e) {
      let t = this.x,
        r = this.y,
        i = this.z,
        s = e.elements,
        o = 1 / (s[3] * t + s[7] * r + s[11] * i + s[15]);
      return this.x = (s[0] * t + s[4] * r + s[8] * i + s[12]) * o,
        this.y = (s[1] * t + s[5] * r + s[9] * i + s[13]) * o,
        this.z = (s[2] * t + s[6] * r + s[10] * i + s[14]) * o,
        this;
    }
    applyQuaternion(e) {
      let t = this.x,
        r = this.y,
        i = this.z,
        s = e.x,
        o = e.y,
        a = e.z,
        u = e.w,
        f = u * t + o * i - a * r,
        d = u * r + a * t - s * i,
        h = u * i + s * r - o * t,
        p = -s * t - o * r - a * i;
      return this.x = f * u + p * -s + d * -a - h * -o,
        this.y = d * u + p * -o + h * -s - f * -a,
        this.z = h * u + p * -a + f * -o - d * -s,
        this;
    }
    project(e) {
      return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
        e.projectionMatrix,
      );
    }
    unproject(e) {
      return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
        e.matrixWorld,
      );
    }
    transformDirection(e) {
      let t = this.x, r = this.y, i = this.z, s = e.elements;
      return this.x = s[0] * t + s[4] * r + s[8] * i,
        this.y = s[1] * t + s[5] * r + s[9] * i,
        this.z = s[2] * t + s[6] * r + s[10] * i,
        this.normalize();
    }
    divide(e) {
      return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    min(e) {
      return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this;
    }
    max(e) {
      return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this;
    }
    clamp(e, t) {
      return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this;
    }
    clampScalar(e, t) {
      return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this;
    }
    clampLength(e, t) {
      let r = this.length();
      return this.divideScalar(r || 1).multiplyScalar(
        Math.max(e, Math.min(t, r)),
      );
    }
    floor() {
      return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this;
    }
    ceil() {
      return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this;
    }
    round() {
      return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y + this.z * e.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this;
    }
    lerpVectors(e, t, r) {
      return this.x = e.x + (t.x - e.x) * r,
        this.y = e.y + (t.y - e.y) * r,
        this.z = e.z + (t.z - e.z) * r,
        this;
    }
    cross(e, t) {
      return t !== void 0
        ? (console.warn(
          "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.",
        ),
          this.crossVectors(e, t))
        : this.crossVectors(this, e);
    }
    crossVectors(e, t) {
      let r = e.x, i = e.y, s = e.z, o = t.x, a = t.y, u = t.z;
      return this.x = i * u - s * a,
        this.y = s * o - r * u,
        this.z = r * a - i * o,
        this;
    }
    projectOnVector(e) {
      let t = e.lengthSq();
      if (t === 0) return this.set(0, 0, 0);
      let r = e.dot(this) / t;
      return this.copy(e).multiplyScalar(r);
    }
    projectOnPlane(e) {
      return Yx.copy(this).projectOnVector(e), this.sub(Yx);
    }
    reflect(e) {
      return this.sub(Yx.copy(e).multiplyScalar(2 * this.dot(e)));
    }
    angleTo(e) {
      let t = Math.sqrt(this.lengthSq() * e.lengthSq());
      if (t === 0) return Math.PI / 2;
      let r = this.dot(e) / t;
      return Math.acos(yn(r, -1, 1));
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
      let t = this.x - e.x, r = this.y - e.y, i = this.z - e.z;
      return t * t + r * r + i * i;
    }
    manhattanDistanceTo(e) {
      return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) +
        Math.abs(this.z - e.z);
    }
    setFromSpherical(e) {
      return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
    }
    setFromSphericalCoords(e, t, r) {
      let i = Math.sin(t) * e;
      return this.x = i * Math.sin(r),
        this.y = Math.cos(t) * e,
        this.z = i * Math.cos(r),
        this;
    }
    setFromCylindrical(e) {
      return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
    }
    setFromCylindricalCoords(e, t, r) {
      return this.x = e * Math.sin(t),
        this.y = r,
        this.z = e * Math.cos(t),
        this;
    }
    setFromMatrixPosition(e) {
      let t = e.elements;
      return this.x = t[12], this.y = t[13], this.z = t[14], this;
    }
    setFromMatrixScale(e) {
      let t = this.setFromMatrixColumn(e, 0).length(),
        r = this.setFromMatrixColumn(e, 1).length(),
        i = this.setFromMatrixColumn(e, 2).length();
      return this.x = t, this.y = r, this.z = i, this;
    }
    setFromMatrixColumn(e, t) {
      return this.fromArray(e.elements, t * 4);
    }
    setFromMatrix3Column(e, t) {
      return this.fromArray(e.elements, t * 3);
    }
    setFromEuler(e) {
      return this.x = e._x, this.y = e._y, this.z = e._z, this;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y && e.z === this.z;
    }
    fromArray(e, t = 0) {
      return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
    }
    fromBufferAttribute(e, t, r) {
      return r !== void 0 &&
        console.warn(
          "THREE.Vector3: offset has been removed from .fromBufferAttribute().",
        ),
        this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this;
    }
    random() {
      return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this;
    }
    randomDirection() {
      let e = (Math.random() - .5) * 2,
        t = Math.random() * Math.PI * 2,
        r = Math.sqrt(1 - e ** 2);
      return this.x = r * Math.cos(t),
        this.y = r * Math.sin(t),
        this.z = e,
        this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z;
    }
  },
  Yx = new I(),
  MC = new Pn(),
  Yi = class {
    constructor(
      e = new I(1 / 0, 1 / 0, 1 / 0),
      t = new I(-1 / 0, -1 / 0, -1 / 0),
    ) {
      this.isBox3 = !0, this.min = e, this.max = t;
    }
    set(e, t) {
      return this.min.copy(e), this.max.copy(t), this;
    }
    setFromArray(e) {
      let t = 1 / 0, r = 1 / 0, i = 1 / 0, s = -1 / 0, o = -1 / 0, a = -1 / 0;
      for (let u = 0, f = e.length; u < f; u += 3) {
        let d = e[u], h = e[u + 1], p = e[u + 2];
        d < t && (t = d),
          h < r && (r = h),
          p < i && (i = p),
          d > s && (s = d),
          h > o && (o = h),
          p > a && (a = p);
      }
      return this.min.set(t, r, i), this.max.set(s, o, a), this;
    }
    setFromBufferAttribute(e) {
      let t = 1 / 0, r = 1 / 0, i = 1 / 0, s = -1 / 0, o = -1 / 0, a = -1 / 0;
      for (let u = 0, f = e.count; u < f; u++) {
        let d = e.getX(u), h = e.getY(u), p = e.getZ(u);
        d < t && (t = d),
          h < r && (r = h),
          p < i && (i = p),
          d > s && (s = d),
          h > o && (o = h),
          p > a && (a = p);
      }
      return this.min.set(t, r, i), this.max.set(s, o, a), this;
    }
    setFromPoints(e) {
      this.makeEmpty();
      for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
      return this;
    }
    setFromCenterAndSize(e, t) {
      let r = ol.copy(t).multiplyScalar(.5);
      return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
    }
    setFromObject(e, t = !1) {
      return this.makeEmpty(), this.expandByObject(e, t);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.min.copy(e.min), this.max.copy(e.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y ||
        this.max.z < this.min.z;
    }
    getCenter(e) {
      return this.isEmpty()
        ? e.set(0, 0, 0)
        : e.addVectors(this.min, this.max).multiplyScalar(.5);
    }
    getSize(e) {
      return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
    }
    expandByPoint(e) {
      return this.min.min(e), this.max.max(e), this;
    }
    expandByVector(e) {
      return this.min.sub(e), this.max.add(e), this;
    }
    expandByScalar(e) {
      return this.min.addScalar(-e), this.max.addScalar(e), this;
    }
    expandByObject(e, t = !1) {
      e.updateWorldMatrix(!1, !1);
      let r = e.geometry;
      if (r !== void 0) {
        if (t && r.attributes != null && r.attributes.position !== void 0) {
          let s = r.attributes.position;
          for (let o = 0, a = s.count; o < a; o++) {
            ol.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld),
              this.expandByPoint(ol);
          }
        } else {r.boundingBox === null && r.computeBoundingBox(),
            Zx.copy(r.boundingBox),
            Zx.applyMatrix4(e.matrixWorld),
            this.union(Zx);}
      }
      let i = e.children;
      for (let s = 0, o = i.length; s < o; s++) this.expandByObject(i[s], t);
      return this;
    }
    containsPoint(e) {
      return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y ||
        e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
    }
    containsBox(e) {
      return this.min.x <= e.min.x && e.max.x <= this.max.x &&
        this.min.y <= e.min.y && e.max.y <= this.max.y &&
        this.min.z <= e.min.z && e.max.z <= this.max.z;
    }
    getParameter(e, t) {
      return t.set(
        (e.x - this.min.x) / (this.max.x - this.min.x),
        (e.y - this.min.y) / (this.max.y - this.min.y),
        (e.z - this.min.z) / (this.max.z - this.min.z),
      );
    }
    intersectsBox(e) {
      return !(e.max.x < this.min.x || e.min.x > this.max.x ||
        e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z ||
        e.min.z > this.max.z);
    }
    intersectsSphere(e) {
      return this.clampPoint(e.center, ol),
        ol.distanceToSquared(e.center) <= e.radius * e.radius;
    }
    intersectsPlane(e) {
      let t, r;
      return e.normal.x > 0
        ? (t = e.normal.x * this.min.x, r = e.normal.x * this.max.x)
        : (t = e.normal.x * this.max.x, r = e.normal.x * this.min.x),
        e.normal.y > 0
          ? (t += e.normal.y * this.min.y, r += e.normal.y * this.max.y)
          : (t += e.normal.y * this.max.y, r += e.normal.y * this.min.y),
        e.normal.z > 0
          ? (t += e.normal.z * this.min.z, r += e.normal.z * this.max.z)
          : (t += e.normal.z * this.max.z, r += e.normal.z * this.min.z),
        t <= -e.constant && r >= -e.constant;
    }
    intersectsTriangle(e) {
      if (this.isEmpty()) return !1;
      this.getCenter(Yf),
        dm.subVectors(this.max, Yf),
        Lu.subVectors(e.a, Yf),
        Pu.subVectors(e.b, Yf),
        Iu.subVectors(e.c, Yf),
        Qo.subVectors(Pu, Lu),
        $o.subVectors(Iu, Pu),
        al.subVectors(Lu, Iu);
      let t = [
        0,
        -Qo.z,
        Qo.y,
        0,
        -$o.z,
        $o.y,
        0,
        -al.z,
        al.y,
        Qo.z,
        0,
        -Qo.x,
        $o.z,
        0,
        -$o.x,
        al.z,
        0,
        -al.x,
        -Qo.y,
        Qo.x,
        0,
        -$o.y,
        $o.x,
        0,
        -al.y,
        al.x,
        0,
      ];
      return !Kx(t, Lu, Pu, Iu, dm) ||
          (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Kx(t, Lu, Pu, Iu, dm))
        ? !1
        : (hm.crossVectors(Qo, $o),
          t = [hm.x, hm.y, hm.z],
          Kx(t, Lu, Pu, Iu, dm));
    }
    clampPoint(e, t) {
      return t.copy(e).clamp(this.min, this.max);
    }
    distanceToPoint(e) {
      return ol.copy(e).clamp(this.min, this.max).sub(e).length();
    }
    getBoundingSphere(e) {
      return this.getCenter(e.center),
        e.radius = this.getSize(ol).length() * .5,
        e;
    }
    intersect(e) {
      return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this;
    }
    union(e) {
      return this.min.min(e.min), this.max.max(e.max), this;
    }
    applyMatrix4(e) {
      return this.isEmpty()
        ? this
        : (Ks[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
          Ks[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
          Ks[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
          Ks[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
          Ks[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
          Ks[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
          Ks[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
          Ks[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
          this.setFromPoints(Ks),
          this);
    }
    translate(e) {
      return this.min.add(e), this.max.add(e), this;
    }
    equals(e) {
      return e.min.equals(this.min) && e.max.equals(this.max);
    }
  },
  Ks = [new I(), new I(), new I(), new I(), new I(), new I(), new I(), new I()],
  ol = new I(),
  Zx = new Yi(),
  Lu = new I(),
  Pu = new I(),
  Iu = new I(),
  Qo = new I(),
  $o = new I(),
  al = new I(),
  Yf = new I(),
  dm = new I(),
  hm = new I(),
  ll = new I();
function Kx(n, e, t, r, i) {
  for (let s = 0, o = n.length - 3; s <= o; s += 3) {
    ll.fromArray(n, s);
    let a = i.x * Math.abs(ll.x) + i.y * Math.abs(ll.y) + i.z * Math.abs(ll.z),
      u = e.dot(ll),
      f = t.dot(ll),
      d = r.dot(ll);
    if (Math.max(-Math.max(u, f, d), Math.min(u, f, d)) > a) return !1;
  }
  return !0;
}
var xD = new Yi(),
  EC = new I(),
  pm = new I(),
  Jx = new I(),
  Zi = class {
    constructor(e = new I(), t = -1) {
      this.center = e, this.radius = t;
    }
    set(e, t) {
      return this.center.copy(e), this.radius = t, this;
    }
    setFromPoints(e, t) {
      let r = this.center;
      t !== void 0 ? r.copy(t) : xD.setFromPoints(e).getCenter(r);
      let i = 0;
      for (let s = 0, o = e.length; s < o; s++) {
        i = Math.max(i, r.distanceToSquared(e[s]));
      }
      return this.radius = Math.sqrt(i), this;
    }
    copy(e) {
      return this.center.copy(e.center), this.radius = e.radius, this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), this.radius = -1, this;
    }
    containsPoint(e) {
      return e.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(e) {
      return e.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(e) {
      let t = this.radius + e.radius;
      return e.center.distanceToSquared(this.center) <= t * t;
    }
    intersectsBox(e) {
      return e.intersectsSphere(this);
    }
    intersectsPlane(e) {
      return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(e, t) {
      let r = this.center.distanceToSquared(e);
      return t.copy(e),
        r > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
          t.multiplyScalar(this.radius).add(this.center)),
        t;
    }
    getBoundingBox(e) {
      return this.isEmpty()
        ? (e.makeEmpty(), e)
        : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
    }
    applyMatrix4(e) {
      return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this;
    }
    translate(e) {
      return this.center.add(e), this;
    }
    expandByPoint(e) {
      Jx.subVectors(e, this.center);
      let t = Jx.lengthSq();
      if (t > this.radius * this.radius) {
        let r = Math.sqrt(t), i = (r - this.radius) * .5;
        this.center.add(Jx.multiplyScalar(i / r)), this.radius += i;
      }
      return this;
    }
    union(e) {
      return this.center.equals(e.center) === !0
        ? pm.set(0, 0, 1).multiplyScalar(e.radius)
        : pm.subVectors(e.center, this.center).normalize().multiplyScalar(
          e.radius,
        ),
        this.expandByPoint(EC.copy(e.center).add(pm)),
        this.expandByPoint(EC.copy(e.center).sub(pm)),
        this;
    }
    equals(e) {
      return e.center.equals(this.center) && e.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  },
  Js = new I(),
  Qx = new I(),
  mm = new I(),
  ea = new I(),
  $x = new I(),
  gm = new I(),
  e_ = new I(),
  Nu = class {
    constructor(e = new I(), t = new I(0, 0, -1)) {
      this.origin = e, this.direction = t;
    }
    set(e, t) {
      return this.origin.copy(e), this.direction.copy(t), this;
    }
    copy(e) {
      return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
    }
    at(e, t) {
      return t.copy(this.direction).multiplyScalar(e).add(this.origin);
    }
    lookAt(e) {
      return this.direction.copy(e).sub(this.origin).normalize(), this;
    }
    recast(e) {
      return this.origin.copy(this.at(e, Js)), this;
    }
    closestPointToPoint(e, t) {
      t.subVectors(e, this.origin);
      let r = t.dot(this.direction);
      return r < 0
        ? t.copy(this.origin)
        : t.copy(this.direction).multiplyScalar(r).add(this.origin);
    }
    distanceToPoint(e) {
      return Math.sqrt(this.distanceSqToPoint(e));
    }
    distanceSqToPoint(e) {
      let t = Js.subVectors(e, this.origin).dot(this.direction);
      return t < 0
        ? this.origin.distanceToSquared(e)
        : (Js.copy(this.direction).multiplyScalar(t).add(this.origin),
          Js.distanceToSquared(e));
    }
    distanceSqToSegment(e, t, r, i) {
      Qx.copy(e).add(t).multiplyScalar(.5),
        mm.copy(t).sub(e).normalize(),
        ea.copy(this.origin).sub(Qx);
      let s = e.distanceTo(t) * .5,
        o = -this.direction.dot(mm),
        a = ea.dot(this.direction),
        u = -ea.dot(mm),
        f = ea.lengthSq(),
        d = Math.abs(1 - o * o),
        h,
        p,
        g,
        y;
      if (d > 0) {
        if (h = o * u - a, p = o * a - u, y = s * d, h >= 0) {
          if (p >= -y) {
            if (p <= y) {
              let v = 1 / d;
              h *= v,
                p *= v,
                g = h * (h + o * p + 2 * a) + p * (o * h + p + 2 * u) + f;
            } else {p = s,
                h = Math.max(0, -(o * p + a)),
                g = -h * h + p * (p + 2 * u) + f;}
          } else {p = -s,
              h = Math.max(0, -(o * p + a)),
              g = -h * h + p * (p + 2 * u) + f;}
        } else {p <= -y
            ? (h = Math.max(0, -(-o * s + a)),
              p = h > 0 ? -s : Math.min(Math.max(-s, -u), s),
              g = -h * h + p * (p + 2 * u) + f)
            : p <= y
            ? (h = 0,
              p = Math.min(Math.max(-s, -u), s),
              g = p * (p + 2 * u) + f)
            : (h = Math.max(0, -(o * s + a)),
              p = h > 0 ? s : Math.min(Math.max(-s, -u), s),
              g = -h * h + p * (p + 2 * u) + f);}
      } else {p = o > 0 ? -s : s,
          h = Math.max(0, -(o * p + a)),
          g = -h * h + p * (p + 2 * u) + f;}
      return r && r.copy(this.direction).multiplyScalar(h).add(this.origin),
        i && i.copy(mm).multiplyScalar(p).add(Qx),
        g;
    }
    intersectSphere(e, t) {
      Js.subVectors(e.center, this.origin);
      let r = Js.dot(this.direction),
        i = Js.dot(Js) - r * r,
        s = e.radius * e.radius;
      if (i > s) return null;
      let o = Math.sqrt(s - i), a = r - o, u = r + o;
      return a < 0 && u < 0 ? null : a < 0 ? this.at(u, t) : this.at(a, t);
    }
    intersectsSphere(e) {
      return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
    }
    distanceToPlane(e) {
      let t = e.normal.dot(this.direction);
      if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
      let r = -(this.origin.dot(e.normal) + e.constant) / t;
      return r >= 0 ? r : null;
    }
    intersectPlane(e, t) {
      let r = this.distanceToPlane(e);
      return r === null ? null : this.at(r, t);
    }
    intersectsPlane(e) {
      let t = e.distanceToPoint(this.origin);
      return t === 0 || e.normal.dot(this.direction) * t < 0;
    }
    intersectBox(e, t) {
      let r,
        i,
        s,
        o,
        a,
        u,
        f = 1 / this.direction.x,
        d = 1 / this.direction.y,
        h = 1 / this.direction.z,
        p = this.origin;
      return f >= 0
        ? (r = (e.min.x - p.x) * f, i = (e.max.x - p.x) * f)
        : (r = (e.max.x - p.x) * f, i = (e.min.x - p.x) * f),
        d >= 0
          ? (s = (e.min.y - p.y) * d, o = (e.max.y - p.y) * d)
          : (s = (e.max.y - p.y) * d, o = (e.min.y - p.y) * d),
        r > o || s > i ||
          ((s > r || r !== r) && (r = s),
            (o < i || i !== i) && (i = o),
            h >= 0
              ? (a = (e.min.z - p.z) * h, u = (e.max.z - p.z) * h)
              : (a = (e.max.z - p.z) * h, u = (e.min.z - p.z) * h),
            r > u || a > i) ||
          ((a > r || r !== r) && (r = a), (u < i || i !== i) && (i = u), i < 0)
          ? null
          : this.at(r >= 0 ? r : i, t);
    }
    intersectsBox(e) {
      return this.intersectBox(e, Js) !== null;
    }
    intersectTriangle(e, t, r, i, s) {
      $x.subVectors(t, e), gm.subVectors(r, e), e_.crossVectors($x, gm);
      let o = this.direction.dot(e_), a;
      if (o > 0) {
        if (i) return null;
        a = 1;
      } else if (o < 0) a = -1, o = -o;
      else return null;
      ea.subVectors(this.origin, e);
      let u = a * this.direction.dot(gm.crossVectors(ea, gm));
      if (u < 0) return null;
      let f = a * this.direction.dot($x.cross(ea));
      if (f < 0 || u + f > o) return null;
      let d = -a * ea.dot(e_);
      return d < 0 ? null : this.at(d / o, s);
    }
    applyMatrix4(e) {
      return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this;
    }
    equals(e) {
      return e.origin.equals(this.origin) && e.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  },
  Ge = class {
    constructor() {
      Ge.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        arguments.length > 0 &&
        console.error(
          "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.",
        );
    }
    set(e, t, r, i, s, o, a, u, f, d, h, p, g, y, v, _) {
      let S = this.elements;
      return S[0] = e,
        S[4] = t,
        S[8] = r,
        S[12] = i,
        S[1] = s,
        S[5] = o,
        S[9] = a,
        S[13] = u,
        S[2] = f,
        S[6] = d,
        S[10] = h,
        S[14] = p,
        S[3] = g,
        S[7] = y,
        S[11] = v,
        S[15] = _,
        this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new Ge().fromArray(this.elements);
    }
    copy(e) {
      let t = this.elements, r = e.elements;
      return t[0] = r[0],
        t[1] = r[1],
        t[2] = r[2],
        t[3] = r[3],
        t[4] = r[4],
        t[5] = r[5],
        t[6] = r[6],
        t[7] = r[7],
        t[8] = r[8],
        t[9] = r[9],
        t[10] = r[10],
        t[11] = r[11],
        t[12] = r[12],
        t[13] = r[13],
        t[14] = r[14],
        t[15] = r[15],
        this;
    }
    copyPosition(e) {
      let t = this.elements, r = e.elements;
      return t[12] = r[12], t[13] = r[13], t[14] = r[14], this;
    }
    setFromMatrix3(e) {
      let t = e.elements;
      return this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1,
      ),
        this;
    }
    extractBasis(e, t, r) {
      return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        r.setFromMatrixColumn(this, 2),
        this;
    }
    makeBasis(e, t, r) {
      return this.set(
        e.x,
        t.x,
        r.x,
        0,
        e.y,
        t.y,
        r.y,
        0,
        e.z,
        t.z,
        r.z,
        0,
        0,
        0,
        0,
        1,
      ),
        this;
    }
    extractRotation(e) {
      let t = this.elements,
        r = e.elements,
        i = 1 / Du.setFromMatrixColumn(e, 0).length(),
        s = 1 / Du.setFromMatrixColumn(e, 1).length(),
        o = 1 / Du.setFromMatrixColumn(e, 2).length();
      return t[0] = r[0] * i,
        t[1] = r[1] * i,
        t[2] = r[2] * i,
        t[3] = 0,
        t[4] = r[4] * s,
        t[5] = r[5] * s,
        t[6] = r[6] * s,
        t[7] = 0,
        t[8] = r[8] * o,
        t[9] = r[9] * o,
        t[10] = r[10] * o,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this;
    }
    makeRotationFromEuler(e) {
      e && e.isEuler ||
        console.error(
          "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.",
        );
      let t = this.elements,
        r = e.x,
        i = e.y,
        s = e.z,
        o = Math.cos(r),
        a = Math.sin(r),
        u = Math.cos(i),
        f = Math.sin(i),
        d = Math.cos(s),
        h = Math.sin(s);
      if (e.order === "XYZ") {
        let p = o * d, g = o * h, y = a * d, v = a * h;
        t[0] = u * d,
          t[4] = -u * h,
          t[8] = f,
          t[1] = g + y * f,
          t[5] = p - v * f,
          t[9] = -a * u,
          t[2] = v - p * f,
          t[6] = y + g * f,
          t[10] = o * u;
      } else if (e.order === "YXZ") {
        let p = u * d, g = u * h, y = f * d, v = f * h;
        t[0] = p + v * a,
          t[4] = y * a - g,
          t[8] = o * f,
          t[1] = o * h,
          t[5] = o * d,
          t[9] = -a,
          t[2] = g * a - y,
          t[6] = v + p * a,
          t[10] = o * u;
      } else if (e.order === "ZXY") {
        let p = u * d, g = u * h, y = f * d, v = f * h;
        t[0] = p - v * a,
          t[4] = -o * h,
          t[8] = y + g * a,
          t[1] = g + y * a,
          t[5] = o * d,
          t[9] = v - p * a,
          t[2] = -o * f,
          t[6] = a,
          t[10] = o * u;
      } else if (e.order === "ZYX") {
        let p = o * d, g = o * h, y = a * d, v = a * h;
        t[0] = u * d,
          t[4] = y * f - g,
          t[8] = p * f + v,
          t[1] = u * h,
          t[5] = v * f + p,
          t[9] = g * f - y,
          t[2] = -f,
          t[6] = a * u,
          t[10] = o * u;
      } else if (e.order === "YZX") {
        let p = o * u, g = o * f, y = a * u, v = a * f;
        t[0] = u * d,
          t[4] = v - p * h,
          t[8] = y * h + g,
          t[1] = h,
          t[5] = o * d,
          t[9] = -a * d,
          t[2] = -f * d,
          t[6] = g * h + y,
          t[10] = p - v * h;
      } else if (e.order === "XZY") {
        let p = o * u, g = o * f, y = a * u, v = a * f;
        t[0] = u * d,
          t[4] = -h,
          t[8] = f * d,
          t[1] = p * h + v,
          t[5] = o * d,
          t[9] = g * h - y,
          t[2] = y * h - g,
          t[6] = a * d,
          t[10] = v * h + p;
      }
      return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this;
    }
    makeRotationFromQuaternion(e) {
      return this.compose(_D, e, SD);
    }
    lookAt(e, t, r) {
      let i = this.elements;
      return Jr.subVectors(e, t),
        Jr.lengthSq() === 0 && (Jr.z = 1),
        Jr.normalize(),
        ta.crossVectors(r, Jr),
        ta.lengthSq() === 0 &&
        (Math.abs(r.z) === 1 ? Jr.x += 1e-4 : Jr.z += 1e-4,
          Jr.normalize(),
          ta.crossVectors(r, Jr)),
        ta.normalize(),
        vm.crossVectors(Jr, ta),
        i[0] = ta.x,
        i[4] = vm.x,
        i[8] = Jr.x,
        i[1] = ta.y,
        i[5] = vm.y,
        i[9] = Jr.y,
        i[2] = ta.z,
        i[6] = vm.z,
        i[10] = Jr.z,
        this;
    }
    multiply(e, t) {
      return t !== void 0
        ? (console.warn(
          "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.",
        ),
          this.multiplyMatrices(e, t))
        : this.multiplyMatrices(this, e);
    }
    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
      let r = e.elements,
        i = t.elements,
        s = this.elements,
        o = r[0],
        a = r[4],
        u = r[8],
        f = r[12],
        d = r[1],
        h = r[5],
        p = r[9],
        g = r[13],
        y = r[2],
        v = r[6],
        _ = r[10],
        S = r[14],
        w = r[3],
        M = r[7],
        T = r[11],
        b = r[15],
        R = i[0],
        P = i[4],
        C = i[8],
        L = i[12],
        k = i[1],
        z = i[5],
        Y = i[9],
        le = i[13],
        V = i[2],
        W = i[6],
        G = i[10],
        re = i[14],
        ie = i[3],
        X = i[7],
        $ = i[11],
        ae = i[15];
      return s[0] = o * R + a * k + u * V + f * ie,
        s[4] = o * P + a * z + u * W + f * X,
        s[8] = o * C + a * Y + u * G + f * $,
        s[12] = o * L + a * le + u * re + f * ae,
        s[1] = d * R + h * k + p * V + g * ie,
        s[5] = d * P + h * z + p * W + g * X,
        s[9] = d * C + h * Y + p * G + g * $,
        s[13] = d * L + h * le + p * re + g * ae,
        s[2] = y * R + v * k + _ * V + S * ie,
        s[6] = y * P + v * z + _ * W + S * X,
        s[10] = y * C + v * Y + _ * G + S * $,
        s[14] = y * L + v * le + _ * re + S * ae,
        s[3] = w * R + M * k + T * V + b * ie,
        s[7] = w * P + M * z + T * W + b * X,
        s[11] = w * C + M * Y + T * G + b * $,
        s[15] = w * L + M * le + T * re + b * ae,
        this;
    }
    multiplyScalar(e) {
      let t = this.elements;
      return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this;
    }
    determinant() {
      let e = this.elements,
        t = e[0],
        r = e[4],
        i = e[8],
        s = e[12],
        o = e[1],
        a = e[5],
        u = e[9],
        f = e[13],
        d = e[2],
        h = e[6],
        p = e[10],
        g = e[14],
        y = e[3],
        v = e[7],
        _ = e[11],
        S = e[15];
      return y *
          (+s * u * h - i * f * h - s * a * p + r * f * p + i * a * g -
            r * u * g) +
        v *
          (+t * u * g - t * f * p + s * o * p - i * o * g + i * f * d -
            s * u * d) +
        _ *
          (+t * f * h - t * a * g - s * o * h + r * o * g + s * a * d -
            r * f * d) +
        S *
          (-i * a * d - t * u * h + t * a * p + i * o * h - r * o * p +
            r * u * d);
    }
    transpose() {
      let e = this.elements, t;
      return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this;
    }
    setPosition(e, t, r) {
      let i = this.elements;
      return e.isVector3
        ? (i[12] = e.x, i[13] = e.y, i[14] = e.z)
        : (i[12] = e, i[13] = t, i[14] = r),
        this;
    }
    invert() {
      let e = this.elements,
        t = e[0],
        r = e[1],
        i = e[2],
        s = e[3],
        o = e[4],
        a = e[5],
        u = e[6],
        f = e[7],
        d = e[8],
        h = e[9],
        p = e[10],
        g = e[11],
        y = e[12],
        v = e[13],
        _ = e[14],
        S = e[15],
        w = h * _ * f - v * p * f + v * u * g - a * _ * g - h * u * S +
          a * p * S,
        M = y * p * f - d * _ * f - y * u * g + o * _ * g + d * u * S -
          o * p * S,
        T = d * v * f - y * h * f + y * a * g - o * v * g - d * a * S +
          o * h * S,
        b = y * h * u - d * v * u - y * a * p + o * v * p + d * a * _ -
          o * h * _,
        R = t * w + r * M + i * T + s * b;
      if (R === 0) {
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
      let P = 1 / R;
      return e[0] = w * P,
        e[1] =
          (v * p * s - h * _ * s - v * i * g + r * _ * g + h * i * S -
            r * p * S) * P,
        e[2] =
          (a * _ * s - v * u * s + v * i * f - r * _ * f - a * i * S +
            r * u * S) * P,
        e[3] =
          (h * u * s - a * p * s - h * i * f + r * p * f + a * i * g -
            r * u * g) * P,
        e[4] = M * P,
        e[5] =
          (d * _ * s - y * p * s + y * i * g - t * _ * g - d * i * S +
            t * p * S) * P,
        e[6] =
          (y * u * s - o * _ * s - y * i * f + t * _ * f + o * i * S -
            t * u * S) * P,
        e[7] =
          (o * p * s - d * u * s + d * i * f - t * p * f - o * i * g +
            t * u * g) * P,
        e[8] = T * P,
        e[9] =
          (y * h * s - d * v * s - y * r * g + t * v * g + d * r * S -
            t * h * S) * P,
        e[10] =
          (o * v * s - y * a * s + y * r * f - t * v * f - o * r * S +
            t * a * S) * P,
        e[11] =
          (d * a * s - o * h * s - d * r * f + t * h * f + o * r * g -
            t * a * g) * P,
        e[12] = b * P,
        e[13] =
          (d * v * i - y * h * i + y * r * p - t * v * p - d * r * _ +
            t * h * _) * P,
        e[14] =
          (y * a * i - o * v * i - y * r * u + t * v * u + o * r * _ -
            t * a * _) * P,
        e[15] =
          (o * h * i - d * a * i + d * r * u - t * h * u - o * r * p +
            t * a * p) * P,
        this;
    }
    scale(e) {
      let t = this.elements, r = e.x, i = e.y, s = e.z;
      return t[0] *= r,
        t[4] *= i,
        t[8] *= s,
        t[1] *= r,
        t[5] *= i,
        t[9] *= s,
        t[2] *= r,
        t[6] *= i,
        t[10] *= s,
        t[3] *= r,
        t[7] *= i,
        t[11] *= s,
        this;
    }
    getMaxScaleOnAxis() {
      let e = this.elements,
        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
        r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
        i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
      return Math.sqrt(Math.max(t, r, i));
    }
    makeTranslation(e, t, r) {
      return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1), this;
    }
    makeRotationX(e) {
      let t = Math.cos(e), r = Math.sin(e);
      return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(e) {
      let t = Math.cos(e), r = Math.sin(e);
      return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(e) {
      let t = Math.cos(e), r = Math.sin(e);
      return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(e, t) {
      let r = Math.cos(t),
        i = Math.sin(t),
        s = 1 - r,
        o = e.x,
        a = e.y,
        u = e.z,
        f = s * o,
        d = s * a;
      return this.set(
        f * o + r,
        f * a - i * u,
        f * u + i * a,
        0,
        f * a + i * u,
        d * a + r,
        d * u - i * o,
        0,
        f * u - i * a,
        d * u + i * o,
        s * u * u + r,
        0,
        0,
        0,
        0,
        1,
      ),
        this;
    }
    makeScale(e, t, r) {
      return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this;
    }
    makeShear(e, t, r, i, s, o) {
      return this.set(1, r, s, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this;
    }
    compose(e, t, r) {
      let i = this.elements,
        s = t._x,
        o = t._y,
        a = t._z,
        u = t._w,
        f = s + s,
        d = o + o,
        h = a + a,
        p = s * f,
        g = s * d,
        y = s * h,
        v = o * d,
        _ = o * h,
        S = a * h,
        w = u * f,
        M = u * d,
        T = u * h,
        b = r.x,
        R = r.y,
        P = r.z;
      return i[0] = (1 - (v + S)) * b,
        i[1] = (g + T) * b,
        i[2] = (y - M) * b,
        i[3] = 0,
        i[4] = (g - T) * R,
        i[5] = (1 - (p + S)) * R,
        i[6] = (_ + w) * R,
        i[7] = 0,
        i[8] = (y + M) * P,
        i[9] = (_ - w) * P,
        i[10] = (1 - (p + v)) * P,
        i[11] = 0,
        i[12] = e.x,
        i[13] = e.y,
        i[14] = e.z,
        i[15] = 1,
        this;
    }
    decompose(e, t, r) {
      let i = this.elements,
        s = Du.set(i[0], i[1], i[2]).length(),
        o = Du.set(i[4], i[5], i[6]).length(),
        a = Du.set(i[8], i[9], i[10]).length();
      this.determinant() < 0 && (s = -s),
        e.x = i[12],
        e.y = i[13],
        e.z = i[14],
        Ki.copy(this);
      let f = 1 / s, d = 1 / o, h = 1 / a;
      return Ki.elements[0] *= f,
        Ki.elements[1] *= f,
        Ki.elements[2] *= f,
        Ki.elements[4] *= d,
        Ki.elements[5] *= d,
        Ki.elements[6] *= d,
        Ki.elements[8] *= h,
        Ki.elements[9] *= h,
        Ki.elements[10] *= h,
        t.setFromRotationMatrix(Ki),
        r.x = s,
        r.y = o,
        r.z = a,
        this;
    }
    makePerspective(e, t, r, i, s, o) {
      o === void 0 &&
        console.warn(
          "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.",
        );
      let a = this.elements,
        u = 2 * s / (t - e),
        f = 2 * s / (r - i),
        d = (t + e) / (t - e),
        h = (r + i) / (r - i),
        p = -(o + s) / (o - s),
        g = -2 * o * s / (o - s);
      return a[0] = u,
        a[4] = 0,
        a[8] = d,
        a[12] = 0,
        a[1] = 0,
        a[5] = f,
        a[9] = h,
        a[13] = 0,
        a[2] = 0,
        a[6] = 0,
        a[10] = p,
        a[14] = g,
        a[3] = 0,
        a[7] = 0,
        a[11] = -1,
        a[15] = 0,
        this;
    }
    makeOrthographic(e, t, r, i, s, o) {
      let a = this.elements,
        u = 1 / (t - e),
        f = 1 / (r - i),
        d = 1 / (o - s),
        h = (t + e) * u,
        p = (r + i) * f,
        g = (o + s) * d;
      return a[0] = 2 * u,
        a[4] = 0,
        a[8] = 0,
        a[12] = -h,
        a[1] = 0,
        a[5] = 2 * f,
        a[9] = 0,
        a[13] = -p,
        a[2] = 0,
        a[6] = 0,
        a[10] = -2 * d,
        a[14] = -g,
        a[3] = 0,
        a[7] = 0,
        a[11] = 0,
        a[15] = 1,
        this;
    }
    equals(e) {
      let t = this.elements, r = e.elements;
      for (let i = 0; i < 16; i++) if (t[i] !== r[i]) return !1;
      return !0;
    }
    fromArray(e, t = 0) {
      for (let r = 0; r < 16; r++) this.elements[r] = e[r + t];
      return this;
    }
    toArray(e = [], t = 0) {
      let r = this.elements;
      return e[t] = r[0],
        e[t + 1] = r[1],
        e[t + 2] = r[2],
        e[t + 3] = r[3],
        e[t + 4] = r[4],
        e[t + 5] = r[5],
        e[t + 6] = r[6],
        e[t + 7] = r[7],
        e[t + 8] = r[8],
        e[t + 9] = r[9],
        e[t + 10] = r[10],
        e[t + 11] = r[11],
        e[t + 12] = r[12],
        e[t + 13] = r[13],
        e[t + 14] = r[14],
        e[t + 15] = r[15],
        e;
    }
  },
  Du = new I(),
  Ki = new Ge(),
  _D = new I(0, 0, 0),
  SD = new I(1, 1, 1),
  ta = new I(),
  vm = new I(),
  Jr = new I(),
  TC = new Ge(),
  AC = new Pn(),
  ul = class {
    constructor(e = 0, t = 0, r = 0, i = ul.DefaultOrder) {
      this.isEuler = !0, this._x = e, this._y = t, this._z = r, this._order = i;
    }
    get x() {
      return this._x;
    }
    set x(e) {
      this._x = e, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e) {
      this._y = e, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e) {
      this._z = e, this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(e) {
      this._order = e, this._onChangeCallback();
    }
    set(e, t, r, i = this._order) {
      return this._x = e,
        this._y = t,
        this._z = r,
        this._order = i,
        this._onChangeCallback(),
        this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(e) {
      return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this;
    }
    setFromRotationMatrix(e, t = this._order, r = !0) {
      let i = e.elements,
        s = i[0],
        o = i[4],
        a = i[8],
        u = i[1],
        f = i[5],
        d = i[9],
        h = i[2],
        p = i[6],
        g = i[10];
      switch (t) {
        case "XYZ":
          this._y = Math.asin(yn(a, -1, 1)),
            Math.abs(a) < .9999999
              ? (this._x = Math.atan2(-d, g), this._z = Math.atan2(-o, s))
              : (this._x = Math.atan2(p, f), this._z = 0);
          break;
        case "YXZ":
          this._x = Math.asin(-yn(d, -1, 1)),
            Math.abs(d) < .9999999
              ? (this._y = Math.atan2(a, g), this._z = Math.atan2(u, f))
              : (this._y = Math.atan2(-h, s), this._z = 0);
          break;
        case "ZXY":
          this._x = Math.asin(yn(p, -1, 1)),
            Math.abs(p) < .9999999
              ? (this._y = Math.atan2(-h, g), this._z = Math.atan2(-o, f))
              : (this._y = 0, this._z = Math.atan2(u, s));
          break;
        case "ZYX":
          this._y = Math.asin(-yn(h, -1, 1)),
            Math.abs(h) < .9999999
              ? (this._x = Math.atan2(p, g), this._z = Math.atan2(u, s))
              : (this._x = 0, this._z = Math.atan2(-o, f));
          break;
        case "YZX":
          this._z = Math.asin(yn(u, -1, 1)),
            Math.abs(u) < .9999999
              ? (this._x = Math.atan2(-d, f), this._y = Math.atan2(-h, s))
              : (this._x = 0, this._y = Math.atan2(a, g));
          break;
        case "XZY":
          this._z = Math.asin(-yn(o, -1, 1)),
            Math.abs(o) < .9999999
              ? (this._x = Math.atan2(p, f), this._y = Math.atan2(a, s))
              : (this._x = Math.atan2(-d, g), this._y = 0);
          break;
        default:
          console.warn(
            "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
              t,
          );
      }
      return this._order = t, r === !0 && this._onChangeCallback(), this;
    }
    setFromQuaternion(e, t, r) {
      return TC.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(TC, t, r);
    }
    setFromVector3(e, t = this._order) {
      return this.set(e.x, e.y, e.z, t);
    }
    reorder(e) {
      return AC.setFromEuler(this), this.setFromQuaternion(AC, e);
    }
    equals(e) {
      return e._x === this._x && e._y === this._y && e._z === this._z &&
        e._order === this._order;
    }
    fromArray(e) {
      return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e;
    }
    _onChange(e) {
      return this._onChangeCallback = e, this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._order;
    }
    toVector3() {
      console.error(
        "THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead",
      );
    }
  };
ul.DefaultOrder = "XYZ";
ul.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
var na = class {
    constructor() {
      this.mask = 1 | 0;
    }
    set(e) {
      this.mask = (1 << e | 0) >>> 0;
    }
    enable(e) {
      this.mask |= 1 << e | 0;
    }
    enableAll() {
      this.mask = 4294967295 | 0;
    }
    toggle(e) {
      this.mask ^= 1 << e | 0;
    }
    disable(e) {
      this.mask &= ~(1 << e | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(e) {
      return (this.mask & e.mask) != 0;
    }
    isEnabled(e) {
      return (this.mask & (1 << e | 0)) != 0;
    }
  },
  wD = 0,
  CC = new I(),
  ku = new Pn(),
  Qs = new Ge(),
  ym = new I(),
  Zf = new I(),
  MD = new I(),
  ED = new Pn(),
  bC = new I(1, 0, 0),
  RC = new I(0, 1, 0),
  LC = new I(0, 0, 1),
  TD = { type: "added" },
  PC = { type: "removed" },
  ct = class extends Xi {
    constructor() {
      super();
      this.isObject3D = !0,
        Object.defineProperty(this, "id", { value: wD++ }),
        this.uuid = Kr(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = ct.DefaultUp.clone();
      let e = new I(), t = new ul(), r = new Pn(), i = new I(1, 1, 1);
      function s() {
        r.setFromEuler(t, !1);
      }
      function o() {
        t.setFromQuaternion(r, void 0, !1);
      }
      t._onChange(s),
        r._onChange(o),
        Object.defineProperties(this, {
          position: { configurable: !0, enumerable: !0, value: e },
          rotation: { configurable: !0, enumerable: !0, value: t },
          quaternion: { configurable: !0, enumerable: !0, value: r },
          scale: { configurable: !0, enumerable: !0, value: i },
          modelViewMatrix: { value: new Ge() },
          normalMatrix: { value: new vr() },
        }),
        this.matrix = new Ge(),
        this.matrixWorld = new Ge(),
        this.matrixAutoUpdate = ct.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new na(),
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {};
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
      this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(e) {
      return this.quaternion.premultiply(e), this;
    }
    setRotationFromAxisAngle(e, t) {
      this.quaternion.setFromAxisAngle(e, t);
    }
    setRotationFromEuler(e) {
      this.quaternion.setFromEuler(e, !0);
    }
    setRotationFromMatrix(e) {
      this.quaternion.setFromRotationMatrix(e);
    }
    setRotationFromQuaternion(e) {
      this.quaternion.copy(e);
    }
    rotateOnAxis(e, t) {
      return ku.setFromAxisAngle(e, t), this.quaternion.multiply(ku), this;
    }
    rotateOnWorldAxis(e, t) {
      return ku.setFromAxisAngle(e, t), this.quaternion.premultiply(ku), this;
    }
    rotateX(e) {
      return this.rotateOnAxis(bC, e);
    }
    rotateY(e) {
      return this.rotateOnAxis(RC, e);
    }
    rotateZ(e) {
      return this.rotateOnAxis(LC, e);
    }
    translateOnAxis(e, t) {
      return CC.copy(e).applyQuaternion(this.quaternion),
        this.position.add(CC.multiplyScalar(t)),
        this;
    }
    translateX(e) {
      return this.translateOnAxis(bC, e);
    }
    translateY(e) {
      return this.translateOnAxis(RC, e);
    }
    translateZ(e) {
      return this.translateOnAxis(LC, e);
    }
    localToWorld(e) {
      return e.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(e) {
      return e.applyMatrix4(Qs.copy(this.matrixWorld).invert());
    }
    lookAt(e, t, r) {
      e.isVector3 ? ym.copy(e) : ym.set(e, t, r);
      let i = this.parent;
      this.updateWorldMatrix(!0, !1),
        Zf.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight
          ? Qs.lookAt(Zf, ym, this.up)
          : Qs.lookAt(ym, Zf, this.up),
        this.quaternion.setFromRotationMatrix(Qs),
        i &&
        (Qs.extractRotation(i.matrixWorld),
          ku.setFromRotationMatrix(Qs),
          this.quaternion.premultiply(ku.invert()));
    }
    add(e) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
        return this;
      }
      return e === this
        ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e,
        ),
          this)
        : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            e.parent = this,
            this.children.push(e),
            e.dispatchEvent(TD))
          : console.error(
            "THREE.Object3D.add: object not an instance of THREE.Object3D.",
            e,
          ),
          this);
    }
    remove(e) {
      if (arguments.length > 1) {
        for (let r = 0; r < arguments.length; r++) this.remove(arguments[r]);
        return this;
      }
      let t = this.children.indexOf(e);
      return t !== -1 &&
        (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(PC)),
        this;
    }
    removeFromParent() {
      let e = this.parent;
      return e !== null && e.remove(this), this;
    }
    clear() {
      for (let e = 0; e < this.children.length; e++) {
        let t = this.children[e];
        t.parent = null, t.dispatchEvent(PC);
      }
      return this.children.length = 0, this;
    }
    attach(e) {
      return this.updateWorldMatrix(!0, !1),
        Qs.copy(this.matrixWorld).invert(),
        e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Qs.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(Qs),
        this.add(e),
        e.updateWorldMatrix(!1, !0),
        this;
    }
    getObjectById(e) {
      return this.getObjectByProperty("id", e);
    }
    getObjectByName(e) {
      return this.getObjectByProperty("name", e);
    }
    getObjectByProperty(e, t) {
      if (this[e] === t) return this;
      for (let r = 0, i = this.children.length; r < i; r++) {
        let o = this.children[r].getObjectByProperty(e, t);
        if (o !== void 0) return o;
      }
    }
    getWorldPosition(e) {
      return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(e) {
      return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Zf, e, MD),
        e;
    }
    getWorldScale(e) {
      return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Zf, ED, e),
        e;
    }
    getWorldDirection(e) {
      this.updateWorldMatrix(!0, !1);
      let t = this.matrixWorld.elements;
      return e.set(t[8], t[9], t[10]).normalize();
    }
    raycast() {}
    traverse(e) {
      e(this);
      let t = this.children;
      for (let r = 0, i = t.length; r < i; r++) t[r].traverse(e);
    }
    traverseVisible(e) {
      if (this.visible === !1) return;
      e(this);
      let t = this.children;
      for (let r = 0, i = t.length; r < i; r++) t[r].traverseVisible(e);
    }
    traverseAncestors(e) {
      let t = this.parent;
      t !== null && (e(t), t.traverseAncestors(e));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0;
    }
    updateMatrixWorld(e) {
      this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix,
          ),
          this.matrixWorldNeedsUpdate = !1,
          e = !0);
      let t = this.children;
      for (let r = 0, i = t.length; r < i; r++) t[r].updateMatrixWorld(e);
    }
    updateWorldMatrix(e, t) {
      let r = this.parent;
      if (
        e === !0 && r !== null && r.updateWorldMatrix(!0, !1),
          this.matrixAutoUpdate && this.updateMatrix(),
          this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix,
            ),
          t === !0
      ) {
        let i = this.children;
        for (let s = 0, o = i.length; s < o; s++) {
          i[s].updateWorldMatrix(!1, !0);
        }
      }
    }
    toJSON(e) {
      let t = e === void 0 || typeof e == "string", r = {};
      t &&
        (e = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          nodes: {},
        },
          r.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON",
          });
      let i = {};
      i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.castShadow === !0 && (i.castShadow = !0),
        this.receiveShadow === !0 && (i.receiveShadow = !0),
        this.visible === !1 && (i.visible = !1),
        this.frustumCulled === !1 && (i.frustumCulled = !1),
        this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
        JSON.stringify(this.userData) !== "{}" && (i.userData = this.userData),
        i.layers = this.layers.mask,
        i.matrix = this.matrix.toArray(),
        this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
        this.isInstancedMesh &&
        (i.type = "InstancedMesh",
          i.count = this.count,
          i.instanceMatrix = this.instanceMatrix.toJSON(),
          this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON()));
      function s(a, u) {
        return a[u.uuid] === void 0 && (a[u.uuid] = u.toJSON(e)), u.uuid;
      }
      if (this.isScene) {
        this.background &&
        (this.background.isColor
          ? i.background = this.background.toJSON()
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
          this.environment && this.environment.isTexture &&
          (i.environment = this.environment.toJSON(e).uuid);
      } else if (this.isMesh || this.isLine || this.isPoints) {
        i.geometry = s(e.geometries, this.geometry);
        let a = this.geometry.parameters;
        if (a !== void 0 && a.shapes !== void 0) {
          let u = a.shapes;
          if (Array.isArray(u)) {
            for (let f = 0, d = u.length; f < d; f++) {
              let h = u[f];
              s(e.shapes, h);
            }
          } else s(e.shapes, u);
        }
      }
      if (
        this.isSkinnedMesh &&
        (i.bindMode = this.bindMode,
          i.bindMatrix = this.bindMatrix.toArray(),
          this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)),
          this.material !== void 0
      ) {
        if (Array.isArray(this.material)) {
          let a = [];
          for (let u = 0, f = this.material.length; u < f; u++) {
            a.push(s(e.materials, this.material[u]));
          }
          i.material = a;
        } else i.material = s(e.materials, this.material);
      }
      if (this.children.length > 0) {
        i.children = [];
        for (let a = 0; a < this.children.length; a++) {
          i.children.push(this.children[a].toJSON(e).object);
        }
      }
      if (this.animations.length > 0) {
        i.animations = [];
        for (let a = 0; a < this.animations.length; a++) {
          let u = this.animations[a];
          i.animations.push(s(e.animations, u));
        }
      }
      if (t) {
        let a = o(e.geometries),
          u = o(e.materials),
          f = o(e.textures),
          d = o(e.images),
          h = o(e.shapes),
          p = o(e.skeletons),
          g = o(e.animations),
          y = o(e.nodes);
        a.length > 0 && (r.geometries = a),
          u.length > 0 && (r.materials = u),
          f.length > 0 && (r.textures = f),
          d.length > 0 && (r.images = d),
          h.length > 0 && (r.shapes = h),
          p.length > 0 && (r.skeletons = p),
          g.length > 0 && (r.animations = g),
          y.length > 0 && (r.nodes = y);
      }
      return r.object = i, r;
      function o(a) {
        let u = [];
        for (let f in a) {
          let d = a[f];
          delete d.metadata, u.push(d);
        }
        return u;
      }
    }
    clone(e) {
      return new this.constructor().copy(this, e);
    }
    copy(e, t = !0) {
      if (
        this.name = e.name,
          this.up.copy(e.up),
          this.position.copy(e.position),
          this.rotation.order = e.rotation.order,
          this.quaternion.copy(e.quaternion),
          this.scale.copy(e.scale),
          this.matrix.copy(e.matrix),
          this.matrixWorld.copy(e.matrixWorld),
          this.matrixAutoUpdate = e.matrixAutoUpdate,
          this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
          this.layers.mask = e.layers.mask,
          this.visible = e.visible,
          this.castShadow = e.castShadow,
          this.receiveShadow = e.receiveShadow,
          this.frustumCulled = e.frustumCulled,
          this.renderOrder = e.renderOrder,
          this.userData = JSON.parse(JSON.stringify(e.userData)),
          t === !0
      ) {
        for (let r = 0; r < e.children.length; r++) {
          let i = e.children[r];
          this.add(i.clone());
        }
      }
      return this;
    }
  };
ct.DefaultUp = new I(0, 1, 0);
ct.DefaultMatrixAutoUpdate = !0;
var Ji = new I(),
  $s = new I(),
  t_ = new I(),
  eo = new I(),
  Fu = new I(),
  Ou = new I(),
  IC = new I(),
  n_ = new I(),
  r_ = new I(),
  i_ = new I(),
  Qr = class {
    constructor(e = new I(), t = new I(), r = new I()) {
      this.a = e, this.b = t, this.c = r;
    }
    static getNormal(e, t, r, i) {
      i.subVectors(r, t), Ji.subVectors(e, t), i.cross(Ji);
      let s = i.lengthSq();
      return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0);
    }
    static getBarycoord(e, t, r, i, s) {
      Ji.subVectors(i, t), $s.subVectors(r, t), t_.subVectors(e, t);
      let o = Ji.dot(Ji),
        a = Ji.dot($s),
        u = Ji.dot(t_),
        f = $s.dot($s),
        d = $s.dot(t_),
        h = o * f - a * a;
      if (h === 0) return s.set(-2, -1, -1);
      let p = 1 / h, g = (f * u - a * d) * p, y = (o * d - a * u) * p;
      return s.set(1 - g - y, y, g);
    }
    static containsPoint(e, t, r, i) {
      return this.getBarycoord(e, t, r, i, eo),
        eo.x >= 0 && eo.y >= 0 && eo.x + eo.y <= 1;
    }
    static getUV(e, t, r, i, s, o, a, u) {
      return this.getBarycoord(e, t, r, i, eo),
        u.set(0, 0),
        u.addScaledVector(s, eo.x),
        u.addScaledVector(o, eo.y),
        u.addScaledVector(a, eo.z),
        u;
    }
    static isFrontFacing(e, t, r, i) {
      return Ji.subVectors(r, t), $s.subVectors(e, t), Ji.cross($s).dot(i) < 0;
    }
    set(e, t, r) {
      return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
    }
    setFromPointsAndIndices(e, t, r, i) {
      return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[i]), this;
    }
    setFromAttributeAndIndices(e, t, r, i) {
      return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, r),
        this.c.fromBufferAttribute(e, i),
        this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
    }
    getArea() {
      return Ji.subVectors(this.c, this.b),
        $s.subVectors(this.a, this.b),
        Ji.cross($s).length() * .5;
    }
    getMidpoint(e) {
      return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(e) {
      return Qr.getNormal(this.a, this.b, this.c, e);
    }
    getPlane(e) {
      return e.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(e, t) {
      return Qr.getBarycoord(e, this.a, this.b, this.c, t);
    }
    getUV(e, t, r, i, s) {
      return Qr.getUV(e, this.a, this.b, this.c, t, r, i, s);
    }
    containsPoint(e) {
      return Qr.containsPoint(e, this.a, this.b, this.c);
    }
    isFrontFacing(e) {
      return Qr.isFrontFacing(this.a, this.b, this.c, e);
    }
    intersectsBox(e) {
      return e.intersectsTriangle(this);
    }
    closestPointToPoint(e, t) {
      let r = this.a, i = this.b, s = this.c, o, a;
      Fu.subVectors(i, r), Ou.subVectors(s, r), n_.subVectors(e, r);
      let u = Fu.dot(n_), f = Ou.dot(n_);
      if (u <= 0 && f <= 0) return t.copy(r);
      r_.subVectors(e, i);
      let d = Fu.dot(r_), h = Ou.dot(r_);
      if (d >= 0 && h <= d) return t.copy(i);
      let p = u * h - d * f;
      if (p <= 0 && u >= 0 && d <= 0) {
        return o = u / (u - d), t.copy(r).addScaledVector(Fu, o);
      }
      i_.subVectors(e, s);
      let g = Fu.dot(i_), y = Ou.dot(i_);
      if (y >= 0 && g <= y) return t.copy(s);
      let v = g * f - u * y;
      if (v <= 0 && f >= 0 && y <= 0) {
        return a = f / (f - y), t.copy(r).addScaledVector(Ou, a);
      }
      let _ = d * y - g * h;
      if (_ <= 0 && h - d >= 0 && g - y >= 0) {
        return IC.subVectors(s, i),
          a = (h - d) / (h - d + (g - y)),
          t.copy(i).addScaledVector(IC, a);
      }
      let S = 1 / (_ + v + p);
      return o = v * S,
        a = p * S,
        t.copy(r).addScaledVector(Fu, o).addScaledVector(Ou, a);
    }
    equals(e) {
      return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
    }
  },
  AD = 0,
  $t = class extends Xi {
    constructor() {
      super();
      this.isMaterial = !0,
        Object.defineProperty(this, "id", { value: AD++ }),
        this.uuid = Kr(),
        this.name = "",
        this.type = "Material",
        this.blending = Ja,
        this.side = Gs,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = mx,
        this.blendDst = gx,
        this.blendEquation = Qa,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = Zp,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = mC,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = im,
        this.stencilZFail = im,
        this.stencilZPass = im,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0;
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(e) {
      this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(e) {
      if (e !== void 0) {
        for (let t in e) {
          let r = e[t];
          if (r === void 0) {
            console.warn("THREE.Material: '" + t + "' parameter is undefined.");
            continue;
          }
          if (t === "shading") {
            console.warn(
              "THREE." + this.type +
                ": .shading has been removed. Use the boolean .flatShading instead.",
            ), this.flatShading = r === wA;
            continue;
          }
          let i = this[t];
          if (i === void 0) {
            console.warn(
              "THREE." + this.type + ": '" + t +
                "' is not a property of this material.",
            );
            continue;
          }
          i && i.isColor
            ? i.set(r)
            : i && i.isVector3 && r && r.isVector3
            ? i.copy(r)
            : this[t] = r;
        }
      }
    }
    toJSON(e) {
      let t = e === void 0 || typeof e == "string";
      t && (e = { textures: {}, images: {} });
      let r = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON",
        },
      };
      r.uuid = this.uuid,
        r.type = this.type,
        this.name !== "" && (r.name = this.name),
        this.color && this.color.isColor && (r.color = this.color.getHex()),
        this.roughness !== void 0 && (r.roughness = this.roughness),
        this.metalness !== void 0 && (r.metalness = this.metalness),
        this.sheen !== void 0 && (r.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor &&
        (r.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 &&
        (r.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor &&
        (r.emissive = this.emissive.getHex()),
        this.emissiveIntensity && this.emissiveIntensity !== 1 &&
        (r.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor &&
        (r.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 &&
        (r.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor &&
        (r.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (r.shininess = this.shininess),
        this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture &&
        (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture &&
        (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture &&
        (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
          r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.iridescence !== void 0 && (r.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 &&
        (r.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture &&
        (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (r.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture &&
        (r.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture &&
        (r.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture &&
        (r.lightMap = this.lightMap.toJSON(e).uuid,
          r.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture &&
        (r.aoMap = this.aoMap.toJSON(e).uuid,
          r.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture &&
        (r.bumpMap = this.bumpMap.toJSON(e).uuid, r.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture &&
        (r.normalMap = this.normalMap.toJSON(e).uuid,
          r.normalMapType = this.normalMapType,
          r.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture &&
        (r.displacementMap = this.displacementMap.toJSON(e).uuid,
          r.displacementScale = this.displacementScale,
          r.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture &&
        (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture &&
        (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture &&
        (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture &&
        (r.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture &&
        (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture &&
        (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture &&
        (r.envMap = this.envMap.toJSON(e).uuid,
          this.combine !== void 0 && (r.combine = this.combine)),
        this.envMapIntensity !== void 0 &&
        (r.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 &&
        (r.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture &&
        (r.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (r.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture &&
        (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (r.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture &&
        (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 &&
        (r.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 &&
        (r.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (r.size = this.size),
        this.shadowSide !== null && (r.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 &&
        (r.sizeAttenuation = this.sizeAttenuation),
        this.blending !== Ja && (r.blending = this.blending),
        this.side !== Gs && (r.side = this.side),
        this.vertexColors && (r.vertexColors = !0),
        this.opacity < 1 && (r.opacity = this.opacity),
        this.transparent === !0 && (r.transparent = this.transparent),
        r.depthFunc = this.depthFunc,
        r.depthTest = this.depthTest,
        r.depthWrite = this.depthWrite,
        r.colorWrite = this.colorWrite,
        r.stencilWrite = this.stencilWrite,
        r.stencilWriteMask = this.stencilWriteMask,
        r.stencilFunc = this.stencilFunc,
        r.stencilRef = this.stencilRef,
        r.stencilFuncMask = this.stencilFuncMask,
        r.stencilFail = this.stencilFail,
        r.stencilZFail = this.stencilZFail,
        r.stencilZPass = this.stencilZPass,
        this.rotation !== void 0 && this.rotation !== 0 &&
        (r.rotation = this.rotation),
        this.polygonOffset === !0 && (r.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 &&
        (r.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 &&
        (r.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 &&
        (r.linewidth = this.linewidth),
        this.dashSize !== void 0 && (r.dashSize = this.dashSize),
        this.gapSize !== void 0 && (r.gapSize = this.gapSize),
        this.scale !== void 0 && (r.scale = this.scale),
        this.dithering === !0 && (r.dithering = !0),
        this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
        this.alphaToCoverage === !0 &&
        (r.alphaToCoverage = this.alphaToCoverage),
        this.premultipliedAlpha === !0 &&
        (r.premultipliedAlpha = this.premultipliedAlpha),
        this.wireframe === !0 && (r.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 &&
        (r.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" &&
        (r.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" &&
        (r.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (r.flatShading = this.flatShading),
        this.visible === !1 && (r.visible = !1),
        this.toneMapped === !1 && (r.toneMapped = !1),
        this.fog === !1 && (r.fog = !1),
        JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData);
      function i(s) {
        let o = [];
        for (let a in s) {
          let u = s[a];
          delete u.metadata, o.push(u);
        }
        return o;
      }
      if (t) {
        let s = i(e.textures), o = i(e.images);
        s.length > 0 && (r.textures = s), o.length > 0 && (r.images = o);
      }
      return r;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
      let t = e.clippingPlanes, r = null;
      if (t !== null) {
        let i = t.length;
        r = new Array(i);
        for (let s = 0; s !== i; ++s) r[s] = t[s].clone();
      }
      return this.clippingPlanes = r,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(e) {
      e === !0 && this.version++;
    }
  },
  en = class extends $t {
    constructor(e) {
      super();
      this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new ve(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Bf,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e);
    }
    copy(e) {
      return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this;
    }
  },
  Mn = new I(),
  xm = new se(),
  pt = class {
    constructor(e, t, r) {
      if (Array.isArray(e)) {
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array.",
        );
      }
      this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = r === !0,
        this.usage = sm,
        this.updateRange = { offset: 0, count: -1 },
        this.version = 0;
    }
    onUploadCallback() {}
    set needsUpdate(e) {
      e === !0 && this.version++;
    }
    setUsage(e) {
      return this.usage = e, this;
    }
    copy(e) {
      return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this;
    }
    copyAt(e, t, r) {
      e *= this.itemSize, r *= t.itemSize;
      for (let i = 0, s = this.itemSize; i < s; i++) {
        this.array[e + i] = t.array[r + i];
      }
      return this;
    }
    copyArray(e) {
      return this.array.set(e), this;
    }
    copyColorsArray(e) {
      let t = this.array, r = 0;
      for (let i = 0, s = e.length; i < s; i++) {
        let o = e[i];
        o === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyColorsArray(): color is undefined",
          i,
        ),
          o = new ve()),
          t[r++] = o.r,
          t[r++] = o.g,
          t[r++] = o.b;
      }
      return this;
    }
    copyVector2sArray(e) {
      let t = this.array, r = 0;
      for (let i = 0, s = e.length; i < s; i++) {
        let o = e[i];
        o === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
          i,
        ),
          o = new se()),
          t[r++] = o.x,
          t[r++] = o.y;
      }
      return this;
    }
    copyVector3sArray(e) {
      let t = this.array, r = 0;
      for (let i = 0, s = e.length; i < s; i++) {
        let o = e[i];
        o === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
          i,
        ),
          o = new I()),
          t[r++] = o.x,
          t[r++] = o.y,
          t[r++] = o.z;
      }
      return this;
    }
    copyVector4sArray(e) {
      let t = this.array, r = 0;
      for (let i = 0, s = e.length; i < s; i++) {
        let o = e[i];
        o === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
          i,
        ),
          o = new Lt()),
          t[r++] = o.x,
          t[r++] = o.y,
          t[r++] = o.z,
          t[r++] = o.w;
      }
      return this;
    }
    applyMatrix3(e) {
      if (this.itemSize === 2) {
        for (let t = 0, r = this.count; t < r; t++) {
          xm.fromBufferAttribute(this, t),
            xm.applyMatrix3(e),
            this.setXY(t, xm.x, xm.y);
        }
      } else if (this.itemSize === 3) {
        for (let t = 0, r = this.count; t < r; t++) {
          Mn.fromBufferAttribute(this, t),
            Mn.applyMatrix3(e),
            this.setXYZ(t, Mn.x, Mn.y, Mn.z);
        }
      }
      return this;
    }
    applyMatrix4(e) {
      for (let t = 0, r = this.count; t < r; t++) {
        Mn.fromBufferAttribute(this, t),
          Mn.applyMatrix4(e),
          this.setXYZ(t, Mn.x, Mn.y, Mn.z);
      }
      return this;
    }
    applyNormalMatrix(e) {
      for (let t = 0, r = this.count; t < r; t++) {
        Mn.fromBufferAttribute(this, t),
          Mn.applyNormalMatrix(e),
          this.setXYZ(t, Mn.x, Mn.y, Mn.z);
      }
      return this;
    }
    transformDirection(e) {
      for (let t = 0, r = this.count; t < r; t++) {
        Mn.fromBufferAttribute(this, t),
          Mn.transformDirection(e),
          this.setXYZ(t, Mn.x, Mn.y, Mn.z);
      }
      return this;
    }
    set(e, t = 0) {
      return this.array.set(e, t), this;
    }
    getX(e) {
      return this.array[e * this.itemSize];
    }
    setX(e, t) {
      return this.array[e * this.itemSize] = t, this;
    }
    getY(e) {
      return this.array[e * this.itemSize + 1];
    }
    setY(e, t) {
      return this.array[e * this.itemSize + 1] = t, this;
    }
    getZ(e) {
      return this.array[e * this.itemSize + 2];
    }
    setZ(e, t) {
      return this.array[e * this.itemSize + 2] = t, this;
    }
    getW(e) {
      return this.array[e * this.itemSize + 3];
    }
    setW(e, t) {
      return this.array[e * this.itemSize + 3] = t, this;
    }
    setXY(e, t, r) {
      return e *= this.itemSize,
        this.array[e + 0] = t,
        this.array[e + 1] = r,
        this;
    }
    setXYZ(e, t, r, i) {
      return e *= this.itemSize,
        this.array[e + 0] = t,
        this.array[e + 1] = r,
        this.array[e + 2] = i,
        this;
    }
    setXYZW(e, t, r, i, s) {
      return e *= this.itemSize,
        this.array[e + 0] = t,
        this.array[e + 1] = r,
        this.array[e + 2] = i,
        this.array[e + 3] = s,
        this;
    }
    onUpload(e) {
      return this.onUploadCallback = e, this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      let e = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized,
      };
      return this.name !== "" && (e.name = this.name),
        this.usage !== sm && (e.usage = this.usage),
        (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (e.updateRange = this.updateRange),
        e;
    }
  },
  NC = class extends pt {
    constructor(e, t, r) {
      super(new Int8Array(e), t, r);
    }
  },
  DC = class extends pt {
    constructor(e, t, r) {
      super(new Uint8Array(e), t, r);
    }
  },
  kC = class extends pt {
    constructor(e, t, r) {
      super(new Uint8ClampedArray(e), t, r);
    }
  },
  FC = class extends pt {
    constructor(e, t, r) {
      super(new Int16Array(e), t, r);
    }
  },
  _m = class extends pt {
    constructor(e, t, r) {
      super(new Uint16Array(e), t, r);
    }
  },
  OC = class extends pt {
    constructor(e, t, r) {
      super(new Int32Array(e), t, r);
    }
  },
  Sm = class extends pt {
    constructor(e, t, r) {
      super(new Uint32Array(e), t, r);
    }
  },
  zC = class extends pt {
    constructor(e, t, r) {
      super(new Uint16Array(e), t, r);
      this.isFloat16BufferAttribute = !0;
    }
  },
  ke = class extends pt {
    constructor(e, t, r) {
      super(new Float32Array(e), t, r);
    }
  },
  BC = class extends pt {
    constructor(e, t, r) {
      super(new Float64Array(e), t, r);
    }
  },
  CD = 0,
  Ti = new Ge(),
  s_ = new ct(),
  zu = new I(),
  $r = new Yi(),
  Kf = new Yi(),
  Bn = new I(),
  Ye = class extends Xi {
    constructor() {
      super();
      this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", { value: CD++ }),
        this.uuid = Kr(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = { start: 0, count: 1 / 0 },
        this.userData = {};
    }
    getIndex() {
      return this.index;
    }
    setIndex(e) {
      return Array.isArray(e)
        ? this.index = new (yC(e) ? Sm : _m)(e, 1)
        : this.index = e,
        this;
    }
    getAttribute(e) {
      return this.attributes[e];
    }
    setAttribute(e, t) {
      return this.attributes[e] = t, this;
    }
    deleteAttribute(e) {
      return delete this.attributes[e], this;
    }
    hasAttribute(e) {
      return this.attributes[e] !== void 0;
    }
    addGroup(e, t, r = 0) {
      this.groups.push({ start: e, count: t, materialIndex: r });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(e, t) {
      this.drawRange.start = e, this.drawRange.count = t;
    }
    applyMatrix4(e) {
      let t = this.attributes.position;
      t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
      let r = this.attributes.normal;
      if (r !== void 0) {
        let s = new vr().getNormalMatrix(e);
        r.applyNormalMatrix(s), r.needsUpdate = !0;
      }
      let i = this.attributes.tangent;
      return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this;
    }
    applyQuaternion(e) {
      return Ti.makeRotationFromQuaternion(e), this.applyMatrix4(Ti), this;
    }
    rotateX(e) {
      return Ti.makeRotationX(e), this.applyMatrix4(Ti), this;
    }
    rotateY(e) {
      return Ti.makeRotationY(e), this.applyMatrix4(Ti), this;
    }
    rotateZ(e) {
      return Ti.makeRotationZ(e), this.applyMatrix4(Ti), this;
    }
    translate(e, t, r) {
      return Ti.makeTranslation(e, t, r), this.applyMatrix4(Ti), this;
    }
    scale(e, t, r) {
      return Ti.makeScale(e, t, r), this.applyMatrix4(Ti), this;
    }
    lookAt(e) {
      return s_.lookAt(e),
        s_.updateMatrix(),
        this.applyMatrix4(s_.matrix),
        this;
    }
    center() {
      return this.computeBoundingBox(),
        this.boundingBox.getCenter(zu).negate(),
        this.translate(zu.x, zu.y, zu.z),
        this;
    }
    setFromPoints(e) {
      let t = [];
      for (let r = 0, i = e.length; r < i; r++) {
        let s = e[r];
        t.push(s.x, s.y, s.z || 0);
      }
      return this.setAttribute("position", new ke(t, 3)), this;
    }
    computeBoundingBox() {
      this.boundingBox === null && (this.boundingBox = new Yi());
      let e = this.attributes.position, t = this.morphAttributes.position;
      if (e && e.isGLBufferAttribute) {
        console.error(
          'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
          this,
        ),
          this.boundingBox.set(
            new I(-1 / 0, -1 / 0, -1 / 0),
            new I(1 / 0, 1 / 0, 1 / 0),
          );
        return;
      }
      if (e !== void 0) {
        if (this.boundingBox.setFromBufferAttribute(e), t) {
          for (let r = 0, i = t.length; r < i; r++) {
            let s = t[r];
            $r.setFromBufferAttribute(s),
              this.morphTargetsRelative
                ? (Bn.addVectors(this.boundingBox.min, $r.min),
                  this.boundingBox.expandByPoint(Bn),
                  Bn.addVectors(this.boundingBox.max, $r.max),
                  this.boundingBox.expandByPoint(Bn))
                : (this.boundingBox.expandByPoint($r.min),
                  this.boundingBox.expandByPoint($r.max));
          }
        }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) ||
        isNaN(this.boundingBox.min.z)) &&
        console.error(
          'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
          this,
        );
    }
    computeBoundingSphere() {
      this.boundingSphere === null && (this.boundingSphere = new Zi());
      let e = this.attributes.position, t = this.morphAttributes.position;
      if (e && e.isGLBufferAttribute) {
        console.error(
          'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
          this,
        ),
          this.boundingSphere.set(new I(), 1 / 0);
        return;
      }
      if (e) {
        let r = this.boundingSphere.center;
        if ($r.setFromBufferAttribute(e), t) {
          for (let s = 0, o = t.length; s < o; s++) {
            let a = t[s];
            Kf.setFromBufferAttribute(a),
              this.morphTargetsRelative
                ? (Bn.addVectors($r.min, Kf.min),
                  $r.expandByPoint(Bn),
                  Bn.addVectors($r.max, Kf.max),
                  $r.expandByPoint(Bn))
                : ($r.expandByPoint(Kf.min), $r.expandByPoint(Kf.max));
          }
        }
        $r.getCenter(r);
        let i = 0;
        for (let s = 0, o = e.count; s < o; s++) {
          Bn.fromBufferAttribute(e, s),
            i = Math.max(i, r.distanceToSquared(Bn));
        }
        if (t) {
          for (let s = 0, o = t.length; s < o; s++) {
            let a = t[s], u = this.morphTargetsRelative;
            for (let f = 0, d = a.count; f < d; f++) {
              Bn.fromBufferAttribute(a, f),
                u && (zu.fromBufferAttribute(e, f), Bn.add(zu)),
                i = Math.max(i, r.distanceToSquared(Bn));
            }
          }
        }
        this.boundingSphere.radius = Math.sqrt(i),
          isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this,
          );
      }
    }
    computeTangents() {
      let e = this.index, t = this.attributes;
      if (
        e === null || t.position === void 0 || t.normal === void 0 ||
        t.uv === void 0
      ) {
        console.error(
          "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)",
        );
        return;
      }
      let r = e.array,
        i = t.position.array,
        s = t.normal.array,
        o = t.uv.array,
        a = i.length / 3;
      this.hasAttribute("tangent") === !1 &&
        this.setAttribute("tangent", new pt(new Float32Array(4 * a), 4));
      let u = this.getAttribute("tangent").array, f = [], d = [];
      for (let k = 0; k < a; k++) f[k] = new I(), d[k] = new I();
      let h = new I(),
        p = new I(),
        g = new I(),
        y = new se(),
        v = new se(),
        _ = new se(),
        S = new I(),
        w = new I();
      function M(k, z, Y) {
        h.fromArray(i, k * 3),
          p.fromArray(i, z * 3),
          g.fromArray(i, Y * 3),
          y.fromArray(o, k * 2),
          v.fromArray(o, z * 2),
          _.fromArray(o, Y * 2),
          p.sub(h),
          g.sub(h),
          v.sub(y),
          _.sub(y);
        let le = 1 / (v.x * _.y - _.x * v.y);
        !isFinite(le) ||
          (S.copy(p).multiplyScalar(_.y).addScaledVector(g, -v.y)
            .multiplyScalar(le),
            w.copy(g).multiplyScalar(v.x).addScaledVector(p, -_.x)
              .multiplyScalar(le),
            f[k].add(S),
            f[z].add(S),
            f[Y].add(S),
            d[k].add(w),
            d[z].add(w),
            d[Y].add(w));
      }
      let T = this.groups;
      T.length === 0 && (T = [{ start: 0, count: r.length }]);
      for (let k = 0, z = T.length; k < z; ++k) {
        let Y = T[k], le = Y.start, V = Y.count;
        for (let W = le, G = le + V; W < G; W += 3) {
          M(r[W + 0], r[W + 1], r[W + 2]);
        }
      }
      let b = new I(), R = new I(), P = new I(), C = new I();
      function L(k) {
        P.fromArray(s, k * 3), C.copy(P);
        let z = f[k];
        b.copy(z),
          b.sub(P.multiplyScalar(P.dot(z))).normalize(),
          R.crossVectors(C, z);
        let le = R.dot(d[k]) < 0 ? -1 : 1;
        u[k * 4] = b.x,
          u[k * 4 + 1] = b.y,
          u[k * 4 + 2] = b.z,
          u[k * 4 + 3] = le;
      }
      for (let k = 0, z = T.length; k < z; ++k) {
        let Y = T[k], le = Y.start, V = Y.count;
        for (let W = le, G = le + V; W < G; W += 3) {
          L(r[W + 0]), L(r[W + 1]), L(r[W + 2]);
        }
      }
    }
    computeVertexNormals() {
      let e = this.index, t = this.getAttribute("position");
      if (t !== void 0) {
        let r = this.getAttribute("normal");
        if (r === void 0) {
          r = new pt(new Float32Array(t.count * 3), 3),
            this.setAttribute("normal", r);
        } else for (let p = 0, g = r.count; p < g; p++) r.setXYZ(p, 0, 0, 0);
        let i = new I(),
          s = new I(),
          o = new I(),
          a = new I(),
          u = new I(),
          f = new I(),
          d = new I(),
          h = new I();
        if (e) {
          for (let p = 0, g = e.count; p < g; p += 3) {
            let y = e.getX(p + 0), v = e.getX(p + 1), _ = e.getX(p + 2);
            i.fromBufferAttribute(t, y),
              s.fromBufferAttribute(t, v),
              o.fromBufferAttribute(t, _),
              d.subVectors(o, s),
              h.subVectors(i, s),
              d.cross(h),
              a.fromBufferAttribute(r, y),
              u.fromBufferAttribute(r, v),
              f.fromBufferAttribute(r, _),
              a.add(d),
              u.add(d),
              f.add(d),
              r.setXYZ(y, a.x, a.y, a.z),
              r.setXYZ(v, u.x, u.y, u.z),
              r.setXYZ(_, f.x, f.y, f.z);
          }
        } else {for (let p = 0, g = t.count; p < g; p += 3) {
            i.fromBufferAttribute(t, p + 0),
              s.fromBufferAttribute(t, p + 1),
              o.fromBufferAttribute(t, p + 2),
              d.subVectors(o, s),
              h.subVectors(i, s),
              d.cross(h),
              r.setXYZ(p + 0, d.x, d.y, d.z),
              r.setXYZ(p + 1, d.x, d.y, d.z),
              r.setXYZ(p + 2, d.x, d.y, d.z);
          }}
        this.normalizeNormals(), r.needsUpdate = !0;
      }
    }
    merge(e, t) {
      if (!(e && e.isBufferGeometry)) {
        console.error(
          "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
          e,
        );
        return;
      }
      t === void 0 &&
        (t = 0,
          console.warn(
            "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.",
          ));
      let r = this.attributes;
      for (let i in r) {
        if (e.attributes[i] === void 0) continue;
        let o = r[i].array,
          a = e.attributes[i],
          u = a.array,
          f = a.itemSize * t,
          d = Math.min(u.length, o.length - f);
        for (let h = 0, p = f; h < d; h++, p++) o[p] = u[h];
      }
      return this;
    }
    normalizeNormals() {
      let e = this.attributes.normal;
      for (let t = 0, r = e.count; t < r; t++) {
        Bn.fromBufferAttribute(e, t),
          Bn.normalize(),
          e.setXYZ(t, Bn.x, Bn.y, Bn.z);
      }
    }
    toNonIndexed() {
      function e(a, u) {
        let f = a.array,
          d = a.itemSize,
          h = a.normalized,
          p = new f.constructor(u.length * d),
          g = 0,
          y = 0;
        for (let v = 0, _ = u.length; v < _; v++) {
          a.isInterleavedBufferAttribute
            ? g = u[v] * a.data.stride + a.offset
            : g = u[v] * d;
          for (let S = 0; S < d; S++) p[y++] = f[g++];
        }
        return new pt(p, d, h);
      }
      if (this.index === null) {
        return console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.",
        ),
          this;
      }
      let t = new Ye(), r = this.index.array, i = this.attributes;
      for (let a in i) {
        let u = i[a], f = e(u, r);
        t.setAttribute(a, f);
      }
      let s = this.morphAttributes;
      for (let a in s) {
        let u = [], f = s[a];
        for (let d = 0, h = f.length; d < h; d++) {
          let p = f[d], g = e(p, r);
          u.push(g);
        }
        t.morphAttributes[a] = u;
      }
      t.morphTargetsRelative = this.morphTargetsRelative;
      let o = this.groups;
      for (let a = 0, u = o.length; a < u; a++) {
        let f = o[a];
        t.addGroup(f.start, f.count, f.materialIndex);
      }
      return t;
    }
    toJSON() {
      let e = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON",
        },
      };
      if (
        e.uuid = this.uuid,
          e.type = this.type,
          this.name !== "" && (e.name = this.name),
          Object.keys(this.userData).length > 0 && (e.userData = this.userData),
          this.parameters !== void 0
      ) {
        let u = this.parameters;
        for (let f in u) u[f] !== void 0 && (e[f] = u[f]);
        return e;
      }
      e.data = { attributes: {} };
      let t = this.index;
      t !== null &&
        (e.data.index = {
          type: t.array.constructor.name,
          array: Array.prototype.slice.call(t.array),
        });
      let r = this.attributes;
      for (let u in r) {
        let f = r[u];
        e.data.attributes[u] = f.toJSON(e.data);
      }
      let i = {}, s = !1;
      for (let u in this.morphAttributes) {
        let f = this.morphAttributes[u], d = [];
        for (let h = 0, p = f.length; h < p; h++) {
          let g = f[h];
          d.push(g.toJSON(e.data));
        }
        d.length > 0 && (i[u] = d, s = !0);
      }
      s &&
        (e.data.morphAttributes = i,
          e.data.morphTargetsRelative = this.morphTargetsRelative);
      let o = this.groups;
      o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
      let a = this.boundingSphere;
      return a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
        e;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
      let t = {};
      this.name = e.name;
      let r = e.index;
      r !== null && this.setIndex(r.clone(t));
      let i = e.attributes;
      for (let f in i) {
        let d = i[f];
        this.setAttribute(f, d.clone(t));
      }
      let s = e.morphAttributes;
      for (let f in s) {
        let d = [], h = s[f];
        for (let p = 0, g = h.length; p < g; p++) d.push(h[p].clone(t));
        this.morphAttributes[f] = d;
      }
      this.morphTargetsRelative = e.morphTargetsRelative;
      let o = e.groups;
      for (let f = 0, d = o.length; f < d; f++) {
        let h = o[f];
        this.addGroup(h.start, h.count, h.materialIndex);
      }
      let a = e.boundingBox;
      a !== null && (this.boundingBox = a.clone());
      let u = e.boundingSphere;
      return u !== null && (this.boundingSphere = u.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        e.parameters !== void 0 &&
        (this.parameters = Object.assign({}, e.parameters)),
        this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  },
  UC = new Ge(),
  Bu = new Nu(),
  o_ = new Zi(),
  ra = new I(),
  ia = new I(),
  sa = new I(),
  a_ = new I(),
  l_ = new I(),
  u_ = new I(),
  wm = new I(),
  Mm = new I(),
  Em = new I(),
  Tm = new se(),
  Am = new se(),
  Cm = new se(),
  c_ = new I(),
  bm = new I(),
  Ot = class extends ct {
    constructor(e = new Ye(), t = new en()) {
      super();
      this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets();
    }
    copy(e, t) {
      return super.copy(e, t),
        e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary,
        )),
        this.material = e.material,
        this.geometry = e.geometry,
        this;
    }
    updateMorphTargets() {
      let t = this.geometry.morphAttributes, r = Object.keys(t);
      if (r.length > 0) {
        let i = t[r[0]];
        if (i !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let s = 0, o = i.length; s < o; s++) {
            let a = i[s].name || String(s);
            this.morphTargetInfluences.push(0),
              this.morphTargetDictionary[a] = s;
          }
        }
      }
    }
    raycast(e, t) {
      let r = this.geometry, i = this.material, s = this.matrixWorld;
      if (
        i === void 0 ||
        (r.boundingSphere === null && r.computeBoundingSphere(),
          o_.copy(r.boundingSphere),
          o_.applyMatrix4(s),
          e.ray.intersectsSphere(o_) === !1) ||
        (UC.copy(s).invert(),
          Bu.copy(e.ray).applyMatrix4(UC),
          r.boundingBox !== null && Bu.intersectsBox(r.boundingBox) === !1)
      ) return;
      let o,
        a = r.index,
        u = r.attributes.position,
        f = r.morphAttributes.position,
        d = r.morphTargetsRelative,
        h = r.attributes.uv,
        p = r.attributes.uv2,
        g = r.groups,
        y = r.drawRange;
      if (a !== null) {
        if (Array.isArray(i)) {
          for (let v = 0, _ = g.length; v < _; v++) {
            let S = g[v],
              w = i[S.materialIndex],
              M = Math.max(S.start, y.start),
              T = Math.min(
                a.count,
                Math.min(S.start + S.count, y.start + y.count),
              );
            for (let b = M, R = T; b < R; b += 3) {
              let P = a.getX(b), C = a.getX(b + 1), L = a.getX(b + 2);
              o = Rm(this, w, e, Bu, u, f, d, h, p, P, C, L),
                o &&
                (o.faceIndex = Math.floor(b / 3),
                  o.face.materialIndex = S.materialIndex,
                  t.push(o));
            }
          }
        } else {
          let v = Math.max(0, y.start),
            _ = Math.min(a.count, y.start + y.count);
          for (let S = v, w = _; S < w; S += 3) {
            let M = a.getX(S), T = a.getX(S + 1), b = a.getX(S + 2);
            o = Rm(this, i, e, Bu, u, f, d, h, p, M, T, b),
              o && (o.faceIndex = Math.floor(S / 3), t.push(o));
          }
        }
      } else if (u !== void 0) {
        if (Array.isArray(i)) {
          for (let v = 0, _ = g.length; v < _; v++) {
            let S = g[v],
              w = i[S.materialIndex],
              M = Math.max(S.start, y.start),
              T = Math.min(
                u.count,
                Math.min(S.start + S.count, y.start + y.count),
              );
            for (let b = M, R = T; b < R; b += 3) {
              let P = b, C = b + 1, L = b + 2;
              o = Rm(this, w, e, Bu, u, f, d, h, p, P, C, L),
                o &&
                (o.faceIndex = Math.floor(b / 3),
                  o.face.materialIndex = S.materialIndex,
                  t.push(o));
            }
          }
        } else {
          let v = Math.max(0, y.start),
            _ = Math.min(u.count, y.start + y.count);
          for (let S = v, w = _; S < w; S += 3) {
            let M = S, T = S + 1, b = S + 2;
            o = Rm(this, i, e, Bu, u, f, d, h, p, M, T, b),
              o && (o.faceIndex = Math.floor(S / 3), t.push(o));
          }
        }
      }
    }
  };
function bD(n, e, t, r, i, s, o, a) {
  let u;
  if (
    e.side === mr
      ? u = r.intersectTriangle(o, s, i, !0, a)
      : u = r.intersectTriangle(i, s, o, e.side !== Gi, a), u === null
  ) return null;
  bm.copy(a), bm.applyMatrix4(n.matrixWorld);
  let f = t.ray.origin.distanceTo(bm);
  return f < t.near || f > t.far
    ? null
    : { distance: f, point: bm.clone(), object: n };
}
function Rm(n, e, t, r, i, s, o, a, u, f, d, h) {
  ra.fromBufferAttribute(i, f),
    ia.fromBufferAttribute(i, d),
    sa.fromBufferAttribute(i, h);
  let p = n.morphTargetInfluences;
  if (s && p) {
    wm.set(0, 0, 0), Mm.set(0, 0, 0), Em.set(0, 0, 0);
    for (let y = 0, v = s.length; y < v; y++) {
      let _ = p[y], S = s[y];
      _ !== 0 && (a_.fromBufferAttribute(S, f),
        l_.fromBufferAttribute(S, d),
        u_.fromBufferAttribute(S, h),
        o
          ? (wm.addScaledVector(a_, _),
            Mm.addScaledVector(l_, _),
            Em.addScaledVector(u_, _))
          : (wm.addScaledVector(a_.sub(ra), _),
            Mm.addScaledVector(l_.sub(ia), _),
            Em.addScaledVector(u_.sub(sa), _)));
    }
    ra.add(wm), ia.add(Mm), sa.add(Em);
  }
  n.isSkinnedMesh &&
    (n.boneTransform(f, ra), n.boneTransform(d, ia), n.boneTransform(h, sa));
  let g = bD(n, e, t, r, ra, ia, sa, c_);
  if (g) {
    a &&
    (Tm.fromBufferAttribute(a, f),
      Am.fromBufferAttribute(a, d),
      Cm.fromBufferAttribute(a, h),
      g.uv = Qr.getUV(c_, ra, ia, sa, Tm, Am, Cm, new se())),
      u &&
      (Tm.fromBufferAttribute(u, f),
        Am.fromBufferAttribute(u, d),
        Cm.fromBufferAttribute(u, h),
        g.uv2 = Qr.getUV(c_, ra, ia, sa, Tm, Am, Cm, new se()));
    let y = { a: f, b: d, c: h, normal: new I(), materialIndex: 0 };
    Qr.getNormal(ra, ia, sa, y.normal), g.face = y;
  }
  return g;
}
var ei = class extends Ye {
  constructor(e = 1, t = 1, r = 1, i = 1, s = 1, o = 1) {
    super();
    this.type = "BoxGeometry",
      this.parameters = {
        width: e,
        height: t,
        depth: r,
        widthSegments: i,
        heightSegments: s,
        depthSegments: o,
      };
    let a = this;
    i = Math.floor(i), s = Math.floor(s), o = Math.floor(o);
    let u = [], f = [], d = [], h = [], p = 0, g = 0;
    y("z", "y", "x", -1, -1, r, t, e, o, s, 0),
      y("z", "y", "x", 1, -1, r, t, -e, o, s, 1),
      y("x", "z", "y", 1, 1, e, r, t, i, o, 2),
      y("x", "z", "y", 1, -1, e, r, -t, i, o, 3),
      y("x", "y", "z", 1, -1, e, t, r, i, s, 4),
      y("x", "y", "z", -1, -1, e, t, -r, i, s, 5),
      this.setIndex(u),
      this.setAttribute("position", new ke(f, 3)),
      this.setAttribute("normal", new ke(d, 3)),
      this.setAttribute("uv", new ke(h, 2));
    function y(v, _, S, w, M, T, b, R, P, C, L) {
      let k = T / P,
        z = b / C,
        Y = T / 2,
        le = b / 2,
        V = R / 2,
        W = P + 1,
        G = C + 1,
        re = 0,
        ie = 0,
        X = new I();
      for (let $ = 0; $ < G; $++) {
        let ae = $ * z - le;
        for (let fe = 0; fe < W; fe++) {
          let pe = fe * k - Y;
          X[v] = pe * w,
            X[_] = ae * M,
            X[S] = V,
            f.push(X.x, X.y, X.z),
            X[v] = 0,
            X[_] = 0,
            X[S] = R > 0 ? 1 : -1,
            d.push(X.x, X.y, X.z),
            h.push(fe / P),
            h.push(1 - $ / C),
            re += 1;
        }
      }
      for (let $ = 0; $ < C; $++) {
        for (let ae = 0; ae < P; ae++) {
          let fe = p + ae + W * $,
            pe = p + ae + W * ($ + 1),
            Pe = p + (ae + 1) + W * ($ + 1),
            Oe = p + (ae + 1) + W * $;
          u.push(fe, pe, Oe), u.push(pe, Pe, Oe), ie += 6;
        }
      }
      a.addGroup(g, ie, L), g += ie, p += re;
    }
  }
  static fromJSON(e) {
    return new ei(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments,
    );
  }
};
function Uu(n) {
  let e = {};
  for (let t in n) {
    e[t] = {};
    for (let r in n[t]) {
      let i = n[t][r];
      i &&
        (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 ||
          i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion)
        ? e[t][r] = i.clone()
        : Array.isArray(i)
        ? e[t][r] = i.slice()
        : e[t][r] = i;
    }
  }
  return e;
}
function ir(n) {
  let e = {};
  for (let t = 0; t < n.length; t++) {
    let r = Uu(n[t]);
    for (let i in r) e[i] = r[i];
  }
  return e;
}
var Lm = { clone: Uu, merge: ir },
  RD = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  LD = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,
  sr = class extends $t {
    constructor(e) {
      super();
      this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.vertexShader = RD,
        this.fragmentShader = LD,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.extensions = {
          derivatives: !1,
          fragDepth: !1,
          drawBuffers: !1,
          shaderTextureLOD: !1,
        },
        this.defaultAttributeValues = {
          color: [1, 1, 1],
          uv: [0, 0],
          uv2: [0, 0],
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 &&
        (e.attributes !== void 0 &&
          console.error(
            "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.",
          ),
          this.setValues(e));
    }
    copy(e) {
      return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = Uu(e.uniforms),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this;
    }
    toJSON(e) {
      let t = super.toJSON(e);
      t.glslVersion = this.glslVersion, t.uniforms = {};
      for (let i in this.uniforms) {
        let o = this.uniforms[i].value;
        o && o.isTexture
          ? t.uniforms[i] = { type: "t", value: o.toJSON(e).uuid }
          : o && o.isColor
          ? t.uniforms[i] = { type: "c", value: o.getHex() }
          : o && o.isVector2
          ? t.uniforms[i] = { type: "v2", value: o.toArray() }
          : o && o.isVector3
          ? t.uniforms[i] = { type: "v3", value: o.toArray() }
          : o && o.isVector4
          ? t.uniforms[i] = { type: "v4", value: o.toArray() }
          : o && o.isMatrix3
          ? t.uniforms[i] = { type: "m3", value: o.toArray() }
          : o && o.isMatrix4
          ? t.uniforms[i] = { type: "m4", value: o.toArray() }
          : t.uniforms[i] = { value: o };
      }
      Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader;
      let r = {};
      for (let i in this.extensions) this.extensions[i] === !0 && (r[i] = !0);
      return Object.keys(r).length > 0 && (t.extensions = r), t;
    }
  },
  oa = class extends ct {
    constructor() {
      super();
      this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new Ge(),
        this.projectionMatrix = new Ge(),
        this.projectionMatrixInverse = new Ge();
    }
    copy(e, t) {
      return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this;
    }
    getWorldDirection(e) {
      this.updateWorldMatrix(!0, !1);
      let t = this.matrixWorld.elements;
      return e.set(-t[8], -t[9], -t[10]).normalize();
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(e, t) {
      super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  },
  ln = class extends oa {
    constructor(e = 50, t = 1, r = .1, i = 2e3) {
      super();
      this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = r,
        this.far = i,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix();
    }
    copy(e, t) {
      return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this;
    }
    setFocalLength(e) {
      let t = .5 * this.getFilmHeight() / e;
      this.fov = Gf * 2 * Math.atan(t), this.updateProjectionMatrix();
    }
    getFocalLength() {
      let e = Math.tan(il * .5 * this.fov);
      return .5 * this.getFilmHeight() / e;
    }
    getEffectiveFOV() {
      return Gf * 2 * Math.atan(Math.tan(il * .5 * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(e, t, r, i, s, o) {
      this.aspect = e / t,
        this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = r,
        this.view.offsetY = i,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      let e = this.near,
        t = e * Math.tan(il * .5 * this.fov) / this.zoom,
        r = 2 * t,
        i = this.aspect * r,
        s = -.5 * i,
        o = this.view;
      if (this.view !== null && this.view.enabled) {
        let u = o.fullWidth, f = o.fullHeight;
        s += o.offsetX * i / u,
          t -= o.offsetY * r / f,
          i *= o.width / u,
          r *= o.height / f;
      }
      let a = this.filmOffset;
      a !== 0 && (s += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(s, s + i, t, t - r, e, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
      let t = super.toJSON(e);
      return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t;
    }
  },
  Vu = 90,
  Hu = 1,
  f_ = class extends ct {
    constructor(e, t, r) {
      super();
      if (this.type = "CubeCamera", r.isWebGLCubeRenderTarget !== !0) {
        console.error(
          "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.",
        );
        return;
      }
      this.renderTarget = r;
      let i = new ln(Vu, Hu, e, t);
      i.layers = this.layers,
        i.up.set(0, -1, 0),
        i.lookAt(new I(1, 0, 0)),
        this.add(i);
      let s = new ln(Vu, Hu, e, t);
      s.layers = this.layers,
        s.up.set(0, -1, 0),
        s.lookAt(new I(-1, 0, 0)),
        this.add(s);
      let o = new ln(Vu, Hu, e, t);
      o.layers = this.layers,
        o.up.set(0, 0, 1),
        o.lookAt(new I(0, 1, 0)),
        this.add(o);
      let a = new ln(Vu, Hu, e, t);
      a.layers = this.layers,
        a.up.set(0, 0, -1),
        a.lookAt(new I(0, -1, 0)),
        this.add(a);
      let u = new ln(Vu, Hu, e, t);
      u.layers = this.layers,
        u.up.set(0, -1, 0),
        u.lookAt(new I(0, 0, 1)),
        this.add(u);
      let f = new ln(Vu, Hu, e, t);
      f.layers = this.layers,
        f.up.set(0, -1, 0),
        f.lookAt(new I(0, 0, -1)),
        this.add(f);
    }
    update(e, t) {
      this.parent === null && this.updateMatrixWorld();
      let r = this.renderTarget,
        [i, s, o, a, u, f] = this.children,
        d = e.getRenderTarget(),
        h = e.toneMapping,
        p = e.xr.enabled;
      e.toneMapping = ji, e.xr.enabled = !1;
      let g = r.texture.generateMipmaps;
      r.texture.generateMipmaps = !1,
        e.setRenderTarget(r, 0),
        e.render(t, i),
        e.setRenderTarget(r, 1),
        e.render(t, s),
        e.setRenderTarget(r, 2),
        e.render(t, o),
        e.setRenderTarget(r, 3),
        e.render(t, a),
        e.setRenderTarget(r, 4),
        e.render(t, u),
        r.texture.generateMipmaps = g,
        e.setRenderTarget(r, 5),
        e.render(t, f),
        e.setRenderTarget(d),
        e.toneMapping = h,
        e.xr.enabled = p,
        r.texture.needsPMREMUpdate = !0;
    }
  },
  Gu = class extends Qt {
    constructor(e, t, r, i, s, o, a, u, f, d) {
      e = e !== void 0 ? e : [], t = t !== void 0 ? t : Ho;
      super(e, t, r, i, s, o, a, u, f, d);
      this.isCubeTexture = !0, this.flipY = !1;
    }
    get images() {
      return this.image;
    }
    set images(e) {
      this.image = e;
    }
  },
  d_ = class extends yr {
    constructor(e, t = {}) {
      super(e, e, t);
      this.isWebGLCubeRenderTarget = !0;
      let r = { width: e, height: e, depth: 1 }, i = [r, r, r, r, r, r];
      this.texture = new Gu(
        i,
        t.mapping,
        t.wrapS,
        t.wrapT,
        t.magFilter,
        t.minFilter,
        t.format,
        t.type,
        t.anisotropy,
        t.encoding,
      ),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0
          ? t.generateMipmaps
          : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : kt;
    }
    fromEquirectangularTexture(e, t) {
      this.texture.type = t.type,
        this.texture.encoding = t.encoding,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
      let r = {
          uniforms: { tEquirect: { value: null } },
          vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
          fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
        },
        i = new ei(5, 5, 5),
        s = new sr({
          name: "CubemapFromEquirect",
          uniforms: Uu(r.uniforms),
          vertexShader: r.vertexShader,
          fragmentShader: r.fragmentShader,
          side: mr,
          blending: js,
        });
      s.uniforms.tEquirect.value = t;
      let o = new Ot(i, s), a = t.minFilter;
      return t.minFilter === Mi && (t.minFilter = kt),
        new f_(1, 10, this).update(e, o),
        t.minFilter = a,
        o.geometry.dispose(),
        o.material.dispose(),
        this;
    }
    clear(e, t, r, i) {
      let s = e.getRenderTarget();
      for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, r, i);
      e.setRenderTarget(s);
    }
  },
  h_ = new I(),
  PD = new I(),
  ID = new vr(),
  to = class {
    constructor(e = new I(1, 0, 0), t = 0) {
      this.isPlane = !0, this.normal = e, this.constant = t;
    }
    set(e, t) {
      return this.normal.copy(e), this.constant = t, this;
    }
    setComponents(e, t, r, i) {
      return this.normal.set(e, t, r), this.constant = i, this;
    }
    setFromNormalAndCoplanarPoint(e, t) {
      return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
    }
    setFromCoplanarPoints(e, t, r) {
      let i = h_.subVectors(r, t).cross(PD.subVectors(e, t)).normalize();
      return this.setFromNormalAndCoplanarPoint(i, e), this;
    }
    copy(e) {
      return this.normal.copy(e.normal), this.constant = e.constant, this;
    }
    normalize() {
      let e = 1 / this.normal.length();
      return this.normal.multiplyScalar(e), this.constant *= e, this;
    }
    negate() {
      return this.constant *= -1, this.normal.negate(), this;
    }
    distanceToPoint(e) {
      return this.normal.dot(e) + this.constant;
    }
    distanceToSphere(e) {
      return this.distanceToPoint(e.center) - e.radius;
    }
    projectPoint(e, t) {
      return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(
        e,
      );
    }
    intersectLine(e, t) {
      let r = e.delta(h_), i = this.normal.dot(r);
      if (i === 0) {return this.distanceToPoint(e.start) === 0
          ? t.copy(e.start)
          : null;}
      let s = -(e.start.dot(this.normal) + this.constant) / i;
      return s < 0 || s > 1 ? null : t.copy(r).multiplyScalar(s).add(e.start);
    }
    intersectsLine(e) {
      let t = this.distanceToPoint(e.start), r = this.distanceToPoint(e.end);
      return t < 0 && r > 0 || r < 0 && t > 0;
    }
    intersectsBox(e) {
      return e.intersectsPlane(this);
    }
    intersectsSphere(e) {
      return e.intersectsPlane(this);
    }
    coplanarPoint(e) {
      return e.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(e, t) {
      let r = t || ID.getNormalMatrix(e),
        i = this.coplanarPoint(h_).applyMatrix4(e),
        s = this.normal.applyMatrix3(r).normalize();
      return this.constant = -i.dot(s), this;
    }
    translate(e) {
      return this.constant -= e.dot(this.normal), this;
    }
    equals(e) {
      return e.normal.equals(this.normal) && e.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  },
  ju = new Zi(),
  Pm = new I(),
  Jf = class {
    constructor(
      e = new to(),
      t = new to(),
      r = new to(),
      i = new to(),
      s = new to(),
      o = new to(),
    ) {
      this.planes = [e, t, r, i, s, o];
    }
    set(e, t, r, i, s, o) {
      let a = this.planes;
      return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(r),
        a[3].copy(i),
        a[4].copy(s),
        a[5].copy(o),
        this;
    }
    copy(e) {
      let t = this.planes;
      for (let r = 0; r < 6; r++) t[r].copy(e.planes[r]);
      return this;
    }
    setFromProjectionMatrix(e) {
      let t = this.planes,
        r = e.elements,
        i = r[0],
        s = r[1],
        o = r[2],
        a = r[3],
        u = r[4],
        f = r[5],
        d = r[6],
        h = r[7],
        p = r[8],
        g = r[9],
        y = r[10],
        v = r[11],
        _ = r[12],
        S = r[13],
        w = r[14],
        M = r[15];
      return t[0].setComponents(a - i, h - u, v - p, M - _).normalize(),
        t[1].setComponents(a + i, h + u, v + p, M + _).normalize(),
        t[2].setComponents(a + s, h + f, v + g, M + S).normalize(),
        t[3].setComponents(a - s, h - f, v - g, M - S).normalize(),
        t[4].setComponents(a - o, h - d, v - y, M - w).normalize(),
        t[5].setComponents(a + o, h + d, v + y, M + w).normalize(),
        this;
    }
    intersectsObject(e) {
      let t = e.geometry;
      return t.boundingSphere === null && t.computeBoundingSphere(),
        ju.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
        this.intersectsSphere(ju);
    }
    intersectsSprite(e) {
      return ju.center.set(0, 0, 0),
        ju.radius = .7071067811865476,
        ju.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(ju);
    }
    intersectsSphere(e) {
      let t = this.planes, r = e.center, i = -e.radius;
      for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(r) < i) return !1;
      return !0;
    }
    intersectsBox(e) {
      let t = this.planes;
      for (let r = 0; r < 6; r++) {
        let i = t[r];
        if (
          Pm.x = i.normal.x > 0 ? e.max.x : e.min.x,
            Pm.y = i.normal.y > 0 ? e.max.y : e.min.y,
            Pm.z = i.normal.z > 0 ? e.max.z : e.min.z,
            i.distanceToPoint(Pm) < 0
        ) return !1;
      }
      return !0;
    }
    containsPoint(e) {
      let t = this.planes;
      for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(e) < 0) return !1;
      return !0;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
function VC() {
  let n = null, e = !1, t = null, r = null;
  function i(s, o) {
    t(s, o), r = n.requestAnimationFrame(i);
  }
  return {
    start: function () {
      e !== !0 && t !== null && (r = n.requestAnimationFrame(i), e = !0);
    },
    stop: function () {
      n.cancelAnimationFrame(r), e = !1;
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      n = s;
    },
  };
}
function ND(n, e) {
  let t = e.isWebGL2, r = new WeakMap();
  function i(f, d) {
    let h = f.array, p = f.usage, g = n.createBuffer();
    n.bindBuffer(d, g), n.bufferData(d, h, p), f.onUploadCallback();
    let y;
    if (h instanceof Float32Array) y = 5126;
    else if (h instanceof Uint16Array) {
      if (f.isFloat16BufferAttribute) {
        if (t) y = 5131;
        else {throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.",
          );}
      } else y = 5123;
    } else if (h instanceof Int16Array) y = 5122;
    else if (h instanceof Uint32Array) y = 5125;
    else if (h instanceof Int32Array) y = 5124;
    else if (h instanceof Int8Array) y = 5120;
    else if (h instanceof Uint8Array) y = 5121;
    else if (h instanceof Uint8ClampedArray) y = 5121;
    else {throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + h,
      );}
    return {
      buffer: g,
      type: y,
      bytesPerElement: h.BYTES_PER_ELEMENT,
      version: f.version,
    };
  }
  function s(f, d, h) {
    let p = d.array, g = d.updateRange;
    n.bindBuffer(h, f),
      g.count === -1
        ? n.bufferSubData(h, 0, p)
        : (t
          ? n.bufferSubData(
            h,
            g.offset * p.BYTES_PER_ELEMENT,
            p,
            g.offset,
            g.count,
          )
          : n.bufferSubData(
            h,
            g.offset * p.BYTES_PER_ELEMENT,
            p.subarray(g.offset, g.offset + g.count),
          ),
          g.count = -1);
  }
  function o(f) {
    return f.isInterleavedBufferAttribute && (f = f.data), r.get(f);
  }
  function a(f) {
    f.isInterleavedBufferAttribute && (f = f.data);
    let d = r.get(f);
    d && (n.deleteBuffer(d.buffer), r.delete(f));
  }
  function u(f, d) {
    if (f.isGLBufferAttribute) {
      let p = r.get(f);
      (!p || p.version < f.version) &&
        r.set(f, {
          buffer: f.buffer,
          type: f.type,
          bytesPerElement: f.elementSize,
          version: f.version,
        });
      return;
    }
    f.isInterleavedBufferAttribute && (f = f.data);
    let h = r.get(f);
    h === void 0
      ? r.set(f, i(f, d))
      : h.version < f.version && (s(h.buffer, f, d), h.version = f.version);
  }
  return { get: o, remove: a, update: u };
}
var cl = class extends Ye {
    constructor(e = 1, t = 1, r = 1, i = 1) {
      super();
      this.type = "PlaneGeometry",
        this.parameters = {
          width: e,
          height: t,
          widthSegments: r,
          heightSegments: i,
        };
      let s = e / 2,
        o = t / 2,
        a = Math.floor(r),
        u = Math.floor(i),
        f = a + 1,
        d = u + 1,
        h = e / a,
        p = t / u,
        g = [],
        y = [],
        v = [],
        _ = [];
      for (let S = 0; S < d; S++) {
        let w = S * p - o;
        for (let M = 0; M < f; M++) {
          let T = M * h - s;
          y.push(T, -w, 0), v.push(0, 0, 1), _.push(M / a), _.push(1 - S / u);
        }
      }
      for (let S = 0; S < u; S++) {
        for (let w = 0; w < a; w++) {
          let M = w + f * S,
            T = w + f * (S + 1),
            b = w + 1 + f * (S + 1),
            R = w + 1 + f * S;
          g.push(M, T, R), g.push(T, b, R);
        }
      }
      this.setIndex(g),
        this.setAttribute("position", new ke(y, 3)),
        this.setAttribute("normal", new ke(v, 3)),
        this.setAttribute("uv", new ke(_, 2));
    }
    static fromJSON(e) {
      return new cl(e.width, e.height, e.widthSegments, e.heightSegments);
    }
  },
  DD = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
  kD = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  FD = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  OD = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  zD = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  BD = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  UD = "vec3 transformed = vec3( position );",
  VD = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  HD = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
  GD = `#ifdef USE_IRIDESCENCE
const mat3 XYZ_TO_REC709 = mat3(
    3.2404542, -0.9692660,  0.0556434,
   -1.5371385,  1.8760108, -0.2040259,
   -0.4985314,  0.0415560,  1.0572252
);
vec3 Fresnel0ToIor( vec3 fresnel0 ) {
   vec3 sqrtF0 = sqrt( fresnel0 );
   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
}
vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
}
float IorToFresnel0( float transmittedIor, float incidentIor ) {
   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
}
vec3 evalSensitivity( float OPD, vec3 shift ) {
   float phase = 2.0 * PI * OPD * 1.0e-9;
   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );
   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );
   xyz /= 1.0685e-7;
   vec3 srgb = XYZ_TO_REC709 * xyz;
   return srgb;
}
vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
   vec3 I;
   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
   float cosTheta2Sq = 1.0 - sinTheta2Sq;
   if ( cosTheta2Sq < 0.0 ) {
       return vec3( 1.0 );
   }
   float cosTheta2 = sqrt( cosTheta2Sq );
   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
   float R12 = F_Schlick( R0, 1.0, cosTheta1 );
   float R21 = R12;
   float T121 = 1.0 - R12;
   float phi12 = 0.0;
   if ( iridescenceIOR < outsideIOR ) phi12 = PI;
   float phi21 = PI - phi12;
   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
   vec3 phi23 = vec3( 0.0 );
   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;
   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;
   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;
   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
   vec3 phi = vec3( phi21 ) + phi23;
   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
   vec3 r123 = sqrt( R123 );
   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
   vec3 C0 = R12 + Rs;
   I = C0;
   vec3 Cm = Rs - T121;
   for ( int m = 1; m <= 2; ++m ) {
       Cm *= r123;
       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
       I += Cm * Sm;
   }
   return max( I, vec3( 0.0 ) );
}
#endif`,
  jD = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  WD = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  XD = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  qD = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  YD = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  ZD = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  KD = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  JD = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  QD = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  $D = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
  ek = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  tk = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  nk = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  rk = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
  ik = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  sk = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  ok = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  ak = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  lk = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  uk = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  ck = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  fk = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  dk = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  hk = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  pk = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  mk = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  gk = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  vk = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,
  yk = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  xk = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  _k = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,
  Sk = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  wk = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
  Mk = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  Ek = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,
  Tk = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  Ak = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,
  Ck = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
  bk = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  Rk = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
float dotNVi = saturate( dot( normal, geometry.viewDir ) );
if ( material.iridescenceThickness == 0.0 ) {
	material.iridescence = 0.0;
} else {
	material.iridescence = saturate( material.iridescence );
}
if ( material.iridescence > 0.0 ) {
	material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
	material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  Lk = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  Pk = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  Ik = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  Nk = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  Dk = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  kk = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  Fk = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  Ok = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  zk = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  Bk = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  Uk = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  Vk = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  Hk = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  Gk = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  jk = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  Wk = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  Xk = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
  qk = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  Yk = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  Zk = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  Kk = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  Jk = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
  Qk = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  $k = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
  eF = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
  tF = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  nF = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  rF = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
  iF = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  sF = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  oF = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  aF = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  lF = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  uF = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  cF = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  fF = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  dF = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
  hF = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  pF = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  mF = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
  gF = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  vF = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  yF = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  xF = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  _F = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  SF = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  wF = `#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,
  MF = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
  EF = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
  TF = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
  AF = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
  CF = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
  bF = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
  RF = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
  LF =
    `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
  PF = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  IF = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  NF = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  DF = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  kF = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  FF = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  OF = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  zF = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  BF = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  UF = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  VF = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  HF = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  GF = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  jF = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  WF = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  XF = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  qF = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  YF = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  ZF = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  KF = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  JF = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  QF = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  $F = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  eO = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  tO = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  nO = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  rO = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  iO = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  sO = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  oO = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  aO = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  lO = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  ut = {
    alphamap_fragment: DD,
    alphamap_pars_fragment: kD,
    alphatest_fragment: FD,
    alphatest_pars_fragment: OD,
    aomap_fragment: zD,
    aomap_pars_fragment: BD,
    begin_vertex: UD,
    beginnormal_vertex: VD,
    bsdfs: HD,
    iridescence_fragment: GD,
    bumpmap_pars_fragment: jD,
    clipping_planes_fragment: WD,
    clipping_planes_pars_fragment: XD,
    clipping_planes_pars_vertex: qD,
    clipping_planes_vertex: YD,
    color_fragment: ZD,
    color_pars_fragment: KD,
    color_pars_vertex: JD,
    color_vertex: QD,
    common: $D,
    cube_uv_reflection_fragment: ek,
    defaultnormal_vertex: tk,
    displacementmap_pars_vertex: nk,
    displacementmap_vertex: rk,
    emissivemap_fragment: ik,
    emissivemap_pars_fragment: sk,
    encodings_fragment: ok,
    encodings_pars_fragment: ak,
    envmap_fragment: lk,
    envmap_common_pars_fragment: uk,
    envmap_pars_fragment: ck,
    envmap_pars_vertex: fk,
    envmap_physical_pars_fragment: wk,
    envmap_vertex: dk,
    fog_vertex: hk,
    fog_pars_vertex: pk,
    fog_fragment: mk,
    fog_pars_fragment: gk,
    gradientmap_pars_fragment: vk,
    lightmap_fragment: yk,
    lightmap_pars_fragment: xk,
    lights_lambert_vertex: _k,
    lights_pars_begin: Sk,
    lights_toon_fragment: Mk,
    lights_toon_pars_fragment: Ek,
    lights_phong_fragment: Tk,
    lights_phong_pars_fragment: Ak,
    lights_physical_fragment: Ck,
    lights_physical_pars_fragment: bk,
    lights_fragment_begin: Rk,
    lights_fragment_maps: Lk,
    lights_fragment_end: Pk,
    logdepthbuf_fragment: Ik,
    logdepthbuf_pars_fragment: Nk,
    logdepthbuf_pars_vertex: Dk,
    logdepthbuf_vertex: kk,
    map_fragment: Fk,
    map_pars_fragment: Ok,
    map_particle_fragment: zk,
    map_particle_pars_fragment: Bk,
    metalnessmap_fragment: Uk,
    metalnessmap_pars_fragment: Vk,
    morphcolor_vertex: Hk,
    morphnormal_vertex: Gk,
    morphtarget_pars_vertex: jk,
    morphtarget_vertex: Wk,
    normal_fragment_begin: Xk,
    normal_fragment_maps: qk,
    normal_pars_fragment: Yk,
    normal_pars_vertex: Zk,
    normal_vertex: Kk,
    normalmap_pars_fragment: Jk,
    clearcoat_normal_fragment_begin: Qk,
    clearcoat_normal_fragment_maps: $k,
    clearcoat_pars_fragment: eF,
    iridescence_pars_fragment: tF,
    output_fragment: nF,
    packing: rF,
    premultiplied_alpha_fragment: iF,
    project_vertex: sF,
    dithering_fragment: oF,
    dithering_pars_fragment: aF,
    roughnessmap_fragment: lF,
    roughnessmap_pars_fragment: uF,
    shadowmap_pars_fragment: cF,
    shadowmap_pars_vertex: fF,
    shadowmap_vertex: dF,
    shadowmask_pars_fragment: hF,
    skinbase_vertex: pF,
    skinning_pars_vertex: mF,
    skinning_vertex: gF,
    skinnormal_vertex: vF,
    specularmap_fragment: yF,
    specularmap_pars_fragment: xF,
    tonemapping_fragment: _F,
    tonemapping_pars_fragment: SF,
    transmission_fragment: wF,
    transmission_pars_fragment: MF,
    uv_pars_fragment: EF,
    uv_pars_vertex: TF,
    uv_vertex: AF,
    uv2_pars_fragment: CF,
    uv2_pars_vertex: bF,
    uv2_vertex: RF,
    worldpos_vertex: LF,
    background_vert: PF,
    background_frag: IF,
    cube_vert: NF,
    cube_frag: DF,
    depth_vert: kF,
    depth_frag: FF,
    distanceRGBA_vert: OF,
    distanceRGBA_frag: zF,
    equirect_vert: BF,
    equirect_frag: UF,
    linedashed_vert: VF,
    linedashed_frag: HF,
    meshbasic_vert: GF,
    meshbasic_frag: jF,
    meshlambert_vert: WF,
    meshlambert_frag: XF,
    meshmatcap_vert: qF,
    meshmatcap_frag: YF,
    meshnormal_vert: ZF,
    meshnormal_frag: KF,
    meshphong_vert: JF,
    meshphong_frag: QF,
    meshphysical_vert: $F,
    meshphysical_frag: eO,
    meshtoon_vert: tO,
    meshtoon_frag: nO,
    points_vert: rO,
    points_frag: iO,
    shadow_vert: sO,
    shadow_frag: oO,
    sprite_vert: aO,
    sprite_frag: lO,
  },
  Ee = {
    common: {
      diffuse: { value: new ve(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new vr() },
      uv2Transform: { value: new vr() },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
    },
    specularmap: { specularMap: { value: null } },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: .98 },
    },
    aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
    lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
    emissivemap: { emissiveMap: { value: null } },
    bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new se(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    roughnessmap: { roughnessMap: { value: null } },
    metalnessmap: { metalnessMap: { value: null } },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new ve(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotShadowMap: { value: [] },
      spotShadowMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new ve(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new vr() },
    },
    sprite: {
      diffuse: { value: new ve(16777215) },
      opacity: { value: 1 },
      center: { value: new se(.5, .5) },
      rotation: { value: 0 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new vr() },
    },
  },
  Qi = {
    basic: {
      uniforms: ir([
        Ee.common,
        Ee.specularmap,
        Ee.envmap,
        Ee.aomap,
        Ee.lightmap,
        Ee.fog,
      ]),
      vertexShader: ut.meshbasic_vert,
      fragmentShader: ut.meshbasic_frag,
    },
    lambert: {
      uniforms: ir([
        Ee.common,
        Ee.specularmap,
        Ee.envmap,
        Ee.aomap,
        Ee.lightmap,
        Ee.emissivemap,
        Ee.fog,
        Ee.lights,
        { emissive: { value: new ve(0) } },
      ]),
      vertexShader: ut.meshlambert_vert,
      fragmentShader: ut.meshlambert_frag,
    },
    phong: {
      uniforms: ir([
        Ee.common,
        Ee.specularmap,
        Ee.envmap,
        Ee.aomap,
        Ee.lightmap,
        Ee.emissivemap,
        Ee.bumpmap,
        Ee.normalmap,
        Ee.displacementmap,
        Ee.fog,
        Ee.lights,
        {
          emissive: { value: new ve(0) },
          specular: { value: new ve(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: ut.meshphong_vert,
      fragmentShader: ut.meshphong_frag,
    },
    standard: {
      uniforms: ir([
        Ee.common,
        Ee.envmap,
        Ee.aomap,
        Ee.lightmap,
        Ee.emissivemap,
        Ee.bumpmap,
        Ee.normalmap,
        Ee.displacementmap,
        Ee.roughnessmap,
        Ee.metalnessmap,
        Ee.fog,
        Ee.lights,
        {
          emissive: { value: new ve(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: ut.meshphysical_vert,
      fragmentShader: ut.meshphysical_frag,
    },
    toon: {
      uniforms: ir([
        Ee.common,
        Ee.aomap,
        Ee.lightmap,
        Ee.emissivemap,
        Ee.bumpmap,
        Ee.normalmap,
        Ee.displacementmap,
        Ee.gradientmap,
        Ee.fog,
        Ee.lights,
        { emissive: { value: new ve(0) } },
      ]),
      vertexShader: ut.meshtoon_vert,
      fragmentShader: ut.meshtoon_frag,
    },
    matcap: {
      uniforms: ir([
        Ee.common,
        Ee.bumpmap,
        Ee.normalmap,
        Ee.displacementmap,
        Ee.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: ut.meshmatcap_vert,
      fragmentShader: ut.meshmatcap_frag,
    },
    points: {
      uniforms: ir([Ee.points, Ee.fog]),
      vertexShader: ut.points_vert,
      fragmentShader: ut.points_frag,
    },
    dashed: {
      uniforms: ir([Ee.common, Ee.fog, {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 },
      }]),
      vertexShader: ut.linedashed_vert,
      fragmentShader: ut.linedashed_frag,
    },
    depth: {
      uniforms: ir([Ee.common, Ee.displacementmap]),
      vertexShader: ut.depth_vert,
      fragmentShader: ut.depth_frag,
    },
    normal: {
      uniforms: ir([Ee.common, Ee.bumpmap, Ee.normalmap, Ee.displacementmap, {
        opacity: { value: 1 },
      }]),
      vertexShader: ut.meshnormal_vert,
      fragmentShader: ut.meshnormal_frag,
    },
    sprite: {
      uniforms: ir([Ee.sprite, Ee.fog]),
      vertexShader: ut.sprite_vert,
      fragmentShader: ut.sprite_frag,
    },
    background: {
      uniforms: { uvTransform: { value: new vr() }, t2D: { value: null } },
      vertexShader: ut.background_vert,
      fragmentShader: ut.background_frag,
    },
    cube: {
      uniforms: ir([Ee.envmap, { opacity: { value: 1 } }]),
      vertexShader: ut.cube_vert,
      fragmentShader: ut.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: ut.equirect_vert,
      fragmentShader: ut.equirect_frag,
    },
    distanceRGBA: {
      uniforms: ir([Ee.common, Ee.displacementmap, {
        referencePosition: { value: new I() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 },
      }]),
      vertexShader: ut.distanceRGBA_vert,
      fragmentShader: ut.distanceRGBA_frag,
    },
    shadow: {
      uniforms: ir([Ee.lights, Ee.fog, {
        color: { value: new ve(0) },
        opacity: { value: 1 },
      }]),
      vertexShader: ut.shadow_vert,
      fragmentShader: ut.shadow_frag,
    },
  };
Qi.physical = {
  uniforms: ir([Qi.standard.uniforms, {
    clearcoat: { value: 0 },
    clearcoatMap: { value: null },
    clearcoatRoughness: { value: 0 },
    clearcoatRoughnessMap: { value: null },
    clearcoatNormalScale: { value: new se(1, 1) },
    clearcoatNormalMap: { value: null },
    iridescence: { value: 0 },
    iridescenceMap: { value: null },
    iridescenceIOR: { value: 1.3 },
    iridescenceThicknessMinimum: { value: 100 },
    iridescenceThicknessMaximum: { value: 400 },
    iridescenceThicknessMap: { value: null },
    sheen: { value: 0 },
    sheenColor: { value: new ve(0) },
    sheenColorMap: { value: null },
    sheenRoughness: { value: 1 },
    sheenRoughnessMap: { value: null },
    transmission: { value: 0 },
    transmissionMap: { value: null },
    transmissionSamplerSize: { value: new se() },
    transmissionSamplerMap: { value: null },
    thickness: { value: 0 },
    thicknessMap: { value: null },
    attenuationDistance: { value: 0 },
    attenuationColor: { value: new ve(0) },
    specularIntensity: { value: 1 },
    specularIntensityMap: { value: null },
    specularColor: { value: new ve(1, 1, 1) },
    specularColorMap: { value: null },
  }]),
  vertexShader: ut.meshphysical_vert,
  fragmentShader: ut.meshphysical_frag,
};
function uO(n, e, t, r, i, s) {
  let o = new ve(0), a = i === !0 ? 0 : 1, u, f, d = null, h = 0, p = null;
  function g(v, _) {
    let S = !1, w = _.isScene === !0 ? _.background : null;
    w && w.isTexture && (w = e.get(w));
    let M = n.xr, T = M.getSession && M.getSession();
    T && T.environmentBlendMode === "additive" && (w = null),
      w === null ? y(o, a) : w && w.isColor && (y(w, 1), S = !0),
      (n.autoClear || S) &&
      n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
      w && (w.isCubeTexture || w.mapping === Au)
        ? (f === void 0 && (f = new Ot(
          new ei(1, 1, 1),
          new sr({
            name: "BackgroundCubeMaterial",
            uniforms: Uu(Qi.cube.uniforms),
            vertexShader: Qi.cube.vertexShader,
            fragmentShader: Qi.cube.fragmentShader,
            side: mr,
            depthTest: !1,
            depthWrite: !1,
            fog: !1,
          }),
        ),
          f.geometry.deleteAttribute("normal"),
          f.geometry.deleteAttribute("uv"),
          f.onBeforeRender = function (b, R, P) {
            this.matrixWorld.copyPosition(P.matrixWorld);
          },
          Object.defineProperty(f.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          r.update(f)),
          f.material.uniforms.envMap.value = w,
          f.material.uniforms.flipEnvMap.value =
            w.isCubeTexture && w.isRenderTargetTexture === !1 ? -1 : 1,
          (d !== w || h !== w.version || p !== n.toneMapping) &&
          (f.material.needsUpdate = !0,
            d = w,
            h = w.version,
            p = n.toneMapping),
          f.layers.enableAll(),
          v.unshift(f, f.geometry, f.material, 0, 0, null))
        : w && w.isTexture &&
          (u === void 0 && (u = new Ot(
            new cl(2, 2),
            new sr({
              name: "BackgroundMaterial",
              uniforms: Uu(Qi.background.uniforms),
              vertexShader: Qi.background.vertexShader,
              fragmentShader: Qi.background.fragmentShader,
              side: Gs,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            }),
          ),
            u.geometry.deleteAttribute("normal"),
            Object.defineProperty(u.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            r.update(u)),
            u.material.uniforms.t2D.value = w,
            w.matrixAutoUpdate === !0 && w.updateMatrix(),
            u.material.uniforms.uvTransform.value.copy(w.matrix),
            (d !== w || h !== w.version || p !== n.toneMapping) &&
            (u.material.needsUpdate = !0,
              d = w,
              h = w.version,
              p = n.toneMapping),
            u.layers.enableAll(),
            v.unshift(u, u.geometry, u.material, 0, 0, null));
  }
  function y(v, _) {
    t.buffers.color.setClear(v.r, v.g, v.b, _, s);
  }
  return {
    getClearColor: function () {
      return o;
    },
    setClearColor: function (v, _ = 1) {
      o.set(v), a = _, y(o, a);
    },
    getClearAlpha: function () {
      return a;
    },
    setClearAlpha: function (v) {
      a = v, y(o, a);
    },
    render: g,
  };
}
function cO(n, e, t, r) {
  let i = n.getParameter(34921),
    s = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    o = r.isWebGL2 || s !== null,
    a = {},
    u = _(null),
    f = u,
    d = !1;
  function h(V, W, G, re, ie) {
    let X = !1;
    if (o) {
      let $ = v(re, G, W);
      f !== $ && (f = $, g(f.object)),
        X = S(V, re, G, ie),
        X && w(V, re, G, ie);
    } else {
      let $ = W.wireframe === !0;
      (f.geometry !== re.id || f.program !== G.id || f.wireframe !== $) &&
        (f.geometry = re.id, f.program = G.id, f.wireframe = $, X = !0);
    }
    ie !== null && t.update(ie, 34963),
      (X || d) &&
      (d = !1,
        C(V, W, G, re),
        ie !== null && n.bindBuffer(34963, t.get(ie).buffer));
  }
  function p() {
    return r.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES();
  }
  function g(V) {
    return r.isWebGL2 ? n.bindVertexArray(V) : s.bindVertexArrayOES(V);
  }
  function y(V) {
    return r.isWebGL2 ? n.deleteVertexArray(V) : s.deleteVertexArrayOES(V);
  }
  function v(V, W, G) {
    let re = G.wireframe === !0, ie = a[V.id];
    ie === void 0 && (ie = {}, a[V.id] = ie);
    let X = ie[W.id];
    X === void 0 && (X = {}, ie[W.id] = X);
    let $ = X[re];
    return $ === void 0 && ($ = _(p()), X[re] = $), $;
  }
  function _(V) {
    let W = [], G = [], re = [];
    for (let ie = 0; ie < i; ie++) W[ie] = 0, G[ie] = 0, re[ie] = 0;
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: W,
      enabledAttributes: G,
      attributeDivisors: re,
      object: V,
      attributes: {},
      index: null,
    };
  }
  function S(V, W, G, re) {
    let ie = f.attributes, X = W.attributes, $ = 0, ae = G.getAttributes();
    for (let fe in ae) {
      if (ae[fe].location >= 0) {
        let Pe = ie[fe], Oe = X[fe];
        if (
          Oe === void 0 &&
          (fe === "instanceMatrix" && V.instanceMatrix &&
            (Oe = V.instanceMatrix),
            fe === "instanceColor" && V.instanceColor &&
            (Oe = V.instanceColor)),
            Pe === void 0 || Pe.attribute !== Oe || Oe && Pe.data !== Oe.data
        ) return !0;
        $++;
      }
    }
    return f.attributesNum !== $ || f.index !== re;
  }
  function w(V, W, G, re) {
    let ie = {}, X = W.attributes, $ = 0, ae = G.getAttributes();
    for (let fe in ae) {
      if (ae[fe].location >= 0) {
        let Pe = X[fe];
        Pe === void 0 &&
          (fe === "instanceMatrix" && V.instanceMatrix &&
            (Pe = V.instanceMatrix),
            fe === "instanceColor" && V.instanceColor &&
            (Pe = V.instanceColor));
        let Oe = {};
        Oe.attribute = Pe,
          Pe && Pe.data && (Oe.data = Pe.data),
          ie[fe] = Oe,
          $++;
      }
    }
    f.attributes = ie, f.attributesNum = $, f.index = re;
  }
  function M() {
    let V = f.newAttributes;
    for (let W = 0, G = V.length; W < G; W++) V[W] = 0;
  }
  function T(V) {
    b(V, 0);
  }
  function b(V, W) {
    let G = f.newAttributes, re = f.enabledAttributes, ie = f.attributeDivisors;
    G[V] = 1,
      re[V] === 0 && (n.enableVertexAttribArray(V), re[V] = 1),
      ie[V] !== W &&
      ((r.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))
        [r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](V, W),
        ie[V] = W);
  }
  function R() {
    let V = f.newAttributes, W = f.enabledAttributes;
    for (let G = 0, re = W.length; G < re; G++) {
      W[G] !== V[G] && (n.disableVertexAttribArray(G), W[G] = 0);
    }
  }
  function P(V, W, G, re, ie, X) {
    r.isWebGL2 === !0 && (G === 5124 || G === 5125)
      ? n.vertexAttribIPointer(V, W, G, ie, X)
      : n.vertexAttribPointer(V, W, G, re, ie, X);
  }
  function C(V, W, G, re) {
    if (
      r.isWebGL2 === !1 &&
      (V.isInstancedMesh || re.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    ) return;
    M();
    let ie = re.attributes, X = G.getAttributes(), $ = W.defaultAttributeValues;
    for (let ae in X) {
      let fe = X[ae];
      if (fe.location >= 0) {
        let pe = ie[ae];
        if (
          pe === void 0 &&
          (ae === "instanceMatrix" && V.instanceMatrix &&
            (pe = V.instanceMatrix),
            ae === "instanceColor" && V.instanceColor &&
            (pe = V.instanceColor)), pe !== void 0
        ) {
          let Pe = pe.normalized, Oe = pe.itemSize, oe = t.get(pe);
          if (oe === void 0) continue;
          let Et = oe.buffer, $e = oe.type, Ze = oe.bytesPerElement;
          if (pe.isInterleavedBufferAttribute) {
            let Se = pe.data, je = Se.stride, ue = pe.offset;
            if (Se.isInstancedInterleavedBuffer) {
              for (let ne = 0; ne < fe.locationSize; ne++) {
                b(
                  fe.location + ne,
                  Se.meshPerAttribute,
                );
              }
              V.isInstancedMesh !== !0 && re._maxInstanceCount === void 0 &&
                (re._maxInstanceCount = Se.meshPerAttribute * Se.count);
            } else {for (let ne = 0; ne < fe.locationSize; ne++) {
                T(
                  fe.location + ne,
                );
              }}
            n.bindBuffer(34962, Et);
            for (let ne = 0; ne < fe.locationSize; ne++) {
              P(
                fe.location + ne,
                Oe / fe.locationSize,
                $e,
                Pe,
                je * Ze,
                (ue + Oe / fe.locationSize * ne) * Ze,
              );
            }
          } else {
            if (pe.isInstancedBufferAttribute) {
              for (let Se = 0; Se < fe.locationSize; Se++) {
                b(
                  fe.location + Se,
                  pe.meshPerAttribute,
                );
              }
              V.isInstancedMesh !== !0 && re._maxInstanceCount === void 0 &&
                (re._maxInstanceCount = pe.meshPerAttribute * pe.count);
            } else {for (let Se = 0; Se < fe.locationSize; Se++) {
                T(
                  fe.location + Se,
                );
              }}
            n.bindBuffer(34962, Et);
            for (let Se = 0; Se < fe.locationSize; Se++) {
              P(
                fe.location + Se,
                Oe / fe.locationSize,
                $e,
                Pe,
                Oe * Ze,
                Oe / fe.locationSize * Se * Ze,
              );
            }
          }
        } else if ($ !== void 0) {
          let Pe = $[ae];
          if (Pe !== void 0) {
            switch (Pe.length) {
              case 2:
                n.vertexAttrib2fv(fe.location, Pe);
                break;
              case 3:
                n.vertexAttrib3fv(fe.location, Pe);
                break;
              case 4:
                n.vertexAttrib4fv(fe.location, Pe);
                break;
              default:
                n.vertexAttrib1fv(fe.location, Pe);
            }
          }
        }
      }
    }
    R();
  }
  function L() {
    Y();
    for (let V in a) {
      let W = a[V];
      for (let G in W) {
        let re = W[G];
        for (let ie in re) y(re[ie].object), delete re[ie];
        delete W[G];
      }
      delete a[V];
    }
  }
  function k(V) {
    if (a[V.id] === void 0) return;
    let W = a[V.id];
    for (let G in W) {
      let re = W[G];
      for (let ie in re) y(re[ie].object), delete re[ie];
      delete W[G];
    }
    delete a[V.id];
  }
  function z(V) {
    for (let W in a) {
      let G = a[W];
      if (G[V.id] === void 0) continue;
      let re = G[V.id];
      for (let ie in re) y(re[ie].object), delete re[ie];
      delete G[V.id];
    }
  }
  function Y() {
    le(), d = !0, f !== u && (f = u, g(f.object));
  }
  function le() {
    u.geometry = null, u.program = null, u.wireframe = !1;
  }
  return {
    setup: h,
    reset: Y,
    resetDefaultState: le,
    dispose: L,
    releaseStatesOfGeometry: k,
    releaseStatesOfProgram: z,
    initAttributes: M,
    enableAttribute: T,
    disableUnusedAttributes: R,
  };
}
function fO(n, e, t, r) {
  let i = r.isWebGL2, s;
  function o(f) {
    s = f;
  }
  function a(f, d) {
    n.drawArrays(s, f, d), t.update(d, s, 1);
  }
  function u(f, d, h) {
    if (h === 0) return;
    let p, g;
    if (i) p = n, g = "drawArraysInstanced";
    else if (
      p = e.get("ANGLE_instanced_arrays"),
        g = "drawArraysInstancedANGLE",
        p === null
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
      );
      return;
    }
    p[g](s, f, d, h), t.update(d, s, h);
  }
  this.setMode = o, this.render = a, this.renderInstances = u;
}
function dO(n, e, t) {
  let r;
  function i() {
    if (r !== void 0) return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      let P = e.get("EXT_texture_filter_anisotropic");
      r = n.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else r = 0;
    return r;
  }
  function s(P) {
    if (P === "highp") {
      if (
        n.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
        n.getShaderPrecisionFormat(35632, 36338).precision > 0
      ) return "highp";
      P = "mediump";
    }
    return P === "mediump" &&
        n.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
        n.getShaderPrecisionFormat(35632, 36337).precision > 0
      ? "mediump"
      : "lowp";
  }
  let o =
      typeof WebGL2RenderingContext != "undefined" &&
        n instanceof WebGL2RenderingContext ||
      typeof WebGL2ComputeRenderingContext != "undefined" &&
        n instanceof WebGL2ComputeRenderingContext,
    a = t.precision !== void 0 ? t.precision : "highp",
    u = s(a);
  u !== a &&
    (console.warn(
      "THREE.WebGLRenderer:",
      a,
      "not supported, using",
      u,
      "instead.",
    ),
      a = u);
  let f = o || e.has("WEBGL_draw_buffers"),
    d = t.logarithmicDepthBuffer === !0,
    h = n.getParameter(34930),
    p = n.getParameter(35660),
    g = n.getParameter(3379),
    y = n.getParameter(34076),
    v = n.getParameter(34921),
    _ = n.getParameter(36347),
    S = n.getParameter(36348),
    w = n.getParameter(36349),
    M = p > 0,
    T = o || e.has("OES_texture_float"),
    b = M && T,
    R = o ? n.getParameter(36183) : 0;
  return {
    isWebGL2: o,
    drawBuffers: f,
    getMaxAnisotropy: i,
    getMaxPrecision: s,
    precision: a,
    logarithmicDepthBuffer: d,
    maxTextures: h,
    maxVertexTextures: p,
    maxTextureSize: g,
    maxCubemapSize: y,
    maxAttributes: v,
    maxVertexUniforms: _,
    maxVaryings: S,
    maxFragmentUniforms: w,
    vertexTextures: M,
    floatFragmentTextures: T,
    floatVertexTextures: b,
    maxSamples: R,
  };
}
function hO(n) {
  let e = this,
    t = null,
    r = 0,
    i = !1,
    s = !1,
    o = new to(),
    a = new vr(),
    u = { value: null, needsUpdate: !1 };
  this.uniform = u,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function (h, p, g) {
      let y = h.length !== 0 || p || r !== 0 || i;
      return i = p, t = d(h, g, 0), r = h.length, y;
    },
    this.beginShadows = function () {
      s = !0, d(null);
    },
    this.endShadows = function () {
      s = !1, f();
    },
    this.setState = function (h, p, g) {
      let y = h.clippingPlanes,
        v = h.clipIntersection,
        _ = h.clipShadows,
        S = n.get(h);
      if (!i || y === null || y.length === 0 || s && !_) s ? d(null) : f();
      else {
        let w = s ? 0 : r, M = w * 4, T = S.clippingState || null;
        u.value = T, T = d(y, p, M, g);
        for (let b = 0; b !== M; ++b) T[b] = t[b];
        S.clippingState = T,
          this.numIntersection = v ? this.numPlanes : 0,
          this.numPlanes += w;
      }
    };
  function f() {
    u.value !== t && (u.value = t, u.needsUpdate = r > 0),
      e.numPlanes = r,
      e.numIntersection = 0;
  }
  function d(h, p, g, y) {
    let v = h !== null ? h.length : 0, _ = null;
    if (v !== 0) {
      if (_ = u.value, y !== !0 || _ === null) {
        let S = g + v * 4, w = p.matrixWorldInverse;
        a.getNormalMatrix(w),
          (_ === null || _.length < S) && (_ = new Float32Array(S));
        for (let M = 0, T = g; M !== v; ++M, T += 4) {
          o.copy(h[M]).applyMatrix4(w, a),
            o.normal.toArray(_, T),
            _[T + 3] = o.constant;
        }
      }
      u.value = _, u.needsUpdate = !0;
    }
    return e.numPlanes = v, e.numIntersection = 0, _;
  }
}
function pO(n) {
  let e = new WeakMap();
  function t(o, a) {
    return a === Uf ? o.mapping = Ho : a === Vf && (o.mapping = Go), o;
  }
  function r(o) {
    if (o && o.isTexture && o.isRenderTargetTexture === !1) {
      let a = o.mapping;
      if (a === Uf || a === Vf) {
        if (e.has(o)) {
          let u = e.get(o).texture;
          return t(u, o.mapping);
        } else {
          let u = o.image;
          if (u && u.height > 0) {
            let f = new d_(u.height / 2);
            return f.fromEquirectangularTexture(n, o),
              e.set(o, f),
              o.addEventListener("dispose", i),
              t(f.texture, o.mapping);
          } else return null;
        }
      }
    }
    return o;
  }
  function i(o) {
    let a = o.target;
    a.removeEventListener("dispose", i);
    let u = e.get(a);
    u !== void 0 && (e.delete(a), u.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: r, dispose: s };
}
var $i = class extends oa {
    constructor(e = -1, t = 1, r = 1, i = -1, s = .1, o = 2e3) {
      super();
      this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = r,
        this.bottom = i,
        this.near = s,
        this.far = o,
        this.updateProjectionMatrix();
    }
    copy(e, t) {
      return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this;
    }
    setViewOffset(e, t, r, i, s, o) {
      this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = r,
        this.view.offsetY = i,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      let e = (this.right - this.left) / (2 * this.zoom),
        t = (this.top - this.bottom) / (2 * this.zoom),
        r = (this.right + this.left) / 2,
        i = (this.top + this.bottom) / 2,
        s = r - e,
        o = r + e,
        a = i + t,
        u = i - t;
      if (this.view !== null && this.view.enabled) {
        let f = (this.right - this.left) / this.view.fullWidth / this.zoom,
          d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        s += f * this.view.offsetX,
          o = s + f * this.view.width,
          a -= d * this.view.offsetY,
          u = a - d * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(s, o, a, u, this.near, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
      let t = super.toJSON(e);
      return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t;
    }
  },
  Wu = 4,
  HC = [.125, .215, .35, .446, .526, .582],
  fl = 20,
  p_ = new $i(),
  GC = new ve(),
  m_ = null,
  dl = (1 + Math.sqrt(5)) / 2,
  Xu = 1 / dl,
  jC = [
    new I(1, 1, 1),
    new I(-1, 1, 1),
    new I(1, 1, -1),
    new I(-1, 1, -1),
    new I(0, dl, Xu),
    new I(0, dl, -Xu),
    new I(Xu, 0, dl),
    new I(-Xu, 0, dl),
    new I(dl, Xu, 0),
    new I(-dl, Xu, 0),
  ],
  Im = class {
    constructor(e) {
      this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial);
    }
    fromScene(e, t = 0, r = .1, i = 100) {
      m_ = this._renderer.getRenderTarget(), this._setSize(256);
      let s = this._allocateTargets();
      return s.depthBuffer = !0,
        this._sceneToCubeUV(e, r, i, s),
        t > 0 && this._blur(s, 0, 0, t),
        this._applyPMREM(s),
        this._cleanup(s),
        s;
    }
    fromEquirectangular(e, t = null) {
      return this._fromTexture(e, t);
    }
    fromCubemap(e, t = null) {
      return this._fromTexture(e, t);
    }
    compileCubemapShader() {
      this._cubemapMaterial === null &&
        (this._cubemapMaterial = qC(),
          this._compileMaterial(this._cubemapMaterial));
    }
    compileEquirectangularShader() {
      this._equirectMaterial === null &&
        (this._equirectMaterial = XC(),
          this._compileMaterial(this._equirectMaterial));
    }
    dispose() {
      this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose();
    }
    _setSize(e) {
      this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax);
    }
    _dispose() {
      this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
      for (let e = 0; e < this._lodPlanes.length; e++) {
        this._lodPlanes[e].dispose();
      }
    }
    _cleanup(e) {
      this._renderer.setRenderTarget(m_),
        e.scissorTest = !1,
        Nm(e, 0, 0, e.width, e.height);
    }
    _fromTexture(e, t) {
      e.mapping === Ho || e.mapping === Go
        ? this._setSize(
          e.image.length === 0
            ? 16
            : e.image[0].width || e.image[0].image.width,
        )
        : this._setSize(e.image.width / 4),
        m_ = this._renderer.getRenderTarget();
      let r = t || this._allocateTargets();
      return this._textureToCubeUV(e, r),
        this._applyPMREM(r),
        this._cleanup(r),
        r;
    }
    _allocateTargets() {
      let e = 3 * Math.max(this._cubeSize, 16 * 7),
        t = 4 * this._cubeSize,
        r = {
          magFilter: kt,
          minFilter: kt,
          generateMipmaps: !1,
          type: Yo,
          format: gr,
          encoding: Ys,
          depthBuffer: !1,
        },
        i = WC(e, t, r);
      if (
        this._pingPongRenderTarget === null ||
        this._pingPongRenderTarget.width !== e
      ) {
        this._pingPongRenderTarget !== null && this._dispose(),
          this._pingPongRenderTarget = WC(e, t, r);
        let { _lodMax: s } = this;
        ({
          sizeLods: this._sizeLods,
          lodPlanes: this._lodPlanes,
          sigmas: this._sigmas,
        } = mO(s)), this._blurMaterial = gO(s, e, t);
      }
      return i;
    }
    _compileMaterial(e) {
      let t = new Ot(this._lodPlanes[0], e);
      this._renderer.compile(t, p_);
    }
    _sceneToCubeUV(e, t, r, i) {
      let s = 90,
        o = 1,
        a = new ln(s, o, t, r),
        u = [1, -1, 1, 1, 1, 1],
        f = [1, 1, 1, -1, -1, -1],
        d = this._renderer,
        h = d.autoClear,
        p = d.toneMapping;
      d.getClearColor(GC), d.toneMapping = ji, d.autoClear = !1;
      let g = new en({
          name: "PMREM.Background",
          side: mr,
          depthWrite: !1,
          depthTest: !1,
        }),
        y = new Ot(new ei(), g),
        v = !1,
        _ = e.background;
      _
        ? _.isColor && (g.color.copy(_), e.background = null, v = !0)
        : (g.color.copy(GC), v = !0);
      for (let S = 0; S < 6; S++) {
        let w = S % 3;
        w === 0
          ? (a.up.set(0, u[S], 0), a.lookAt(f[S], 0, 0))
          : w === 1
          ? (a.up.set(0, 0, u[S]), a.lookAt(0, f[S], 0))
          : (a.up.set(0, u[S], 0), a.lookAt(0, 0, f[S]));
        let M = this._cubeSize;
        Nm(i, w * M, S > 2 ? M : 0, M, M),
          d.setRenderTarget(i),
          v && d.render(y, a),
          d.render(e, a);
      }
      y.geometry.dispose(),
        y.material.dispose(),
        d.toneMapping = p,
        d.autoClear = h,
        e.background = _;
    }
    _textureToCubeUV(e, t) {
      let r = this._renderer, i = e.mapping === Ho || e.mapping === Go;
      i
        ? (this._cubemapMaterial === null && (this._cubemapMaterial = qC()),
          this._cubemapMaterial.uniforms.flipEnvMap.value =
            e.isRenderTargetTexture === !1 ? -1 : 1)
        : this._equirectMaterial === null && (this._equirectMaterial = XC());
      let s = i ? this._cubemapMaterial : this._equirectMaterial,
        o = new Ot(this._lodPlanes[0], s),
        a = s.uniforms;
      a.envMap.value = e;
      let u = this._cubeSize;
      Nm(t, 0, 0, 3 * u, 2 * u), r.setRenderTarget(t), r.render(o, p_);
    }
    _applyPMREM(e) {
      let t = this._renderer, r = t.autoClear;
      t.autoClear = !1;
      for (let i = 1; i < this._lodPlanes.length; i++) {
        let s = Math.sqrt(
            this._sigmas[i] * this._sigmas[i] -
              this._sigmas[i - 1] * this._sigmas[i - 1],
          ),
          o = jC[(i - 1) % jC.length];
        this._blur(e, i - 1, i, s, o);
      }
      t.autoClear = r;
    }
    _blur(e, t, r, i, s) {
      let o = this._pingPongRenderTarget;
      this._halfBlur(e, o, t, r, i, "latitudinal", s),
        this._halfBlur(o, e, r, r, i, "longitudinal", s);
    }
    _halfBlur(e, t, r, i, s, o, a) {
      let u = this._renderer, f = this._blurMaterial;
      o !== "latitudinal" && o !== "longitudinal" &&
        console.error(
          "blur direction must be either latitudinal or longitudinal!",
        );
      let d = 3,
        h = new Ot(this._lodPlanes[i], f),
        p = f.uniforms,
        g = this._sizeLods[r] - 1,
        y = isFinite(s) ? Math.PI / (2 * g) : 2 * Math.PI / (2 * fl - 1),
        v = s / y,
        _ = isFinite(s) ? 1 + Math.floor(d * v) : fl;
      _ > fl &&
        console.warn(
          `sigmaRadians, ${s}, is too large and will clip, as it requested ${_} samples when the maximum is set to ${fl}`,
        );
      let S = [], w = 0;
      for (let P = 0; P < fl; ++P) {
        let C = P / v, L = Math.exp(-C * C / 2);
        S.push(L), P === 0 ? w += L : P < _ && (w += 2 * L);
      }
      for (let P = 0; P < S.length; P++) S[P] = S[P] / w;
      p.envMap.value = e.texture,
        p.samples.value = _,
        p.weights.value = S,
        p.latitudinal.value = o === "latitudinal",
        a && (p.poleAxis.value = a);
      let { _lodMax: M } = this;
      p.dTheta.value = y, p.mipInt.value = M - r;
      let T = this._sizeLods[i],
        b = 3 * T * (i > M - Wu ? i - M + Wu : 0),
        R = 4 * (this._cubeSize - T);
      Nm(t, b, R, 3 * T, 2 * T), u.setRenderTarget(t), u.render(h, p_);
    }
  };
function mO(n) {
  let e = [], t = [], r = [], i = n, s = n - Wu + 1 + HC.length;
  for (let o = 0; o < s; o++) {
    let a = Math.pow(2, i);
    t.push(a);
    let u = 1 / a;
    o > n - Wu ? u = HC[o - n + Wu - 1] : o === 0 && (u = 0), r.push(u);
    let f = 1 / (a - 2),
      d = -f,
      h = 1 + f,
      p = [d, d, h, d, h, h, d, d, h, h, d, h],
      g = 6,
      y = 6,
      v = 3,
      _ = 2,
      S = 1,
      w = new Float32Array(v * y * g),
      M = new Float32Array(_ * y * g),
      T = new Float32Array(S * y * g);
    for (let R = 0; R < g; R++) {
      let P = R % 3 * 2 / 3 - 1,
        C = R > 2 ? 0 : -1,
        L = [
          P,
          C,
          0,
          P + 2 / 3,
          C,
          0,
          P + 2 / 3,
          C + 1,
          0,
          P,
          C,
          0,
          P + 2 / 3,
          C + 1,
          0,
          P,
          C + 1,
          0,
        ];
      w.set(L, v * y * R), M.set(p, _ * y * R);
      let k = [R, R, R, R, R, R];
      T.set(k, S * y * R);
    }
    let b = new Ye();
    b.setAttribute("position", new pt(w, v)),
      b.setAttribute("uv", new pt(M, _)),
      b.setAttribute("faceIndex", new pt(T, S)),
      e.push(b),
      i > Wu && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: r };
}
function WC(n, e, t) {
  let r = new yr(n, e, t);
  return r.texture.mapping = Au,
    r.texture.name = "PMREM.cubeUv",
    r.scissorTest = !0,
    r;
}
function Nm(n, e, t, r, i) {
  n.viewport.set(e, t, r, i), n.scissor.set(e, t, r, i);
}
function gO(n, e, t) {
  let r = new Float32Array(fl), i = new I(0, 1, 0);
  return new sr({
    name: "SphericalGaussianBlur",
    defines: {
      n: fl,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: r },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: g_(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: js,
    depthTest: !1,
    depthWrite: !1,
  });
}
function XC() {
  return new sr({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: g_(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: js,
    depthTest: !1,
    depthWrite: !1,
  });
}
function qC() {
  return new sr({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: g_(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: js,
    depthTest: !1,
    depthWrite: !1,
  });
}
function g_() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function vO(n) {
  let e = new WeakMap(), t = null;
  function r(a) {
    if (a && a.isTexture) {
      let u = a.mapping, f = u === Uf || u === Vf, d = u === Ho || u === Go;
      if (f || d) {
        if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
          a.needsPMREMUpdate = !1;
          let h = e.get(a);
          return t === null && (t = new Im(n)),
            h = f ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h),
            e.set(a, h),
            h.texture;
        } else {
          if (e.has(a)) return e.get(a).texture;
          {
            let h = a.image;
            if (f && h && h.height > 0 || d && h && i(h)) {
              t === null && (t = new Im(n));
              let p = f ? t.fromEquirectangular(a) : t.fromCubemap(a);
              return e.set(a, p), a.addEventListener("dispose", s), p.texture;
            } else return null;
          }
        }
      }
    }
    return a;
  }
  function i(a) {
    let u = 0, f = 6;
    for (let d = 0; d < f; d++) a[d] !== void 0 && u++;
    return u === f;
  }
  function s(a) {
    let u = a.target;
    u.removeEventListener("dispose", s);
    let f = e.get(u);
    f !== void 0 && (e.delete(u), f.dispose());
  }
  function o() {
    e = new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return { get: r, dispose: o };
}
function yO(n) {
  let e = {};
  function t(r) {
    if (e[r] !== void 0) return e[r];
    let i;
    switch (r) {
      case "WEBGL_depth_texture":
        i = n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i = n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i = n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i = n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = n.getExtension(r);
    }
    return e[r] = i, i;
  }
  return {
    has: function (r) {
      return t(r) !== null;
    },
    init: function (r) {
      r.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"),
        t("OES_texture_float"),
        t("OES_texture_half_float"),
        t("OES_texture_half_float_linear"),
        t("OES_standard_derivatives"),
        t("OES_element_index_uint"),
        t("OES_vertex_array_object"),
        t("ANGLE_instanced_arrays")),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture");
    },
    get: function (r) {
      let i = t(r);
      return i === null &&
        console.warn("THREE.WebGLRenderer: " + r + " extension not supported."),
        i;
    },
  };
}
function xO(n, e, t, r) {
  let i = {}, s = new WeakMap();
  function o(h) {
    let p = h.target;
    p.index !== null && e.remove(p.index);
    for (let y in p.attributes) e.remove(p.attributes[y]);
    p.removeEventListener("dispose", o), delete i[p.id];
    let g = s.get(p);
    g && (e.remove(g), s.delete(p)),
      r.releaseStatesOfGeometry(p),
      p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount,
      t.memory.geometries--;
  }
  function a(h, p) {
    return i[p.id] === !0 ||
      (p.addEventListener("dispose", o), i[p.id] = !0, t.memory.geometries++),
      p;
  }
  function u(h) {
    let p = h.attributes;
    for (let y in p) e.update(p[y], 34962);
    let g = h.morphAttributes;
    for (let y in g) {
      let v = g[y];
      for (let _ = 0, S = v.length; _ < S; _++) e.update(v[_], 34962);
    }
  }
  function f(h) {
    let p = [], g = h.index, y = h.attributes.position, v = 0;
    if (g !== null) {
      let w = g.array;
      v = g.version;
      for (let M = 0, T = w.length; M < T; M += 3) {
        let b = w[M + 0], R = w[M + 1], P = w[M + 2];
        p.push(b, R, R, P, P, b);
      }
    } else {
      let w = y.array;
      v = y.version;
      for (let M = 0, T = w.length / 3 - 1; M < T; M += 3) {
        let b = M + 0, R = M + 1, P = M + 2;
        p.push(b, R, R, P, P, b);
      }
    }
    let _ = new (yC(p) ? Sm : _m)(p, 1);
    _.version = v;
    let S = s.get(h);
    S && e.remove(S), s.set(h, _);
  }
  function d(h) {
    let p = s.get(h);
    if (p) {
      let g = h.index;
      g !== null && p.version < g.version && f(h);
    } else f(h);
    return s.get(h);
  }
  return { get: a, update: u, getWireframeAttribute: d };
}
function _O(n, e, t, r) {
  let i = r.isWebGL2, s;
  function o(p) {
    s = p;
  }
  let a, u;
  function f(p) {
    a = p.type, u = p.bytesPerElement;
  }
  function d(p, g) {
    n.drawElements(s, g, a, p * u), t.update(g, s, 1);
  }
  function h(p, g, y) {
    if (y === 0) return;
    let v, _;
    if (i) v = n, _ = "drawElementsInstanced";
    else if (
      v = e.get("ANGLE_instanced_arrays"),
        _ = "drawElementsInstancedANGLE",
        v === null
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
      );
      return;
    }
    v[_](s, g, a, p * u, y), t.update(g, s, y);
  }
  this.setMode = o,
    this.setIndex = f,
    this.render = d,
    this.renderInstances = h;
}
function SO(n) {
  let e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function r(s, o, a) {
    switch (t.calls++, o) {
      case 4:
        t.triangles += a * (s / 3);
        break;
      case 1:
        t.lines += a * (s / 2);
        break;
      case 3:
        t.lines += a * (s - 1);
        break;
      case 2:
        t.lines += a * s;
        break;
      case 0:
        t.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function i() {
    t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: r,
  };
}
function wO(n, e) {
  return n[0] - e[0];
}
function MO(n, e) {
  return Math.abs(e[1]) - Math.abs(n[1]);
}
function v_(n, e) {
  let t = 1, r = e.isInterleavedBufferAttribute ? e.data.array : e.array;
  r instanceof Int8Array
    ? t = 127
    : r instanceof Uint8Array
    ? t = 255
    : r instanceof Uint16Array
    ? t = 65535
    : r instanceof Int16Array
    ? t = 32767
    : r instanceof Int32Array
    ? t = 2147483647
    : console.error(
      "THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",
      r,
    ),
    n.divideScalar(t);
}
function EO(n, e, t) {
  let r = {}, i = new Float32Array(8), s = new WeakMap(), o = new Lt(), a = [];
  for (let f = 0; f < 8; f++) a[f] = [f, 0];
  function u(f, d, h, p) {
    let g = f.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      let y = d.morphAttributes.position || d.morphAttributes.normal ||
          d.morphAttributes.color,
        v = y !== void 0 ? y.length : 0,
        _ = s.get(d);
      if (_ === void 0 || _.count !== v) {
        let W = function () {
          le.dispose(), s.delete(d), d.removeEventListener("dispose", W);
        };
        _ !== void 0 && _.texture.dispose();
        let M = d.morphAttributes.position !== void 0,
          T = d.morphAttributes.normal !== void 0,
          b = d.morphAttributes.color !== void 0,
          R = d.morphAttributes.position || [],
          P = d.morphAttributes.normal || [],
          C = d.morphAttributes.color || [],
          L = 0;
        M === !0 && (L = 1), T === !0 && (L = 2), b === !0 && (L = 3);
        let k = d.attributes.position.count * L, z = 1;
        k > e.maxTextureSize &&
          (z = Math.ceil(k / e.maxTextureSize), k = e.maxTextureSize);
        let Y = new Float32Array(k * z * 4 * v), le = new Ru(Y, k, z, v);
        le.type = Xs, le.needsUpdate = !0;
        let V = L * 4;
        for (let G = 0; G < v; G++) {
          let re = R[G], ie = P[G], X = C[G], $ = k * z * 4 * G;
          for (let ae = 0; ae < re.count; ae++) {
            let fe = ae * V;
            M === !0 &&
            (o.fromBufferAttribute(re, ae),
              re.normalized === !0 && v_(o, re),
              Y[$ + fe + 0] = o.x,
              Y[$ + fe + 1] = o.y,
              Y[$ + fe + 2] = o.z,
              Y[$ + fe + 3] = 0),
              T === !0 &&
              (o.fromBufferAttribute(ie, ae),
                ie.normalized === !0 && v_(o, ie),
                Y[$ + fe + 4] = o.x,
                Y[$ + fe + 5] = o.y,
                Y[$ + fe + 6] = o.z,
                Y[$ + fe + 7] = 0),
              b === !0 &&
              (o.fromBufferAttribute(X, ae),
                X.normalized === !0 && v_(o, X),
                Y[$ + fe + 8] = o.x,
                Y[$ + fe + 9] = o.y,
                Y[$ + fe + 10] = o.z,
                Y[$ + fe + 11] = X.itemSize === 4 ? o.w : 1);
          }
        }
        _ = { count: v, texture: le, size: new se(k, z) },
          s.set(d, _),
          d.addEventListener("dispose", W);
      }
      let S = 0;
      for (let M = 0; M < g.length; M++) S += g[M];
      let w = d.morphTargetsRelative ? 1 : 1 - S;
      p.getUniforms().setValue(n, "morphTargetBaseInfluence", w),
        p.getUniforms().setValue(n, "morphTargetInfluences", g),
        p.getUniforms().setValue(n, "morphTargetsTexture", _.texture, t),
        p.getUniforms().setValue(n, "morphTargetsTextureSize", _.size);
    } else {
      let y = g === void 0 ? 0 : g.length, v = r[d.id];
      if (v === void 0 || v.length !== y) {
        v = [];
        for (let T = 0; T < y; T++) v[T] = [T, 0];
        r[d.id] = v;
      }
      for (let T = 0; T < y; T++) {
        let b = v[T];
        b[0] = T, b[1] = g[T];
      }
      v.sort(MO);
      for (let T = 0; T < 8; T++) {
        T < y && v[T][1]
          ? (a[T][0] = v[T][0], a[T][1] = v[T][1])
          : (a[T][0] = Number.MAX_SAFE_INTEGER, a[T][1] = 0);
      }
      a.sort(wO);
      let _ = d.morphAttributes.position, S = d.morphAttributes.normal, w = 0;
      for (let T = 0; T < 8; T++) {
        let b = a[T], R = b[0], P = b[1];
        R !== Number.MAX_SAFE_INTEGER && P
          ? (_ && d.getAttribute("morphTarget" + T) !== _[R] &&
            d.setAttribute("morphTarget" + T, _[R]),
            S && d.getAttribute("morphNormal" + T) !== S[R] &&
            d.setAttribute("morphNormal" + T, S[R]),
            i[T] = P,
            w += P)
          : (_ && d.hasAttribute("morphTarget" + T) === !0 &&
            d.deleteAttribute("morphTarget" + T),
            S && d.hasAttribute("morphNormal" + T) === !0 &&
            d.deleteAttribute("morphNormal" + T),
            i[T] = 0);
      }
      let M = d.morphTargetsRelative ? 1 : 1 - w;
      p.getUniforms().setValue(n, "morphTargetBaseInfluence", M),
        p.getUniforms().setValue(n, "morphTargetInfluences", i);
    }
  }
  return { update: u };
}
function TO(n, e, t, r) {
  let i = new WeakMap();
  function s(u) {
    let f = r.render.frame, d = u.geometry, h = e.get(u, d);
    return i.get(h) !== f && (e.update(h), i.set(h, f)),
      u.isInstancedMesh &&
      (u.hasEventListener("dispose", a) === !1 &&
        u.addEventListener("dispose", a),
        t.update(u.instanceMatrix, 34962),
        u.instanceColor !== null && t.update(u.instanceColor, 34962)),
      h;
  }
  function o() {
    i = new WeakMap();
  }
  function a(u) {
    let f = u.target;
    f.removeEventListener("dispose", a),
      t.remove(f.instanceMatrix),
      f.instanceColor !== null && t.remove(f.instanceColor);
  }
  return { update: s, dispose: o };
}
var YC = new Qt(),
  ZC = new Ru(),
  KC = new qf(),
  JC = new Gu(),
  QC = [],
  $C = [],
  eb = new Float32Array(16),
  tb = new Float32Array(9),
  nb = new Float32Array(4);
function qu(n, e, t) {
  let r = n[0];
  if (r <= 0 || r > 0) return n;
  let i = e * t, s = QC[i];
  if (s === void 0 && (s = new Float32Array(i), QC[i] = s), e !== 0) {
    r.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o) a += t, n[o].toArray(s, a);
  }
  return s;
}
function xr(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, r = n.length; t < r; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function _r(n, e) {
  for (let t = 0, r = e.length; t < r; t++) n[t] = e[t];
}
function Dm(n, e) {
  let t = $C[e];
  t === void 0 && (t = new Int32Array(e), $C[e] = t);
  for (let r = 0; r !== e; ++r) t[r] = n.allocateTextureUnit();
  return t;
}
function AO(n, e) {
  let t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), t[0] = e);
}
function CO(n, e) {
  let t = this.cache;
  if (e.x !== void 0) {
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  } else {
    if (xr(t, e)) return;
    n.uniform2fv(this.addr, e), _r(t, e);
  }
}
function bO(n, e) {
  let t = this.cache;
  if (e.x !== void 0) {
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
  } else if (e.r !== void 0) {
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
  } else {
    if (xr(t, e)) return;
    n.uniform3fv(this.addr, e), _r(t, e);
  }
}
function RO(n, e) {
  let t = this.cache;
  if (e.x !== void 0) {
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
  } else {
    if (xr(t, e)) return;
    n.uniform4fv(this.addr, e), _r(t, e);
  }
}
function LO(n, e) {
  let t = this.cache, r = e.elements;
  if (r === void 0) {
    if (xr(t, e)) return;
    n.uniformMatrix2fv(this.addr, !1, e), _r(t, e);
  } else {
    if (xr(t, r)) return;
    nb.set(r), n.uniformMatrix2fv(this.addr, !1, nb), _r(t, r);
  }
}
function PO(n, e) {
  let t = this.cache, r = e.elements;
  if (r === void 0) {
    if (xr(t, e)) return;
    n.uniformMatrix3fv(this.addr, !1, e), _r(t, e);
  } else {
    if (xr(t, r)) return;
    tb.set(r), n.uniformMatrix3fv(this.addr, !1, tb), _r(t, r);
  }
}
function IO(n, e) {
  let t = this.cache, r = e.elements;
  if (r === void 0) {
    if (xr(t, e)) return;
    n.uniformMatrix4fv(this.addr, !1, e), _r(t, e);
  } else {
    if (xr(t, r)) return;
    eb.set(r), n.uniformMatrix4fv(this.addr, !1, eb), _r(t, r);
  }
}
function NO(n, e) {
  let t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), t[0] = e);
}
function DO(n, e) {
  let t = this.cache;
  xr(t, e) || (n.uniform2iv(this.addr, e), _r(t, e));
}
function kO(n, e) {
  let t = this.cache;
  xr(t, e) || (n.uniform3iv(this.addr, e), _r(t, e));
}
function FO(n, e) {
  let t = this.cache;
  xr(t, e) || (n.uniform4iv(this.addr, e), _r(t, e));
}
function OO(n, e) {
  let t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), t[0] = e);
}
function zO(n, e) {
  let t = this.cache;
  xr(t, e) || (n.uniform2uiv(this.addr, e), _r(t, e));
}
function BO(n, e) {
  let t = this.cache;
  xr(t, e) || (n.uniform3uiv(this.addr, e), _r(t, e));
}
function UO(n, e) {
  let t = this.cache;
  xr(t, e) || (n.uniform4uiv(this.addr, e), _r(t, e));
}
function VO(n, e, t) {
  let r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i),
    t.setTexture2D(e || YC, i);
}
function HO(n, e, t) {
  let r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i),
    t.setTexture3D(e || KC, i);
}
function GO(n, e, t) {
  let r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i),
    t.setTextureCube(e || JC, i);
}
function jO(n, e, t) {
  let r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i),
    t.setTexture2DArray(e || ZC, i);
}
function WO(n) {
  switch (n) {
    case 5126:
      return AO;
    case 35664:
      return CO;
    case 35665:
      return bO;
    case 35666:
      return RO;
    case 35674:
      return LO;
    case 35675:
      return PO;
    case 35676:
      return IO;
    case 5124:
    case 35670:
      return NO;
    case 35667:
    case 35671:
      return DO;
    case 35668:
    case 35672:
      return kO;
    case 35669:
    case 35673:
      return FO;
    case 5125:
      return OO;
    case 36294:
      return zO;
    case 36295:
      return BO;
    case 36296:
      return UO;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return VO;
    case 35679:
    case 36299:
    case 36307:
      return HO;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return GO;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return jO;
  }
}
function XO(n, e) {
  n.uniform1fv(this.addr, e);
}
function qO(n, e) {
  let t = qu(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function YO(n, e) {
  let t = qu(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function ZO(n, e) {
  let t = qu(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function KO(n, e) {
  let t = qu(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function JO(n, e) {
  let t = qu(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function QO(n, e) {
  let t = qu(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function $O(n, e) {
  n.uniform1iv(this.addr, e);
}
function ez(n, e) {
  n.uniform2iv(this.addr, e);
}
function tz(n, e) {
  n.uniform3iv(this.addr, e);
}
function nz(n, e) {
  n.uniform4iv(this.addr, e);
}
function rz(n, e) {
  n.uniform1uiv(this.addr, e);
}
function iz(n, e) {
  n.uniform2uiv(this.addr, e);
}
function sz(n, e) {
  n.uniform3uiv(this.addr, e);
}
function oz(n, e) {
  n.uniform4uiv(this.addr, e);
}
function az(n, e, t) {
  let r = e.length, i = Dm(t, r);
  n.uniform1iv(this.addr, i);
  for (let s = 0; s !== r; ++s) t.setTexture2D(e[s] || YC, i[s]);
}
function lz(n, e, t) {
  let r = e.length, i = Dm(t, r);
  n.uniform1iv(this.addr, i);
  for (let s = 0; s !== r; ++s) t.setTexture3D(e[s] || KC, i[s]);
}
function uz(n, e, t) {
  let r = e.length, i = Dm(t, r);
  n.uniform1iv(this.addr, i);
  for (let s = 0; s !== r; ++s) t.setTextureCube(e[s] || JC, i[s]);
}
function cz(n, e, t) {
  let r = e.length, i = Dm(t, r);
  n.uniform1iv(this.addr, i);
  for (let s = 0; s !== r; ++s) t.setTexture2DArray(e[s] || ZC, i[s]);
}
function fz(n) {
  switch (n) {
    case 5126:
      return XO;
    case 35664:
      return qO;
    case 35665:
      return YO;
    case 35666:
      return ZO;
    case 35674:
      return KO;
    case 35675:
      return JO;
    case 35676:
      return QO;
    case 5124:
    case 35670:
      return $O;
    case 35667:
    case 35671:
      return ez;
    case 35668:
    case 35672:
      return tz;
    case 35669:
    case 35673:
      return nz;
    case 5125:
      return rz;
    case 36294:
      return iz;
    case 36295:
      return sz;
    case 36296:
      return oz;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return az;
    case 35679:
    case 36299:
    case 36307:
      return lz;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return uz;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return cz;
  }
}
var rb = class {
    constructor(e, t, r) {
      this.id = e, this.addr = r, this.cache = [], this.setValue = WO(t.type);
    }
  },
  ib = class {
    constructor(e, t, r) {
      this.id = e,
        this.addr = r,
        this.cache = [],
        this.size = t.size,
        this.setValue = fz(t.type);
    }
  },
  sb = class {
    constructor(e) {
      this.id = e, this.seq = [], this.map = {};
    }
    setValue(e, t, r) {
      let i = this.seq;
      for (let s = 0, o = i.length; s !== o; ++s) {
        let a = i[s];
        a.setValue(e, t[a.id], r);
      }
    }
  },
  y_ = /(\w+)(\])?(\[|\.)?/g;
function ob(n, e) {
  n.seq.push(e), n.map[e.id] = e;
}
function dz(n, e, t) {
  let r = n.name, i = r.length;
  for (y_.lastIndex = 0;;) {
    let s = y_.exec(r), o = y_.lastIndex, a = s[1], u = s[2] === "]", f = s[3];
    if (u && (a = a | 0), f === void 0 || f === "[" && o + 2 === i) {
      ob(t, f === void 0 ? new rb(a, n, e) : new ib(a, n, e));
      break;
    } else {
      let h = t.map[a];
      h === void 0 && (h = new sb(a), ob(t, h)), t = h;
    }
  }
}
var Qf = class {
  constructor(e, t) {
    this.seq = [], this.map = {};
    let r = e.getProgramParameter(t, 35718);
    for (let i = 0; i < r; ++i) {
      let s = e.getActiveUniform(t, i), o = e.getUniformLocation(t, s.name);
      dz(s, o, this);
    }
  }
  setValue(e, t, r, i) {
    let s = this.map[t];
    s !== void 0 && s.setValue(e, r, i);
  }
  setOptional(e, t, r) {
    let i = t[r];
    i !== void 0 && this.setValue(e, r, i);
  }
  static upload(e, t, r, i) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      let a = t[s], u = r[a.id];
      u.needsUpdate !== !1 && a.setValue(e, u.value, i);
    }
  }
  static seqWithValue(e, t) {
    let r = [];
    for (let i = 0, s = e.length; i !== s; ++i) {
      let o = e[i];
      o.id in t && r.push(o);
    }
    return r;
  }
};
function ab(n, e, t) {
  let r = n.createShader(e);
  return n.shaderSource(r, t), n.compileShader(r), r;
}
var hz = 0;
function pz(n, e) {
  let t = n.split(`
`),
    r = [],
    i = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let o = i; o < s; o++) {
    let a = o + 1;
    r.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return r.join(`
`);
}
function mz(n) {
  switch (n) {
    case Ys:
      return ["Linear", "( value )"];
    case yt:
      return ["sRGB", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported encoding:", n),
        ["Linear", "( value )"];
  }
}
function lb(n, e, t) {
  let r = n.getShaderParameter(e, 35713), i = n.getShaderInfoLog(e).trim();
  if (r && i === "") return "";
  let s = /ERROR: 0:(\d+)/.exec(i);
  if (s) {
    let o = parseInt(s[1]);
    return t.toUpperCase() + `

` + i + `

` + pz(n.getShaderSource(e), o);
  } else return i;
}
function gz(n, e) {
  let t = mz(e);
  return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function vz(n, e) {
  let t;
  switch (e) {
    case jA:
      t = "Linear";
      break;
    case WA:
      t = "Reinhard";
      break;
    case XA:
      t = "OptimizedCineon";
      break;
    case vx:
      t = "ACESFilmic";
      break;
    case qA:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear";
  }
  return "vec3 " + n + "( vec3 color ) { return " + t +
    "ToneMapping( color ); }";
}
function yz(n) {
  return [
    n.extensionDerivatives || !!n.envMapCubeUVHeight || n.bumpMap ||
      n.tangentSpaceNormalMap || n.clearcoatNormalMap || n.flatShading ||
      n.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (n.extensionFragDepth || n.logarithmicDepthBuffer) &&
      n.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    n.extensionDrawBuffers && n.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (n.extensionShaderTextureLOD || n.envMap || n.transmission) &&
      n.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter($f).join(`
`);
}
function xz(n) {
  let e = [];
  for (let t in n) {
    let r = n[t];
    r !== !1 && e.push("#define " + t + " " + r);
  }
  return e.join(`
`);
}
function _z(n, e) {
  let t = {}, r = n.getProgramParameter(e, 35721);
  for (let i = 0; i < r; i++) {
    let s = n.getActiveAttrib(e, i), o = s.name, a = 1;
    s.type === 35674 && (a = 2),
      s.type === 35675 && (a = 3),
      s.type === 35676 && (a = 4),
      t[o] = {
        type: s.type,
        location: n.getAttribLocation(e, o),
        locationSize: a,
      };
  }
  return t;
}
function $f(n) {
  return n !== "";
}
function ub(n, e) {
  return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(
    /NUM_SPOT_LIGHTS/g,
    e.numSpotLights,
  ).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(
    /NUM_POINT_LIGHTS/g,
    e.numPointLights,
  ).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(
    /NUM_DIR_LIGHT_SHADOWS/g,
    e.numDirLightShadows,
  ).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(
    /NUM_POINT_LIGHT_SHADOWS/g,
    e.numPointLightShadows,
  );
}
function cb(n, e) {
  return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(
    /UNION_CLIPPING_PLANES/g,
    e.numClippingPlanes - e.numClipIntersection,
  );
}
var Sz = /^[ \t]*#include +<([\w\d./]+)>/gm;
function x_(n) {
  return n.replace(Sz, wz);
}
function wz(n, e) {
  let t = ut[e];
  if (t === void 0) throw new Error("Can not resolve #include <" + e + ">");
  return x_(t);
}
var Mz =
    /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
  Ez =
    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function fb(n) {
  return n.replace(Ez, db).replace(Mz, Tz);
}
function Tz(n, e, t, r) {
  return console.warn(
    "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.",
  ),
    db(n, e, t, r);
}
function db(n, e, t, r) {
  let i = "";
  for (let s = parseInt(e); s < parseInt(t); s++) {
    i += r.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(
      /UNROLLED_LOOP_INDEX/g,
      s,
    );
  }
  return i;
}
function hb(n) {
  let e = "precision " + n.precision + ` float;
precision ` + n.precision + " int;";
  return n.precision === "highp"
    ? e += `
#define HIGH_PRECISION`
    : n.precision === "mediump"
    ? e += `
#define MEDIUM_PRECISION`
    : n.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e;
}
function Az(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return n.shadowMapType === Yp
    ? e = "SHADOWMAP_TYPE_PCF"
    : n.shadowMapType === zf
    ? e = "SHADOWMAP_TYPE_PCF_SOFT"
    : n.shadowMapType === Ka && (e = "SHADOWMAP_TYPE_VSM"),
    e;
}
function Cz(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap) {
    switch (n.envMapMode) {
      case Ho:
      case Go:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Au:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return e;
}
function bz(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap) {
    switch (n.envMapMode) {
      case Go:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return e;
}
function Rz(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap) {
    switch (n.combine) {
      case Bf:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case HA:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case GA:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return e;
}
function Lz(n) {
  let e = n.envMapCubeUVHeight;
  if (e === null) return null;
  let t = Math.log2(e) - 2, r = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: r,
    maxMip: t,
  };
}
function Pz(n, e, t, r) {
  let i = n.getContext(),
    s = t.defines,
    o = t.vertexShader,
    a = t.fragmentShader,
    u = Az(t),
    f = Cz(t),
    d = bz(t),
    h = Rz(t),
    p = Lz(t),
    g = t.isWebGL2 ? "" : yz(t),
    y = xz(s),
    v = i.createProgram(),
    _,
    S,
    w = t.glslVersion
      ? "#version " + t.glslVersion + `
`
      : "";
  t.isRawShaderMaterial
    ? (_ = [y].filter($f).join(`
`),
      _.length > 0 && (_ += `
`),
      S = [g, y].filter($f).join(`
`),
      S.length > 0 && (S += `
`))
    : (_ = [
      hb(t),
      "#define SHADER_NAME " + t.shaderName,
      y,
      t.instancing ? "#define USE_INSTANCING" : "",
      t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      t.useFog && t.fog ? "#define USE_FOG" : "",
      t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
      t.map ? "#define USE_MAP" : "",
      t.envMap ? "#define USE_ENVMAP" : "",
      t.envMap ? "#define " + d : "",
      t.lightMap ? "#define USE_LIGHTMAP" : "",
      t.aoMap ? "#define USE_AOMAP" : "",
      t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      t.bumpMap ? "#define USE_BUMPMAP" : "",
      t.normalMap ? "#define USE_NORMALMAP" : "",
      t.normalMap && t.objectSpaceNormalMap
        ? "#define OBJECTSPACE_NORMALMAP"
        : "",
      t.normalMap && t.tangentSpaceNormalMap
        ? "#define TANGENTSPACE_NORMALMAP"
        : "",
      t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      t.displacementMap && t.supportsVertexTextures
        ? "#define USE_DISPLACEMENTMAP"
        : "",
      t.specularMap ? "#define USE_SPECULARMAP" : "",
      t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
      t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      t.metalnessMap ? "#define USE_METALNESSMAP" : "",
      t.alphaMap ? "#define USE_ALPHAMAP" : "",
      t.transmission ? "#define USE_TRANSMISSION" : "",
      t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
      t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
      t.vertexTangents ? "#define USE_TANGENT" : "",
      t.vertexColors ? "#define USE_COLOR" : "",
      t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      t.vertexUvs ? "#define USE_UV" : "",
      t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      t.flatShading ? "#define FLAT_SHADED" : "",
      t.skinning ? "#define USE_SKINNING" : "",
      t.morphTargets ? "#define USE_MORPHTARGETS" : "",
      t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
      t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
      t.morphTargetsCount > 0 && t.isWebGL2
        ? "#define MORPHTARGETS_TEXTURE"
        : "",
      t.morphTargetsCount > 0 && t.isWebGL2
        ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
        : "",
      t.morphTargetsCount > 0 && t.isWebGL2
        ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
        : "",
      t.doubleSided ? "#define DOUBLE_SIDED" : "",
      t.flipSided ? "#define FLIP_SIDED" : "",
      t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      t.shadowMapEnabled ? "#define " + u : "",
      t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
        ? "#define USE_LOGDEPTHBUF_EXT"
        : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      `
`,
    ].filter($f).join(`
`),
      S = [
        g,
        hb(t),
        "#define SHADER_NAME " + t.shaderName,
        y,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + f : "",
        t.envMap ? "#define " + d : "",
        t.envMap ? "#define " + h : "",
        p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
        p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
        p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMap && t.objectSpaceNormalMap
          ? "#define OBJECTSPACE_NORMALMAP"
          : "",
        t.normalMap && t.tangentSpaceNormalMap
          ? "#define TANGENTSPACE_NORMALMAP"
          : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUvs ? "#define USE_UV" : "",
        t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + u : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== ji ? "#define TONE_MAPPING" : "",
        t.toneMapping !== ji ? ut.tonemapping_pars_fragment : "",
        t.toneMapping !== ji ? vz("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        ut.encodings_pars_fragment,
        gz("linearToOutputTexel", t.outputEncoding),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter($f).join(`
`)),
    o = x_(o),
    o = ub(o, t),
    o = cb(o, t),
    a = x_(a),
    a = ub(a, t),
    a = cb(a, t),
    o = fb(o),
    a = fb(a),
    t.isWebGL2 && t.isRawShaderMaterial !== !0 && (w = `#version 300 es
`,
      _ =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) + `
` + _,
      S = [
        "#define varying in",
        t.glslVersion === Hx
          ? ""
          : "layout(location = 0) out highp vec4 pc_fragColor;",
        t.glslVersion === Hx ? "" : "#define gl_FragColor pc_fragColor",
        "#define gl_FragDepthEXT gl_FragDepth",
        "#define texture2D texture",
        "#define textureCube texture",
        "#define texture2DProj textureProj",
        "#define texture2DLodEXT textureLod",
        "#define texture2DProjLodEXT textureProjLod",
        "#define textureCubeLodEXT textureLod",
        "#define texture2DGradEXT textureGrad",
        "#define texture2DProjGradEXT textureProjGrad",
        "#define textureCubeGradEXT textureGrad",
      ].join(`
`) + `
` + S);
  let M = w + _ + o, T = w + S + a, b = ab(i, 35633, M), R = ab(i, 35632, T);
  if (
    i.attachShader(v, b),
      i.attachShader(v, R),
      t.index0AttributeName !== void 0
        ? i.bindAttribLocation(v, 0, t.index0AttributeName)
        : t.morphTargets === !0 && i.bindAttribLocation(v, 0, "position"),
      i.linkProgram(v),
      n.debug.checkShaderErrors
  ) {
    let L = i.getProgramInfoLog(v).trim(),
      k = i.getShaderInfoLog(b).trim(),
      z = i.getShaderInfoLog(R).trim(),
      Y = !0,
      le = !0;
    if (i.getProgramParameter(v, 35714) === !1) {
      Y = !1;
      let V = lb(i, b, "vertex"), W = lb(i, R, "fragment");
      console.error(
        "THREE.WebGLProgram: Shader Error " + i.getError() +
          " - VALIDATE_STATUS " + i.getProgramParameter(v, 35715) + `

Program Info Log: ` + L + `
` + V + `
` +
          W,
      );
    } else {L !== ""
        ? console.warn("THREE.WebGLProgram: Program Info Log:", L)
        : (k === "" || z === "") && (le = !1);}
    le &&
      (this.diagnostics = {
        runnable: Y,
        programLog: L,
        vertexShader: { log: k, prefix: _ },
        fragmentShader: { log: z, prefix: S },
      });
  }
  i.deleteShader(b), i.deleteShader(R);
  let P;
  this.getUniforms = function () {
    return P === void 0 && (P = new Qf(i, v)), P;
  };
  let C;
  return this.getAttributes = function () {
    return C === void 0 && (C = _z(i, v)), C;
  },
    this.destroy = function () {
      r.releaseStatesOfProgram(this), i.deleteProgram(v), this.program = void 0;
    },
    this.name = t.shaderName,
    this.id = hz++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = v,
    this.vertexShader = b,
    this.fragmentShader = R,
    this;
}
var Iz = 0,
  pb = class {
    constructor() {
      this.shaderCache = new Map(), this.materialCache = new Map();
    }
    update(e) {
      let t = e.vertexShader,
        r = e.fragmentShader,
        i = this._getShaderStage(t),
        s = this._getShaderStage(r),
        o = this._getShaderCacheForMaterial(e);
      return o.has(i) === !1 && (o.add(i), i.usedTimes++),
        o.has(s) === !1 && (o.add(s), s.usedTimes++),
        this;
    }
    remove(e) {
      let t = this.materialCache.get(e);
      for (let r of t) {
        r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
      }
      return this.materialCache.delete(e), this;
    }
    getVertexShaderID(e) {
      return this._getShaderStage(e.vertexShader).id;
    }
    getFragmentShaderID(e) {
      return this._getShaderStage(e.fragmentShader).id;
    }
    dispose() {
      this.shaderCache.clear(), this.materialCache.clear();
    }
    _getShaderCacheForMaterial(e) {
      let t = this.materialCache;
      return t.has(e) === !1 && t.set(e, new Set()), t.get(e);
    }
    _getShaderStage(e) {
      let t = this.shaderCache;
      if (t.has(e) === !1) {
        let r = new mb(e);
        t.set(e, r);
      }
      return t.get(e);
    }
  },
  mb = class {
    constructor(e) {
      this.id = Iz++, this.code = e, this.usedTimes = 0;
    }
  };
function Nz(n, e, t, r, i, s, o) {
  let a = new na(),
    u = new pb(),
    f = [],
    d = i.isWebGL2,
    h = i.logarithmicDepthBuffer,
    p = i.vertexTextures,
    g = i.precision,
    y = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite",
    };
  function v(C, L, k, z, Y) {
    let le = z.fog,
      V = Y.geometry,
      W = C.isMeshStandardMaterial ? z.environment : null,
      G = (C.isMeshStandardMaterial ? t : e).get(C.envMap || W),
      re = !!G && G.mapping === Au ? G.image.height : null,
      ie = y[C.type];
    C.precision !== null &&
      (g = i.getMaxPrecision(C.precision),
        g !== C.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          C.precision,
          "not supported, using",
          g,
          "instead.",
        ));
    let X = V.morphAttributes.position || V.morphAttributes.normal ||
        V.morphAttributes.color,
      $ = X !== void 0 ? X.length : 0,
      ae = 0;
    V.morphAttributes.position !== void 0 && (ae = 1),
      V.morphAttributes.normal !== void 0 && (ae = 2),
      V.morphAttributes.color !== void 0 && (ae = 3);
    let fe, pe, Pe, Oe;
    if (ie) {
      let je = Qi[ie];
      fe = je.vertexShader, pe = je.fragmentShader;
    } else {fe = C.vertexShader,
        pe = C.fragmentShader,
        u.update(C),
        Pe = u.getVertexShaderID(C),
        Oe = u.getFragmentShaderID(C);}
    let oe = n.getRenderTarget(),
      Et = C.alphaTest > 0,
      $e = C.clearcoat > 0,
      Ze = C.iridescence > 0;
    return {
      isWebGL2: d,
      shaderID: ie,
      shaderName: C.type,
      vertexShader: fe,
      fragmentShader: pe,
      defines: C.defines,
      customVertexShaderID: Pe,
      customFragmentShaderID: Oe,
      isRawShaderMaterial: C.isRawShaderMaterial === !0,
      glslVersion: C.glslVersion,
      precision: g,
      instancing: Y.isInstancedMesh === !0,
      instancingColor: Y.isInstancedMesh === !0 && Y.instanceColor !== null,
      supportsVertexTextures: p,
      outputEncoding: oe === null
        ? n.outputEncoding
        : oe.isXRRenderTarget === !0
        ? oe.texture.encoding
        : Ys,
      map: !!C.map,
      matcap: !!C.matcap,
      envMap: !!G,
      envMapMode: G && G.mapping,
      envMapCubeUVHeight: re,
      lightMap: !!C.lightMap,
      aoMap: !!C.aoMap,
      emissiveMap: !!C.emissiveMap,
      bumpMap: !!C.bumpMap,
      normalMap: !!C.normalMap,
      objectSpaceNormalMap: C.normalMapType === pC,
      tangentSpaceNormalMap: C.normalMapType === Zs,
      decodeVideoTexture: !!C.map && C.map.isVideoTexture === !0 &&
        C.map.encoding === yt,
      clearcoat: $e,
      clearcoatMap: $e && !!C.clearcoatMap,
      clearcoatRoughnessMap: $e && !!C.clearcoatRoughnessMap,
      clearcoatNormalMap: $e && !!C.clearcoatNormalMap,
      iridescence: Ze,
      iridescenceMap: Ze && !!C.iridescenceMap,
      iridescenceThicknessMap: Ze && !!C.iridescenceThicknessMap,
      displacementMap: !!C.displacementMap,
      roughnessMap: !!C.roughnessMap,
      metalnessMap: !!C.metalnessMap,
      specularMap: !!C.specularMap,
      specularIntensityMap: !!C.specularIntensityMap,
      specularColorMap: !!C.specularColorMap,
      opaque: C.transparent === !1 && C.blending === Ja,
      alphaMap: !!C.alphaMap,
      alphaTest: Et,
      gradientMap: !!C.gradientMap,
      sheen: C.sheen > 0,
      sheenColorMap: !!C.sheenColorMap,
      sheenRoughnessMap: !!C.sheenRoughnessMap,
      transmission: C.transmission > 0,
      transmissionMap: !!C.transmissionMap,
      thicknessMap: !!C.thicknessMap,
      combine: C.combine,
      vertexTangents: !!C.normalMap && !!V.attributes.tangent,
      vertexColors: C.vertexColors,
      vertexAlphas: C.vertexColors === !0 && !!V.attributes.color &&
        V.attributes.color.itemSize === 4,
      vertexUvs: !!C.map || !!C.bumpMap || !!C.normalMap || !!C.specularMap ||
        !!C.alphaMap || !!C.emissiveMap || !!C.roughnessMap ||
        !!C.metalnessMap || !!C.clearcoatMap || !!C.clearcoatRoughnessMap ||
        !!C.clearcoatNormalMap || !!C.iridescenceMap ||
        !!C.iridescenceThicknessMap || !!C.displacementMap ||
        !!C.transmissionMap || !!C.thicknessMap || !!C.specularIntensityMap ||
        !!C.specularColorMap || !!C.sheenColorMap || !!C.sheenRoughnessMap,
      uvsVertexOnly:
        !(!!C.map || !!C.bumpMap || !!C.normalMap || !!C.specularMap ||
          !!C.alphaMap || !!C.emissiveMap || !!C.roughnessMap ||
          !!C.metalnessMap || !!C.clearcoatNormalMap || !!C.iridescenceMap ||
          !!C.iridescenceThicknessMap || C.transmission > 0 ||
          !!C.transmissionMap || !!C.thicknessMap || !!C.specularIntensityMap ||
          !!C.specularColorMap || C.sheen > 0 || !!C.sheenColorMap ||
          !!C.sheenRoughnessMap) && !!C.displacementMap,
      fog: !!le,
      useFog: C.fog === !0,
      fogExp2: le && le.isFogExp2,
      flatShading: !!C.flatShading,
      sizeAttenuation: C.sizeAttenuation,
      logarithmicDepthBuffer: h,
      skinning: Y.isSkinnedMesh === !0,
      morphTargets: V.morphAttributes.position !== void 0,
      morphNormals: V.morphAttributes.normal !== void 0,
      morphColors: V.morphAttributes.color !== void 0,
      morphTargetsCount: $,
      morphTextureStride: ae,
      numDirLights: L.directional.length,
      numPointLights: L.point.length,
      numSpotLights: L.spot.length,
      numRectAreaLights: L.rectArea.length,
      numHemiLights: L.hemi.length,
      numDirLightShadows: L.directionalShadowMap.length,
      numPointLightShadows: L.pointShadowMap.length,
      numSpotLightShadows: L.spotShadowMap.length,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: C.dithering,
      shadowMapEnabled: n.shadowMap.enabled && k.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: C.toneMapped ? n.toneMapping : ji,
      physicallyCorrectLights: n.physicallyCorrectLights,
      premultipliedAlpha: C.premultipliedAlpha,
      doubleSided: C.side === Gi,
      flipSided: C.side === mr,
      useDepthPacking: !!C.depthPacking,
      depthPacking: C.depthPacking || 0,
      index0AttributeName: C.index0AttributeName,
      extensionDerivatives: C.extensions && C.extensions.derivatives,
      extensionFragDepth: C.extensions && C.extensions.fragDepth,
      extensionDrawBuffers: C.extensions && C.extensions.drawBuffers,
      extensionShaderTextureLOD: C.extensions && C.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: d || r.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: d || r.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: d || r.has("EXT_shader_texture_lod"),
      customProgramCacheKey: C.customProgramCacheKey(),
    };
  }
  function _(C) {
    let L = [];
    if (
      C.shaderID
        ? L.push(C.shaderID)
        : (L.push(C.customVertexShaderID), L.push(C.customFragmentShaderID)),
        C.defines !== void 0
    ) { for (let k in C.defines) L.push(k), L.push(C.defines[k]); }
    return C.isRawShaderMaterial === !1 &&
      (S(L, C), w(L, C), L.push(n.outputEncoding)),
      L.push(C.customProgramCacheKey),
      L.join();
  }
  function S(C, L) {
    C.push(L.precision),
      C.push(L.outputEncoding),
      C.push(L.envMapMode),
      C.push(L.envMapCubeUVHeight),
      C.push(L.combine),
      C.push(L.vertexUvs),
      C.push(L.fogExp2),
      C.push(L.sizeAttenuation),
      C.push(L.morphTargetsCount),
      C.push(L.morphAttributeCount),
      C.push(L.numDirLights),
      C.push(L.numPointLights),
      C.push(L.numSpotLights),
      C.push(L.numHemiLights),
      C.push(L.numRectAreaLights),
      C.push(L.numDirLightShadows),
      C.push(L.numPointLightShadows),
      C.push(L.numSpotLightShadows),
      C.push(L.shadowMapType),
      C.push(L.toneMapping),
      C.push(L.numClippingPlanes),
      C.push(L.numClipIntersection),
      C.push(L.depthPacking);
  }
  function w(C, L) {
    a.disableAll(),
      L.isWebGL2 && a.enable(0),
      L.supportsVertexTextures && a.enable(1),
      L.instancing && a.enable(2),
      L.instancingColor && a.enable(3),
      L.map && a.enable(4),
      L.matcap && a.enable(5),
      L.envMap && a.enable(6),
      L.lightMap && a.enable(7),
      L.aoMap && a.enable(8),
      L.emissiveMap && a.enable(9),
      L.bumpMap && a.enable(10),
      L.normalMap && a.enable(11),
      L.objectSpaceNormalMap && a.enable(12),
      L.tangentSpaceNormalMap && a.enable(13),
      L.clearcoat && a.enable(14),
      L.clearcoatMap && a.enable(15),
      L.clearcoatRoughnessMap && a.enable(16),
      L.clearcoatNormalMap && a.enable(17),
      L.iridescence && a.enable(18),
      L.iridescenceMap && a.enable(19),
      L.iridescenceThicknessMap && a.enable(20),
      L.displacementMap && a.enable(21),
      L.specularMap && a.enable(22),
      L.roughnessMap && a.enable(23),
      L.metalnessMap && a.enable(24),
      L.gradientMap && a.enable(25),
      L.alphaMap && a.enable(26),
      L.alphaTest && a.enable(27),
      L.vertexColors && a.enable(28),
      L.vertexAlphas && a.enable(29),
      L.vertexUvs && a.enable(30),
      L.vertexTangents && a.enable(31),
      L.uvsVertexOnly && a.enable(32),
      L.fog && a.enable(33),
      C.push(a.mask),
      a.disableAll(),
      L.useFog && a.enable(0),
      L.flatShading && a.enable(1),
      L.logarithmicDepthBuffer && a.enable(2),
      L.skinning && a.enable(3),
      L.morphTargets && a.enable(4),
      L.morphNormals && a.enable(5),
      L.morphColors && a.enable(6),
      L.premultipliedAlpha && a.enable(7),
      L.shadowMapEnabled && a.enable(8),
      L.physicallyCorrectLights && a.enable(9),
      L.doubleSided && a.enable(10),
      L.flipSided && a.enable(11),
      L.useDepthPacking && a.enable(12),
      L.dithering && a.enable(13),
      L.specularIntensityMap && a.enable(14),
      L.specularColorMap && a.enable(15),
      L.transmission && a.enable(16),
      L.transmissionMap && a.enable(17),
      L.thicknessMap && a.enable(18),
      L.sheen && a.enable(19),
      L.sheenColorMap && a.enable(20),
      L.sheenRoughnessMap && a.enable(21),
      L.decodeVideoTexture && a.enable(22),
      L.opaque && a.enable(23),
      C.push(a.mask);
  }
  function M(C) {
    let L = y[C.type], k;
    if (L) {
      let z = Qi[L];
      k = Lm.clone(z.uniforms);
    } else k = C.uniforms;
    return k;
  }
  function T(C, L) {
    let k;
    for (let z = 0, Y = f.length; z < Y; z++) {
      let le = f[z];
      if (le.cacheKey === L) {
        k = le, ++k.usedTimes;
        break;
      }
    }
    return k === void 0 && (k = new Pz(n, L, C, s), f.push(k)), k;
  }
  function b(C) {
    if (--C.usedTimes == 0) {
      let L = f.indexOf(C);
      f[L] = f[f.length - 1], f.pop(), C.destroy();
    }
  }
  function R(C) {
    u.remove(C);
  }
  function P() {
    u.dispose();
  }
  return {
    getParameters: v,
    getProgramCacheKey: _,
    getUniforms: M,
    acquireProgram: T,
    releaseProgram: b,
    releaseShaderCache: R,
    programs: f,
    dispose: P,
  };
}
function Dz() {
  let n = new WeakMap();
  function e(s) {
    let o = n.get(s);
    return o === void 0 && (o = {}, n.set(s, o)), o;
  }
  function t(s) {
    n.delete(s);
  }
  function r(s, o, a) {
    n.get(s)[o] = a;
  }
  function i() {
    n = new WeakMap();
  }
  return { get: e, remove: t, update: r, dispose: i };
}
function kz(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.material.id !== e.material.id
    ? n.material.id - e.material.id
    : n.z !== e.z
    ? n.z - e.z
    : n.id - e.id;
}
function gb(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.z !== e.z
    ? e.z - n.z
    : n.id - e.id;
}
function vb() {
  let n = [], e = 0, t = [], r = [], i = [];
  function s() {
    e = 0, t.length = 0, r.length = 0, i.length = 0;
  }
  function o(h, p, g, y, v, _) {
    let S = n[e];
    return S === void 0
      ? (S = {
        id: h.id,
        object: h,
        geometry: p,
        material: g,
        groupOrder: y,
        renderOrder: h.renderOrder,
        z: v,
        group: _,
      },
        n[e] = S)
      : (S.id = h.id,
        S.object = h,
        S.geometry = p,
        S.material = g,
        S.groupOrder = y,
        S.renderOrder = h.renderOrder,
        S.z = v,
        S.group = _),
      e++,
      S;
  }
  function a(h, p, g, y, v, _) {
    let S = o(h, p, g, y, v, _);
    g.transmission > 0
      ? r.push(S)
      : g.transparent === !0
      ? i.push(S)
      : t.push(S);
  }
  function u(h, p, g, y, v, _) {
    let S = o(h, p, g, y, v, _);
    g.transmission > 0
      ? r.unshift(S)
      : g.transparent === !0
      ? i.unshift(S)
      : t.unshift(S);
  }
  function f(h, p) {
    t.length > 1 && t.sort(h || kz),
      r.length > 1 && r.sort(p || gb),
      i.length > 1 && i.sort(p || gb);
  }
  function d() {
    for (let h = e, p = n.length; h < p; h++) {
      let g = n[h];
      if (g.id === null) break;
      g.id = null,
        g.object = null,
        g.geometry = null,
        g.material = null,
        g.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: r,
    transparent: i,
    init: s,
    push: a,
    unshift: u,
    finish: d,
    sort: f,
  };
}
function Fz() {
  let n = new WeakMap();
  function e(r, i) {
    let s;
    return n.has(r) === !1
      ? (s = new vb(), n.set(r, [s]))
      : i >= n.get(r).length
      ? (s = new vb(), n.get(r).push(s))
      : s = n.get(r)[i],
      s;
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function Oz() {
  let n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new I(), color: new ve() };
          break;
        case "SpotLight":
          t = {
            position: new I(),
            direction: new I(),
            color: new ve(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new I(), color: new ve(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new I(), skyColor: new ve(), groundColor: new ve() };
          break;
        case "RectAreaLight":
          t = {
            color: new ve(),
            position: new I(),
            halfWidth: new I(),
            halfHeight: new I(),
          };
          break;
      }
      return n[e.id] = t, t;
    },
  };
}
function zz() {
  let n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new se(),
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new se(),
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new se(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return n[e.id] = t, t;
    },
  };
}
var Bz = 0;
function Uz(n, e) {
  return (e.castShadow ? 1 : 0) - (n.castShadow ? 1 : 0);
}
function Vz(n, e) {
  let t = new Oz(),
    r = zz(),
    i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadow: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
    };
  for (let d = 0; d < 9; d++) i.probe.push(new I());
  let s = new I(), o = new Ge(), a = new Ge();
  function u(d, h) {
    let p = 0, g = 0, y = 0;
    for (let L = 0; L < 9; L++) i.probe[L].set(0, 0, 0);
    let v = 0, _ = 0, S = 0, w = 0, M = 0, T = 0, b = 0, R = 0;
    d.sort(Uz);
    let P = h !== !0 ? Math.PI : 1;
    for (let L = 0, k = d.length; L < k; L++) {
      let z = d[L],
        Y = z.color,
        le = z.intensity,
        V = z.distance,
        W = z.shadow && z.shadow.map ? z.shadow.map.texture : null;
      if (z.isAmbientLight) {
        p += Y.r * le * P, g += Y.g * le * P, y += Y.b * le * P;
      } else if (z.isLightProbe) {
        for (let G = 0; G < 9; G++) {
          i.probe[G].addScaledVector(z.sh.coefficients[G], le);
        }
      } else if (z.isDirectionalLight) {
        let G = t.get(z);
        if (
          G.color.copy(z.color).multiplyScalar(z.intensity * P), z.castShadow
        ) {
          let re = z.shadow, ie = r.get(z);
          ie.shadowBias = re.bias,
            ie.shadowNormalBias = re.normalBias,
            ie.shadowRadius = re.radius,
            ie.shadowMapSize = re.mapSize,
            i.directionalShadow[v] = ie,
            i.directionalShadowMap[v] = W,
            i.directionalShadowMatrix[v] = z.shadow.matrix,
            T++;
        }
        i.directional[v] = G, v++;
      } else if (z.isSpotLight) {
        let G = t.get(z);
        if (
          G.position.setFromMatrixPosition(z.matrixWorld),
            G.color.copy(Y).multiplyScalar(le * P),
            G.distance = V,
            G.coneCos = Math.cos(z.angle),
            G.penumbraCos = Math.cos(z.angle * (1 - z.penumbra)),
            G.decay = z.decay,
            z.castShadow
        ) {
          let re = z.shadow, ie = r.get(z);
          ie.shadowBias = re.bias,
            ie.shadowNormalBias = re.normalBias,
            ie.shadowRadius = re.radius,
            ie.shadowMapSize = re.mapSize,
            i.spotShadow[S] = ie,
            i.spotShadowMap[S] = W,
            i.spotShadowMatrix[S] = z.shadow.matrix,
            R++;
        }
        i.spot[S] = G, S++;
      } else if (z.isRectAreaLight) {
        let G = t.get(z);
        G.color.copy(Y).multiplyScalar(le),
          G.halfWidth.set(z.width * .5, 0, 0),
          G.halfHeight.set(0, z.height * .5, 0),
          i.rectArea[w] = G,
          w++;
      } else if (z.isPointLight) {
        let G = t.get(z);
        if (
          G.color.copy(z.color).multiplyScalar(z.intensity * P),
            G.distance = z.distance,
            G.decay = z.decay,
            z.castShadow
        ) {
          let re = z.shadow, ie = r.get(z);
          ie.shadowBias = re.bias,
            ie.shadowNormalBias = re.normalBias,
            ie.shadowRadius = re.radius,
            ie.shadowMapSize = re.mapSize,
            ie.shadowCameraNear = re.camera.near,
            ie.shadowCameraFar = re.camera.far,
            i.pointShadow[_] = ie,
            i.pointShadowMap[_] = W,
            i.pointShadowMatrix[_] = z.shadow.matrix,
            b++;
        }
        i.point[_] = G, _++;
      } else if (z.isHemisphereLight) {
        let G = t.get(z);
        G.skyColor.copy(z.color).multiplyScalar(le * P),
          G.groundColor.copy(z.groundColor).multiplyScalar(le * P),
          i.hemi[M] = G,
          M++;
      }
    }
    w > 0 &&
    (e.isWebGL2 || n.has("OES_texture_float_linear") === !0
      ? (i.rectAreaLTC1 = Ee.LTC_FLOAT_1, i.rectAreaLTC2 = Ee.LTC_FLOAT_2)
      : n.has("OES_texture_half_float_linear") === !0
      ? (i.rectAreaLTC1 = Ee.LTC_HALF_1, i.rectAreaLTC2 = Ee.LTC_HALF_2)
      : console.error(
        "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.",
      )),
      i.ambient[0] = p,
      i.ambient[1] = g,
      i.ambient[2] = y;
    let C = i.hash;
    (C.directionalLength !== v || C.pointLength !== _ || C.spotLength !== S ||
      C.rectAreaLength !== w || C.hemiLength !== M ||
      C.numDirectionalShadows !== T || C.numPointShadows !== b ||
      C.numSpotShadows !== R) && (i.directional.length = v,
        i.spot.length = S,
        i.rectArea.length = w,
        i.point.length = _,
        i.hemi.length = M,
        i.directionalShadow.length = T,
        i.directionalShadowMap.length = T,
        i.pointShadow.length = b,
        i.pointShadowMap.length = b,
        i.spotShadow.length = R,
        i.spotShadowMap.length = R,
        i.directionalShadowMatrix.length = T,
        i.pointShadowMatrix.length = b,
        i.spotShadowMatrix.length = R,
        C.directionalLength = v,
        C.pointLength = _,
        C.spotLength = S,
        C.rectAreaLength = w,
        C.hemiLength = M,
        C.numDirectionalShadows = T,
        C.numPointShadows = b,
        C.numSpotShadows = R,
        i.version = Bz++);
  }
  function f(d, h) {
    let p = 0, g = 0, y = 0, v = 0, _ = 0, S = h.matrixWorldInverse;
    for (let w = 0, M = d.length; w < M; w++) {
      let T = d[w];
      if (T.isDirectionalLight) {
        let b = i.directional[p];
        b.direction.setFromMatrixPosition(T.matrixWorld),
          s.setFromMatrixPosition(T.target.matrixWorld),
          b.direction.sub(s),
          b.direction.transformDirection(S),
          p++;
      } else if (T.isSpotLight) {
        let b = i.spot[y];
        b.position.setFromMatrixPosition(T.matrixWorld),
          b.position.applyMatrix4(S),
          b.direction.setFromMatrixPosition(T.matrixWorld),
          s.setFromMatrixPosition(T.target.matrixWorld),
          b.direction.sub(s),
          b.direction.transformDirection(S),
          y++;
      } else if (T.isRectAreaLight) {
        let b = i.rectArea[v];
        b.position.setFromMatrixPosition(T.matrixWorld),
          b.position.applyMatrix4(S),
          a.identity(),
          o.copy(T.matrixWorld),
          o.premultiply(S),
          a.extractRotation(o),
          b.halfWidth.set(T.width * .5, 0, 0),
          b.halfHeight.set(0, T.height * .5, 0),
          b.halfWidth.applyMatrix4(a),
          b.halfHeight.applyMatrix4(a),
          v++;
      } else if (T.isPointLight) {
        let b = i.point[g];
        b.position.setFromMatrixPosition(T.matrixWorld),
          b.position.applyMatrix4(S),
          g++;
      } else if (T.isHemisphereLight) {
        let b = i.hemi[_];
        b.direction.setFromMatrixPosition(T.matrixWorld),
          b.direction.transformDirection(S),
          _++;
      }
    }
  }
  return { setup: u, setupView: f, state: i };
}
function yb(n, e) {
  let t = new Vz(n, e), r = [], i = [];
  function s() {
    r.length = 0, i.length = 0;
  }
  function o(h) {
    r.push(h);
  }
  function a(h) {
    i.push(h);
  }
  function u(h) {
    t.setup(r, h);
  }
  function f(h) {
    t.setupView(r, h);
  }
  return {
    init: s,
    state: { lightsArray: r, shadowsArray: i, lights: t },
    setupLights: u,
    setupLightsView: f,
    pushLight: o,
    pushShadow: a,
  };
}
function Hz(n, e) {
  let t = new WeakMap();
  function r(s, o = 0) {
    let a;
    return t.has(s) === !1
      ? (a = new yb(n, e), t.set(s, [a]))
      : o >= t.get(s).length
      ? (a = new yb(n, e), t.get(s).push(a))
      : a = t.get(s)[o],
      a;
  }
  function i() {
    t = new WeakMap();
  }
  return { get: r, dispose: i };
}
var Yu = class extends $t {
    constructor(e) {
      super();
      this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = dC,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e);
    }
    copy(e) {
      return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this;
    }
  },
  km = class extends $t {
    constructor(e) {
      super();
      this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new I(),
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e);
    }
    copy(e) {
      return super.copy(e),
        this.referencePosition.copy(e.referencePosition),
        this.nearDistance = e.nearDistance,
        this.farDistance = e.farDistance,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this;
    }
  },
  Gz = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  jz = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Wz(n, e, t) {
  let r = new Jf(),
    i = new se(),
    s = new se(),
    o = new Lt(),
    a = new Yu({ depthPacking: hC }),
    u = new km(),
    f = {},
    d = t.maxTextureSize,
    h = { 0: mr, 1: Gs, 2: Gi },
    p = new sr({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new se() },
        radius: { value: 4 },
      },
      vertexShader: Gz,
      fragmentShader: jz,
    }),
    g = p.clone();
  g.defines.HORIZONTAL_PASS = 1;
  let y = new Ye();
  y.setAttribute(
    "position",
    new pt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3),
  );
  let v = new Ot(y, p), _ = this;
  this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = Yp,
    this.render = function (T, b, R) {
      if (
        _.enabled === !1 || _.autoUpdate === !1 && _.needsUpdate === !1 ||
        T.length === 0
      ) return;
      let P = n.getRenderTarget(),
        C = n.getActiveCubeFace(),
        L = n.getActiveMipmapLevel(),
        k = n.state;
      k.setBlending(js),
        k.buffers.color.setClear(1, 1, 1, 1),
        k.buffers.depth.setTest(!0),
        k.setScissorTest(!1);
      for (let z = 0, Y = T.length; z < Y; z++) {
        let le = T[z], V = le.shadow;
        if (V === void 0) {
          console.warn("THREE.WebGLShadowMap:", le, "has no shadow.");
          continue;
        }
        if (V.autoUpdate === !1 && V.needsUpdate === !1) continue;
        i.copy(V.mapSize);
        let W = V.getFrameExtents();
        if (
          i.multiply(W),
            s.copy(V.mapSize),
            (i.x > d || i.y > d) &&
            (i.x > d &&
              (s.x = Math.floor(d / W.x), i.x = s.x * W.x, V.mapSize.x = s.x),
              i.y > d &&
              (s.y = Math.floor(d / W.y), i.y = s.y * W.y, V.mapSize.y = s.y)),
            V.map === null
        ) {
          let re = this.type !== Ka ? { minFilter: Jt, magFilter: Jt } : {};
          V.map = new yr(i.x, i.y, re),
            V.map.texture.name = le.name + ".shadowMap",
            V.camera.updateProjectionMatrix();
        }
        n.setRenderTarget(V.map), n.clear();
        let G = V.getViewportCount();
        for (let re = 0; re < G; re++) {
          let ie = V.getViewport(re);
          o.set(s.x * ie.x, s.y * ie.y, s.x * ie.z, s.y * ie.w),
            k.viewport(o),
            V.updateMatrices(le, re),
            r = V.getFrustum(),
            M(b, R, V.camera, le, this.type);
        }
        V.isPointLightShadow !== !0 && this.type === Ka && S(V, R),
          V.needsUpdate = !1;
      }
      _.needsUpdate = !1, n.setRenderTarget(P, C, L);
    };
  function S(T, b) {
    let R = e.update(v);
    p.defines.VSM_SAMPLES !== T.blurSamples &&
    (p.defines.VSM_SAMPLES = T.blurSamples,
      g.defines.VSM_SAMPLES = T.blurSamples,
      p.needsUpdate = !0,
      g.needsUpdate = !0),
      T.mapPass === null && (T.mapPass = new yr(i.x, i.y)),
      p.uniforms.shadow_pass.value = T.map.texture,
      p.uniforms.resolution.value = T.mapSize,
      p.uniforms.radius.value = T.radius,
      n.setRenderTarget(T.mapPass),
      n.clear(),
      n.renderBufferDirect(b, null, R, p, v, null),
      g.uniforms.shadow_pass.value = T.mapPass.texture,
      g.uniforms.resolution.value = T.mapSize,
      g.uniforms.radius.value = T.radius,
      n.setRenderTarget(T.map),
      n.clear(),
      n.renderBufferDirect(b, null, R, g, v, null);
  }
  function w(T, b, R, P, C, L) {
    let k = null,
      z = R.isPointLight === !0
        ? T.customDistanceMaterial
        : T.customDepthMaterial;
    if (
      z !== void 0 ? k = z : k = R.isPointLight === !0 ? u : a,
        n.localClippingEnabled && b.clipShadows === !0 &&
          Array.isArray(b.clippingPlanes) && b.clippingPlanes.length !== 0 ||
        b.displacementMap && b.displacementScale !== 0 ||
        b.alphaMap && b.alphaTest > 0
    ) {
      let Y = k.uuid, le = b.uuid, V = f[Y];
      V === void 0 && (V = {}, f[Y] = V);
      let W = V[le];
      W === void 0 && (W = k.clone(), V[le] = W), k = W;
    }
    return k.visible = b.visible,
      k.wireframe = b.wireframe,
      L === Ka
        ? k.side = b.shadowSide !== null ? b.shadowSide : b.side
        : k.side = b.shadowSide !== null ? b.shadowSide : h[b.side],
      k.alphaMap = b.alphaMap,
      k.alphaTest = b.alphaTest,
      k.clipShadows = b.clipShadows,
      k.clippingPlanes = b.clippingPlanes,
      k.clipIntersection = b.clipIntersection,
      k.displacementMap = b.displacementMap,
      k.displacementScale = b.displacementScale,
      k.displacementBias = b.displacementBias,
      k.wireframeLinewidth = b.wireframeLinewidth,
      k.linewidth = b.linewidth,
      R.isPointLight === !0 && k.isMeshDistanceMaterial === !0 &&
      (k.referencePosition.setFromMatrixPosition(R.matrixWorld),
        k.nearDistance = P,
        k.farDistance = C),
      k;
  }
  function M(T, b, R, P, C) {
    if (T.visible === !1) return;
    if (
      T.layers.test(b.layers) && (T.isMesh || T.isLine || T.isPoints) &&
      (T.castShadow || T.receiveShadow && C === Ka) &&
      (!T.frustumCulled || r.intersectsObject(T))
    ) {
      T.modelViewMatrix.multiplyMatrices(R.matrixWorldInverse, T.matrixWorld);
      let z = e.update(T), Y = T.material;
      if (Array.isArray(Y)) {
        let le = z.groups;
        for (let V = 0, W = le.length; V < W; V++) {
          let G = le[V], re = Y[G.materialIndex];
          if (re && re.visible) {
            let ie = w(T, re, P, R.near, R.far, C);
            n.renderBufferDirect(R, null, z, ie, T, G);
          }
        }
      } else if (Y.visible) {
        let le = w(T, Y, P, R.near, R.far, C);
        n.renderBufferDirect(R, null, z, le, T, null);
      }
    }
    let k = T.children;
    for (let z = 0, Y = k.length; z < Y; z++) M(k[z], b, R, P, C);
  }
}
function Xz(n, e, t) {
  let r = t.isWebGL2;
  function i() {
    let B = !1, Me = new Lt(), we = null, Xe = new Lt(0, 0, 0, 0);
    return {
      setMask: function (Ne) {
        we !== Ne && !B && (n.colorMask(Ne, Ne, Ne, Ne), we = Ne);
      },
      setLocked: function (Ne) {
        B = Ne;
      },
      setClear: function (Ne, Je, ye, Qe, At) {
        At === !0 && (Ne *= Qe, Je *= Qe, ye *= Qe),
          Me.set(Ne, Je, ye, Qe),
          Xe.equals(Me) === !1 && (n.clearColor(Ne, Je, ye, Qe), Xe.copy(Me));
      },
      reset: function () {
        B = !1, we = null, Xe.set(-1, 0, 0, 0);
      },
    };
  }
  function s() {
    let B = !1, Me = null, we = null, Xe = null;
    return {
      setTest: function (Ne) {
        Ne ? Oe(2929) : oe(2929);
      },
      setMask: function (Ne) {
        Me !== Ne && !B && (n.depthMask(Ne), Me = Ne);
      },
      setFunc: function (Ne) {
        if (we !== Ne) {
          if (Ne) {
            switch (Ne) {
              case kA:
                n.depthFunc(512);
                break;
              case FA:
                n.depthFunc(519);
                break;
              case OA:
                n.depthFunc(513);
                break;
              case Zp:
                n.depthFunc(515);
                break;
              case zA:
                n.depthFunc(514);
                break;
              case BA:
                n.depthFunc(518);
                break;
              case UA:
                n.depthFunc(516);
                break;
              case VA:
                n.depthFunc(517);
                break;
              default:
                n.depthFunc(515);
            }
          } else n.depthFunc(515);
          we = Ne;
        }
      },
      setLocked: function (Ne) {
        B = Ne;
      },
      setClear: function (Ne) {
        Xe !== Ne && (n.clearDepth(Ne), Xe = Ne);
      },
      reset: function () {
        B = !1, Me = null, we = null, Xe = null;
      },
    };
  }
  function o() {
    let B = !1,
      Me = null,
      we = null,
      Xe = null,
      Ne = null,
      Je = null,
      ye = null,
      Qe = null,
      At = null;
    return {
      setTest: function (Ct) {
        B || (Ct ? Oe(2960) : oe(2960));
      },
      setMask: function (Ct) {
        Me !== Ct && !B && (n.stencilMask(Ct), Me = Ct);
      },
      setFunc: function (Ct, Vn, Br) {
        (we !== Ct || Xe !== Vn || Ne !== Br) &&
          (n.stencilFunc(Ct, Vn, Br), we = Ct, Xe = Vn, Ne = Br);
      },
      setOp: function (Ct, Vn, Br) {
        (Je !== Ct || ye !== Vn || Qe !== Br) &&
          (n.stencilOp(Ct, Vn, Br), Je = Ct, ye = Vn, Qe = Br);
      },
      setLocked: function (Ct) {
        B = Ct;
      },
      setClear: function (Ct) {
        At !== Ct && (n.clearStencil(Ct), At = Ct);
      },
      reset: function () {
        B = !1,
          Me = null,
          we = null,
          Xe = null,
          Ne = null,
          Je = null,
          ye = null,
          Qe = null,
          At = null;
      },
    };
  }
  let a = new i(),
    u = new s(),
    f = new o(),
    d = {},
    h = {},
    p = new WeakMap(),
    g = [],
    y = null,
    v = !1,
    _ = null,
    S = null,
    w = null,
    M = null,
    T = null,
    b = null,
    R = null,
    P = !1,
    C = null,
    L = null,
    k = null,
    z = null,
    Y = null,
    le = n.getParameter(35661),
    V = !1,
    W = 0,
    G = n.getParameter(7938);
  G.indexOf("WebGL") !== -1
    ? (W = parseFloat(/^WebGL (\d)/.exec(G)[1]), V = W >= 1)
    : G.indexOf("OpenGL ES") !== -1 &&
      (W = parseFloat(/^OpenGL ES (\d)/.exec(G)[1]), V = W >= 2);
  let re = null,
    ie = {},
    X = n.getParameter(3088),
    $ = n.getParameter(2978),
    ae = new Lt().fromArray(X),
    fe = new Lt().fromArray($);
  function pe(B, Me, we) {
    let Xe = new Uint8Array(4), Ne = n.createTexture();
    n.bindTexture(B, Ne),
      n.texParameteri(B, 10241, 9728),
      n.texParameteri(B, 10240, 9728);
    for (let Je = 0; Je < we; Je++) {
      n.texImage2D(Me + Je, 0, 6408, 1, 1, 0, 6408, 5121, Xe);
    }
    return Ne;
  }
  let Pe = {};
  Pe[3553] = pe(3553, 3553, 1),
    Pe[34067] = pe(34067, 34069, 6),
    a.setClear(0, 0, 0, 1),
    u.setClear(1),
    f.setClear(0),
    Oe(2929),
    u.setFunc(Zp),
    _e(!1),
    Fe(ux),
    Oe(2884),
    ue(js);
  function Oe(B) {
    d[B] !== !0 && (n.enable(B), d[B] = !0);
  }
  function oe(B) {
    d[B] !== !1 && (n.disable(B), d[B] = !1);
  }
  function Et(B, Me) {
    return h[B] !== Me
      ? (n.bindFramebuffer(B, Me),
        h[B] = Me,
        r && (B === 36009 && (h[36160] = Me), B === 36160 && (h[36009] = Me)),
        !0)
      : !1;
  }
  function $e(B, Me) {
    let we = g, Xe = !1;
    if (B) {
      if (
        we = p.get(Me),
          we === void 0 && (we = [], p.set(Me, we)),
          B.isWebGLMultipleRenderTargets
      ) {
        let Ne = B.texture;
        if (we.length !== Ne.length || we[0] !== 36064) {
          for (let Je = 0, ye = Ne.length; Je < ye; Je++) we[Je] = 36064 + Je;
          we.length = Ne.length, Xe = !0;
        }
      } else we[0] !== 36064 && (we[0] = 36064, Xe = !0);
    } else we[0] !== 1029 && (we[0] = 1029, Xe = !0);
    Xe &&
      (t.isWebGL2
        ? n.drawBuffers(we)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(we));
  }
  function Ze(B) {
    return y !== B ? (n.useProgram(B), y = B, !0) : !1;
  }
  let Se = { [Qa]: 32774, [EA]: 32778, [TA]: 32779 };
  if (r) Se[hx] = 32775, Se[px] = 32776;
  else {
    let B = e.get("EXT_blend_minmax");
    B !== null && (Se[hx] = B.MIN_EXT, Se[px] = B.MAX_EXT);
  }
  let je = {
    [AA]: 0,
    [CA]: 1,
    [bA]: 768,
    [mx]: 770,
    [DA]: 776,
    [IA]: 774,
    [LA]: 772,
    [RA]: 769,
    [gx]: 771,
    [NA]: 775,
    [PA]: 773,
  };
  function ue(B, Me, we, Xe, Ne, Je, ye, Qe) {
    if (B === js) {
      v === !0 && (oe(3042), v = !1);
      return;
    }
    if (v === !1 && (Oe(3042), v = !0), B !== MA) {
      if (B !== _ || Qe !== P) {
        if (
          (S !== Qa || T !== Qa) && (n.blendEquation(32774), S = Qa, T = Qa), Qe
        ) {
          switch (B) {
            case Ja:
              n.blendFuncSeparate(1, 771, 1, 771);
              break;
            case cx:
              n.blendFunc(1, 1);
              break;
            case fx:
              n.blendFuncSeparate(0, 769, 0, 1);
              break;
            case dx:
              n.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", B);
              break;
          }
        } else {switch (B) {
            case Ja:
              n.blendFuncSeparate(770, 771, 1, 771);
              break;
            case cx:
              n.blendFunc(770, 1);
              break;
            case fx:
              n.blendFuncSeparate(0, 769, 0, 1);
              break;
            case dx:
              n.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", B);
              break;
          }}
        w = null, M = null, b = null, R = null, _ = B, P = Qe;
      }
      return;
    }
    Ne = Ne || Me,
      Je = Je || we,
      ye = ye || Xe,
      (Me !== S || Ne !== T) &&
      (n.blendEquationSeparate(Se[Me], Se[Ne]), S = Me, T = Ne),
      (we !== w || Xe !== M || Je !== b || ye !== R) &&
      (n.blendFuncSeparate(je[we], je[Xe], je[Je], je[ye]),
        w = we,
        M = Xe,
        b = Je,
        R = ye),
      _ = B,
      P = null;
  }
  function ne(B, Me) {
    B.side === Gi ? oe(2884) : Oe(2884);
    let we = B.side === mr;
    Me && (we = !we),
      _e(we),
      B.blending === Ja && B.transparent === !1
        ? ue(js)
        : ue(
          B.blending,
          B.blendEquation,
          B.blendSrc,
          B.blendDst,
          B.blendEquationAlpha,
          B.blendSrcAlpha,
          B.blendDstAlpha,
          B.premultipliedAlpha,
        ),
      u.setFunc(B.depthFunc),
      u.setTest(B.depthTest),
      u.setMask(B.depthWrite),
      a.setMask(B.colorWrite);
    let Xe = B.stencilWrite;
    f.setTest(Xe),
      Xe &&
      (f.setMask(B.stencilWriteMask),
        f.setFunc(B.stencilFunc, B.stencilRef, B.stencilFuncMask),
        f.setOp(B.stencilFail, B.stencilZFail, B.stencilZPass)),
      et(B.polygonOffset, B.polygonOffsetFactor, B.polygonOffsetUnits),
      B.alphaToCoverage === !0 ? Oe(32926) : oe(32926);
  }
  function _e(B) {
    C !== B && (B ? n.frontFace(2304) : n.frontFace(2305), C = B);
  }
  function Fe(B) {
    B !== xA
      ? (Oe(2884),
        B !== L &&
        (B === ux
          ? n.cullFace(1029)
          : B === _A
          ? n.cullFace(1028)
          : n.cullFace(1032)))
      : oe(2884), L = B;
  }
  function Ae(B) {
    B !== k && (V && n.lineWidth(B), k = B);
  }
  function et(B, Me, we) {
    B
      ? (Oe(32823),
        (z !== Me || Y !== we) && (n.polygonOffset(Me, we), z = Me, Y = we))
      : oe(32823);
  }
  function We(B) {
    B ? Oe(3089) : oe(3089);
  }
  function Ve(B) {
    B === void 0 && (B = 33984 + le - 1),
      re !== B && (n.activeTexture(B), re = B);
  }
  function Tt(B, Me) {
    re === null && Ve();
    let we = ie[re];
    we === void 0 && (we = { type: void 0, texture: void 0 }, ie[re] = we),
      (we.type !== B || we.texture !== Me) &&
      (n.bindTexture(B, Me || Pe[B]), we.type = B, we.texture = Me);
  }
  function Nt() {
    let B = ie[re];
    B !== void 0 && B.type !== void 0 &&
      (n.bindTexture(B.type, null), B.type = void 0, B.texture = void 0);
  }
  function O() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function N() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function J() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function me() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function xe() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function Ce() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function Ke() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function ee() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function Be(B) {
    ae.equals(B) === !1 && (n.scissor(B.x, B.y, B.z, B.w), ae.copy(B));
  }
  function Ie(B) {
    fe.equals(B) === !1 && (n.viewport(B.x, B.y, B.z, B.w), fe.copy(B));
  }
  function Re() {
    n.disable(3042),
      n.disable(2884),
      n.disable(2929),
      n.disable(32823),
      n.disable(3089),
      n.disable(2960),
      n.disable(32926),
      n.blendEquation(32774),
      n.blendFunc(1, 0),
      n.blendFuncSeparate(1, 0, 1, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(513),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(519, 0, 4294967295),
      n.stencilOp(7680, 7680, 7680),
      n.clearStencil(0),
      n.cullFace(1029),
      n.frontFace(2305),
      n.polygonOffset(0, 0),
      n.activeTexture(33984),
      n.bindFramebuffer(36160, null),
      r === !0 &&
      (n.bindFramebuffer(36009, null), n.bindFramebuffer(36008, null)),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      d = {},
      re = null,
      ie = {},
      h = {},
      p = new WeakMap(),
      g = [],
      y = null,
      v = !1,
      _ = null,
      S = null,
      w = null,
      M = null,
      T = null,
      b = null,
      R = null,
      P = !1,
      C = null,
      L = null,
      k = null,
      z = null,
      Y = null,
      ae.set(0, 0, n.canvas.width, n.canvas.height),
      fe.set(0, 0, n.canvas.width, n.canvas.height),
      a.reset(),
      u.reset(),
      f.reset();
  }
  return {
    buffers: { color: a, depth: u, stencil: f },
    enable: Oe,
    disable: oe,
    bindFramebuffer: Et,
    drawBuffers: $e,
    useProgram: Ze,
    setBlending: ue,
    setMaterial: ne,
    setFlipSided: _e,
    setCullFace: Fe,
    setLineWidth: Ae,
    setPolygonOffset: et,
    setScissorTest: We,
    activeTexture: Ve,
    bindTexture: Tt,
    unbindTexture: Nt,
    compressedTexImage2D: O,
    texImage2D: Ke,
    texImage3D: ee,
    texStorage2D: xe,
    texStorage3D: Ce,
    texSubImage2D: N,
    texSubImage3D: J,
    compressedTexSubImage2D: me,
    scissor: Be,
    viewport: Ie,
    reset: Re,
  };
}
function qz(n, e, t, r, i, s, o) {
  let a = i.isWebGL2,
    u = i.maxTextures,
    f = i.maxCubemapSize,
    d = i.maxTextureSize,
    h = i.maxSamples,
    p = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    g = /OculusBrowser/g.test(navigator.userAgent),
    y = new WeakMap(),
    v,
    _ = new WeakMap(),
    S = !1;
  try {
    S = typeof OffscreenCanvas != "undefined" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function w(O, N) {
    return S ? new OffscreenCanvas(O, N) : Xf("canvas");
  }
  function M(O, N, J, me) {
    let xe = 1;
    if (
      (O.width > me || O.height > me) &&
      (xe = me / Math.max(O.width, O.height)), xe < 1 || N === !0
    ) {
      if (
        typeof HTMLImageElement != "undefined" &&
          O instanceof HTMLImageElement ||
        typeof HTMLCanvasElement != "undefined" &&
          O instanceof HTMLCanvasElement ||
        typeof ImageBitmap != "undefined" && O instanceof ImageBitmap
      ) {
        let Ce = N ? am : Math.floor,
          Ke = Ce(xe * O.width),
          ee = Ce(xe * O.height);
        v === void 0 && (v = w(Ke, ee));
        let Be = J ? w(Ke, ee) : v;
        return Be.width = Ke,
          Be.height = ee,
          Be.getContext("2d").drawImage(O, 0, 0, Ke, ee),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" + O.width +
              "x" + O.height + ") to (" + Ke + "x" + ee + ").",
          ),
          Be;
      } else {return "data" in O &&
          console.warn(
            "THREE.WebGLRenderer: Image in DataTexture is too big (" + O.width +
              "x" + O.height + ").",
          ),
          O;}
    }
    return O;
  }
  function T(O) {
    return jx(O.width) && jx(O.height);
  }
  function b(O) {
    return a
      ? !1
      : O.wrapS !== Rn || O.wrapT !== Rn ||
        O.minFilter !== Jt && O.minFilter !== kt;
  }
  function R(O, N) {
    return O.generateMipmaps && N && O.minFilter !== Jt && O.minFilter !== kt;
  }
  function P(O) {
    n.generateMipmap(O);
  }
  function C(O, N, J, me, xe = !1) {
    if (a === !1) return N;
    if (O !== null) {
      if (n[O] !== void 0) return n[O];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          O + "'",
      );
    }
    let Ce = N;
    return N === 6403 &&
      (J === 5126 && (Ce = 33326),
        J === 5131 && (Ce = 33325),
        J === 5121 && (Ce = 33321)),
      N === 33319 &&
      (J === 5126 && (Ce = 33328),
        J === 5131 && (Ce = 33327),
        J === 5121 && (Ce = 33323)),
      N === 6408 &&
      (J === 5126 && (Ce = 34836),
        J === 5131 && (Ce = 34842),
        J === 5121 && (Ce = me === yt && xe === !1 ? 35907 : 32856),
        J === 32819 && (Ce = 32854),
        J === 32820 && (Ce = 32855)),
      (Ce === 33325 || Ce === 33326 || Ce === 33327 || Ce === 33328 ||
        Ce === 34842 || Ce === 34836) && e.get("EXT_color_buffer_float"),
      Ce;
  }
  function L(O, N, J) {
    return R(O, J) === !0 ||
        O.isFramebufferTexture && O.minFilter !== Jt && O.minFilter !== kt
      ? Math.log2(Math.max(N.width, N.height)) + 1
      : O.mipmaps !== void 0 && O.mipmaps.length > 0
      ? O.mipmaps.length
      : O.isCompressedTexture && Array.isArray(O.image)
      ? N.mipmaps.length
      : 1;
  }
  function k(O) {
    return O === Jt || O === jo || O === Wo ? 9728 : 9729;
  }
  function z(O) {
    let N = O.target;
    N.removeEventListener("dispose", z), le(N), N.isVideoTexture && y.delete(N);
  }
  function Y(O) {
    let N = O.target;
    N.removeEventListener("dispose", Y), W(N);
  }
  function le(O) {
    let N = r.get(O);
    if (N.__webglInit === void 0) return;
    let J = O.source, me = _.get(J);
    if (me) {
      let xe = me[N.__cacheKey];
      xe.usedTimes--,
        xe.usedTimes === 0 && V(O),
        Object.keys(me).length === 0 && _.delete(J);
    }
    r.remove(O);
  }
  function V(O) {
    let N = r.get(O);
    n.deleteTexture(N.__webglTexture);
    let J = O.source, me = _.get(J);
    delete me[N.__cacheKey], o.memory.textures--;
  }
  function W(O) {
    let N = O.texture, J = r.get(O), me = r.get(N);
    if (
      me.__webglTexture !== void 0 &&
      (n.deleteTexture(me.__webglTexture), o.memory.textures--),
        O.depthTexture && O.depthTexture.dispose(),
        O.isWebGLCubeRenderTarget
    ) {
      for (let xe = 0; xe < 6; xe++) {
        n.deleteFramebuffer(J.__webglFramebuffer[xe]),
          J.__webglDepthbuffer &&
          n.deleteRenderbuffer(J.__webglDepthbuffer[xe]);
      }
    } else {
      if (
        n.deleteFramebuffer(J.__webglFramebuffer),
          J.__webglDepthbuffer && n.deleteRenderbuffer(J.__webglDepthbuffer),
          J.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(J.__webglMultisampledFramebuffer),
          J.__webglColorRenderbuffer
      ) {
        for (let xe = 0; xe < J.__webglColorRenderbuffer.length; xe++) {
          J.__webglColorRenderbuffer[xe] &&
            n.deleteRenderbuffer(J.__webglColorRenderbuffer[xe]);
        }
      }
      J.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(J.__webglDepthRenderbuffer);
    }
    if (O.isWebGLMultipleRenderTargets) {
      for (let xe = 0, Ce = N.length; xe < Ce; xe++) {
        let Ke = r.get(N[xe]);
        Ke.__webglTexture &&
        (n.deleteTexture(Ke.__webglTexture), o.memory.textures--),
          r.remove(N[xe]);
      }
    }
    r.remove(N), r.remove(O);
  }
  let G = 0;
  function re() {
    G = 0;
  }
  function ie() {
    let O = G;
    return O >= u &&
      console.warn(
        "THREE.WebGLTextures: Trying to use " + O +
          " texture units while this GPU supports only " + u,
      ),
      G += 1,
      O;
  }
  function X(O) {
    let N = [];
    return N.push(O.wrapS),
      N.push(O.wrapT),
      N.push(O.magFilter),
      N.push(O.minFilter),
      N.push(O.anisotropy),
      N.push(O.internalFormat),
      N.push(O.format),
      N.push(O.type),
      N.push(O.generateMipmaps),
      N.push(O.premultiplyAlpha),
      N.push(O.flipY),
      N.push(O.unpackAlignment),
      N.push(O.encoding),
      N.join();
  }
  function $(O, N) {
    let J = r.get(O);
    if (
      O.isVideoTexture && Tt(O),
        O.isRenderTargetTexture === !1 && O.version > 0 &&
        J.__version !== O.version
    ) {
      let me = O.image;
      if (me === null) {
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found.",
        );
      } else if (me.complete === !1) {
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete",
        );
      } else {
        $e(J, O, N);
        return;
      }
    }
    t.activeTexture(33984 + N), t.bindTexture(3553, J.__webglTexture);
  }
  function ae(O, N) {
    let J = r.get(O);
    if (O.version > 0 && J.__version !== O.version) {
      $e(J, O, N);
      return;
    }
    t.activeTexture(33984 + N), t.bindTexture(35866, J.__webglTexture);
  }
  function fe(O, N) {
    let J = r.get(O);
    if (O.version > 0 && J.__version !== O.version) {
      $e(J, O, N);
      return;
    }
    t.activeTexture(33984 + N), t.bindTexture(32879, J.__webglTexture);
  }
  function pe(O, N) {
    let J = r.get(O);
    if (O.version > 0 && J.__version !== O.version) {
      Ze(J, O, N);
      return;
    }
    t.activeTexture(33984 + N), t.bindTexture(34067, J.__webglTexture);
  }
  let Pe = { [Wi]: 10497, [Rn]: 33071, [Ws]: 33648 },
    Oe = {
      [Jt]: 9728,
      [jo]: 9984,
      [Wo]: 9986,
      [kt]: 9729,
      [$a]: 9985,
      [Mi]: 9987,
    };
  function oe(O, N, J) {
    if (
      J
        ? (n.texParameteri(O, 10242, Pe[N.wrapS]),
          n.texParameteri(O, 10243, Pe[N.wrapT]),
          (O === 32879 || O === 35866) &&
          n.texParameteri(O, 32882, Pe[N.wrapR]),
          n.texParameteri(O, 10240, Oe[N.magFilter]),
          n.texParameteri(O, 10241, Oe[N.minFilter]))
        : (n.texParameteri(O, 10242, 33071),
          n.texParameteri(O, 10243, 33071),
          (O === 32879 || O === 35866) && n.texParameteri(O, 32882, 33071),
          (N.wrapS !== Rn || N.wrapT !== Rn) &&
          console.warn(
            "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.",
          ),
          n.texParameteri(O, 10240, k(N.magFilter)),
          n.texParameteri(O, 10241, k(N.minFilter)),
          N.minFilter !== Jt && N.minFilter !== kt &&
          console.warn(
            "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.",
          )),
        e.has("EXT_texture_filter_anisotropic") === !0
    ) {
      let me = e.get("EXT_texture_filter_anisotropic");
      if (
        N.type === Xs && e.has("OES_texture_float_linear") === !1 ||
        a === !1 && N.type === Yo &&
          e.has("OES_texture_half_float_linear") === !1
      ) return;
      (N.anisotropy > 1 || r.get(N).__currentAnisotropy) &&
        (n.texParameterf(
          O,
          me.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(N.anisotropy, i.getMaxAnisotropy()),
        ),
          r.get(N).__currentAnisotropy = N.anisotropy);
    }
  }
  function Et(O, N) {
    let J = !1;
    O.__webglInit === void 0 &&
      (O.__webglInit = !0, N.addEventListener("dispose", z));
    let me = N.source, xe = _.get(me);
    xe === void 0 && (xe = {}, _.set(me, xe));
    let Ce = X(N);
    if (Ce !== O.__cacheKey) {
      xe[Ce] === void 0 &&
      (xe[Ce] = { texture: n.createTexture(), usedTimes: 0 },
        o.memory.textures++,
        J = !0), xe[Ce].usedTimes++;
      let Ke = xe[O.__cacheKey];
      Ke !== void 0 &&
      (xe[O.__cacheKey].usedTimes--, Ke.usedTimes === 0 && V(N)),
        O.__cacheKey = Ce,
        O.__webglTexture = xe[Ce].texture;
    }
    return J;
  }
  function $e(O, N, J) {
    let me = 3553;
    N.isDataArrayTexture && (me = 35866), N.isData3DTexture && (me = 32879);
    let xe = Et(O, N), Ce = N.source;
    if (
      t.activeTexture(33984 + J),
        t.bindTexture(me, O.__webglTexture),
        Ce.version !== Ce.__currentVersion || xe === !0
    ) {
      n.pixelStorei(37440, N.flipY),
        n.pixelStorei(37441, N.premultiplyAlpha),
        n.pixelStorei(3317, N.unpackAlignment),
        n.pixelStorei(37443, 0);
      let Ke = b(N) && T(N.image) === !1, ee = M(N.image, Ke, !1, d);
      ee = Nt(N, ee);
      let Be = T(ee) || a,
        Ie = s.convert(N.format, N.encoding),
        Re = s.convert(N.type),
        B = C(N.internalFormat, Ie, Re, N.encoding, N.isVideoTexture);
      oe(me, N, Be);
      let Me,
        we = N.mipmaps,
        Xe = a && N.isVideoTexture !== !0,
        Ne = Ce.__currentVersion === void 0 || xe === !0,
        Je = L(N, ee, Be);
      if (N.isDepthTexture) {
        B = 6402,
          a
            ? N.type === Xs
              ? B = 36012
              : N.type === qo
              ? B = 33190
              : N.type === el
              ? B = 35056
              : B = 33189
            : N.type === Xs &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2.",
              ),
          N.format === Zo && B === 6402 && N.type !== yx && N.type !== qo &&
          (console.warn(
            "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.",
          ),
            N.type = qo,
            Re = s.convert(N.type)),
          N.format === tl && B === 6402 &&
          (B = 34041,
            N.type !== el &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.",
            ),
              N.type = el,
              Re = s.convert(N.type))),
          Ne && (Xe
            ? t.texStorage2D(3553, 1, B, ee.width, ee.height)
            : t.texImage2D(3553, 0, B, ee.width, ee.height, 0, Ie, Re, null));
      } else if (N.isDataTexture) {
        if (we.length > 0 && Be) {
          Xe && Ne && t.texStorage2D(3553, Je, B, we[0].width, we[0].height);
          for (let ye = 0, Qe = we.length; ye < Qe; ye++) {
            Me = we[ye],
              Xe
                ? t.texSubImage2D(
                  3553,
                  ye,
                  0,
                  0,
                  Me.width,
                  Me.height,
                  Ie,
                  Re,
                  Me.data,
                )
                : t.texImage2D(
                  3553,
                  ye,
                  B,
                  Me.width,
                  Me.height,
                  0,
                  Ie,
                  Re,
                  Me.data,
                );
          }
          N.generateMipmaps = !1;
        } else {Xe
            ? (Ne && t.texStorage2D(3553, Je, B, ee.width, ee.height),
              t.texSubImage2D(
                3553,
                0,
                0,
                0,
                ee.width,
                ee.height,
                Ie,
                Re,
                ee.data,
              ))
            : t.texImage2D(
              3553,
              0,
              B,
              ee.width,
              ee.height,
              0,
              Ie,
              Re,
              ee.data,
            );}
      } else if (N.isCompressedTexture) {
        Xe && Ne && t.texStorage2D(3553, Je, B, we[0].width, we[0].height);
        for (let ye = 0, Qe = we.length; ye < Qe; ye++) {
          Me = we[ye],
            N.format !== gr
              ? Ie !== null
                ? Xe
                  ? t.compressedTexSubImage2D(
                    3553,
                    ye,
                    0,
                    0,
                    Me.width,
                    Me.height,
                    Ie,
                    Me.data,
                  )
                  : t.compressedTexImage2D(
                    3553,
                    ye,
                    B,
                    Me.width,
                    Me.height,
                    0,
                    Me.data,
                  )
                : console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                )
              : Xe
              ? t.texSubImage2D(
                3553,
                ye,
                0,
                0,
                Me.width,
                Me.height,
                Ie,
                Re,
                Me.data,
              )
              : t.texImage2D(
                3553,
                ye,
                B,
                Me.width,
                Me.height,
                0,
                Ie,
                Re,
                Me.data,
              );
        }
      } else if (N.isDataArrayTexture) {
        Xe
          ? (Ne && t.texStorage3D(35866, Je, B, ee.width, ee.height, ee.depth),
            t.texSubImage3D(
              35866,
              0,
              0,
              0,
              0,
              ee.width,
              ee.height,
              ee.depth,
              Ie,
              Re,
              ee.data,
            ))
          : t.texImage3D(
            35866,
            0,
            B,
            ee.width,
            ee.height,
            ee.depth,
            0,
            Ie,
            Re,
            ee.data,
          );
      } else if (N.isData3DTexture) {
        Xe
          ? (Ne && t.texStorage3D(32879, Je, B, ee.width, ee.height, ee.depth),
            t.texSubImage3D(
              32879,
              0,
              0,
              0,
              0,
              ee.width,
              ee.height,
              ee.depth,
              Ie,
              Re,
              ee.data,
            ))
          : t.texImage3D(
            32879,
            0,
            B,
            ee.width,
            ee.height,
            ee.depth,
            0,
            Ie,
            Re,
            ee.data,
          );
      } else if (N.isFramebufferTexture) {
        if (Ne) {
          if (Xe) t.texStorage2D(3553, Je, B, ee.width, ee.height);
          else {
            let ye = ee.width, Qe = ee.height;
            for (let At = 0; At < Je; At++) {
              t.texImage2D(3553, At, B, ye, Qe, 0, Ie, Re, null),
                ye >>= 1,
                Qe >>= 1;
            }
          }
        }
      } else if (we.length > 0 && Be) {
        Xe && Ne && t.texStorage2D(3553, Je, B, we[0].width, we[0].height);
        for (let ye = 0, Qe = we.length; ye < Qe; ye++) {
          Me = we[ye],
            Xe
              ? t.texSubImage2D(3553, ye, 0, 0, Ie, Re, Me)
              : t.texImage2D(3553, ye, B, Ie, Re, Me);
        }
        N.generateMipmaps = !1;
      } else {Xe
          ? (Ne && t.texStorage2D(3553, Je, B, ee.width, ee.height),
            t.texSubImage2D(3553, 0, 0, 0, Ie, Re, ee))
          : t.texImage2D(3553, 0, B, Ie, Re, ee);}
      R(N, Be) && P(me),
        Ce.__currentVersion = Ce.version,
        N.onUpdate && N.onUpdate(N);
    }
    O.__version = N.version;
  }
  function Ze(O, N, J) {
    if (N.image.length !== 6) return;
    let me = Et(O, N), xe = N.source;
    if (
      t.activeTexture(33984 + J),
        t.bindTexture(34067, O.__webglTexture),
        xe.version !== xe.__currentVersion || me === !0
    ) {
      n.pixelStorei(37440, N.flipY),
        n.pixelStorei(37441, N.premultiplyAlpha),
        n.pixelStorei(3317, N.unpackAlignment),
        n.pixelStorei(37443, 0);
      let Ce = N.isCompressedTexture || N.image[0].isCompressedTexture,
        Ke = N.image[0] && N.image[0].isDataTexture,
        ee = [];
      for (let ye = 0; ye < 6; ye++) {
        !Ce && !Ke
          ? ee[ye] = M(N.image[ye], !1, !0, f)
          : ee[ye] = Ke ? N.image[ye].image : N.image[ye],
          ee[ye] = Nt(N, ee[ye]);
      }
      let Be = ee[0],
        Ie = T(Be) || a,
        Re = s.convert(N.format, N.encoding),
        B = s.convert(N.type),
        Me = C(N.internalFormat, Re, B, N.encoding),
        we = a && N.isVideoTexture !== !0,
        Xe = xe.__currentVersion === void 0 || me === !0,
        Ne = L(N, Be, Ie);
      oe(34067, N, Ie);
      let Je;
      if (Ce) {
        we && Xe && t.texStorage2D(34067, Ne, Me, Be.width, Be.height);
        for (let ye = 0; ye < 6; ye++) {
          Je = ee[ye].mipmaps;
          for (let Qe = 0; Qe < Je.length; Qe++) {
            let At = Je[Qe];
            N.format !== gr
              ? Re !== null
                ? we
                  ? t.compressedTexSubImage2D(
                    34069 + ye,
                    Qe,
                    0,
                    0,
                    At.width,
                    At.height,
                    Re,
                    At.data,
                  )
                  : t.compressedTexImage2D(
                    34069 + ye,
                    Qe,
                    Me,
                    At.width,
                    At.height,
                    0,
                    At.data,
                  )
                : console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()",
                )
              : we
              ? t.texSubImage2D(
                34069 + ye,
                Qe,
                0,
                0,
                At.width,
                At.height,
                Re,
                B,
                At.data,
              )
              : t.texImage2D(
                34069 + ye,
                Qe,
                Me,
                At.width,
                At.height,
                0,
                Re,
                B,
                At.data,
              );
          }
        }
      } else {
        Je = N.mipmaps,
          we && Xe &&
          (Je.length > 0 && Ne++,
            t.texStorage2D(34067, Ne, Me, ee[0].width, ee[0].height));
        for (let ye = 0; ye < 6; ye++) {
          if (Ke) {
            we
              ? t.texSubImage2D(
                34069 + ye,
                0,
                0,
                0,
                ee[ye].width,
                ee[ye].height,
                Re,
                B,
                ee[ye].data,
              )
              : t.texImage2D(
                34069 + ye,
                0,
                Me,
                ee[ye].width,
                ee[ye].height,
                0,
                Re,
                B,
                ee[ye].data,
              );
            for (let Qe = 0; Qe < Je.length; Qe++) {
              let Ct = Je[Qe].image[ye].image;
              we
                ? t.texSubImage2D(
                  34069 + ye,
                  Qe + 1,
                  0,
                  0,
                  Ct.width,
                  Ct.height,
                  Re,
                  B,
                  Ct.data,
                )
                : t.texImage2D(
                  34069 + ye,
                  Qe + 1,
                  Me,
                  Ct.width,
                  Ct.height,
                  0,
                  Re,
                  B,
                  Ct.data,
                );
            }
          } else {
            we
              ? t.texSubImage2D(34069 + ye, 0, 0, 0, Re, B, ee[ye])
              : t.texImage2D(34069 + ye, 0, Me, Re, B, ee[ye]);
            for (let Qe = 0; Qe < Je.length; Qe++) {
              let At = Je[Qe];
              we
                ? t.texSubImage2D(34069 + ye, Qe + 1, 0, 0, Re, B, At.image[ye])
                : t.texImage2D(34069 + ye, Qe + 1, Me, Re, B, At.image[ye]);
            }
          }
        }
      }
      R(N, Ie) && P(34067),
        xe.__currentVersion = xe.version,
        N.onUpdate && N.onUpdate(N);
    }
    O.__version = N.version;
  }
  function Se(O, N, J, me, xe) {
    let Ce = s.convert(J.format, J.encoding),
      Ke = s.convert(J.type),
      ee = C(J.internalFormat, Ce, Ke, J.encoding);
    r.get(N).__hasExternalTextures ||
    (xe === 32879 || xe === 35866
      ? t.texImage3D(xe, 0, ee, N.width, N.height, N.depth, 0, Ce, Ke, null)
      : t.texImage2D(xe, 0, ee, N.width, N.height, 0, Ce, Ke, null)),
      t.bindFramebuffer(36160, O),
      Ve(N)
        ? p.framebufferTexture2DMultisampleEXT(
          36160,
          me,
          xe,
          r.get(J).__webglTexture,
          0,
          We(N),
        )
        : n.framebufferTexture2D(36160, me, xe, r.get(J).__webglTexture, 0),
      t.bindFramebuffer(36160, null);
  }
  function je(O, N, J) {
    if (n.bindRenderbuffer(36161, O), N.depthBuffer && !N.stencilBuffer) {
      let me = 33189;
      if (J || Ve(N)) {
        let xe = N.depthTexture;
        xe && xe.isDepthTexture &&
          (xe.type === Xs ? me = 36012 : xe.type === qo && (me = 33190));
        let Ce = We(N);
        Ve(N)
          ? p.renderbufferStorageMultisampleEXT(
            36161,
            Ce,
            me,
            N.width,
            N.height,
          )
          : n.renderbufferStorageMultisample(36161, Ce, me, N.width, N.height);
      } else n.renderbufferStorage(36161, me, N.width, N.height);
      n.framebufferRenderbuffer(36160, 36096, 36161, O);
    } else if (N.depthBuffer && N.stencilBuffer) {
      let me = We(N);
      J && Ve(N) === !1
        ? n.renderbufferStorageMultisample(36161, me, 35056, N.width, N.height)
        : Ve(N)
        ? p.renderbufferStorageMultisampleEXT(
          36161,
          me,
          35056,
          N.width,
          N.height,
        )
        : n.renderbufferStorage(36161, 34041, N.width, N.height),
        n.framebufferRenderbuffer(36160, 33306, 36161, O);
    } else {
      let me = N.isWebGLMultipleRenderTargets === !0 ? N.texture : [N.texture];
      for (let xe = 0; xe < me.length; xe++) {
        let Ce = me[xe],
          Ke = s.convert(Ce.format, Ce.encoding),
          ee = s.convert(Ce.type),
          Be = C(Ce.internalFormat, Ke, ee, Ce.encoding),
          Ie = We(N);
        J && Ve(N) === !1
          ? n.renderbufferStorageMultisample(36161, Ie, Be, N.width, N.height)
          : Ve(N)
          ? p.renderbufferStorageMultisampleEXT(
            36161,
            Ie,
            Be,
            N.width,
            N.height,
          )
          : n.renderbufferStorage(36161, Be, N.width, N.height);
      }
    }
    n.bindRenderbuffer(36161, null);
  }
  function ue(O, N) {
    if (N && N.isWebGLCubeRenderTarget) {
      throw new Error(
        "Depth Texture with cube render targets is not supported",
      );
    }
    if (
      t.bindFramebuffer(36160, O),
        !(N.depthTexture && N.depthTexture.isDepthTexture)
    ) {
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture",
      );
    }
    (!r.get(N.depthTexture).__webglTexture ||
      N.depthTexture.image.width !== N.width ||
      N.depthTexture.image.height !== N.height) &&
    (N.depthTexture.image.width = N.width,
      N.depthTexture.image.height = N.height,
      N.depthTexture.needsUpdate = !0),
      $(N.depthTexture, 0);
    let me = r.get(N.depthTexture).__webglTexture, xe = We(N);
    if (N.depthTexture.format === Zo) {
      Ve(N)
        ? p.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, me, 0, xe)
        : n.framebufferTexture2D(36160, 36096, 3553, me, 0);
    } else if (N.depthTexture.format === tl) {
      Ve(N)
        ? p.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, me, 0, xe)
        : n.framebufferTexture2D(36160, 33306, 3553, me, 0);
    } else throw new Error("Unknown depthTexture format");
  }
  function ne(O) {
    let N = r.get(O), J = O.isWebGLCubeRenderTarget === !0;
    if (O.depthTexture && !N.__autoAllocateDepthBuffer) {
      if (J) {
        throw new Error(
          "target.depthTexture not supported in Cube render targets",
        );
      }
      ue(N.__webglFramebuffer, O);
    } else if (J) {
      N.__webglDepthbuffer = [];
      for (let me = 0; me < 6; me++) {
        t.bindFramebuffer(36160, N.__webglFramebuffer[me]),
          N.__webglDepthbuffer[me] = n.createRenderbuffer(),
          je(N.__webglDepthbuffer[me], O, !1);
      }
    } else {t.bindFramebuffer(36160, N.__webglFramebuffer),
        N.__webglDepthbuffer = n.createRenderbuffer(),
        je(N.__webglDepthbuffer, O, !1);}
    t.bindFramebuffer(36160, null);
  }
  function _e(O, N, J) {
    let me = r.get(O);
    N !== void 0 && Se(me.__webglFramebuffer, O, O.texture, 36064, 3553),
      J !== void 0 && ne(O);
  }
  function Fe(O) {
    let N = O.texture, J = r.get(O), me = r.get(N);
    O.addEventListener("dispose", Y),
      O.isWebGLMultipleRenderTargets !== !0 &&
      (me.__webglTexture === void 0 && (me.__webglTexture = n.createTexture()),
        me.__version = N.version,
        o.memory.textures++);
    let xe = O.isWebGLCubeRenderTarget === !0,
      Ce = O.isWebGLMultipleRenderTargets === !0,
      Ke = T(O) || a;
    if (xe) {
      J.__webglFramebuffer = [];
      for (let ee = 0; ee < 6; ee++) {
        J.__webglFramebuffer[ee] = n.createFramebuffer();
      }
    } else {
      if (J.__webglFramebuffer = n.createFramebuffer(), Ce) {
        if (i.drawBuffers) {
          let ee = O.texture;
          for (let Be = 0, Ie = ee.length; Be < Ie; Be++) {
            let Re = r.get(ee[Be]);
            Re.__webglTexture === void 0 &&
              (Re.__webglTexture = n.createTexture(), o.memory.textures++);
          }
        } else {console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.",
          );}
      }
      if (a && O.samples > 0 && Ve(O) === !1) {
        let ee = Ce ? N : [N];
        J.__webglMultisampledFramebuffer = n.createFramebuffer(),
          J.__webglColorRenderbuffer = [],
          t.bindFramebuffer(36160, J.__webglMultisampledFramebuffer);
        for (let Be = 0; Be < ee.length; Be++) {
          let Ie = ee[Be];
          J.__webglColorRenderbuffer[Be] = n.createRenderbuffer(),
            n.bindRenderbuffer(36161, J.__webglColorRenderbuffer[Be]);
          let Re = s.convert(Ie.format, Ie.encoding),
            B = s.convert(Ie.type),
            Me = C(Ie.internalFormat, Re, B, Ie.encoding),
            we = We(O);
          n.renderbufferStorageMultisample(36161, we, Me, O.width, O.height),
            n.framebufferRenderbuffer(
              36160,
              36064 + Be,
              36161,
              J.__webglColorRenderbuffer[Be],
            );
        }
        n.bindRenderbuffer(36161, null),
          O.depthBuffer &&
          (J.__webglDepthRenderbuffer = n.createRenderbuffer(),
            je(J.__webglDepthRenderbuffer, O, !0)),
          t.bindFramebuffer(36160, null);
      }
    }
    if (xe) {
      t.bindTexture(34067, me.__webglTexture), oe(34067, N, Ke);
      for (let ee = 0; ee < 6; ee++) {
        Se(J.__webglFramebuffer[ee], O, N, 36064, 34069 + ee);
      }
      R(N, Ke) && P(34067), t.unbindTexture();
    } else if (Ce) {
      let ee = O.texture;
      for (let Be = 0, Ie = ee.length; Be < Ie; Be++) {
        let Re = ee[Be], B = r.get(Re);
        t.bindTexture(3553, B.__webglTexture),
          oe(3553, Re, Ke),
          Se(J.__webglFramebuffer, O, Re, 36064 + Be, 3553),
          R(Re, Ke) && P(3553);
      }
      t.unbindTexture();
    } else {
      let ee = 3553;
      (O.isWebGL3DRenderTarget || O.isWebGLArrayRenderTarget) &&
      (a
        ? ee = O.isWebGL3DRenderTarget ? 32879 : 35866
        : console.error(
          "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.",
        )),
        t.bindTexture(ee, me.__webglTexture),
        oe(ee, N, Ke),
        Se(J.__webglFramebuffer, O, N, 36064, ee),
        R(N, Ke) && P(ee),
        t.unbindTexture();
    }
    O.depthBuffer && ne(O);
  }
  function Ae(O) {
    let N = T(O) || a,
      J = O.isWebGLMultipleRenderTargets === !0 ? O.texture : [O.texture];
    for (let me = 0, xe = J.length; me < xe; me++) {
      let Ce = J[me];
      if (R(Ce, N)) {
        let Ke = O.isWebGLCubeRenderTarget ? 34067 : 3553,
          ee = r.get(Ce).__webglTexture;
        t.bindTexture(Ke, ee), P(Ke), t.unbindTexture();
      }
    }
  }
  function et(O) {
    if (a && O.samples > 0 && Ve(O) === !1) {
      let N = O.isWebGLMultipleRenderTargets ? O.texture : [O.texture],
        J = O.width,
        me = O.height,
        xe = 16384,
        Ce = [],
        Ke = O.stencilBuffer ? 33306 : 36096,
        ee = r.get(O),
        Be = O.isWebGLMultipleRenderTargets === !0;
      if (Be) {
        for (let Ie = 0; Ie < N.length; Ie++) {
          t.bindFramebuffer(36160, ee.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(36160, 36064 + Ie, 36161, null),
            t.bindFramebuffer(36160, ee.__webglFramebuffer),
            n.framebufferTexture2D(36009, 36064 + Ie, 3553, null, 0);
        }
      }
      t.bindFramebuffer(36008, ee.__webglMultisampledFramebuffer),
        t.bindFramebuffer(36009, ee.__webglFramebuffer);
      for (let Ie = 0; Ie < N.length; Ie++) {
        Ce.push(36064 + Ie), O.depthBuffer && Ce.push(Ke);
        let Re = ee.__ignoreDepthValues !== void 0
          ? ee.__ignoreDepthValues
          : !1;
        if (
          Re === !1 &&
          (O.depthBuffer && (xe |= 256), O.stencilBuffer && (xe |= 1024)),
            Be &&
            n.framebufferRenderbuffer(
              36008,
              36064,
              36161,
              ee.__webglColorRenderbuffer[Ie],
            ),
            Re === !0 &&
            (n.invalidateFramebuffer(36008, [Ke]),
              n.invalidateFramebuffer(36009, [Ke])),
            Be
        ) {
          let B = r.get(N[Ie]).__webglTexture;
          n.framebufferTexture2D(36009, 36064, 3553, B, 0);
        }
        n.blitFramebuffer(0, 0, J, me, 0, 0, J, me, xe, 9728),
          g && n.invalidateFramebuffer(36008, Ce);
      }
      if (
        t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), Be
      ) {
        for (let Ie = 0; Ie < N.length; Ie++) {
          t.bindFramebuffer(36160, ee.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(
              36160,
              36064 + Ie,
              36161,
              ee.__webglColorRenderbuffer[Ie],
            );
          let Re = r.get(N[Ie]).__webglTexture;
          t.bindFramebuffer(36160, ee.__webglFramebuffer),
            n.framebufferTexture2D(36009, 36064 + Ie, 3553, Re, 0);
        }
      }
      t.bindFramebuffer(36009, ee.__webglMultisampledFramebuffer);
    }
  }
  function We(O) {
    return Math.min(h, O.samples);
  }
  function Ve(O) {
    let N = r.get(O);
    return a && O.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      N.__useRenderToTexture !== !1;
  }
  function Tt(O) {
    let N = o.render.frame;
    y.get(O) !== N && (y.set(O, N), O.update());
  }
  function Nt(O, N) {
    let J = O.encoding, me = O.format, xe = O.type;
    return O.isCompressedTexture === !0 || O.isVideoTexture === !0 ||
      O.format === om || J !== Ys && (J === yt
          ? a === !1
            ? e.has("EXT_sRGB") === !0 && me === gr
              ? (O.format = om, O.minFilter = kt, O.generateMipmaps = !1)
              : N = fm.sRGBToLinear(N)
            : (me !== gr || xe !== Xo) &&
              console.warn(
                "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.",
              )
          : console.error(
            "THREE.WebGLTextures: Unsupported texture encoding:",
            J,
          )),
      N;
  }
  this.allocateTextureUnit = ie,
    this.resetTextureUnits = re,
    this.setTexture2D = $,
    this.setTexture2DArray = ae,
    this.setTexture3D = fe,
    this.setTextureCube = pe,
    this.rebindTextures = _e,
    this.setupRenderTarget = Fe,
    this.updateRenderTargetMipmap = Ae,
    this.updateMultisampleRenderTarget = et,
    this.setupDepthRenderbuffer = ne,
    this.setupFrameBufferTexture = Se,
    this.useMultisampledRTT = Ve;
}
function xb(n, e, t) {
  let r = t.isWebGL2;
  function i(s, o = null) {
    let a;
    if (s === Xo) return 5121;
    if (s === JA) return 32819;
    if (s === QA) return 32820;
    if (s === YA) return 5120;
    if (s === ZA) return 5122;
    if (s === yx) return 5123;
    if (s === KA) return 5124;
    if (s === qo) return 5125;
    if (s === Xs) return 5126;
    if (s === Yo) {
      return r
        ? 5131
        : (a = e.get("OES_texture_half_float"),
          a !== null ? a.HALF_FLOAT_OES : null);
    }
    if (s === $A) return 6406;
    if (s === gr) return 6408;
    if (s === tC) return 6409;
    if (s === nC) return 6410;
    if (s === Zo) return 6402;
    if (s === tl) return 34041;
    if (s === rC) return 6403;
    if (s === eC) {
      return console.warn(
        "THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228",
      ),
        6408;
    }
    if (s === om) {
      return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
    }
    if (s === iC) return 36244;
    if (s === sC) return 33319;
    if (s === oC) return 33320;
    if (s === aC) return 36249;
    if (s === Jp || s === Qp || s === $p || s === em) {
      if (o === yt) {
        if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
          if (s === Jp) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === Qp) {
            return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          }
          if (s === $p) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === em) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      } else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (s === Jp) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === Qp) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === $p) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === em) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    }
    if (s === xx || s === _x || s === Sx || s === wx) {
      if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (s === xx) {
          return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        }
        if (s === _x) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === Sx) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === wx) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    }
    if (s === lC) {
      return a = e.get("WEBGL_compressed_texture_etc1"),
        a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
    }
    if (s === Mx || s === Ex) {
      if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
        if (s === Mx) {
          return o === yt
            ? a.COMPRESSED_SRGB8_ETC2
            : a.COMPRESSED_RGB8_ETC2;
        }
        if (s === Ex) {
          return o === yt
            ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : a.COMPRESSED_RGBA8_ETC2_EAC;
        }
      } else return null;
    }
    if (
      s === Tx || s === Ax || s === Cx || s === bx || s === Rx || s === Lx ||
      s === Px || s === Ix || s === Nx || s === Dx || s === kx || s === Fx ||
      s === Ox || s === zx
    ) {
      if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
        if (s === Tx) {
          return o === yt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        }
        if (s === Ax) {
          return o === yt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        }
        if (s === Cx) {
          return o === yt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        }
        if (s === bx) {
          return o === yt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        }
        if (s === Rx) {
          return o === yt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        }
        if (s === Lx) {
          return o === yt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        }
        if (s === Px) {
          return o === yt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        }
        if (s === Ix) {
          return o === yt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        }
        if (s === Nx) {
          return o === yt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        }
        if (s === Dx) {
          return o === yt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        }
        if (s === kx) {
          return o === yt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        }
        if (s === Fx) {
          return o === yt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        }
        if (s === Ox) {
          return o === yt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        }
        if (s === zx) {
          return o === yt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
        }
      } else return null;
    }
    if (s === Bx) {
      if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
        if (s === Bx) {
          return o === yt
            ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        }
      } else return null;
    }
    return s === el
      ? r
        ? 34042
        : (a = e.get("WEBGL_depth_texture"),
          a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null)
      : n[s] !== void 0
      ? n[s]
      : null;
  }
  return { convert: i };
}
var __ = class extends ln {
    constructor(e = []) {
      super();
      this.isArrayCamera = !0, this.cameras = e;
    }
  },
  ti = class extends ct {
    constructor() {
      super();
      this.isGroup = !0, this.type = "Group";
    }
  },
  Yz = { type: "move" },
  Fm = class {
    constructor() {
      this._targetRay = null, this._grip = null, this._hand = null;
    }
    getHandSpace() {
      return this._hand === null &&
        (this._hand = new ti(),
          this._hand.matrixAutoUpdate = !1,
          this._hand.visible = !1,
          this._hand.joints = {},
          this._hand.inputState = { pinching: !1 }),
        this._hand;
    }
    getTargetRaySpace() {
      return this._targetRay === null && (this._targetRay = new ti(),
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new I(),
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new I()),
        this._targetRay;
    }
    getGripSpace() {
      return this._grip === null && (this._grip = new ti(),
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new I(),
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new I()),
        this._grip;
    }
    dispatchEvent(e) {
      return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this;
    }
    disconnect(e) {
      return this.dispatchEvent({ type: "disconnected", data: e }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this;
    }
    update(e, t, r) {
      let i = null,
        s = null,
        o = null,
        a = this._targetRay,
        u = this._grip,
        f = this._hand;
      if (e && t.session.visibilityState !== "visible-blurred") {
        if (f && e.hand) {
          o = !0;
          for (let v of e.hand.values()) {
            let _ = t.getJointPose(v, r);
            if (f.joints[v.jointName] === void 0) {
              let w = new ti();
              w.matrixAutoUpdate = !1,
                w.visible = !1,
                f.joints[v.jointName] = w,
                f.add(w);
            }
            let S = f.joints[v.jointName];
            _ !== null &&
            (S.matrix.fromArray(_.transform.matrix),
              S.matrix.decompose(S.position, S.rotation, S.scale),
              S.jointRadius = _.radius), S.visible = _ !== null;
          }
          let d = f.joints["index-finger-tip"],
            h = f.joints["thumb-tip"],
            p = d.position.distanceTo(h.position),
            g = .02,
            y = .005;
          f.inputState.pinching && p > g + y
            ? (f.inputState.pinching = !1,
              this.dispatchEvent({
                type: "pinchend",
                handedness: e.handedness,
                target: this,
              }))
            : !f.inputState.pinching && p <= g - y &&
              (f.inputState.pinching = !0,
                this.dispatchEvent({
                  type: "pinchstart",
                  handedness: e.handedness,
                  target: this,
                }));
        } else {u !== null && e.gripSpace && (s = t.getPose(e.gripSpace, r),
            s !== null && (u.matrix.fromArray(s.transform.matrix),
              u.matrix.decompose(u.position, u.rotation, u.scale),
              s.linearVelocity
                ? (u.hasLinearVelocity = !0,
                  u.linearVelocity.copy(s.linearVelocity))
                : u.hasLinearVelocity = !1,
              s.angularVelocity
                ? (u.hasAngularVelocity = !0,
                  u.angularVelocity.copy(s.angularVelocity))
                : u.hasAngularVelocity = !1));}
        a !== null && (i = t.getPose(e.targetRaySpace, r),
          i === null && s !== null && (i = s),
          i !== null && (a.matrix.fromArray(i.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            i.linearVelocity
              ? (a.hasLinearVelocity = !0,
                a.linearVelocity.copy(i.linearVelocity))
              : a.hasLinearVelocity = !1,
            i.angularVelocity
              ? (a.hasAngularVelocity = !0,
                a.angularVelocity.copy(i.angularVelocity))
              : a.hasAngularVelocity = !1,
            this.dispatchEvent(Yz)));
      }
      return a !== null && (a.visible = i !== null),
        u !== null && (u.visible = s !== null),
        f !== null && (f.visible = o !== null),
        this;
    }
  },
  S_ = class extends Qt {
    constructor(e, t, r, i, s, o, a, u, f, d) {
      if (d = d !== void 0 ? d : Zo, d !== Zo && d !== tl) {
        throw new Error(
          "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat",
        );
      }
      r === void 0 && d === Zo && (r = qo),
        r === void 0 && d === tl && (r = el);
      super(null, i, s, o, a, u, d, r, f);
      this.isDepthTexture = !0,
        this.image = { width: e, height: t },
        this.magFilter = a !== void 0 ? a : Jt,
        this.minFilter = u !== void 0 ? u : Jt,
        this.flipY = !1,
        this.generateMipmaps = !1;
    }
  },
  _b = class extends Xi {
    constructor(e, t) {
      super();
      let r = this,
        i = null,
        s = 1,
        o = null,
        a = "local-floor",
        u = null,
        f = null,
        d = null,
        h = null,
        p = null,
        g = null,
        y = t.getContextAttributes(),
        v = null,
        _ = null,
        S = [],
        w = [],
        M = new ln();
      M.layers.enable(1), M.viewport = new Lt();
      let T = new ln();
      T.layers.enable(2), T.viewport = new Lt();
      let b = [M, T], R = new __();
      R.layers.enable(1), R.layers.enable(2);
      let P = null, C = null;
      this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function (X) {
          let $ = S[X];
          return $ === void 0 && ($ = new Fm(), S[X] = $),
            $.getTargetRaySpace();
        },
        this.getControllerGrip = function (X) {
          let $ = S[X];
          return $ === void 0 && ($ = new Fm(), S[X] = $), $.getGripSpace();
        },
        this.getHand = function (X) {
          let $ = S[X];
          return $ === void 0 && ($ = new Fm(), S[X] = $), $.getHandSpace();
        };
      function L(X) {
        let $ = w.indexOf(X.inputSource);
        if ($ === -1) return;
        let ae = S[$];
        ae !== void 0 &&
          ae.dispatchEvent({ type: X.type, data: X.inputSource });
      }
      function k() {
        i.removeEventListener("select", L),
          i.removeEventListener("selectstart", L),
          i.removeEventListener("selectend", L),
          i.removeEventListener("squeeze", L),
          i.removeEventListener("squeezestart", L),
          i.removeEventListener("squeezeend", L),
          i.removeEventListener("end", k),
          i.removeEventListener("inputsourceschange", z);
        for (let X = 0; X < S.length; X++) {
          let $ = w[X];
          $ !== null && (w[X] = null, S[X].disconnect($));
        }
        P = null,
          C = null,
          e.setRenderTarget(v),
          p = null,
          h = null,
          d = null,
          i = null,
          _ = null,
          ie.stop(),
          r.isPresenting = !1,
          r.dispatchEvent({ type: "sessionend" });
      }
      this.setFramebufferScaleFactor = function (X) {
        s = X,
          r.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting.",
          );
      },
        this.setReferenceSpaceType = function (X) {
          a = X,
            r.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting.",
            );
        },
        this.getReferenceSpace = function () {
          return u || o;
        },
        this.setReferenceSpace = function (X) {
          u = X;
        },
        this.getBaseLayer = function () {
          return h !== null ? h : p;
        },
        this.getBinding = function () {
          return d;
        },
        this.getFrame = function () {
          return g;
        },
        this.getSession = function () {
          return i;
        },
        this.setSession = async function (X) {
          if (i = X, i !== null) {
            if (
              v = e.getRenderTarget(),
                i.addEventListener("select", L),
                i.addEventListener("selectstart", L),
                i.addEventListener("selectend", L),
                i.addEventListener("squeeze", L),
                i.addEventListener("squeezestart", L),
                i.addEventListener("squeezeend", L),
                i.addEventListener("end", k),
                i.addEventListener("inputsourceschange", z),
                y.xrCompatible !== !0 && await t.makeXRCompatible(),
                i.renderState.layers === void 0 ||
                e.capabilities.isWebGL2 === !1
            ) {
              let $ = {
                antialias: i.renderState.layers === void 0 ? y.antialias : !0,
                alpha: y.alpha,
                depth: y.depth,
                stencil: y.stencil,
                framebufferScaleFactor: s,
              };
              p = new XRWebGLLayer(i, t, $),
                i.updateRenderState({ baseLayer: p }),
                _ = new yr(p.framebufferWidth, p.framebufferHeight, {
                  format: gr,
                  type: Xo,
                  encoding: e.outputEncoding,
                });
            } else {
              let $ = null, ae = null, fe = null;
              y.depth &&
                (fe = y.stencil ? 35056 : 33190,
                  $ = y.stencil ? tl : Zo,
                  ae = y.stencil ? el : qo);
              let pe = { colorFormat: 32856, depthFormat: fe, scaleFactor: s };
              d = new XRWebGLBinding(i, t),
                h = d.createProjectionLayer(pe),
                i.updateRenderState({ layers: [h] }),
                _ = new yr(h.textureWidth, h.textureHeight, {
                  format: gr,
                  type: Xo,
                  depthTexture: new S_(
                    h.textureWidth,
                    h.textureHeight,
                    ae,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    $,
                  ),
                  stencilBuffer: y.stencil,
                  encoding: e.outputEncoding,
                  samples: y.antialias ? 4 : 0,
                });
              let Pe = e.properties.get(_);
              Pe.__ignoreDepthValues = h.ignoreDepthValues;
            }
            _.isXRRenderTarget = !0,
              this.setFoveation(1),
              u = null,
              o = await i.requestReferenceSpace(a),
              ie.setContext(i),
              ie.start(),
              r.isPresenting = !0,
              r.dispatchEvent({ type: "sessionstart" });
          }
        };
      function z(X) {
        for (let $ = 0; $ < X.removed.length; $++) {
          let ae = X.removed[$], fe = w.indexOf(ae);
          fe >= 0 &&
            (w[fe] = null,
              S[fe].dispatchEvent({ type: "disconnected", data: ae }));
        }
        for (let $ = 0; $ < X.added.length; $++) {
          let ae = X.added[$], fe = w.indexOf(ae);
          if (fe === -1) {
            for (let Pe = 0; Pe < S.length; Pe++) {
              if (Pe >= w.length) {
                w.push(ae), fe = Pe;
                break;
              } else if (w[Pe] === null) {
                w[Pe] = ae, fe = Pe;
                break;
              }
            }
            if (fe === -1) break;
          }
          let pe = S[fe];
          pe && pe.dispatchEvent({ type: "connected", data: ae });
        }
      }
      let Y = new I(), le = new I();
      function V(X, $, ae) {
        Y.setFromMatrixPosition($.matrixWorld),
          le.setFromMatrixPosition(ae.matrixWorld);
        let fe = Y.distanceTo(le),
          pe = $.projectionMatrix.elements,
          Pe = ae.projectionMatrix.elements,
          Oe = pe[14] / (pe[10] - 1),
          oe = pe[14] / (pe[10] + 1),
          Et = (pe[9] + 1) / pe[5],
          $e = (pe[9] - 1) / pe[5],
          Ze = (pe[8] - 1) / pe[0],
          Se = (Pe[8] + 1) / Pe[0],
          je = Oe * Ze,
          ue = Oe * Se,
          ne = fe / (-Ze + Se),
          _e = ne * -Ze;
        $.matrixWorld.decompose(X.position, X.quaternion, X.scale),
          X.translateX(_e),
          X.translateZ(ne),
          X.matrixWorld.compose(X.position, X.quaternion, X.scale),
          X.matrixWorldInverse.copy(X.matrixWorld).invert();
        let Fe = Oe + ne,
          Ae = oe + ne,
          et = je - _e,
          We = ue + (fe - _e),
          Ve = Et * oe / Ae * Fe,
          Tt = $e * oe / Ae * Fe;
        X.projectionMatrix.makePerspective(et, We, Ve, Tt, Fe, Ae);
      }
      function W(X, $) {
        $ === null
          ? X.matrixWorld.copy(X.matrix)
          : X.matrixWorld.multiplyMatrices($.matrixWorld, X.matrix),
          X.matrixWorldInverse.copy(X.matrixWorld).invert();
      }
      this.updateCamera = function (X) {
        if (i === null) return;
        R.near = T.near = M.near = X.near,
          R.far = T.far = M.far = X.far,
          (P !== R.near || C !== R.far) &&
          (i.updateRenderState({ depthNear: R.near, depthFar: R.far }),
            P = R.near,
            C = R.far);
        let $ = X.parent, ae = R.cameras;
        W(R, $);
        for (let pe = 0; pe < ae.length; pe++) W(ae[pe], $);
        R.matrixWorld.decompose(R.position, R.quaternion, R.scale),
          X.position.copy(R.position),
          X.quaternion.copy(R.quaternion),
          X.scale.copy(R.scale),
          X.matrix.copy(R.matrix),
          X.matrixWorld.copy(R.matrixWorld);
        let fe = X.children;
        for (let pe = 0, Pe = fe.length; pe < Pe; pe++) {
          fe[pe].updateMatrixWorld(!0);
        }
        ae.length === 2
          ? V(R, M, T)
          : R.projectionMatrix.copy(M.projectionMatrix);
      },
        this.getCamera = function () {
          return R;
        },
        this.getFoveation = function () {
          if (h !== null) return h.fixedFoveation;
          if (p !== null) return p.fixedFoveation;
        },
        this.setFoveation = function (X) {
          h !== null && (h.fixedFoveation = X),
            p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = X);
        };
      let G = null;
      function re(X, $) {
        if (f = $.getViewerPose(u || o), g = $, f !== null) {
          let ae = f.views;
          p !== null &&
            (e.setRenderTargetFramebuffer(_, p.framebuffer),
              e.setRenderTarget(_));
          let fe = !1;
          ae.length !== R.cameras.length && (R.cameras.length = 0, fe = !0);
          for (let pe = 0; pe < ae.length; pe++) {
            let Pe = ae[pe], Oe = null;
            if (p !== null) Oe = p.getViewport(Pe);
            else {
              let Et = d.getViewSubImage(h, Pe);
              Oe = Et.viewport,
                pe === 0 &&
                (e.setRenderTargetTextures(
                  _,
                  Et.colorTexture,
                  h.ignoreDepthValues ? void 0 : Et.depthStencilTexture,
                ),
                  e.setRenderTarget(_));
            }
            let oe = b[pe];
            oe === void 0 &&
            (oe = new ln(),
              oe.layers.enable(pe),
              oe.viewport = new Lt(),
              b[pe] = oe),
              oe.matrix.fromArray(Pe.transform.matrix),
              oe.projectionMatrix.fromArray(Pe.projectionMatrix),
              oe.viewport.set(Oe.x, Oe.y, Oe.width, Oe.height),
              pe === 0 && R.matrix.copy(oe.matrix),
              fe === !0 && R.cameras.push(oe);
          }
        }
        for (let ae = 0; ae < S.length; ae++) {
          let fe = w[ae], pe = S[ae];
          fe !== null && pe !== void 0 && pe.update(fe, $, u || o);
        }
        G && G(X, $), g = null;
      }
      let ie = new VC();
      ie.setAnimationLoop(re),
        this.setAnimationLoop = function (X) {
          G = X;
        },
        this.dispose = function () {};
    }
  };
function Zz(n, e) {
  function t(v, _) {
    v.fogColor.value.copy(_.color),
      _.isFog
        ? (v.fogNear.value = _.near, v.fogFar.value = _.far)
        : _.isFogExp2 && (v.fogDensity.value = _.density);
  }
  function r(v, _, S, w, M) {
    _.isMeshBasicMaterial || _.isMeshLambertMaterial
      ? i(v, _)
      : _.isMeshToonMaterial
      ? (i(v, _), d(v, _))
      : _.isMeshPhongMaterial
      ? (i(v, _), f(v, _))
      : _.isMeshStandardMaterial
      ? (i(v, _), h(v, _), _.isMeshPhysicalMaterial && p(v, _, M))
      : _.isMeshMatcapMaterial
      ? (i(v, _), g(v, _))
      : _.isMeshDepthMaterial
      ? i(v, _)
      : _.isMeshDistanceMaterial
      ? (i(v, _), y(v, _))
      : _.isMeshNormalMaterial
      ? i(v, _)
      : _.isLineBasicMaterial
      ? (s(v, _), _.isLineDashedMaterial && o(v, _))
      : _.isPointsMaterial
      ? a(v, _, S, w)
      : _.isSpriteMaterial
      ? u(v, _)
      : _.isShadowMaterial
      ? (v.color.value.copy(_.color), v.opacity.value = _.opacity)
      : _.isShaderMaterial && (_.uniformsNeedUpdate = !1);
  }
  function i(v, _) {
    v.opacity.value = _.opacity,
      _.color && v.diffuse.value.copy(_.color),
      _.emissive &&
      v.emissive.value.copy(_.emissive).multiplyScalar(_.emissiveIntensity),
      _.map && (v.map.value = _.map),
      _.alphaMap && (v.alphaMap.value = _.alphaMap),
      _.bumpMap &&
      (v.bumpMap.value = _.bumpMap,
        v.bumpScale.value = _.bumpScale,
        _.side === mr && (v.bumpScale.value *= -1)),
      _.displacementMap &&
      (v.displacementMap.value = _.displacementMap,
        v.displacementScale.value = _.displacementScale,
        v.displacementBias.value = _.displacementBias),
      _.emissiveMap && (v.emissiveMap.value = _.emissiveMap),
      _.normalMap &&
      (v.normalMap.value = _.normalMap,
        v.normalScale.value.copy(_.normalScale),
        _.side === mr && v.normalScale.value.negate()),
      _.specularMap && (v.specularMap.value = _.specularMap),
      _.alphaTest > 0 && (v.alphaTest.value = _.alphaTest);
    let S = e.get(_).envMap;
    if (
      S && (v.envMap.value = S,
        v.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1
          ? -1
          : 1,
        v.reflectivity.value = _.reflectivity,
        v.ior.value = _.ior,
        v.refractionRatio.value = _.refractionRatio),
        _.lightMap
    ) {
      v.lightMap.value = _.lightMap;
      let T = n.physicallyCorrectLights !== !0 ? Math.PI : 1;
      v.lightMapIntensity.value = _.lightMapIntensity * T;
    }
    _.aoMap &&
      (v.aoMap.value = _.aoMap, v.aoMapIntensity.value = _.aoMapIntensity);
    let w;
    _.map
      ? w = _.map
      : _.specularMap
      ? w = _.specularMap
      : _.displacementMap
      ? w = _.displacementMap
      : _.normalMap
      ? w = _.normalMap
      : _.bumpMap
      ? w = _.bumpMap
      : _.roughnessMap
      ? w = _.roughnessMap
      : _.metalnessMap
      ? w = _.metalnessMap
      : _.alphaMap
      ? w = _.alphaMap
      : _.emissiveMap
      ? w = _.emissiveMap
      : _.clearcoatMap
      ? w = _.clearcoatMap
      : _.clearcoatNormalMap
      ? w = _.clearcoatNormalMap
      : _.clearcoatRoughnessMap
      ? w = _.clearcoatRoughnessMap
      : _.iridescenceMap
      ? w = _.iridescenceMap
      : _.iridescenceThicknessMap
      ? w = _.iridescenceThicknessMap
      : _.specularIntensityMap
      ? w = _.specularIntensityMap
      : _.specularColorMap
      ? w = _.specularColorMap
      : _.transmissionMap
      ? w = _.transmissionMap
      : _.thicknessMap
      ? w = _.thicknessMap
      : _.sheenColorMap
      ? w = _.sheenColorMap
      : _.sheenRoughnessMap && (w = _.sheenRoughnessMap),
      w !== void 0 &&
      (w.isWebGLRenderTarget && (w = w.texture),
        w.matrixAutoUpdate === !0 && w.updateMatrix(),
        v.uvTransform.value.copy(w.matrix));
    let M;
    _.aoMap ? M = _.aoMap : _.lightMap && (M = _.lightMap),
      M !== void 0 &&
      (M.isWebGLRenderTarget && (M = M.texture),
        M.matrixAutoUpdate === !0 && M.updateMatrix(),
        v.uv2Transform.value.copy(M.matrix));
  }
  function s(v, _) {
    v.diffuse.value.copy(_.color), v.opacity.value = _.opacity;
  }
  function o(v, _) {
    v.dashSize.value = _.dashSize,
      v.totalSize.value = _.dashSize + _.gapSize,
      v.scale.value = _.scale;
  }
  function a(v, _, S, w) {
    v.diffuse.value.copy(_.color),
      v.opacity.value = _.opacity,
      v.size.value = _.size * S,
      v.scale.value = w * .5,
      _.map && (v.map.value = _.map),
      _.alphaMap && (v.alphaMap.value = _.alphaMap),
      _.alphaTest > 0 && (v.alphaTest.value = _.alphaTest);
    let M;
    _.map ? M = _.map : _.alphaMap && (M = _.alphaMap),
      M !== void 0 &&
      (M.matrixAutoUpdate === !0 && M.updateMatrix(),
        v.uvTransform.value.copy(M.matrix));
  }
  function u(v, _) {
    v.diffuse.value.copy(_.color),
      v.opacity.value = _.opacity,
      v.rotation.value = _.rotation,
      _.map && (v.map.value = _.map),
      _.alphaMap && (v.alphaMap.value = _.alphaMap),
      _.alphaTest > 0 && (v.alphaTest.value = _.alphaTest);
    let S;
    _.map ? S = _.map : _.alphaMap && (S = _.alphaMap),
      S !== void 0 &&
      (S.matrixAutoUpdate === !0 && S.updateMatrix(),
        v.uvTransform.value.copy(S.matrix));
  }
  function f(v, _) {
    v.specular.value.copy(_.specular),
      v.shininess.value = Math.max(_.shininess, 1e-4);
  }
  function d(v, _) {
    _.gradientMap && (v.gradientMap.value = _.gradientMap);
  }
  function h(v, _) {
    v.roughness.value = _.roughness,
      v.metalness.value = _.metalness,
      _.roughnessMap && (v.roughnessMap.value = _.roughnessMap),
      _.metalnessMap && (v.metalnessMap.value = _.metalnessMap),
      e.get(_).envMap && (v.envMapIntensity.value = _.envMapIntensity);
  }
  function p(v, _, S) {
    v.ior.value = _.ior,
      _.sheen > 0 &&
      (v.sheenColor.value.copy(_.sheenColor).multiplyScalar(_.sheen),
        v.sheenRoughness.value = _.sheenRoughness,
        _.sheenColorMap && (v.sheenColorMap.value = _.sheenColorMap),
        _.sheenRoughnessMap &&
        (v.sheenRoughnessMap.value = _.sheenRoughnessMap)),
      _.clearcoat > 0 && (v.clearcoat.value = _.clearcoat,
        v.clearcoatRoughness.value = _.clearcoatRoughness,
        _.clearcoatMap && (v.clearcoatMap.value = _.clearcoatMap),
        _.clearcoatRoughnessMap &&
        (v.clearcoatRoughnessMap.value = _.clearcoatRoughnessMap),
        _.clearcoatNormalMap &&
        (v.clearcoatNormalScale.value.copy(_.clearcoatNormalScale),
          v.clearcoatNormalMap.value = _.clearcoatNormalMap,
          _.side === mr && v.clearcoatNormalScale.value.negate())),
      _.iridescence > 0 && (v.iridescence.value = _.iridescence,
        v.iridescenceIOR.value = _.iridescenceIOR,
        v.iridescenceThicknessMinimum.value = _.iridescenceThicknessRange[0],
        v.iridescenceThicknessMaximum.value = _.iridescenceThicknessRange[1],
        _.iridescenceMap && (v.iridescenceMap.value = _.iridescenceMap),
        _.iridescenceThicknessMap &&
        (v.iridescenceThicknessMap.value = _.iridescenceThicknessMap)),
      _.transmission > 0 && (v.transmission.value = _.transmission,
        v.transmissionSamplerMap.value = S.texture,
        v.transmissionSamplerSize.value.set(S.width, S.height),
        _.transmissionMap && (v.transmissionMap.value = _.transmissionMap),
        v.thickness.value = _.thickness,
        _.thicknessMap && (v.thicknessMap.value = _.thicknessMap),
        v.attenuationDistance.value = _.attenuationDistance,
        v.attenuationColor.value.copy(_.attenuationColor)),
      v.specularIntensity.value = _.specularIntensity,
      v.specularColor.value.copy(_.specularColor),
      _.specularIntensityMap &&
      (v.specularIntensityMap.value = _.specularIntensityMap),
      _.specularColorMap && (v.specularColorMap.value = _.specularColorMap);
  }
  function g(v, _) {
    _.matcap && (v.matcap.value = _.matcap);
  }
  function y(v, _) {
    v.referencePosition.value.copy(_.referencePosition),
      v.nearDistance.value = _.nearDistance,
      v.farDistance.value = _.farDistance;
  }
  return { refreshFogUniforms: t, refreshMaterialUniforms: r };
}
function Kz() {
  let n = Xf("canvas");
  return n.style.display = "block", n;
}
function w_(n = {}) {
  this.isWebGLRenderer = !0;
  let e = n.canvas !== void 0 ? n.canvas : Kz(),
    t = n.context !== void 0 ? n.context : null,
    r = n.depth !== void 0 ? n.depth : !0,
    i = n.stencil !== void 0 ? n.stencil : !0,
    s = n.antialias !== void 0 ? n.antialias : !1,
    o = n.premultipliedAlpha !== void 0 ? n.premultipliedAlpha : !0,
    a = n.preserveDrawingBuffer !== void 0 ? n.preserveDrawingBuffer : !1,
    u = n.powerPreference !== void 0 ? n.powerPreference : "default",
    f = n.failIfMajorPerformanceCaveat !== void 0
      ? n.failIfMajorPerformanceCaveat
      : !1,
    d;
  t !== null
    ? d = t.getContextAttributes().alpha
    : d = n.alpha !== void 0 ? n.alpha : !1;
  let h = null, p = null, g = [], y = [];
  this.domElement = e,
    this.debug = { checkShaderErrors: !0 },
    this.autoClear = !0,
    this.autoClearColor = !0,
    this.autoClearDepth = !0,
    this.autoClearStencil = !0,
    this.sortObjects = !0,
    this.clippingPlanes = [],
    this.localClippingEnabled = !1,
    this.outputEncoding = Ys,
    this.physicallyCorrectLights = !1,
    this.toneMapping = ji,
    this.toneMappingExposure = 1,
    Object.defineProperties(this, {
      gammaFactor: {
        get: function () {
          return console.warn(
            "THREE.WebGLRenderer: .gammaFactor has been removed.",
          ),
            2;
        },
        set: function () {
          console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
        },
      },
    });
  let v = this,
    _ = !1,
    S = 0,
    w = 0,
    M = null,
    T = -1,
    b = null,
    R = new Lt(),
    P = new Lt(),
    C = null,
    L = e.width,
    k = e.height,
    z = 1,
    Y = null,
    le = null,
    V = new Lt(0, 0, L, k),
    W = new Lt(0, 0, L, k),
    G = !1,
    re = new Jf(),
    ie = !1,
    X = !1,
    $ = null,
    ae = new Ge(),
    fe = new se(),
    pe = new I(),
    Pe = {
      background: null,
      fog: null,
      environment: null,
      overrideMaterial: null,
      isScene: !0,
    };
  function Oe() {
    return M === null ? z : 1;
  }
  let oe = t;
  function Et(D, q) {
    for (let Q = 0; Q < D.length; Q++) {
      let Z = D[Q], de = e.getContext(Z, q);
      if (de !== null) return de;
    }
    return null;
  }
  try {
    let D = {
      alpha: !0,
      depth: r,
      stencil: i,
      antialias: s,
      premultipliedAlpha: o,
      preserveDrawingBuffer: a,
      powerPreference: u,
      failIfMajorPerformanceCaveat: f,
    };
    if (
      "setAttribute" in e && e.setAttribute("data-engine", `three.js r${qp}`),
        e.addEventListener("webglcontextlost", B, !1),
        e.addEventListener("webglcontextrestored", Me, !1),
        e.addEventListener("webglcontextcreationerror", we, !1),
        oe === null
    ) {
      let q = ["webgl2", "webgl", "experimental-webgl"];
      if (v.isWebGL1Renderer === !0 && q.shift(), oe = Et(q, D), oe === null) {
        throw Et(q)
          ? new Error(
            "Error creating WebGL context with your selected attributes.",
          )
          : new Error("Error creating WebGL context.");
      }
    }
    oe.getShaderPrecisionFormat === void 0 &&
      (oe.getShaderPrecisionFormat = function () {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
  } catch (D) {
    throw console.error("THREE.WebGLRenderer: " + D.message), D;
  }
  let $e,
    Ze,
    Se,
    je,
    ue,
    ne,
    _e,
    Fe,
    Ae,
    et,
    We,
    Ve,
    Tt,
    Nt,
    O,
    N,
    J,
    me,
    xe,
    Ce,
    Ke,
    ee,
    Be;
  function Ie() {
    $e = new yO(oe),
      Ze = new dO(oe, $e, n),
      $e.init(Ze),
      ee = new xb(oe, $e, Ze),
      Se = new Xz(oe, $e, Ze),
      je = new SO(),
      ue = new Dz(),
      ne = new qz(oe, $e, Se, ue, Ze, ee, je),
      _e = new pO(v),
      Fe = new vO(v),
      Ae = new ND(oe, Ze),
      Be = new cO(oe, $e, Ae, Ze),
      et = new xO(oe, Ae, je, Be),
      We = new TO(oe, et, Ae, je),
      xe = new EO(oe, Ze, ne),
      N = new hO(ue),
      Ve = new Nz(v, _e, Fe, $e, Ze, Be, N),
      Tt = new Zz(v, ue),
      Nt = new Fz(),
      O = new Hz($e, Ze),
      me = new uO(v, _e, Se, We, d, o),
      J = new Wz(v, We, Ze),
      Ce = new fO(oe, $e, je, Ze),
      Ke = new _O(oe, $e, je, Ze),
      je.programs = Ve.programs,
      v.capabilities = Ze,
      v.extensions = $e,
      v.properties = ue,
      v.renderLists = Nt,
      v.shadowMap = J,
      v.state = Se,
      v.info = je;
  }
  Ie();
  let Re = new _b(v, oe);
  this.xr = Re,
    this.getContext = function () {
      return oe;
    },
    this.getContextAttributes = function () {
      return oe.getContextAttributes();
    },
    this.forceContextLoss = function () {
      let D = $e.get("WEBGL_lose_context");
      D && D.loseContext();
    },
    this.forceContextRestore = function () {
      let D = $e.get("WEBGL_lose_context");
      D && D.restoreContext();
    },
    this.getPixelRatio = function () {
      return z;
    },
    this.setPixelRatio = function (D) {
      D !== void 0 && (z = D, this.setSize(L, k, !1));
    },
    this.getSize = function (D) {
      return D.set(L, k);
    },
    this.setSize = function (D, q, Q) {
      if (Re.isPresenting) {
        console.warn(
          "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
        );
        return;
      }
      L = D,
        k = q,
        e.width = Math.floor(D * z),
        e.height = Math.floor(q * z),
        Q !== !1 && (e.style.width = D + "px", e.style.height = q + "px"),
        this.setViewport(0, 0, D, q);
    },
    this.getDrawingBufferSize = function (D) {
      return D.set(L * z, k * z).floor();
    },
    this.setDrawingBufferSize = function (D, q, Q) {
      L = D,
        k = q,
        z = Q,
        e.width = Math.floor(D * Q),
        e.height = Math.floor(q * Q),
        this.setViewport(0, 0, D, q);
    },
    this.getCurrentViewport = function (D) {
      return D.copy(R);
    },
    this.getViewport = function (D) {
      return D.copy(V);
    },
    this.setViewport = function (D, q, Q, Z) {
      D.isVector4 ? V.set(D.x, D.y, D.z, D.w) : V.set(D, q, Q, Z),
        Se.viewport(R.copy(V).multiplyScalar(z).floor());
    },
    this.getScissor = function (D) {
      return D.copy(W);
    },
    this.setScissor = function (D, q, Q, Z) {
      D.isVector4 ? W.set(D.x, D.y, D.z, D.w) : W.set(D, q, Q, Z),
        Se.scissor(P.copy(W).multiplyScalar(z).floor());
    },
    this.getScissorTest = function () {
      return G;
    },
    this.setScissorTest = function (D) {
      Se.setScissorTest(G = D);
    },
    this.setOpaqueSort = function (D) {
      Y = D;
    },
    this.setTransparentSort = function (D) {
      le = D;
    },
    this.getClearColor = function (D) {
      return D.copy(me.getClearColor());
    },
    this.setClearColor = function () {
      me.setClearColor.apply(me, arguments);
    },
    this.getClearAlpha = function () {
      return me.getClearAlpha();
    },
    this.setClearAlpha = function () {
      me.setClearAlpha.apply(me, arguments);
    },
    this.clear = function (D = !0, q = !0, Q = !0) {
      let Z = 0;
      D && (Z |= 16384), q && (Z |= 256), Q && (Z |= 1024), oe.clear(Z);
    },
    this.clearColor = function () {
      this.clear(!0, !1, !1);
    },
    this.clearDepth = function () {
      this.clear(!1, !0, !1);
    },
    this.clearStencil = function () {
      this.clear(!1, !1, !0);
    },
    this.dispose = function () {
      e.removeEventListener("webglcontextlost", B, !1),
        e.removeEventListener("webglcontextrestored", Me, !1),
        e.removeEventListener("webglcontextcreationerror", we, !1),
        Nt.dispose(),
        O.dispose(),
        ue.dispose(),
        _e.dispose(),
        Fe.dispose(),
        We.dispose(),
        Be.dispose(),
        Ve.dispose(),
        Re.dispose(),
        Re.removeEventListener("sessionstart", At),
        Re.removeEventListener("sessionend", Ct),
        $ && ($.dispose(), $ = null),
        Vn.stop();
    };
  function B(D) {
    D.preventDefault(),
      console.log("THREE.WebGLRenderer: Context Lost."),
      _ = !0;
  }
  function Me() {
    console.log("THREE.WebGLRenderer: Context Restored."), _ = !1;
    let D = je.autoReset,
      q = J.enabled,
      Q = J.autoUpdate,
      Z = J.needsUpdate,
      de = J.type;
    Ie(),
      je.autoReset = D,
      J.enabled = q,
      J.autoUpdate = Q,
      J.needsUpdate = Z,
      J.type = de;
  }
  function we(D) {
    console.error(
      "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
      D.statusMessage,
    );
  }
  function Xe(D) {
    let q = D.target;
    q.removeEventListener("dispose", Xe), Ne(q);
  }
  function Ne(D) {
    Je(D), ue.remove(D);
  }
  function Je(D) {
    let q = ue.get(D).programs;
    q !== void 0 && (q.forEach(function (Q) {
      Ve.releaseProgram(Q);
    }),
      D.isShaderMaterial && Ve.releaseShaderCache(D));
  }
  this.renderBufferDirect = function (D, q, Q, Z, de, qe) {
    q === null && (q = Pe);
    let tt = de.isMesh && de.matrixWorld.determinant() < 0,
      ot = zg(D, q, Q, Z, de);
    Se.setMaterial(Z, tt);
    let it = Q.index, bt = Q.attributes.position;
    if (it === null) { if (bt === void 0 || bt.count === 0) return; }
    else if (it.count === 0) return;
    let dt = 1;
    Z.wireframe === !0 && (it = et.getWireframeAttribute(Q), dt = 2),
      Be.setup(de, Z, ot, Q, it);
    let mt, Xt = Ce;
    it !== null && (mt = Ae.get(it), Xt = Ke, Xt.setIndex(mt));
    let Ts = it !== null ? it.count : bt.count,
      co = Q.drawRange.start * dt,
      fo = Q.drawRange.count * dt,
      oi = qe !== null ? qe.start * dt : 0,
      gt = qe !== null ? qe.count * dt : 1 / 0,
      ai = Math.max(co, oi),
      qt = Math.min(Ts, co + fo, oi + gt) - 1,
      Tr = Math.max(0, qt - ai + 1);
    if (Tr !== 0) {
      if (de.isMesh) {
        Z.wireframe === !0
          ? (Se.setLineWidth(Z.wireframeLinewidth * Oe()), Xt.setMode(1))
          : Xt.setMode(4);
      } else if (de.isLine) {
        let is = Z.linewidth;
        is === void 0 && (is = 1),
          Se.setLineWidth(is * Oe()),
          de.isLineSegments
            ? Xt.setMode(1)
            : de.isLineLoop
            ? Xt.setMode(2)
            : Xt.setMode(3);
      } else de.isPoints ? Xt.setMode(0) : de.isSprite && Xt.setMode(4);
      if (de.isInstancedMesh) Xt.renderInstances(ai, Tr, de.count);
      else if (Q.isInstancedBufferGeometry) {
        let is = Math.min(Q.instanceCount, Q._maxInstanceCount);
        Xt.renderInstances(ai, Tr, is);
      } else Xt.render(ai, Tr);
    }
  },
    this.compile = function (D, q) {
      p = O.get(D),
        p.init(),
        y.push(p),
        D.traverseVisible(function (Q) {
          Q.isLight && Q.layers.test(q.layers) &&
            (p.pushLight(Q), Q.castShadow && p.pushShadow(Q));
        }),
        p.setupLights(v.physicallyCorrectLights),
        D.traverse(function (Q) {
          let Z = Q.material;
          if (Z) {
            if (Array.isArray(Z)) {
              for (let de = 0; de < Z.length; de++) {
                let qe = Z[de];
                Fl(qe, D, Q);
              }
            } else Fl(Z, D, Q);
          }
        }),
        y.pop(),
        p = null;
    };
  let ye = null;
  function Qe(D) {
    ye && ye(D);
  }
  function At() {
    Vn.stop();
  }
  function Ct() {
    Vn.start();
  }
  let Vn = new VC();
  Vn.setAnimationLoop(Qe),
    typeof self != "undefined" && Vn.setContext(self),
    this.setAnimationLoop = function (D) {
      ye = D, Re.setAnimationLoop(D), D === null ? Vn.stop() : Vn.start();
    },
    Re.addEventListener("sessionstart", At),
    Re.addEventListener("sessionend", Ct),
    this.render = function (D, q) {
      if (q !== void 0 && q.isCamera !== !0) {
        console.error(
          "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.",
        );
        return;
      }
      if (_ === !0) return;
      D.autoUpdate === !0 && D.updateMatrixWorld(),
        q.parent === null && q.updateMatrixWorld(),
        Re.enabled === !0 && Re.isPresenting === !0 &&
        (Re.cameraAutoUpdate === !0 && Re.updateCamera(q), q = Re.getCamera()),
        D.isScene === !0 && D.onBeforeRender(v, D, q, M),
        p = O.get(D, y.length),
        p.init(),
        y.push(p),
        ae.multiplyMatrices(q.projectionMatrix, q.matrixWorldInverse),
        re.setFromProjectionMatrix(ae),
        X = this.localClippingEnabled,
        ie = N.init(this.clippingPlanes, X, q),
        h = Nt.get(D, g.length),
        h.init(),
        g.push(h),
        Br(D, q, 0, v.sortObjects),
        h.finish(),
        v.sortObjects === !0 && h.sort(Y, le),
        ie === !0 && N.beginShadows();
      let Q = p.state.shadowsArray;
      if (
        J.render(Q, D, q),
          ie === !0 && N.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          me.render(h, D),
          p.setupLights(v.physicallyCorrectLights),
          q.isArrayCamera
      ) {
        let Z = q.cameras;
        for (let de = 0, qe = Z.length; de < qe; de++) {
          let tt = Z[de];
          Ec(h, D, tt, tt.viewport);
        }
      } else Ec(h, D, q);
      M !== null &&
      (ne.updateMultisampleRenderTarget(M), ne.updateRenderTargetMipmap(M)),
        D.isScene === !0 && D.onAfterRender(v, D, q),
        Be.resetDefaultState(),
        T = -1,
        b = null,
        y.pop(),
        y.length > 0 ? p = y[y.length - 1] : p = null,
        g.pop(),
        g.length > 0 ? h = g[g.length - 1] : h = null;
    };
  function Br(D, q, Q, Z) {
    if (D.visible === !1) return;
    if (D.layers.test(q.layers)) {
      if (D.isGroup) Q = D.renderOrder;
      else if (D.isLOD) D.autoUpdate === !0 && D.update(q);
      else if (D.isLight) p.pushLight(D), D.castShadow && p.pushShadow(D);
      else if (D.isSprite) {
        if (!D.frustumCulled || re.intersectsSprite(D)) {
          Z && pe.setFromMatrixPosition(D.matrixWorld).applyMatrix4(ae);
          let tt = We.update(D), ot = D.material;
          ot.visible && h.push(D, tt, ot, Q, pe.z, null);
        }
      } else if (
        (D.isMesh || D.isLine || D.isPoints) &&
        (D.isSkinnedMesh && D.skeleton.frame !== je.render.frame &&
          (D.skeleton.update(), D.skeleton.frame = je.render.frame),
          !D.frustumCulled || re.intersectsObject(D))
      ) {
        Z && pe.setFromMatrixPosition(D.matrixWorld).applyMatrix4(ae);
        let tt = We.update(D), ot = D.material;
        if (Array.isArray(ot)) {
          let it = tt.groups;
          for (let bt = 0, dt = it.length; bt < dt; bt++) {
            let mt = it[bt], Xt = ot[mt.materialIndex];
            Xt && Xt.visible && h.push(D, tt, Xt, Q, pe.z, mt);
          }
        } else ot.visible && h.push(D, tt, ot, Q, pe.z, null);
      }
    }
    let qe = D.children;
    for (let tt = 0, ot = qe.length; tt < ot; tt++) Br(qe[tt], q, Q, Z);
  }
  function Ec(D, q, Q, Z) {
    let de = D.opaque, qe = D.transmissive, tt = D.transparent;
    p.setupLightsView(Q),
      qe.length > 0 && Og(de, q, Q),
      Z && Se.viewport(R.copy(Z)),
      de.length > 0 && Ea(de, q, Q),
      qe.length > 0 && Ea(qe, q, Q),
      tt.length > 0 && Ea(tt, q, Q),
      Se.buffers.depth.setTest(!0),
      Se.buffers.depth.setMask(!0),
      Se.buffers.color.setMask(!0),
      Se.setPolygonOffset(!1);
  }
  function Og(D, q, Q) {
    let Z = Ze.isWebGL2;
    $ === null &&
    ($ = new yr(1, 1, {
      generateMipmaps: !0,
      type: $e.has("EXT_color_buffer_half_float") ? Yo : Xo,
      minFilter: Mi,
      samples: Z && s === !0 ? 4 : 0,
    })),
      v.getDrawingBufferSize(fe),
      Z ? $.setSize(fe.x, fe.y) : $.setSize(am(fe.x), am(fe.y));
    let de = v.getRenderTarget();
    v.setRenderTarget($), v.clear();
    let qe = v.toneMapping;
    v.toneMapping = ji,
      Ea(D, q, Q),
      v.toneMapping = qe,
      ne.updateMultisampleRenderTarget($),
      ne.updateRenderTargetMipmap($),
      v.setRenderTarget(de);
  }
  function Ea(D, q, Q) {
    let Z = q.isScene === !0 ? q.overrideMaterial : null;
    for (let de = 0, qe = D.length; de < qe; de++) {
      let tt = D[de],
        ot = tt.object,
        it = tt.geometry,
        bt = Z === null ? tt.material : Z,
        dt = tt.group;
      ot.layers.test(Q.layers) && bd(ot, q, Q, it, bt, dt);
    }
  }
  function bd(D, q, Q, Z, de, qe) {
    D.onBeforeRender(v, q, Q, Z, de, qe),
      D.modelViewMatrix.multiplyMatrices(Q.matrixWorldInverse, D.matrixWorld),
      D.normalMatrix.getNormalMatrix(D.modelViewMatrix),
      de.onBeforeRender(v, q, Q, Z, D, qe),
      de.transparent === !0 && de.side === Gi
        ? (de.side = mr,
          de.needsUpdate = !0,
          v.renderBufferDirect(Q, q, Z, de, D, qe),
          de.side = Gs,
          de.needsUpdate = !0,
          v.renderBufferDirect(Q, q, Z, de, D, qe),
          de.side = Gi)
        : v.renderBufferDirect(Q, q, Z, de, D, qe),
      D.onAfterRender(v, q, Q, Z, de, qe);
  }
  function Fl(D, q, Q) {
    q.isScene !== !0 && (q = Pe);
    let Z = ue.get(D),
      de = p.state.lights,
      qe = p.state.shadowsArray,
      tt = de.state.version,
      ot = Ve.getParameters(D, de.state, qe, q, Q),
      it = Ve.getProgramCacheKey(ot),
      bt = Z.programs;
    Z.environment = D.isMeshStandardMaterial ? q.environment : null,
      Z.fog = q.fog,
      Z.envMap = (D.isMeshStandardMaterial ? Fe : _e).get(
        D.envMap || Z.environment,
      ),
      bt === void 0 &&
      (D.addEventListener("dispose", Xe), bt = new Map(), Z.programs = bt);
    let dt = bt.get(it);
    if (dt !== void 0) {
      if (Z.currentProgram === dt && Z.lightsStateVersion === tt) {
        return Rd(D, ot), dt;
      }
    } else {ot.uniforms = Ve.getUniforms(D),
        D.onBuild(Q, ot, v),
        D.onBeforeCompile(ot, v),
        dt = Ve.acquireProgram(ot, it),
        bt.set(it, dt),
        Z.uniforms = ot.uniforms;}
    let mt = Z.uniforms;
    (!D.isShaderMaterial && !D.isRawShaderMaterial || D.clipping === !0) &&
    (mt.clippingPlanes = N.uniform),
      Rd(D, ot),
      Z.needsLights = Ld(D),
      Z.lightsStateVersion = tt,
      Z.needsLights && (mt.ambientLightColor.value = de.state.ambient,
        mt.lightProbe.value = de.state.probe,
        mt.directionalLights.value = de.state.directional,
        mt.directionalLightShadows.value = de.state.directionalShadow,
        mt.spotLights.value = de.state.spot,
        mt.spotLightShadows.value = de.state.spotShadow,
        mt.rectAreaLights.value = de.state.rectArea,
        mt.ltc_1.value = de.state.rectAreaLTC1,
        mt.ltc_2.value = de.state.rectAreaLTC2,
        mt.pointLights.value = de.state.point,
        mt.pointLightShadows.value = de.state.pointShadow,
        mt.hemisphereLights.value = de.state.hemi,
        mt.directionalShadowMap.value = de.state.directionalShadowMap,
        mt.directionalShadowMatrix.value = de.state.directionalShadowMatrix,
        mt.spotShadowMap.value = de.state.spotShadowMap,
        mt.spotShadowMatrix.value = de.state.spotShadowMatrix,
        mt.pointShadowMap.value = de.state.pointShadowMap,
        mt.pointShadowMatrix.value = de.state.pointShadowMatrix);
    let Xt = dt.getUniforms(), Ts = Qf.seqWithValue(Xt.seq, mt);
    return Z.currentProgram = dt, Z.uniformsList = Ts, dt;
  }
  function Rd(D, q) {
    let Q = ue.get(D);
    Q.outputEncoding = q.outputEncoding,
      Q.instancing = q.instancing,
      Q.skinning = q.skinning,
      Q.morphTargets = q.morphTargets,
      Q.morphNormals = q.morphNormals,
      Q.morphColors = q.morphColors,
      Q.morphTargetsCount = q.morphTargetsCount,
      Q.numClippingPlanes = q.numClippingPlanes,
      Q.numIntersection = q.numClipIntersection,
      Q.vertexAlphas = q.vertexAlphas,
      Q.vertexTangents = q.vertexTangents,
      Q.toneMapping = q.toneMapping;
  }
  function zg(D, q, Q, Z, de) {
    q.isScene !== !0 && (q = Pe), ne.resetTextureUnits();
    let qe = q.fog,
      tt = Z.isMeshStandardMaterial ? q.environment : null,
      ot = M === null
        ? v.outputEncoding
        : M.isXRRenderTarget === !0
        ? M.texture.encoding
        : Ys,
      it = (Z.isMeshStandardMaterial ? Fe : _e).get(Z.envMap || tt),
      bt = Z.vertexColors === !0 && !!Q.attributes.color &&
        Q.attributes.color.itemSize === 4,
      dt = !!Z.normalMap && !!Q.attributes.tangent,
      mt = !!Q.morphAttributes.position,
      Xt = !!Q.morphAttributes.normal,
      Ts = !!Q.morphAttributes.color,
      co = Z.toneMapped ? v.toneMapping : ji,
      fo = Q.morphAttributes.position || Q.morphAttributes.normal ||
        Q.morphAttributes.color,
      oi = fo !== void 0 ? fo.length : 0,
      gt = ue.get(Z),
      ai = p.state.lights;
    if (ie === !0 && (X === !0 || D !== b)) {
      let En = D === b && Z.id === T;
      N.setState(Z, D, En);
    }
    let qt = !1;
    Z.version === gt.__version
      ? (gt.needsLights && gt.lightsStateVersion !== ai.state.version ||
        gt.outputEncoding !== ot ||
        de.isInstancedMesh && gt.instancing === !1 ||
        !de.isInstancedMesh && gt.instancing === !0 ||
        de.isSkinnedMesh && gt.skinning === !1 ||
        !de.isSkinnedMesh && gt.skinning === !0 || gt.envMap !== it ||
        Z.fog === !0 && gt.fog !== qe ||
        gt.numClippingPlanes !== void 0 &&
          (gt.numClippingPlanes !== N.numPlanes ||
            gt.numIntersection !== N.numIntersection) ||
        gt.vertexAlphas !== bt || gt.vertexTangents !== dt ||
        gt.morphTargets !== mt || gt.morphNormals !== Xt ||
        gt.morphColors !== Ts || gt.toneMapping !== co ||
        Ze.isWebGL2 === !0 && gt.morphTargetsCount !== oi) && (qt = !0)
      : (qt = !0, gt.__version = Z.version);
    let Tr = gt.currentProgram;
    qt === !0 && (Tr = Fl(Z, q, de));
    let is = !1, As = !1, ss = !1, Yt = Tr.getUniforms(), Rt = gt.uniforms;
    if (
      Se.useProgram(Tr.program) && (is = !0, As = !0, ss = !0),
        Z.id !== T && (T = Z.id, As = !0),
        is || b !== D
    ) {
      if (
        Yt.setValue(oe, "projectionMatrix", D.projectionMatrix),
          Ze.logarithmicDepthBuffer &&
          Yt.setValue(
            oe,
            "logDepthBufFC",
            2 / (Math.log(D.far + 1) / Math.LN2),
          ),
          b !== D && (b = D, As = !0, ss = !0),
          Z.isShaderMaterial || Z.isMeshPhongMaterial || Z.isMeshToonMaterial ||
          Z.isMeshStandardMaterial || Z.envMap
      ) {
        let En = Yt.map.cameraPosition;
        En !== void 0 &&
          En.setValue(oe, pe.setFromMatrixPosition(D.matrixWorld));
      }
      (Z.isMeshPhongMaterial || Z.isMeshToonMaterial ||
        Z.isMeshLambertMaterial || Z.isMeshBasicMaterial ||
        Z.isMeshStandardMaterial || Z.isShaderMaterial) &&
      Yt.setValue(oe, "isOrthographic", D.isOrthographicCamera === !0),
        (Z.isMeshPhongMaterial || Z.isMeshToonMaterial ||
          Z.isMeshLambertMaterial || Z.isMeshBasicMaterial ||
          Z.isMeshStandardMaterial || Z.isShaderMaterial ||
          Z.isShadowMaterial || de.isSkinnedMesh) &&
        Yt.setValue(oe, "viewMatrix", D.matrixWorldInverse);
    }
    if (de.isSkinnedMesh) {
      Yt.setOptional(oe, de, "bindMatrix"),
        Yt.setOptional(oe, de, "bindMatrixInverse");
      let En = de.skeleton;
      En &&
        (Ze.floatVertexTextures
          ? (En.boneTexture === null && En.computeBoneTexture(),
            Yt.setValue(oe, "boneTexture", En.boneTexture, ne),
            Yt.setValue(oe, "boneTextureSize", En.boneTextureSize))
          : console.warn(
            "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.",
          ));
    }
    let Pt = Q.morphAttributes;
    return (Pt.position !== void 0 || Pt.normal !== void 0 ||
      Pt.color !== void 0 && Ze.isWebGL2 === !0) && xe.update(de, Q, Z, Tr),
      (As || gt.receiveShadow !== de.receiveShadow) &&
      (gt.receiveShadow = de.receiveShadow,
        Yt.setValue(oe, "receiveShadow", de.receiveShadow)),
      As && (Yt.setValue(oe, "toneMappingExposure", v.toneMappingExposure),
        gt.needsLights && Bg(Rt, ss),
        qe && Z.fog === !0 && Tt.refreshFogUniforms(Rt, qe),
        Tt.refreshMaterialUniforms(Rt, Z, z, k, $),
        Qf.upload(oe, gt.uniformsList, Rt, ne)),
      Z.isShaderMaterial && Z.uniformsNeedUpdate === !0 &&
      (Qf.upload(oe, gt.uniformsList, Rt, ne), Z.uniformsNeedUpdate = !1),
      Z.isSpriteMaterial && Yt.setValue(oe, "center", de.center),
      Yt.setValue(oe, "modelViewMatrix", de.modelViewMatrix),
      Yt.setValue(oe, "normalMatrix", de.normalMatrix),
      Yt.setValue(oe, "modelMatrix", de.matrixWorld),
      Tr;
  }
  function Bg(D, q) {
    D.ambientLightColor.needsUpdate = q,
      D.lightProbe.needsUpdate = q,
      D.directionalLights.needsUpdate = q,
      D.directionalLightShadows.needsUpdate = q,
      D.pointLights.needsUpdate = q,
      D.pointLightShadows.needsUpdate = q,
      D.spotLights.needsUpdate = q,
      D.spotLightShadows.needsUpdate = q,
      D.rectAreaLights.needsUpdate = q,
      D.hemisphereLights.needsUpdate = q;
  }
  function Ld(D) {
    return D.isMeshLambertMaterial || D.isMeshToonMaterial ||
      D.isMeshPhongMaterial || D.isMeshStandardMaterial || D.isShadowMaterial ||
      D.isShaderMaterial && D.lights === !0;
  }
  this.getActiveCubeFace = function () {
    return S;
  },
    this.getActiveMipmapLevel = function () {
      return w;
    },
    this.getRenderTarget = function () {
      return M;
    },
    this.setRenderTargetTextures = function (D, q, Q) {
      ue.get(D.texture).__webglTexture = q,
        ue.get(D.depthTexture).__webglTexture = Q;
      let Z = ue.get(D);
      Z.__hasExternalTextures = !0,
        Z.__hasExternalTextures && (Z.__autoAllocateDepthBuffer = Q === void 0,
          Z.__autoAllocateDepthBuffer ||
          $e.has("WEBGL_multisampled_render_to_texture") === !0 &&
            (console.warn(
              "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided",
            ),
              Z.__useRenderToTexture = !1));
    },
    this.setRenderTargetFramebuffer = function (D, q) {
      let Q = ue.get(D);
      Q.__webglFramebuffer = q, Q.__useDefaultFramebuffer = q === void 0;
    },
    this.setRenderTarget = function (D, q = 0, Q = 0) {
      M = D, S = q, w = Q;
      let Z = !0;
      if (D) {
        let it = ue.get(D);
        it.__useDefaultFramebuffer !== void 0
          ? (Se.bindFramebuffer(36160, null), Z = !1)
          : it.__webglFramebuffer === void 0
          ? ne.setupRenderTarget(D)
          : it.__hasExternalTextures &&
            ne.rebindTextures(
              D,
              ue.get(D.texture).__webglTexture,
              ue.get(D.depthTexture).__webglTexture,
            );
      }
      let de = null, qe = !1, tt = !1;
      if (D) {
        let it = D.texture;
        (it.isData3DTexture || it.isDataArrayTexture) && (tt = !0);
        let bt = ue.get(D).__webglFramebuffer;
        D.isWebGLCubeRenderTarget
          ? (de = bt[q], qe = !0)
          : Ze.isWebGL2 && D.samples > 0 && ne.useMultisampledRTT(D) === !1
          ? de = ue.get(D).__webglMultisampledFramebuffer
          : de = bt,
          R.copy(D.viewport),
          P.copy(D.scissor),
          C = D.scissorTest;
      } else {R.copy(V).multiplyScalar(z).floor(),
          P.copy(W).multiplyScalar(z).floor(),
          C = G;}
      if (
        Se.bindFramebuffer(36160, de) && Ze.drawBuffers && Z &&
        Se.drawBuffers(D, de),
          Se.viewport(R),
          Se.scissor(P),
          Se.setScissorTest(C),
          qe
      ) {
        let it = ue.get(D.texture);
        oe.framebufferTexture2D(36160, 36064, 34069 + q, it.__webglTexture, Q);
      } else if (tt) {
        let it = ue.get(D.texture), bt = q || 0;
        oe.framebufferTextureLayer(36160, 36064, it.__webglTexture, Q || 0, bt);
      }
      T = -1;
    },
    this.readRenderTargetPixels = function (D, q, Q, Z, de, qe, tt) {
      if (!(D && D.isWebGLRenderTarget)) {
        console.error(
          "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.",
        );
        return;
      }
      let ot = ue.get(D).__webglFramebuffer;
      if (D.isWebGLCubeRenderTarget && tt !== void 0 && (ot = ot[tt]), ot) {
        Se.bindFramebuffer(36160, ot);
        try {
          let it = D.texture, bt = it.format, dt = it.type;
          if (bt !== gr && ee.convert(bt) !== oe.getParameter(35739)) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.",
            );
            return;
          }
          let mt = dt === Yo &&
            ($e.has("EXT_color_buffer_half_float") ||
              Ze.isWebGL2 && $e.has("EXT_color_buffer_float"));
          if (
            dt !== Xo && ee.convert(dt) !== oe.getParameter(35738) &&
            !(dt === Xs &&
              (Ze.isWebGL2 || $e.has("OES_texture_float") ||
                $e.has("WEBGL_color_buffer_float"))) &&
            !mt
          ) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.",
            );
            return;
          }
          q >= 0 && q <= D.width - Z && Q >= 0 && Q <= D.height - de &&
            oe.readPixels(q, Q, Z, de, ee.convert(bt), ee.convert(dt), qe);
        } finally {
          let it = M !== null ? ue.get(M).__webglFramebuffer : null;
          Se.bindFramebuffer(36160, it);
        }
      }
    },
    this.copyFramebufferToTexture = function (D, q, Q = 0) {
      let Z = Math.pow(2, -Q),
        de = Math.floor(q.image.width * Z),
        qe = Math.floor(q.image.height * Z);
      ne.setTexture2D(q, 0),
        oe.copyTexSubImage2D(3553, Q, 0, 0, D.x, D.y, de, qe),
        Se.unbindTexture();
    },
    this.copyTextureToTexture = function (D, q, Q, Z = 0) {
      let de = q.image.width,
        qe = q.image.height,
        tt = ee.convert(Q.format),
        ot = ee.convert(Q.type);
      ne.setTexture2D(Q, 0),
        oe.pixelStorei(37440, Q.flipY),
        oe.pixelStorei(37441, Q.premultiplyAlpha),
        oe.pixelStorei(3317, Q.unpackAlignment),
        q.isDataTexture
          ? oe.texSubImage2D(3553, Z, D.x, D.y, de, qe, tt, ot, q.image.data)
          : q.isCompressedTexture
          ? oe.compressedTexSubImage2D(
            3553,
            Z,
            D.x,
            D.y,
            q.mipmaps[0].width,
            q.mipmaps[0].height,
            tt,
            q.mipmaps[0].data,
          )
          : oe.texSubImage2D(3553, Z, D.x, D.y, tt, ot, q.image),
        Z === 0 && Q.generateMipmaps && oe.generateMipmap(3553),
        Se.unbindTexture();
    },
    this.copyTextureToTexture3D = function (D, q, Q, Z, de = 0) {
      if (v.isWebGL1Renderer) {
        console.warn(
          "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.",
        );
        return;
      }
      let qe = D.max.x - D.min.x + 1,
        tt = D.max.y - D.min.y + 1,
        ot = D.max.z - D.min.z + 1,
        it = ee.convert(Z.format),
        bt = ee.convert(Z.type),
        dt;
      if (Z.isData3DTexture) ne.setTexture3D(Z, 0), dt = 32879;
      else if (Z.isDataArrayTexture) ne.setTexture2DArray(Z, 0), dt = 35866;
      else {
        console.warn(
          "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.",
        );
        return;
      }
      oe.pixelStorei(37440, Z.flipY),
        oe.pixelStorei(37441, Z.premultiplyAlpha),
        oe.pixelStorei(3317, Z.unpackAlignment);
      let mt = oe.getParameter(3314),
        Xt = oe.getParameter(32878),
        Ts = oe.getParameter(3316),
        co = oe.getParameter(3315),
        fo = oe.getParameter(32877),
        oi = Q.isCompressedTexture ? Q.mipmaps[0] : Q.image;
      oe.pixelStorei(3314, oi.width),
        oe.pixelStorei(32878, oi.height),
        oe.pixelStorei(3316, D.min.x),
        oe.pixelStorei(3315, D.min.y),
        oe.pixelStorei(32877, D.min.z),
        Q.isDataTexture || Q.isData3DTexture
          ? oe.texSubImage3D(dt, de, q.x, q.y, q.z, qe, tt, ot, it, bt, oi.data)
          : Q.isCompressedTexture
          ? (console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.",
          ),
            oe.compressedTexSubImage3D(
              dt,
              de,
              q.x,
              q.y,
              q.z,
              qe,
              tt,
              ot,
              it,
              oi.data,
            ))
          : oe.texSubImage3D(dt, de, q.x, q.y, q.z, qe, tt, ot, it, bt, oi),
        oe.pixelStorei(3314, mt),
        oe.pixelStorei(32878, Xt),
        oe.pixelStorei(3316, Ts),
        oe.pixelStorei(3315, co),
        oe.pixelStorei(32877, fo),
        de === 0 && Z.generateMipmaps && oe.generateMipmap(dt),
        Se.unbindTexture();
    },
    this.initTexture = function (D) {
      D.isCubeTexture
        ? ne.setTextureCube(D, 0)
        : D.isData3DTexture
        ? ne.setTexture3D(D, 0)
        : D.isDataArrayTexture
        ? ne.setTexture2DArray(D, 0)
        : ne.setTexture2D(D, 0),
        Se.unbindTexture();
    },
    this.resetState = function () {
      S = 0, w = 0, M = null, Se.reset(), Be.reset();
    },
    typeof __THREE_DEVTOOLS__ != "undefined" &&
    __THREE_DEVTOOLS__.dispatchEvent(
      new CustomEvent("observe", { detail: this }),
    );
}
var M_ = class extends w_ {};
M_.prototype.isWebGL1Renderer = !0;
var ed = class {
    constructor(e, t = 25e-5) {
      this.isFogExp2 = !0,
        this.name = "",
        this.color = new ve(e),
        this.density = t;
    }
    clone() {
      return new ed(this.color, this.density);
    }
    toJSON() {
      return {
        type: "FogExp2",
        color: this.color.getHex(),
        density: this.density,
      };
    }
  },
  td = class {
    constructor(e, t = 1, r = 1e3) {
      this.isFog = !0,
        this.name = "",
        this.color = new ve(e),
        this.near = t,
        this.far = r;
    }
    clone() {
      return new td(this.color, this.near, this.far);
    }
    toJSON() {
      return {
        type: "Fog",
        color: this.color.getHex(),
        near: this.near,
        far: this.far,
      };
    }
  },
  hl = class extends ct {
    constructor() {
      super();
      this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.overrideMaterial = null,
        this.autoUpdate = !0,
        typeof __THREE_DEVTOOLS__ != "undefined" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this }),
        );
    }
    copy(e, t) {
      return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
        this.autoUpdate = e.autoUpdate,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this;
    }
    toJSON(e) {
      let t = super.toJSON(e);
      return this.fog !== null && (t.object.fog = this.fog.toJSON()), t;
    }
  },
  pl = class {
    constructor(e, t) {
      this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.usage = sm,
        this.updateRange = { offset: 0, count: -1 },
        this.version = 0,
        this.uuid = Kr();
    }
    onUploadCallback() {}
    set needsUpdate(e) {
      e === !0 && this.version++;
    }
    setUsage(e) {
      return this.usage = e, this;
    }
    copy(e) {
      return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this;
    }
    copyAt(e, t, r) {
      e *= this.stride, r *= t.stride;
      for (let i = 0, s = this.stride; i < s; i++) {
        this.array[e + i] = t.array[r + i];
      }
      return this;
    }
    set(e, t = 0) {
      return this.array.set(e, t), this;
    }
    clone(e) {
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Kr()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
      let t = new this.array.constructor(
          e.arrayBuffers[this.array.buffer._uuid],
        ),
        r = new this.constructor(t, this.stride);
      return r.setUsage(this.usage), r;
    }
    onUpload(e) {
      return this.onUploadCallback = e, this;
    }
    toJSON(e) {
      return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Kr()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer),
        )),
        {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride,
        };
    }
  },
  Sr = new I(),
  Ai = class {
    constructor(e, t, r, i = !1) {
      this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = r,
        this.normalized = i === !0;
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(e) {
      this.data.needsUpdate = e;
    }
    applyMatrix4(e) {
      for (let t = 0, r = this.data.count; t < r; t++) {
        Sr.fromBufferAttribute(this, t),
          Sr.applyMatrix4(e),
          this.setXYZ(t, Sr.x, Sr.y, Sr.z);
      }
      return this;
    }
    applyNormalMatrix(e) {
      for (let t = 0, r = this.count; t < r; t++) {
        Sr.fromBufferAttribute(this, t),
          Sr.applyNormalMatrix(e),
          this.setXYZ(t, Sr.x, Sr.y, Sr.z);
      }
      return this;
    }
    transformDirection(e) {
      for (let t = 0, r = this.count; t < r; t++) {
        Sr.fromBufferAttribute(this, t),
          Sr.transformDirection(e),
          this.setXYZ(t, Sr.x, Sr.y, Sr.z);
      }
      return this;
    }
    setX(e, t) {
      return this.data.array[e * this.data.stride + this.offset] = t, this;
    }
    setY(e, t) {
      return this.data.array[e * this.data.stride + this.offset + 1] = t, this;
    }
    setZ(e, t) {
      return this.data.array[e * this.data.stride + this.offset + 2] = t, this;
    }
    setW(e, t) {
      return this.data.array[e * this.data.stride + this.offset + 3] = t, this;
    }
    getX(e) {
      return this.data.array[e * this.data.stride + this.offset];
    }
    getY(e) {
      return this.data.array[e * this.data.stride + this.offset + 1];
    }
    getZ(e) {
      return this.data.array[e * this.data.stride + this.offset + 2];
    }
    getW(e) {
      return this.data.array[e * this.data.stride + this.offset + 3];
    }
    setXY(e, t, r) {
      return e = e * this.data.stride + this.offset,
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = r,
        this;
    }
    setXYZ(e, t, r, i) {
      return e = e * this.data.stride + this.offset,
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = r,
        this.data.array[e + 2] = i,
        this;
    }
    setXYZW(e, t, r, i, s) {
      return e = e * this.data.stride + this.offset,
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = r,
        this.data.array[e + 2] = i,
        this.data.array[e + 3] = s,
        this;
    }
    clone(e) {
      if (e === void 0) {
        console.log(
          "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.",
        );
        let t = [];
        for (let r = 0; r < this.count; r++) {
          let i = r * this.data.stride + this.offset;
          for (let s = 0; s < this.itemSize; s++) {
            t.push(this.data.array[i + s]);
          }
        }
        return new pt(
          new this.array.constructor(t),
          this.itemSize,
          this.normalized,
        );
      } else {return e.interleavedBuffers === void 0 &&
          (e.interleavedBuffers = {}),
          e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
          new Ai(
            e.interleavedBuffers[this.data.uuid],
            this.itemSize,
            this.offset,
            this.normalized,
          );}
    }
    toJSON(e) {
      if (e === void 0) {
        console.log(
          "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.",
        );
        let t = [];
        for (let r = 0; r < this.count; r++) {
          let i = r * this.data.stride + this.offset;
          for (let s = 0; s < this.itemSize; s++) {
            t.push(this.data.array[i + s]);
          }
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: t,
          normalized: this.normalized,
        };
      } else {return e.interleavedBuffers === void 0 &&
          (e.interleavedBuffers = {}),
          e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
          {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized,
          };}
    }
  },
  Om = class extends $t {
    constructor(e) {
      super();
      this.isSpriteMaterial = !0,
        this.type = "SpriteMaterial",
        this.color = new ve(16777215),
        this.map = null,
        this.alphaMap = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e);
    }
    copy(e) {
      return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.rotation = e.rotation,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this;
    }
  },
  Zu,
  nd = new I(),
  Ku = new I(),
  Ju = new I(),
  Qu = new se(),
  rd = new se(),
  Sb = new Ge(),
  zm = new I(),
  id = new I(),
  Bm = new I(),
  wb = new se(),
  E_ = new se(),
  Mb = new se(),
  T_ = class extends ct {
    constructor(e) {
      super();
      if (this.isSprite = !0, this.type = "Sprite", Zu === void 0) {
        Zu = new Ye();
        let t = new Float32Array([
            -.5,
            -.5,
            0,
            0,
            0,
            .5,
            -.5,
            0,
            1,
            0,
            .5,
            .5,
            0,
            1,
            1,
            -.5,
            .5,
            0,
            0,
            1,
          ]),
          r = new pl(t, 5);
        Zu.setIndex([0, 1, 2, 0, 2, 3]),
          Zu.setAttribute("position", new Ai(r, 3, 0, !1)),
          Zu.setAttribute("uv", new Ai(r, 2, 3, !1));
      }
      this.geometry = Zu,
        this.material = e !== void 0 ? e : new Om(),
        this.center = new se(.5, .5);
    }
    raycast(e, t) {
      e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.',
      ),
        Ku.setFromMatrixScale(this.matrixWorld),
        Sb.copy(e.camera.matrixWorld),
        this.modelViewMatrix.multiplyMatrices(
          e.camera.matrixWorldInverse,
          this.matrixWorld,
        ),
        Ju.setFromMatrixPosition(this.modelViewMatrix),
        e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 &&
        Ku.multiplyScalar(-Ju.z);
      let r = this.material.rotation, i, s;
      r !== 0 && (s = Math.cos(r), i = Math.sin(r));
      let o = this.center;
      Um(zm.set(-.5, -.5, 0), Ju, o, Ku, i, s),
        Um(id.set(.5, -.5, 0), Ju, o, Ku, i, s),
        Um(Bm.set(.5, .5, 0), Ju, o, Ku, i, s),
        wb.set(0, 0),
        E_.set(1, 0),
        Mb.set(1, 1);
      let a = e.ray.intersectTriangle(zm, id, Bm, !1, nd);
      if (
        a === null &&
        (Um(id.set(-.5, .5, 0), Ju, o, Ku, i, s),
          E_.set(0, 1),
          a = e.ray.intersectTriangle(zm, Bm, id, !1, nd),
          a === null)
      ) return;
      let u = e.ray.origin.distanceTo(nd);
      u < e.near || u > e.far ||
        t.push({
          distance: u,
          point: nd.clone(),
          uv: Qr.getUV(nd, zm, id, Bm, wb, E_, Mb, new se()),
          face: null,
          object: this,
        });
    }
    copy(e, t) {
      return super.copy(e, t),
        e.center !== void 0 && this.center.copy(e.center),
        this.material = e.material,
        this;
    }
  };
function Um(n, e, t, r, i, s) {
  Qu.subVectors(n, t).addScalar(.5).multiply(r),
    i !== void 0
      ? (rd.x = s * Qu.x - i * Qu.y, rd.y = i * Qu.x + s * Qu.y)
      : rd.copy(Qu),
    n.copy(e),
    n.x += rd.x,
    n.y += rd.y,
    n.applyMatrix4(Sb);
}
var Vm = new I(),
  Eb = new I(),
  A_ = class extends ct {
    constructor() {
      super();
      this._currentLevel = 0,
        this.type = "LOD",
        Object.defineProperties(this, {
          levels: { enumerable: !0, value: [] },
          isLOD: { value: !0 },
        }),
        this.autoUpdate = !0;
    }
    copy(e) {
      super.copy(e, !1);
      let t = e.levels;
      for (let r = 0, i = t.length; r < i; r++) {
        let s = t[r];
        this.addLevel(s.object.clone(), s.distance);
      }
      return this.autoUpdate = e.autoUpdate, this;
    }
    addLevel(e, t = 0) {
      t = Math.abs(t);
      let r = this.levels, i;
      for (i = 0; i < r.length && !(t < r[i].distance); i++);
      return r.splice(i, 0, { distance: t, object: e }), this.add(e), this;
    }
    getCurrentLevel() {
      return this._currentLevel;
    }
    getObjectForDistance(e) {
      let t = this.levels;
      if (t.length > 0) {
        let r, i;
        for (r = 1, i = t.length; r < i && !(e < t[r].distance); r++);
        return t[r - 1].object;
      }
      return null;
    }
    raycast(e, t) {
      if (this.levels.length > 0) {
        Vm.setFromMatrixPosition(this.matrixWorld);
        let i = e.ray.origin.distanceTo(Vm);
        this.getObjectForDistance(i).raycast(e, t);
      }
    }
    update(e) {
      let t = this.levels;
      if (t.length > 1) {
        Vm.setFromMatrixPosition(e.matrixWorld),
          Eb.setFromMatrixPosition(this.matrixWorld);
        let r = Vm.distanceTo(Eb) / e.zoom;
        t[0].object.visible = !0;
        let i, s;
        for (i = 1, s = t.length; i < s && r >= t[i].distance; i++) {
          t[i - 1].object.visible = !1, t[i].object.visible = !0;
        }
        for (this._currentLevel = i - 1; i < s; i++) t[i].object.visible = !1;
      }
    }
    toJSON(e) {
      let t = super.toJSON(e);
      this.autoUpdate === !1 && (t.object.autoUpdate = !1),
        t.object.levels = [];
      let r = this.levels;
      for (let i = 0, s = r.length; i < s; i++) {
        let o = r[i];
        t.object.levels.push({ object: o.object.uuid, distance: o.distance });
      }
      return t;
    }
  },
  Tb = new I(),
  Ab = new Lt(),
  Cb = new Lt(),
  Jz = new I(),
  bb = new Ge(),
  aa = class extends Ot {
    constructor(e, t) {
      super(e, t);
      this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new Ge(),
        this.bindMatrixInverse = new Ge();
    }
    copy(e, t) {
      return super.copy(e, t),
        this.bindMode = e.bindMode,
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        this.skeleton = e.skeleton,
        this;
    }
    bind(e, t) {
      this.skeleton = e,
        t === void 0 &&
        (this.updateMatrixWorld(!0),
          this.skeleton.calculateInverses(),
          t = this.matrixWorld),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      let e = new Lt(), t = this.geometry.attributes.skinWeight;
      for (let r = 0, i = t.count; r < i; r++) {
        e.fromBufferAttribute(t, r);
        let s = 1 / e.manhattanLength();
        s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
          t.setXYZW(r, e.x, e.y, e.z, e.w);
      }
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e),
        this.bindMode === "attached"
          ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
          : this.bindMode === "detached"
          ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
          : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode,
          );
    }
    boneTransform(e, t) {
      let r = this.skeleton, i = this.geometry;
      Ab.fromBufferAttribute(i.attributes.skinIndex, e),
        Cb.fromBufferAttribute(i.attributes.skinWeight, e),
        Tb.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
      for (let s = 0; s < 4; s++) {
        let o = Cb.getComponent(s);
        if (o !== 0) {
          let a = Ab.getComponent(s);
          bb.multiplyMatrices(r.bones[a].matrixWorld, r.boneInverses[a]),
            t.addScaledVector(Jz.copy(Tb).applyMatrix4(bb), o);
        }
      }
      return t.applyMatrix4(this.bindMatrixInverse);
    }
  },
  $u = class extends ct {
    constructor() {
      super();
      this.isBone = !0, this.type = "Bone";
    }
  },
  ml = class extends Qt {
    constructor(e = null, t = 1, r = 1, i, s, o, a, u, f = Jt, d = Jt, h, p) {
      super(null, o, a, u, f, d, i, s, h, p);
      this.isDataTexture = !0,
        this.image = { data: e, width: t, height: r },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1;
    }
  },
  Rb = new Ge(),
  Qz = new Ge(),
  gl = class {
    constructor(e = [], t = []) {
      this.uuid = Kr(),
        this.bones = e.slice(0),
        this.boneInverses = t,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.boneTextureSize = 0,
        this.frame = -1,
        this.init();
    }
    init() {
      let e = this.bones, t = this.boneInverses;
      if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) {
        this.calculateInverses();
      } else if (e.length !== t.length) {
        console.warn(
          "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.",
        ), this.boneInverses = [];
        for (let r = 0, i = this.bones.length; r < i; r++) {
          this.boneInverses.push(new Ge());
        }
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let e = 0, t = this.bones.length; e < t; e++) {
        let r = new Ge();
        this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(),
          this.boneInverses.push(r);
      }
    }
    pose() {
      for (let e = 0, t = this.bones.length; e < t; e++) {
        let r = this.bones[e];
        r && r.matrixWorld.copy(this.boneInverses[e]).invert();
      }
      for (let e = 0, t = this.bones.length; e < t; e++) {
        let r = this.bones[e];
        r &&
          (r.parent && r.parent.isBone
            ? (r.matrix.copy(r.parent.matrixWorld).invert(),
              r.matrix.multiply(r.matrixWorld))
            : r.matrix.copy(r.matrixWorld),
            r.matrix.decompose(r.position, r.quaternion, r.scale));
      }
    }
    update() {
      let e = this.bones,
        t = this.boneInverses,
        r = this.boneMatrices,
        i = this.boneTexture;
      for (let s = 0, o = e.length; s < o; s++) {
        let a = e[s] ? e[s].matrixWorld : Qz;
        Rb.multiplyMatrices(a, t[s]), Rb.toArray(r, s * 16);
      }
      i !== null && (i.needsUpdate = !0);
    }
    clone() {
      return new gl(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
      let e = Math.sqrt(this.bones.length * 4);
      e = vC(e), e = Math.max(e, 4);
      let t = new Float32Array(e * e * 4);
      t.set(this.boneMatrices);
      let r = new ml(t, e, e, gr, Xs);
      return r.needsUpdate = !0,
        this.boneMatrices = t,
        this.boneTexture = r,
        this.boneTextureSize = e,
        this;
    }
    getBoneByName(e) {
      for (let t = 0, r = this.bones.length; t < r; t++) {
        let i = this.bones[t];
        if (i.name === e) return i;
      }
    }
    dispose() {
      this.boneTexture !== null &&
        (this.boneTexture.dispose(), this.boneTexture = null);
    }
    fromJSON(e, t) {
      this.uuid = e.uuid;
      for (let r = 0, i = e.bones.length; r < i; r++) {
        let s = e.bones[r], o = t[s];
        o === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
          o = new $u()),
          this.bones.push(o),
          this.boneInverses.push(new Ge().fromArray(e.boneInverses[r]));
      }
      return this.init(), this;
    }
    toJSON() {
      let e = {
        metadata: {
          version: 4.5,
          type: "Skeleton",
          generator: "Skeleton.toJSON",
        },
        bones: [],
        boneInverses: [],
      };
      e.uuid = this.uuid;
      let t = this.bones, r = this.boneInverses;
      for (let i = 0, s = t.length; i < s; i++) {
        let o = t[i];
        e.bones.push(o.uuid);
        let a = r[i];
        e.boneInverses.push(a.toArray());
      }
      return e;
    }
  },
  vl = class extends pt {
    constructor(e, t, r, i = 1) {
      typeof r == "number" &&
        (i = r,
          r = !1,
          console.error(
            "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.",
          ));
      super(e, t, r);
      this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
    }
    copy(e) {
      return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
    }
    toJSON() {
      let e = super.toJSON();
      return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e;
    }
  },
  Lb = new Ge(),
  Pb = new Ge(),
  Hm = [],
  sd = new Ot(),
  C_ = class extends Ot {
    constructor(e, t, r) {
      super(e, t);
      this.isInstancedMesh = !0,
        this.instanceMatrix = new vl(new Float32Array(r * 16), 16),
        this.instanceColor = null,
        this.count = r,
        this.frustumCulled = !1;
    }
    copy(e, t) {
      return super.copy(e, t),
        this.instanceMatrix.copy(e.instanceMatrix),
        e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
        this.count = e.count,
        this;
    }
    getColorAt(e, t) {
      t.fromArray(this.instanceColor.array, e * 3);
    }
    getMatrixAt(e, t) {
      t.fromArray(this.instanceMatrix.array, e * 16);
    }
    raycast(e, t) {
      let r = this.matrixWorld, i = this.count;
      if (
        sd.geometry = this.geometry,
          sd.material = this.material,
          sd.material !== void 0
      ) {
        for (let s = 0; s < i; s++) {
          this.getMatrixAt(s, Lb),
            Pb.multiplyMatrices(r, Lb),
            sd.matrixWorld = Pb,
            sd.raycast(e, Hm);
          for (let o = 0, a = Hm.length; o < a; o++) {
            let u = Hm[o];
            u.instanceId = s, u.object = this, t.push(u);
          }
          Hm.length = 0;
        }
      }
    }
    setColorAt(e, t) {
      this.instanceColor === null &&
      (this.instanceColor = new vl(
        new Float32Array(this.instanceMatrix.count * 3),
        3,
      )), t.toArray(this.instanceColor.array, e * 3);
    }
    setMatrixAt(e, t) {
      t.toArray(this.instanceMatrix.array, e * 16);
    }
    updateMorphTargets() {}
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  },
  Un = class extends $t {
    constructor(e) {
      super();
      this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new ve(16777215),
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e);
    }
    copy(e) {
      return super.copy(e),
        this.color.copy(e.color),
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this;
    }
  },
  Ib = new I(),
  Nb = new I(),
  Db = new Ge(),
  b_ = new Nu(),
  Gm = new Zi(),
  Fr = class extends ct {
    constructor(e = new Ye(), t = new Un()) {
      super();
      this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets();
    }
    copy(e, t) {
      return super.copy(e, t),
        this.material = e.material,
        this.geometry = e.geometry,
        this;
    }
    computeLineDistances() {
      let e = this.geometry;
      if (e.index === null) {
        let t = e.attributes.position, r = [0];
        for (let i = 1, s = t.count; i < s; i++) {
          Ib.fromBufferAttribute(t, i - 1),
            Nb.fromBufferAttribute(t, i),
            r[i] = r[i - 1],
            r[i] += Ib.distanceTo(Nb);
        }
        e.setAttribute("lineDistance", new ke(r, 1));
      } else {console.warn(
          "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
        );}
      return this;
    }
    raycast(e, t) {
      let r = this.geometry,
        i = this.matrixWorld,
        s = e.params.Line.threshold,
        o = r.drawRange;
      if (
        r.boundingSphere === null && r.computeBoundingSphere(),
          Gm.copy(r.boundingSphere),
          Gm.applyMatrix4(i),
          Gm.radius += s,
          e.ray.intersectsSphere(Gm) === !1
      ) return;
      Db.copy(i).invert(), b_.copy(e.ray).applyMatrix4(Db);
      let a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
        u = a * a,
        f = new I(),
        d = new I(),
        h = new I(),
        p = new I(),
        g = this.isLineSegments ? 2 : 1,
        y = r.index,
        _ = r.attributes.position;
      if (y !== null) {
        let S = Math.max(0, o.start), w = Math.min(y.count, o.start + o.count);
        for (let M = S, T = w - 1; M < T; M += g) {
          let b = y.getX(M), R = y.getX(M + 1);
          if (
            f.fromBufferAttribute(_, b),
              d.fromBufferAttribute(_, R),
              b_.distanceSqToSegment(f, d, p, h) > u
          ) continue;
          p.applyMatrix4(this.matrixWorld);
          let C = e.ray.origin.distanceTo(p);
          C < e.near || C > e.far ||
            t.push({
              distance: C,
              point: h.clone().applyMatrix4(this.matrixWorld),
              index: M,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      } else {
        let S = Math.max(0, o.start), w = Math.min(_.count, o.start + o.count);
        for (let M = S, T = w - 1; M < T; M += g) {
          if (
            f.fromBufferAttribute(_, M),
              d.fromBufferAttribute(_, M + 1),
              b_.distanceSqToSegment(f, d, p, h) > u
          ) continue;
          p.applyMatrix4(this.matrixWorld);
          let R = e.ray.origin.distanceTo(p);
          R < e.near || R > e.far ||
            t.push({
              distance: R,
              point: h.clone().applyMatrix4(this.matrixWorld),
              index: M,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      }
    }
    updateMorphTargets() {
      let t = this.geometry.morphAttributes, r = Object.keys(t);
      if (r.length > 0) {
        let i = t[r[0]];
        if (i !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let s = 0, o = i.length; s < o; s++) {
            let a = i[s].name || String(s);
            this.morphTargetInfluences.push(0),
              this.morphTargetDictionary[a] = s;
          }
        }
      }
    }
  },
  kb = new I(),
  Fb = new I(),
  wr = class extends Fr {
    constructor(e, t) {
      super(e, t);
      this.isLineSegments = !0, this.type = "LineSegments";
    }
    computeLineDistances() {
      let e = this.geometry;
      if (e.index === null) {
        let t = e.attributes.position, r = [];
        for (let i = 0, s = t.count; i < s; i += 2) {
          kb.fromBufferAttribute(t, i),
            Fb.fromBufferAttribute(t, i + 1),
            r[i] = i === 0 ? 0 : r[i - 1],
            r[i + 1] = r[i] + kb.distanceTo(Fb);
        }
        e.setAttribute("lineDistance", new ke(r, 1));
      } else {console.warn(
          "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
        );}
      return this;
    }
  },
  yl = class extends Fr {
    constructor(e, t) {
      super(e, t);
      this.isLineLoop = !0, this.type = "LineLoop";
    }
  },
  ec = class extends $t {
    constructor(e) {
      super();
      this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new ve(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e);
    }
    copy(e) {
      return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this;
    }
  },
  Ob = new Ge(),
  R_ = new Nu(),
  jm = new Zi(),
  Wm = new I(),
  la = class extends ct {
    constructor(e = new Ye(), t = new ec()) {
      super();
      this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets();
    }
    copy(e, t) {
      return super.copy(e, t),
        this.material = e.material,
        this.geometry = e.geometry,
        this;
    }
    raycast(e, t) {
      let r = this.geometry,
        i = this.matrixWorld,
        s = e.params.Points.threshold,
        o = r.drawRange;
      if (
        r.boundingSphere === null && r.computeBoundingSphere(),
          jm.copy(r.boundingSphere),
          jm.applyMatrix4(i),
          jm.radius += s,
          e.ray.intersectsSphere(jm) === !1
      ) return;
      Ob.copy(i).invert(), R_.copy(e.ray).applyMatrix4(Ob);
      let a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
        u = a * a,
        f = r.index,
        h = r.attributes.position;
      if (f !== null) {
        let p = Math.max(0, o.start), g = Math.min(f.count, o.start + o.count);
        for (let y = p, v = g; y < v; y++) {
          let _ = f.getX(y);
          Wm.fromBufferAttribute(h, _), zb(Wm, _, u, i, e, t, this);
        }
      } else {
        let p = Math.max(0, o.start), g = Math.min(h.count, o.start + o.count);
        for (let y = p, v = g; y < v; y++) {
          Wm.fromBufferAttribute(h, y), zb(Wm, y, u, i, e, t, this);
        }
      }
    }
    updateMorphTargets() {
      let t = this.geometry.morphAttributes, r = Object.keys(t);
      if (r.length > 0) {
        let i = t[r[0]];
        if (i !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let s = 0, o = i.length; s < o; s++) {
            let a = i[s].name || String(s);
            this.morphTargetInfluences.push(0),
              this.morphTargetDictionary[a] = s;
          }
        }
      }
    }
  };
function zb(n, e, t, r, i, s, o) {
  let a = R_.distanceSqToPoint(n);
  if (a < t) {
    let u = new I();
    R_.closestPointToPoint(n, u), u.applyMatrix4(r);
    let f = i.ray.origin.distanceTo(u);
    if (f < i.near || f > i.far) return;
    s.push({
      distance: f,
      distanceToRay: Math.sqrt(a),
      point: u,
      index: e,
      face: null,
      object: o,
    });
  }
}
var Bb = class extends Qt {
    constructor(e, t, r, i, s, o, a, u, f) {
      super(e, t, r, i, s, o, a, u, f);
      this.isVideoTexture = !0,
        this.minFilter = o !== void 0 ? o : kt,
        this.magFilter = s !== void 0 ? s : kt,
        this.generateMipmaps = !1;
      let d = this;
      function h() {
        d.needsUpdate = !0, e.requestVideoFrameCallback(h);
      }
      "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(h);
    }
    clone() {
      return new this.constructor(this.image).copy(this);
    }
    update() {
      let e = this.image;
      "requestVideoFrameCallback" in e === !1 &&
        e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
    }
  },
  Ub = class extends Qt {
    constructor(e, t, r) {
      super({ width: e, height: t });
      this.isFramebufferTexture = !0,
        this.format = r,
        this.magFilter = Jt,
        this.minFilter = Jt,
        this.generateMipmaps = !1,
        this.needsUpdate = !0;
    }
  },
  L_ = class extends Qt {
    constructor(e, t, r, i, s, o, a, u, f, d, h, p) {
      super(null, o, a, u, f, d, i, s, h, p);
      this.isCompressedTexture = !0,
        this.image = { width: t, height: r },
        this.mipmaps = e,
        this.flipY = !1,
        this.generateMipmaps = !1;
    }
  },
  Vb = class extends Qt {
    constructor(e, t, r, i, s, o, a, u, f) {
      super(e, t, r, i, s, o, a, u, f);
      this.isCanvasTexture = !0, this.needsUpdate = !0;
    }
  },
  Ci = class {
    constructor() {
      this.type = "Curve", this.arcLengthDivisions = 200;
    }
    getPoint() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    }
    getPointAt(e, t) {
      let r = this.getUtoTmapping(e);
      return this.getPoint(r, t);
    }
    getPoints(e = 5) {
      let t = [];
      for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
      return t;
    }
    getSpacedPoints(e = 5) {
      let t = [];
      for (let r = 0; r <= e; r++) t.push(this.getPointAt(r / e));
      return t;
    }
    getLength() {
      let e = this.getLengths();
      return e[e.length - 1];
    }
    getLengths(e = this.arcLengthDivisions) {
      if (
        this.cacheArcLengths && this.cacheArcLengths.length === e + 1 &&
        !this.needsUpdate
      ) return this.cacheArcLengths;
      this.needsUpdate = !1;
      let t = [], r, i = this.getPoint(0), s = 0;
      t.push(0);
      for (let o = 1; o <= e; o++) {
        r = this.getPoint(o / e), s += r.distanceTo(i), t.push(s), i = r;
      }
      return this.cacheArcLengths = t, t;
    }
    updateArcLengths() {
      this.needsUpdate = !0, this.getLengths();
    }
    getUtoTmapping(e, t) {
      let r = this.getLengths(), i = 0, s = r.length, o;
      t ? o = t : o = e * r[s - 1];
      let a = 0, u = s - 1, f;
      for (; a <= u;) {
        if (i = Math.floor(a + (u - a) / 2), f = r[i] - o, f < 0) a = i + 1;
        else if (f > 0) u = i - 1;
        else {
          u = i;
          break;
        }
      }
      if (i = u, r[i] === o) return i / (s - 1);
      let d = r[i], p = r[i + 1] - d, g = (o - d) / p;
      return (i + g) / (s - 1);
    }
    getTangent(e, t) {
      let r = 1e-4, i = e - r, s = e + r;
      i < 0 && (i = 0), s > 1 && (s = 1);
      let o = this.getPoint(i),
        a = this.getPoint(s),
        u = t || (o.isVector2 ? new se() : new I());
      return u.copy(a).sub(o).normalize(), u;
    }
    getTangentAt(e, t) {
      let r = this.getUtoTmapping(e);
      return this.getTangent(r, t);
    }
    computeFrenetFrames(e, t) {
      let r = new I(), i = [], s = [], o = [], a = new I(), u = new Ge();
      for (let g = 0; g <= e; g++) {
        let y = g / e;
        i[g] = this.getTangentAt(y, new I());
      }
      s[0] = new I(), o[0] = new I();
      let f = Number.MAX_VALUE,
        d = Math.abs(i[0].x),
        h = Math.abs(i[0].y),
        p = Math.abs(i[0].z);
      d <= f && (f = d, r.set(1, 0, 0)),
        h <= f && (f = h, r.set(0, 1, 0)),
        p <= f && r.set(0, 0, 1),
        a.crossVectors(i[0], r).normalize(),
        s[0].crossVectors(i[0], a),
        o[0].crossVectors(i[0], s[0]);
      for (let g = 1; g <= e; g++) {
        if (
          s[g] = s[g - 1].clone(),
            o[g] = o[g - 1].clone(),
            a.crossVectors(i[g - 1], i[g]),
            a.length() > Number.EPSILON
        ) {
          a.normalize();
          let y = Math.acos(yn(i[g - 1].dot(i[g]), -1, 1));
          s[g].applyMatrix4(u.makeRotationAxis(a, y));
        }
        o[g].crossVectors(i[g], s[g]);
      }
      if (t === !0) {
        let g = Math.acos(yn(s[0].dot(s[e]), -1, 1));
        g /= e, i[0].dot(a.crossVectors(s[0], s[e])) > 0 && (g = -g);
        for (let y = 1; y <= e; y++) {
          s[y].applyMatrix4(u.makeRotationAxis(i[y], g * y)),
            o[y].crossVectors(i[y], s[y]);
        }
      }
      return { tangents: i, normals: s, binormals: o };
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.arcLengthDivisions = e.arcLengthDivisions, this;
    }
    toJSON() {
      let e = {
        metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" },
      };
      return e.arcLengthDivisions = this.arcLengthDivisions,
        e.type = this.type,
        e;
    }
    fromJSON(e) {
      return this.arcLengthDivisions = e.arcLengthDivisions, this;
    }
  },
  od = class extends Ci {
    constructor(
      e = 0,
      t = 0,
      r = 1,
      i = 1,
      s = 0,
      o = Math.PI * 2,
      a = !1,
      u = 0,
    ) {
      super();
      this.isEllipseCurve = !0,
        this.type = "EllipseCurve",
        this.aX = e,
        this.aY = t,
        this.xRadius = r,
        this.yRadius = i,
        this.aStartAngle = s,
        this.aEndAngle = o,
        this.aClockwise = a,
        this.aRotation = u;
    }
    getPoint(e, t) {
      let r = t || new se(),
        i = Math.PI * 2,
        s = this.aEndAngle - this.aStartAngle,
        o = Math.abs(s) < Number.EPSILON;
      for (; s < 0;) s += i;
      for (; s > i;) s -= i;
      s < Number.EPSILON && (o ? s = 0 : s = i),
        this.aClockwise === !0 && !o && (s === i ? s = -i : s = s - i);
      let a = this.aStartAngle + e * s,
        u = this.aX + this.xRadius * Math.cos(a),
        f = this.aY + this.yRadius * Math.sin(a);
      if (this.aRotation !== 0) {
        let d = Math.cos(this.aRotation),
          h = Math.sin(this.aRotation),
          p = u - this.aX,
          g = f - this.aY;
        u = p * d - g * h + this.aX, f = p * h + g * d + this.aY;
      }
      return r.set(u, f);
    }
    copy(e) {
      return super.copy(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this;
    }
    toJSON() {
      let e = super.toJSON();
      return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e;
    }
    fromJSON(e) {
      return super.fromJSON(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this;
    }
  },
  P_ = class extends od {
    constructor(e, t, r, i, s, o) {
      super(e, t, r, r, i, s, o);
      this.isArcCurve = !0, this.type = "ArcCurve";
    }
  };
function I_() {
  let n = 0, e = 0, t = 0, r = 0;
  function i(s, o, a, u) {
    n = s, e = a, t = -3 * s + 3 * o - 2 * a - u, r = 2 * s - 2 * o + a + u;
  }
  return {
    initCatmullRom: function (s, o, a, u, f) {
      i(o, a, f * (a - s), f * (u - o));
    },
    initNonuniformCatmullRom: function (s, o, a, u, f, d, h) {
      let p = (o - s) / f - (a - s) / (f + d) + (a - o) / d,
        g = (a - o) / d - (u - o) / (d + h) + (u - a) / h;
      p *= d, g *= d, i(o, a, p, g);
    },
    calc: function (s) {
      let o = s * s, a = o * s;
      return n + e * s + t * o + r * a;
    },
  };
}
var Xm = new I(),
  N_ = new I_(),
  D_ = new I_(),
  k_ = new I_(),
  F_ = class extends Ci {
    constructor(e = [], t = !1, r = "centripetal", i = .5) {
      super();
      this.isCatmullRomCurve3 = !0,
        this.type = "CatmullRomCurve3",
        this.points = e,
        this.closed = t,
        this.curveType = r,
        this.tension = i;
    }
    getPoint(e, t = new I()) {
      let r = t,
        i = this.points,
        s = i.length,
        o = (s - (this.closed ? 0 : 1)) * e,
        a = Math.floor(o),
        u = o - a;
      this.closed
        ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s
        : u === 0 && a === s - 1 && (a = s - 2, u = 1);
      let f, d;
      this.closed || a > 0
        ? f = i[(a - 1) % s]
        : (Xm.subVectors(i[0], i[1]).add(i[0]), f = Xm);
      let h = i[a % s], p = i[(a + 1) % s];
      if (
        this.closed || a + 2 < s
          ? d = i[(a + 2) % s]
          : (Xm.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), d = Xm),
          this.curveType === "centripetal" || this.curveType === "chordal"
      ) {
        let g = this.curveType === "chordal" ? .5 : .25,
          y = Math.pow(f.distanceToSquared(h), g),
          v = Math.pow(h.distanceToSquared(p), g),
          _ = Math.pow(p.distanceToSquared(d), g);
        v < 1e-4 && (v = 1),
          y < 1e-4 && (y = v),
          _ < 1e-4 && (_ = v),
          N_.initNonuniformCatmullRom(f.x, h.x, p.x, d.x, y, v, _),
          D_.initNonuniformCatmullRom(f.y, h.y, p.y, d.y, y, v, _),
          k_.initNonuniformCatmullRom(f.z, h.z, p.z, d.z, y, v, _);
      } else {this.curveType === "catmullrom" &&
          (N_.initCatmullRom(f.x, h.x, p.x, d.x, this.tension),
            D_.initCatmullRom(f.y, h.y, p.y, d.y, this.tension),
            k_.initCatmullRom(f.z, h.z, p.z, d.z, this.tension));}
      return r.set(N_.calc(u), D_.calc(u), k_.calc(u)), r;
    }
    copy(e) {
      super.copy(e), this.points = [];
      for (let t = 0, r = e.points.length; t < r; t++) {
        let i = e.points[t];
        this.points.push(i.clone());
      }
      return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this;
    }
    toJSON() {
      let e = super.toJSON();
      e.points = [];
      for (let t = 0, r = this.points.length; t < r; t++) {
        let i = this.points[t];
        e.points.push(i.toArray());
      }
      return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e;
    }
    fromJSON(e) {
      super.fromJSON(e), this.points = [];
      for (let t = 0, r = e.points.length; t < r; t++) {
        let i = e.points[t];
        this.points.push(new I().fromArray(i));
      }
      return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this;
    }
  };
function Hb(n, e, t, r, i) {
  let s = (r - e) * .5, o = (i - t) * .5, a = n * n, u = n * a;
  return (2 * t - 2 * r + s + o) * u + (-3 * t + 3 * r - 2 * s - o) * a +
    s * n + t;
}
function $z(n, e) {
  let t = 1 - n;
  return t * t * e;
}
function e4(n, e) {
  return 2 * (1 - n) * n * e;
}
function t4(n, e) {
  return n * n * e;
}
function ad(n, e, t, r) {
  return $z(n, e) + e4(n, t) + t4(n, r);
}
function n4(n, e) {
  let t = 1 - n;
  return t * t * t * e;
}
function r4(n, e) {
  let t = 1 - n;
  return 3 * t * t * n * e;
}
function i4(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function s4(n, e) {
  return n * n * n * e;
}
function ld(n, e, t, r, i) {
  return n4(n, e) + r4(n, t) + i4(n, r) + s4(n, i);
}
var qm = class extends Ci {
    constructor(e = new se(), t = new se(), r = new se(), i = new se()) {
      super();
      this.isCubicBezierCurve = !0,
        this.type = "CubicBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = r,
        this.v3 = i;
    }
    getPoint(e, t = new se()) {
      let r = t, i = this.v0, s = this.v1, o = this.v2, a = this.v3;
      return r.set(ld(e, i.x, s.x, o.x, a.x), ld(e, i.y, s.y, o.y, a.y)), r;
    }
    copy(e) {
      return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this;
    }
    toJSON() {
      let e = super.toJSON();
      return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e;
    }
    fromJSON(e) {
      return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this;
    }
  },
  O_ = class extends Ci {
    constructor(e = new I(), t = new I(), r = new I(), i = new I()) {
      super();
      this.isCubicBezierCurve3 = !0,
        this.type = "CubicBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = r,
        this.v3 = i;
    }
    getPoint(e, t = new I()) {
      let r = t, i = this.v0, s = this.v1, o = this.v2, a = this.v3;
      return r.set(
        ld(e, i.x, s.x, o.x, a.x),
        ld(e, i.y, s.y, o.y, a.y),
        ld(e, i.z, s.z, o.z, a.z),
      ),
        r;
    }
    copy(e) {
      return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this;
    }
    toJSON() {
      let e = super.toJSON();
      return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e;
    }
    fromJSON(e) {
      return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this;
    }
  },
  ud = class extends Ci {
    constructor(e = new se(), t = new se()) {
      super();
      this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
    }
    getPoint(e, t = new se()) {
      let r = t;
      return e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
        r;
    }
    getPointAt(e, t) {
      return this.getPoint(e, t);
    }
    getTangent(e, t) {
      let r = t || new se();
      return r.copy(this.v2).sub(this.v1).normalize(), r;
    }
    copy(e) {
      return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
      let e = super.toJSON();
      return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this;
    }
  },
  z_ = class extends Ci {
    constructor(e = new I(), t = new I()) {
      super();
      this.isLineCurve3 = !0,
        this.type = "LineCurve3",
        this.v1 = e,
        this.v2 = t;
    }
    getPoint(e, t = new I()) {
      let r = t;
      return e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
        r;
    }
    getPointAt(e, t) {
      return this.getPoint(e, t);
    }
    copy(e) {
      return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
      let e = super.toJSON();
      return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this;
    }
  },
  Ym = class extends Ci {
    constructor(e = new se(), t = new se(), r = new se()) {
      super();
      this.isQuadraticBezierCurve = !0,
        this.type = "QuadraticBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = r;
    }
    getPoint(e, t = new se()) {
      let r = t, i = this.v0, s = this.v1, o = this.v2;
      return r.set(ad(e, i.x, s.x, o.x), ad(e, i.y, s.y, o.y)), r;
    }
    copy(e) {
      return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this;
    }
    toJSON() {
      let e = super.toJSON();
      return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e;
    }
    fromJSON(e) {
      return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this;
    }
  },
  Zm = class extends Ci {
    constructor(e = new I(), t = new I(), r = new I()) {
      super();
      this.isQuadraticBezierCurve3 = !0,
        this.type = "QuadraticBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = r;
    }
    getPoint(e, t = new I()) {
      let r = t, i = this.v0, s = this.v1, o = this.v2;
      return r.set(
        ad(e, i.x, s.x, o.x),
        ad(e, i.y, s.y, o.y),
        ad(e, i.z, s.z, o.z),
      ),
        r;
    }
    copy(e) {
      return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this;
    }
    toJSON() {
      let e = super.toJSON();
      return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e;
    }
    fromJSON(e) {
      return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this;
    }
  },
  Km = class extends Ci {
    constructor(e = []) {
      super();
      this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
    }
    getPoint(e, t = new se()) {
      let r = t,
        i = this.points,
        s = (i.length - 1) * e,
        o = Math.floor(s),
        a = s - o,
        u = i[o === 0 ? o : o - 1],
        f = i[o],
        d = i[o > i.length - 2 ? i.length - 1 : o + 1],
        h = i[o > i.length - 3 ? i.length - 1 : o + 2];
      return r.set(Hb(a, u.x, f.x, d.x, h.x), Hb(a, u.y, f.y, d.y, h.y)), r;
    }
    copy(e) {
      super.copy(e), this.points = [];
      for (let t = 0, r = e.points.length; t < r; t++) {
        let i = e.points[t];
        this.points.push(i.clone());
      }
      return this;
    }
    toJSON() {
      let e = super.toJSON();
      e.points = [];
      for (let t = 0, r = this.points.length; t < r; t++) {
        let i = this.points[t];
        e.points.push(i.toArray());
      }
      return e;
    }
    fromJSON(e) {
      super.fromJSON(e), this.points = [];
      for (let t = 0, r = e.points.length; t < r; t++) {
        let i = e.points[t];
        this.points.push(new se().fromArray(i));
      }
      return this;
    }
  },
  B_ = Object.freeze({
    __proto__: null,
    ArcCurve: P_,
    CatmullRomCurve3: F_,
    CubicBezierCurve: qm,
    CubicBezierCurve3: O_,
    EllipseCurve: od,
    LineCurve: ud,
    LineCurve3: z_,
    QuadraticBezierCurve: Ym,
    QuadraticBezierCurve3: Zm,
    SplineCurve: Km,
  }),
  U_ = class extends Ci {
    constructor() {
      super();
      this.type = "CurvePath", this.curves = [], this.autoClose = !1;
    }
    add(e) {
      this.curves.push(e);
    }
    closePath() {
      let e = this.curves[0].getPoint(0),
        t = this.curves[this.curves.length - 1].getPoint(1);
      e.equals(t) || this.curves.push(new ud(t, e));
    }
    getPoint(e, t) {
      let r = e * this.getLength(), i = this.getCurveLengths(), s = 0;
      for (; s < i.length;) {
        if (i[s] >= r) {
          let o = i[s] - r,
            a = this.curves[s],
            u = a.getLength(),
            f = u === 0 ? 0 : 1 - o / u;
          return a.getPointAt(f, t);
        }
        s++;
      }
      return null;
    }
    getLength() {
      let e = this.getCurveLengths();
      return e[e.length - 1];
    }
    updateArcLengths() {
      this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
    }
    getCurveLengths() {
      if (
        this.cacheLengths && this.cacheLengths.length === this.curves.length
      ) return this.cacheLengths;
      let e = [], t = 0;
      for (let r = 0, i = this.curves.length; r < i; r++) {
        t += this.curves[r].getLength(), e.push(t);
      }
      return this.cacheLengths = e, e;
    }
    getSpacedPoints(e = 40) {
      let t = [];
      for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
      return this.autoClose && t.push(t[0]), t;
    }
    getPoints(e = 12) {
      let t = [], r;
      for (let i = 0, s = this.curves; i < s.length; i++) {
        let o = s[i],
          a = o.isEllipseCurve
            ? e * 2
            : o.isLineCurve || o.isLineCurve3
            ? 1
            : o.isSplineCurve
            ? e * o.points.length
            : e,
          u = o.getPoints(a);
        for (let f = 0; f < u.length; f++) {
          let d = u[f];
          r && r.equals(d) || (t.push(d), r = d);
        }
      }
      return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
        t;
    }
    copy(e) {
      super.copy(e), this.curves = [];
      for (let t = 0, r = e.curves.length; t < r; t++) {
        let i = e.curves[t];
        this.curves.push(i.clone());
      }
      return this.autoClose = e.autoClose, this;
    }
    toJSON() {
      let e = super.toJSON();
      e.autoClose = this.autoClose, e.curves = [];
      for (let t = 0, r = this.curves.length; t < r; t++) {
        let i = this.curves[t];
        e.curves.push(i.toJSON());
      }
      return e;
    }
    fromJSON(e) {
      super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
      for (let t = 0, r = e.curves.length; t < r; t++) {
        let i = e.curves[t];
        this.curves.push(new B_[i.type]().fromJSON(i));
      }
      return this;
    }
  },
  tc = class extends U_ {
    constructor(e) {
      super();
      this.type = "Path",
        this.currentPoint = new se(),
        e && this.setFromPoints(e);
    }
    setFromPoints(e) {
      this.moveTo(e[0].x, e[0].y);
      for (let t = 1, r = e.length; t < r; t++) this.lineTo(e[t].x, e[t].y);
      return this;
    }
    moveTo(e, t) {
      return this.currentPoint.set(e, t), this;
    }
    lineTo(e, t) {
      let r = new ud(this.currentPoint.clone(), new se(e, t));
      return this.curves.push(r), this.currentPoint.set(e, t), this;
    }
    quadraticCurveTo(e, t, r, i) {
      let s = new Ym(this.currentPoint.clone(), new se(e, t), new se(r, i));
      return this.curves.push(s), this.currentPoint.set(r, i), this;
    }
    bezierCurveTo(e, t, r, i, s, o) {
      let a = new qm(
        this.currentPoint.clone(),
        new se(e, t),
        new se(r, i),
        new se(s, o),
      );
      return this.curves.push(a), this.currentPoint.set(s, o), this;
    }
    splineThru(e) {
      let t = [this.currentPoint.clone()].concat(e), r = new Km(t);
      return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
    }
    arc(e, t, r, i, s, o) {
      let a = this.currentPoint.x, u = this.currentPoint.y;
      return this.absarc(e + a, t + u, r, i, s, o), this;
    }
    absarc(e, t, r, i, s, o) {
      return this.absellipse(e, t, r, r, i, s, o), this;
    }
    ellipse(e, t, r, i, s, o, a, u) {
      let f = this.currentPoint.x, d = this.currentPoint.y;
      return this.absellipse(e + f, t + d, r, i, s, o, a, u), this;
    }
    absellipse(e, t, r, i, s, o, a, u) {
      let f = new od(e, t, r, i, s, o, a, u);
      if (this.curves.length > 0) {
        let h = f.getPoint(0);
        h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
      }
      this.curves.push(f);
      let d = f.getPoint(1);
      return this.currentPoint.copy(d), this;
    }
    copy(e) {
      return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
    }
    toJSON() {
      let e = super.toJSON();
      return e.currentPoint = this.currentPoint.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e),
        this.currentPoint.fromArray(e.currentPoint),
        this;
    }
  },
  xl = class extends Ye {
    constructor(
      e = [new se(0, .5), new se(.5, 0), new se(0, -.5)],
      t = 12,
      r = 0,
      i = Math.PI * 2,
    ) {
      super();
      this.type = "LatheGeometry",
        this.parameters = { points: e, segments: t, phiStart: r, phiLength: i },
        t = Math.floor(t),
        i = yn(i, 0, Math.PI * 2);
      let s = [],
        o = [],
        a = [],
        u = [],
        f = [],
        d = 1 / t,
        h = new I(),
        p = new se(),
        g = new I(),
        y = new I(),
        v = new I(),
        _ = 0,
        S = 0;
      for (let w = 0; w <= e.length - 1; w++) {
        switch (w) {
          case 0:
            _ = e[w + 1].x - e[w].x,
              S = e[w + 1].y - e[w].y,
              g.x = S * 1,
              g.y = -_,
              g.z = S * 0,
              v.copy(g),
              g.normalize(),
              u.push(g.x, g.y, g.z);
            break;
          case e.length - 1:
            u.push(v.x, v.y, v.z);
            break;
          default:
            _ = e[w + 1].x - e[w].x,
              S = e[w + 1].y - e[w].y,
              g.x = S * 1,
              g.y = -_,
              g.z = S * 0,
              y.copy(g),
              g.x += v.x,
              g.y += v.y,
              g.z += v.z,
              g.normalize(),
              u.push(g.x, g.y, g.z),
              v.copy(y);
        }
      }
      for (let w = 0; w <= t; w++) {
        let M = r + w * d * i, T = Math.sin(M), b = Math.cos(M);
        for (let R = 0; R <= e.length - 1; R++) {
          h.x = e[R].x * T,
            h.y = e[R].y,
            h.z = e[R].x * b,
            o.push(h.x, h.y, h.z),
            p.x = w / t,
            p.y = R / (e.length - 1),
            a.push(p.x, p.y);
          let P = u[3 * R + 0] * T, C = u[3 * R + 1], L = u[3 * R + 0] * b;
          f.push(P, C, L);
        }
      }
      for (let w = 0; w < t; w++) {
        for (let M = 0; M < e.length - 1; M++) {
          let T = M + w * e.length,
            b = T,
            R = T + e.length,
            P = T + e.length + 1,
            C = T + 1;
          s.push(b, R, C), s.push(P, C, R);
        }
      }
      this.setIndex(s),
        this.setAttribute("position", new ke(o, 3)),
        this.setAttribute("uv", new ke(a, 2)),
        this.setAttribute("normal", new ke(f, 3));
    }
    static fromJSON(e) {
      return new xl(e.points, e.segments, e.phiStart, e.phiLength);
    }
  },
  nc = class extends xl {
    constructor(e = 1, t = 1, r = 4, i = 8) {
      let s = new tc();
      s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
        s.absarc(0, t / 2, e, 0, Math.PI * .5);
      super(s.getPoints(r), i);
      this.type = "CapsuleGeometry",
        this.parameters = {
          radius: e,
          height: t,
          capSegments: r,
          radialSegments: i,
        };
    }
    static fromJSON(e) {
      return new nc(e.radius, e.length, e.capSegments, e.radialSegments);
    }
  },
  rc = class extends Ye {
    constructor(e = 1, t = 8, r = 0, i = Math.PI * 2) {
      super();
      this.type = "CircleGeometry",
        this.parameters = {
          radius: e,
          segments: t,
          thetaStart: r,
          thetaLength: i,
        },
        t = Math.max(3, t);
      let s = [], o = [], a = [], u = [], f = new I(), d = new se();
      o.push(0, 0, 0), a.push(0, 0, 1), u.push(.5, .5);
      for (let h = 0, p = 3; h <= t; h++, p += 3) {
        let g = r + h / t * i;
        f.x = e * Math.cos(g),
          f.y = e * Math.sin(g),
          o.push(f.x, f.y, f.z),
          a.push(0, 0, 1),
          d.x = (o[p] / e + 1) / 2,
          d.y = (o[p + 1] / e + 1) / 2,
          u.push(d.x, d.y);
      }
      for (let h = 1; h <= t; h++) s.push(h, h + 1, 0);
      this.setIndex(s),
        this.setAttribute("position", new ke(o, 3)),
        this.setAttribute("normal", new ke(a, 3)),
        this.setAttribute("uv", new ke(u, 2));
    }
    static fromJSON(e) {
      return new rc(e.radius, e.segments, e.thetaStart, e.thetaLength);
    }
  },
  ua = class extends Ye {
    constructor(
      e = 1,
      t = 1,
      r = 1,
      i = 8,
      s = 1,
      o = !1,
      a = 0,
      u = Math.PI * 2,
    ) {
      super();
      this.type = "CylinderGeometry",
        this.parameters = {
          radiusTop: e,
          radiusBottom: t,
          height: r,
          radialSegments: i,
          heightSegments: s,
          openEnded: o,
          thetaStart: a,
          thetaLength: u,
        };
      let f = this;
      i = Math.floor(i), s = Math.floor(s);
      let d = [], h = [], p = [], g = [], y = 0, v = [], _ = r / 2, S = 0;
      w(),
        o === !1 && (e > 0 && M(!0), t > 0 && M(!1)),
        this.setIndex(d),
        this.setAttribute("position", new ke(h, 3)),
        this.setAttribute("normal", new ke(p, 3)),
        this.setAttribute("uv", new ke(g, 2));
      function w() {
        let T = new I(), b = new I(), R = 0, P = (t - e) / r;
        for (let C = 0; C <= s; C++) {
          let L = [], k = C / s, z = k * (t - e) + e;
          for (let Y = 0; Y <= i; Y++) {
            let le = Y / i, V = le * u + a, W = Math.sin(V), G = Math.cos(V);
            b.x = z * W,
              b.y = -k * r + _,
              b.z = z * G,
              h.push(b.x, b.y, b.z),
              T.set(W, P, G).normalize(),
              p.push(T.x, T.y, T.z),
              g.push(le, 1 - k),
              L.push(y++);
          }
          v.push(L);
        }
        for (let C = 0; C < i; C++) {
          for (let L = 0; L < s; L++) {
            let k = v[L][C],
              z = v[L + 1][C],
              Y = v[L + 1][C + 1],
              le = v[L][C + 1];
            d.push(k, z, le), d.push(z, Y, le), R += 6;
          }
        }
        f.addGroup(S, R, 0), S += R;
      }
      function M(T) {
        let b = y,
          R = new se(),
          P = new I(),
          C = 0,
          L = T === !0 ? e : t,
          k = T === !0 ? 1 : -1;
        for (let Y = 1; Y <= i; Y++) {
          h.push(0, _ * k, 0), p.push(0, k, 0), g.push(.5, .5), y++;
        }
        let z = y;
        for (let Y = 0; Y <= i; Y++) {
          let V = Y / i * u + a, W = Math.cos(V), G = Math.sin(V);
          P.x = L * G,
            P.y = _ * k,
            P.z = L * W,
            h.push(P.x, P.y, P.z),
            p.push(0, k, 0),
            R.x = W * .5 + .5,
            R.y = G * .5 * k + .5,
            g.push(R.x, R.y),
            y++;
        }
        for (let Y = 0; Y < i; Y++) {
          let le = b + Y, V = z + Y;
          T === !0 ? d.push(V, V + 1, le) : d.push(V + 1, V, le), C += 3;
        }
        f.addGroup(S, C, T === !0 ? 1 : 2), S += C;
      }
    }
    static fromJSON(e) {
      return new ua(
        e.radiusTop,
        e.radiusBottom,
        e.height,
        e.radialSegments,
        e.heightSegments,
        e.openEnded,
        e.thetaStart,
        e.thetaLength,
      );
    }
  },
  ic = class extends ua {
    constructor(e = 1, t = 1, r = 8, i = 1, s = !1, o = 0, a = Math.PI * 2) {
      super(0, e, t, r, i, s, o, a);
      this.type = "ConeGeometry",
        this.parameters = {
          radius: e,
          height: t,
          radialSegments: r,
          heightSegments: i,
          openEnded: s,
          thetaStart: o,
          thetaLength: a,
        };
    }
    static fromJSON(e) {
      return new ic(
        e.radius,
        e.height,
        e.radialSegments,
        e.heightSegments,
        e.openEnded,
        e.thetaStart,
        e.thetaLength,
      );
    }
  },
  Ss = class extends Ye {
    constructor(e = [], t = [], r = 1, i = 0) {
      super();
      this.type = "PolyhedronGeometry",
        this.parameters = { vertices: e, indices: t, radius: r, detail: i };
      let s = [], o = [];
      a(i),
        f(r),
        d(),
        this.setAttribute("position", new ke(s, 3)),
        this.setAttribute("normal", new ke(s.slice(), 3)),
        this.setAttribute("uv", new ke(o, 2)),
        i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
      function a(w) {
        let M = new I(), T = new I(), b = new I();
        for (let R = 0; R < t.length; R += 3) {
          g(t[R + 0], M), g(t[R + 1], T), g(t[R + 2], b), u(M, T, b, w);
        }
      }
      function u(w, M, T, b) {
        let R = b + 1, P = [];
        for (let C = 0; C <= R; C++) {
          P[C] = [];
          let L = w.clone().lerp(T, C / R),
            k = M.clone().lerp(T, C / R),
            z = R - C;
          for (let Y = 0; Y <= z; Y++) {
            Y === 0 && C === R
              ? P[C][Y] = L
              : P[C][Y] = L.clone().lerp(k, Y / z);
          }
        }
        for (let C = 0; C < R; C++) {
          for (let L = 0; L < 2 * (R - C) - 1; L++) {
            let k = Math.floor(L / 2);
            L % 2 == 0
              ? (p(P[C][k + 1]), p(P[C + 1][k]), p(P[C][k]))
              : (p(P[C][k + 1]), p(P[C + 1][k + 1]), p(P[C + 1][k]));
          }
        }
      }
      function f(w) {
        let M = new I();
        for (let T = 0; T < s.length; T += 3) {
          M.x = s[T + 0],
            M.y = s[T + 1],
            M.z = s[T + 2],
            M.normalize().multiplyScalar(w),
            s[T + 0] = M.x,
            s[T + 1] = M.y,
            s[T + 2] = M.z;
        }
      }
      function d() {
        let w = new I();
        for (let M = 0; M < s.length; M += 3) {
          w.x = s[M + 0], w.y = s[M + 1], w.z = s[M + 2];
          let T = _(w) / 2 / Math.PI + .5, b = S(w) / Math.PI + .5;
          o.push(T, 1 - b);
        }
        y(), h();
      }
      function h() {
        for (let w = 0; w < o.length; w += 6) {
          let M = o[w + 0],
            T = o[w + 2],
            b = o[w + 4],
            R = Math.max(M, T, b),
            P = Math.min(M, T, b);
          R > .9 && P < .1 &&
            (M < .2 && (o[w + 0] += 1),
              T < .2 && (o[w + 2] += 1),
              b < .2 && (o[w + 4] += 1));
        }
      }
      function p(w) {
        s.push(w.x, w.y, w.z);
      }
      function g(w, M) {
        let T = w * 3;
        M.x = e[T + 0], M.y = e[T + 1], M.z = e[T + 2];
      }
      function y() {
        let w = new I(),
          M = new I(),
          T = new I(),
          b = new I(),
          R = new se(),
          P = new se(),
          C = new se();
        for (let L = 0, k = 0; L < s.length; L += 9, k += 6) {
          w.set(s[L + 0], s[L + 1], s[L + 2]),
            M.set(s[L + 3], s[L + 4], s[L + 5]),
            T.set(s[L + 6], s[L + 7], s[L + 8]),
            R.set(o[k + 0], o[k + 1]),
            P.set(o[k + 2], o[k + 3]),
            C.set(o[k + 4], o[k + 5]),
            b.copy(w).add(M).add(T).divideScalar(3);
          let z = _(b);
          v(R, k + 0, w, z), v(P, k + 2, M, z), v(C, k + 4, T, z);
        }
      }
      function v(w, M, T, b) {
        b < 0 && w.x === 1 && (o[M] = w.x - 1),
          T.x === 0 && T.z === 0 && (o[M] = b / 2 / Math.PI + .5);
      }
      function _(w) {
        return Math.atan2(w.z, -w.x);
      }
      function S(w) {
        return Math.atan2(-w.y, Math.sqrt(w.x * w.x + w.z * w.z));
      }
    }
    static fromJSON(e) {
      return new Ss(e.vertices, e.indices, e.radius, e.details);
    }
  },
  sc = class extends Ss {
    constructor(e = 1, t = 0) {
      let r = (1 + Math.sqrt(5)) / 2,
        i = 1 / r,
        s = [
          -1,
          -1,
          -1,
          -1,
          -1,
          1,
          -1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          1,
          1,
          1,
          -1,
          1,
          1,
          1,
          0,
          -i,
          -r,
          0,
          -i,
          r,
          0,
          i,
          -r,
          0,
          i,
          r,
          -i,
          -r,
          0,
          -i,
          r,
          0,
          i,
          -r,
          0,
          i,
          r,
          0,
          -r,
          0,
          -i,
          r,
          0,
          -i,
          -r,
          0,
          i,
          r,
          0,
          i,
        ],
        o = [
          3,
          11,
          7,
          3,
          7,
          15,
          3,
          15,
          13,
          7,
          19,
          17,
          7,
          17,
          6,
          7,
          6,
          15,
          17,
          4,
          8,
          17,
          8,
          10,
          17,
          10,
          6,
          8,
          0,
          16,
          8,
          16,
          2,
          8,
          2,
          10,
          0,
          12,
          1,
          0,
          1,
          18,
          0,
          18,
          16,
          6,
          10,
          2,
          6,
          2,
          13,
          6,
          13,
          15,
          2,
          16,
          18,
          2,
          18,
          3,
          2,
          3,
          13,
          18,
          1,
          9,
          18,
          9,
          11,
          18,
          11,
          3,
          4,
          14,
          12,
          4,
          12,
          0,
          4,
          0,
          8,
          11,
          9,
          5,
          11,
          5,
          19,
          11,
          19,
          7,
          19,
          5,
          14,
          19,
          14,
          4,
          19,
          4,
          17,
          1,
          12,
          14,
          1,
          14,
          5,
          1,
          5,
          9,
        ];
      super(s, o, e, t);
      this.type = "DodecahedronGeometry",
        this.parameters = { radius: e, detail: t };
    }
    static fromJSON(e) {
      return new sc(e.radius, e.detail);
    }
  },
  Jm = new I(),
  Qm = new I(),
  V_ = new I(),
  $m = new Qr(),
  H_ = class extends Ye {
    constructor(e = null, t = 1) {
      super();
      if (
        this.type = "EdgesGeometry",
          this.parameters = { geometry: e, thresholdAngle: t },
          e !== null
      ) {
        let i = Math.pow(10, 4),
          s = Math.cos(il * t),
          o = e.getIndex(),
          a = e.getAttribute("position"),
          u = o ? o.count : a.count,
          f = [0, 0, 0],
          d = ["a", "b", "c"],
          h = new Array(3),
          p = {},
          g = [];
        for (let y = 0; y < u; y += 3) {
          o
            ? (f[0] = o.getX(y), f[1] = o.getX(y + 1), f[2] = o.getX(y + 2))
            : (f[0] = y, f[1] = y + 1, f[2] = y + 2);
          let { a: v, b: _, c: S } = $m;
          if (
            v.fromBufferAttribute(a, f[0]),
              _.fromBufferAttribute(a, f[1]),
              S.fromBufferAttribute(a, f[2]),
              $m.getNormal(V_),
              h[0] = `${Math.round(v.x * i)},${Math.round(v.y * i)},${
                Math.round(v.z * i)
              }`,
              h[1] = `${Math.round(_.x * i)},${Math.round(_.y * i)},${
                Math.round(_.z * i)
              }`,
              h[2] = `${Math.round(S.x * i)},${Math.round(S.y * i)},${
                Math.round(S.z * i)
              }`,
              !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0])
          ) {
            for (let w = 0; w < 3; w++) {
              let M = (w + 1) % 3,
                T = h[w],
                b = h[M],
                R = $m[d[w]],
                P = $m[d[M]],
                C = `${T}_${b}`,
                L = `${b}_${T}`;
              L in p && p[L]
                ? (V_.dot(p[L].normal) <= s &&
                  (g.push(R.x, R.y, R.z), g.push(P.x, P.y, P.z)),
                  p[L] = null)
                : C in p ||
                  (p[C] = { index0: f[w], index1: f[M], normal: V_.clone() });
            }
          }
        }
        for (let y in p) {
          if (p[y]) {
            let { index0: v, index1: _ } = p[y];
            Jm.fromBufferAttribute(a, v),
              Qm.fromBufferAttribute(a, _),
              g.push(Jm.x, Jm.y, Jm.z),
              g.push(Qm.x, Qm.y, Qm.z);
          }
        }
        this.setAttribute("position", new ke(g, 3));
      }
    }
  },
  ca = class extends tc {
    constructor(e) {
      super(e);
      this.uuid = Kr(), this.type = "Shape", this.holes = [];
    }
    getPointsHoles(e) {
      let t = [];
      for (let r = 0, i = this.holes.length; r < i; r++) {
        t[r] = this.holes[r].getPoints(e);
      }
      return t;
    }
    extractPoints(e) {
      return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
    }
    copy(e) {
      super.copy(e), this.holes = [];
      for (let t = 0, r = e.holes.length; t < r; t++) {
        let i = e.holes[t];
        this.holes.push(i.clone());
      }
      return this;
    }
    toJSON() {
      let e = super.toJSON();
      e.uuid = this.uuid, e.holes = [];
      for (let t = 0, r = this.holes.length; t < r; t++) {
        let i = this.holes[t];
        e.holes.push(i.toJSON());
      }
      return e;
    }
    fromJSON(e) {
      super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
      for (let t = 0, r = e.holes.length; t < r; t++) {
        let i = e.holes[t];
        this.holes.push(new tc().fromJSON(i));
      }
      return this;
    }
  },
  o4 = {
    triangulate: function (n, e, t = 2) {
      let r = e && e.length,
        i = r ? e[0] * t : n.length,
        s = Gb(n, 0, i, t, !0),
        o = [];
      if (!s || s.next === s.prev) return o;
      let a, u, f, d, h, p, g;
      if (r && (s = f4(n, e, s, t)), n.length > 80 * t) {
        a = f = n[0], u = d = n[1];
        for (let y = t; y < i; y += t) {
          h = n[y],
            p = n[y + 1],
            h < a && (a = h),
            p < u && (u = p),
            h > f && (f = h),
            p > d && (d = p);
        }
        g = Math.max(f - a, d - u), g = g !== 0 ? 1 / g : 0;
      }
      return cd(s, o, t, a, u, g), o;
    },
  };
function Gb(n, e, t, r, i) {
  let s, o;
  if (i === w4(n, e, t, r) > 0) {
    for (s = e; s < t; s += r) o = Xb(s, n[s], n[s + 1], o);
  } else for (s = t - r; s >= e; s -= r) o = Xb(s, n[s], n[s + 1], o);
  return o && eg(o, o.next) && (dd(o), o = o.next), o;
}
function fa(n, e) {
  if (!n) return n;
  e || (e = n);
  let t = n, r;
  do if (r = !1, !t.steiner && (eg(t, t.next) || un(t.prev, t, t.next) === 0)) {
    if (dd(t), t = e = t.prev, t === t.next) break;
    r = !0;
  } else t = t.next; while (r || t !== e);
  return e;
}
function cd(n, e, t, r, i, s, o) {
  if (!n) return;
  !o && s && g4(n, r, i, s);
  let a = n, u, f;
  for (; n.prev !== n.next;) {
    if (u = n.prev, f = n.next, s ? l4(n, r, i, s) : a4(n)) {
      e.push(u.i / t),
        e.push(n.i / t),
        e.push(f.i / t),
        dd(n),
        n = f.next,
        a = f.next;
      continue;
    }
    if (n = f, n === a) {
      o
        ? o === 1
          ? (n = u4(fa(n), e, t), cd(n, e, t, r, i, s, 2))
          : o === 2 && c4(n, e, t, r, i, s)
        : cd(fa(n), e, t, r, i, s, 1);
      break;
    }
  }
}
function a4(n) {
  let e = n.prev, t = n, r = n.next;
  if (un(e, t, r) >= 0) return !1;
  let i = n.next.next;
  for (; i !== n.prev;) {
    if (
      oc(e.x, e.y, t.x, t.y, r.x, r.y, i.x, i.y) && un(i.prev, i, i.next) >= 0
    ) return !1;
    i = i.next;
  }
  return !0;
}
function l4(n, e, t, r) {
  let i = n.prev, s = n, o = n.next;
  if (un(i, s, o) >= 0) return !1;
  let a = i.x < s.x ? i.x < o.x ? i.x : o.x : s.x < o.x ? s.x : o.x,
    u = i.y < s.y ? i.y < o.y ? i.y : o.y : s.y < o.y ? s.y : o.y,
    f = i.x > s.x ? i.x > o.x ? i.x : o.x : s.x > o.x ? s.x : o.x,
    d = i.y > s.y ? i.y > o.y ? i.y : o.y : s.y > o.y ? s.y : o.y,
    h = G_(a, u, e, t, r),
    p = G_(f, d, e, t, r),
    g = n.prevZ,
    y = n.nextZ;
  for (; g && g.z >= h && y && y.z <= p;) {
    if (
      g !== n.prev && g !== n.next &&
        oc(i.x, i.y, s.x, s.y, o.x, o.y, g.x, g.y) &&
        un(g.prev, g, g.next) >= 0 ||
      (g = g.prevZ,
        y !== n.prev && y !== n.next &&
        oc(i.x, i.y, s.x, s.y, o.x, o.y, y.x, y.y) &&
        un(y.prev, y, y.next) >= 0)
    ) return !1;
    y = y.nextZ;
  }
  for (; g && g.z >= h;) {
    if (
      g !== n.prev && g !== n.next &&
      oc(i.x, i.y, s.x, s.y, o.x, o.y, g.x, g.y) && un(g.prev, g, g.next) >= 0
    ) return !1;
    g = g.prevZ;
  }
  for (; y && y.z <= p;) {
    if (
      y !== n.prev && y !== n.next &&
      oc(i.x, i.y, s.x, s.y, o.x, o.y, y.x, y.y) && un(y.prev, y, y.next) >= 0
    ) return !1;
    y = y.nextZ;
  }
  return !0;
}
function u4(n, e, t) {
  let r = n;
  do {
    let i = r.prev, s = r.next.next;
    !eg(i, s) && jb(i, r, r.next, s) && fd(i, s) && fd(s, i) &&
    (e.push(i.i / t),
      e.push(r.i / t),
      e.push(s.i / t),
      dd(r),
      dd(r.next),
      r = n = s), r = r.next;
  } while (r !== n);
  return fa(r);
}
function c4(n, e, t, r, i, s) {
  let o = n;
  do {
    let a = o.next.next;
    for (; a !== o.prev;) {
      if (o.i !== a.i && x4(o, a)) {
        let u = Wb(o, a);
        o = fa(o, o.next),
          u = fa(u, u.next),
          cd(o, e, t, r, i, s),
          cd(u, e, t, r, i, s);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== n);
}
function f4(n, e, t, r) {
  let i = [], s, o, a, u, f;
  for (s = 0, o = e.length; s < o; s++) {
    a = e[s] * r,
      u = s < o - 1 ? e[s + 1] * r : n.length,
      f = Gb(n, a, u, r, !1),
      f === f.next && (f.steiner = !0),
      i.push(y4(f));
  }
  for (i.sort(d4), s = 0; s < i.length; s++) h4(i[s], t), t = fa(t, t.next);
  return t;
}
function d4(n, e) {
  return n.x - e.x;
}
function h4(n, e) {
  if (e = p4(n, e), e) {
    let t = Wb(e, n);
    fa(e, e.next), fa(t, t.next);
  }
}
function p4(n, e) {
  let t = e, r = n.x, i = n.y, s = -1 / 0, o;
  do {
    if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
      let p = t.x + (i - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (p <= r && p > s) {
        if (s = p, p === r) {
          if (i === t.y) return t;
          if (i === t.next.y) return t.next;
        }
        o = t.x < t.next.x ? t : t.next;
      }
    }
    t = t.next;
  } while (t !== e);
  if (!o) return null;
  if (r === s) return o;
  let a = o, u = o.x, f = o.y, d = 1 / 0, h;
  t = o;
  do r >= t.x && t.x >= u && r !== t.x &&
    oc(i < f ? r : s, i, u, f, i < f ? s : r, i, t.x, t.y) &&
    (h = Math.abs(i - t.y) / (r - t.x),
      fd(t, n) &&
      (h < d || h === d && (t.x > o.x || t.x === o.x && m4(o, t))) &&
      (o = t, d = h)),
    t = t.next; while (t !== a);
  return o;
}
function m4(n, e) {
  return un(n.prev, n, e.prev) < 0 && un(e.next, n, n.next) < 0;
}
function g4(n, e, t, r) {
  let i = n;
  do i.z === null && (i.z = G_(i.x, i.y, e, t, r)),
    i.prevZ = i.prev,
    i.nextZ = i.next,
    i = i.next; while (i !== n);
  i.prevZ.nextZ = null, i.prevZ = null, v4(i);
}
function v4(n) {
  let e, t, r, i, s, o, a, u, f = 1;
  do {
    for (t = n, n = null, s = null, o = 0; t;) {
      for (o++, r = t, a = 0, e = 0; e < f && (a++, r = r.nextZ, !!r); e++);
      for (u = f; a > 0 || u > 0 && r;) {
        a !== 0 && (u === 0 || !r || t.z <= r.z)
          ? (i = t, t = t.nextZ, a--)
          : (i = r, r = r.nextZ, u--),
          s ? s.nextZ = i : n = i,
          i.prevZ = s,
          s = i;
      }
      t = r;
    }
    s.nextZ = null, f *= 2;
  } while (o > 1);
  return n;
}
function G_(n, e, t, r, i) {
  return n = 32767 * (n - t) * i,
    e = 32767 * (e - r) * i,
    n = (n | n << 8) & 16711935,
    n = (n | n << 4) & 252645135,
    n = (n | n << 2) & 858993459,
    n = (n | n << 1) & 1431655765,
    e = (e | e << 8) & 16711935,
    e = (e | e << 4) & 252645135,
    e = (e | e << 2) & 858993459,
    e = (e | e << 1) & 1431655765,
    n | e << 1;
}
function y4(n) {
  let e = n, t = n;
  do (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next; while (
    e !== n
  );
  return t;
}
function oc(n, e, t, r, i, s, o, a) {
  return (i - o) * (e - a) - (n - o) * (s - a) >= 0 &&
    (n - o) * (r - a) - (t - o) * (e - a) >= 0 &&
    (t - o) * (s - a) - (i - o) * (r - a) >= 0;
}
function x4(n, e) {
  return n.next.i !== e.i && n.prev.i !== e.i && !_4(n, e) &&
    (fd(n, e) && fd(e, n) && S4(n, e) &&
        (un(n.prev, n, e.prev) || un(n, e.prev, e)) ||
      eg(n, e) && un(n.prev, n, n.next) > 0 && un(e.prev, e, e.next) > 0);
}
function un(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function eg(n, e) {
  return n.x === e.x && n.y === e.y;
}
function jb(n, e, t, r) {
  let i = ng(un(n, e, t)),
    s = ng(un(n, e, r)),
    o = ng(un(t, r, n)),
    a = ng(un(t, r, e));
  return !!(i !== s && o !== a || i === 0 && tg(n, t, e) ||
    s === 0 && tg(n, r, e) || o === 0 && tg(t, n, r) || a === 0 && tg(t, e, r));
}
function tg(n, e, t) {
  return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y);
}
function ng(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function _4(n, e) {
  let t = n;
  do {
    if (
      t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i &&
      jb(t, t.next, n, e)
    ) return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function fd(n, e) {
  return un(n.prev, n, n.next) < 0
    ? un(n, e, n.next) >= 0 && un(n, n.prev, e) >= 0
    : un(n, e, n.prev) < 0 || un(n, n.next, e) < 0;
}
function S4(n, e) {
  let t = n, r = !1, i = (n.x + e.x) / 2, s = (n.y + e.y) / 2;
  do t.y > s != t.next.y > s && t.next.y !== t.y &&
    i < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (r = !r),
    t = t.next; while (t !== n);
  return r;
}
function Wb(n, e) {
  let t = new j_(n.i, n.x, n.y),
    r = new j_(e.i, e.x, e.y),
    i = n.next,
    s = e.prev;
  return n.next = e,
    e.prev = n,
    t.next = i,
    i.prev = t,
    r.next = t,
    t.prev = r,
    s.next = r,
    r.prev = s,
    r;
}
function Xb(n, e, t, r) {
  let i = new j_(n, e, t);
  return r
    ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i)
    : (i.prev = i, i.next = i),
    i;
}
function dd(n) {
  n.next.prev = n.prev,
    n.prev.next = n.next,
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function j_(n, e, t) {
  this.i = n,
    this.x = e,
    this.y = t,
    this.prev = null,
    this.next = null,
    this.z = null,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1;
}
function w4(n, e, t, r) {
  let i = 0;
  for (let s = e, o = t - r; s < t; s += r) {
    i += (n[o] - n[s]) * (n[s + 1] + n[o + 1]), o = s;
  }
  return i;
}
var es = class {
  static area(e) {
    let t = e.length, r = 0;
    for (let i = t - 1, s = 0; s < t; i = s++) {
      r += e[i].x * e[s].y - e[s].x * e[i].y;
    }
    return r * .5;
  }
  static isClockWise(e) {
    return es.area(e) < 0;
  }
  static triangulateShape(e, t) {
    let r = [], i = [], s = [];
    qb(e), Yb(r, e);
    let o = e.length;
    t.forEach(qb);
    for (let u = 0; u < t.length; u++) i.push(o), o += t[u].length, Yb(r, t[u]);
    let a = o4.triangulate(r, i);
    for (let u = 0; u < a.length; u += 3) s.push(a.slice(u, u + 3));
    return s;
  }
};
function qb(n) {
  let e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function Yb(n, e) {
  for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y);
}
var ac = class extends Ye {
    constructor(
      e = new ca([
        new se(.5, .5),
        new se(-.5, .5),
        new se(-.5, -.5),
        new se(.5, -.5),
      ]),
      t = {},
    ) {
      super();
      this.type = "ExtrudeGeometry",
        this.parameters = { shapes: e, options: t },
        e = Array.isArray(e) ? e : [e];
      let r = this, i = [], s = [];
      for (let a = 0, u = e.length; a < u; a++) {
        let f = e[a];
        o(f);
      }
      this.setAttribute("position", new ke(i, 3)),
        this.setAttribute("uv", new ke(s, 2)),
        this.computeVertexNormals();
      function o(a) {
        let u = [],
          f = t.curveSegments !== void 0 ? t.curveSegments : 12,
          d = t.steps !== void 0 ? t.steps : 1,
          h = t.depth !== void 0 ? t.depth : 1,
          p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
          g = t.bevelThickness !== void 0 ? t.bevelThickness : .2,
          y = t.bevelSize !== void 0 ? t.bevelSize : g - .1,
          v = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
          _ = t.bevelSegments !== void 0 ? t.bevelSegments : 3,
          S = t.extrudePath,
          w = t.UVGenerator !== void 0 ? t.UVGenerator : M4;
        t.amount !== void 0 &&
          (console.warn(
            "THREE.ExtrudeBufferGeometry: amount has been renamed to depth.",
          ),
            h = t.amount);
        let M, T = !1, b, R, P, C;
        S &&
        (M = S.getSpacedPoints(d),
          T = !0,
          p = !1,
          b = S.computeFrenetFrames(d, !1),
          R = new I(),
          P = new I(),
          C = new I()), p || (_ = 0, g = 0, y = 0, v = 0);
        let L = a.extractPoints(f), k = L.shape, z = L.holes;
        if (!es.isClockWise(k)) {
          k = k.reverse();
          for (let ue = 0, ne = z.length; ue < ne; ue++) {
            let _e = z[ue];
            es.isClockWise(_e) && (z[ue] = _e.reverse());
          }
        }
        let le = es.triangulateShape(k, z), V = k;
        for (let ue = 0, ne = z.length; ue < ne; ue++) {
          let _e = z[ue];
          k = k.concat(_e);
        }
        function W(ue, ne, _e) {
          return ne ||
            console.error("THREE.ExtrudeGeometry: vec does not exist"),
            ne.clone().multiplyScalar(_e).add(ue);
        }
        let G = k.length, re = le.length;
        function ie(ue, ne, _e) {
          let Fe,
            Ae,
            et,
            We = ue.x - ne.x,
            Ve = ue.y - ne.y,
            Tt = _e.x - ue.x,
            Nt = _e.y - ue.y,
            O = We * We + Ve * Ve,
            N = We * Nt - Ve * Tt;
          if (Math.abs(N) > Number.EPSILON) {
            let J = Math.sqrt(O),
              me = Math.sqrt(Tt * Tt + Nt * Nt),
              xe = ne.x - Ve / J,
              Ce = ne.y + We / J,
              Ke = _e.x - Nt / me,
              ee = _e.y + Tt / me,
              Be = ((Ke - xe) * Nt - (ee - Ce) * Tt) / (We * Nt - Ve * Tt);
            Fe = xe + We * Be - ue.x, Ae = Ce + Ve * Be - ue.y;
            let Ie = Fe * Fe + Ae * Ae;
            if (Ie <= 2) return new se(Fe, Ae);
            et = Math.sqrt(Ie / 2);
          } else {
            let J = !1;
            We > Number.EPSILON
              ? Tt > Number.EPSILON && (J = !0)
              : We < -Number.EPSILON
              ? Tt < -Number.EPSILON && (J = !0)
              : Math.sign(Ve) === Math.sign(Nt) && (J = !0),
              J
                ? (Fe = -Ve, Ae = We, et = Math.sqrt(O))
                : (Fe = We, Ae = Ve, et = Math.sqrt(O / 2));
          }
          return new se(Fe / et, Ae / et);
        }
        let X = [];
        for (
          let ue = 0, ne = V.length, _e = ne - 1, Fe = ue + 1;
          ue < ne;
          ue++, _e++, Fe++
        ) {
          _e === ne && (_e = 0),
            Fe === ne && (Fe = 0),
            X[ue] = ie(V[ue], V[_e], V[Fe]);
        }
        let $ = [], ae, fe = X.concat();
        for (let ue = 0, ne = z.length; ue < ne; ue++) {
          let _e = z[ue];
          ae = [];
          for (
            let Fe = 0, Ae = _e.length, et = Ae - 1, We = Fe + 1;
            Fe < Ae;
            Fe++, et++, We++
          ) {
            et === Ae && (et = 0),
              We === Ae && (We = 0),
              ae[Fe] = ie(_e[Fe], _e[et], _e[We]);
          }
          $.push(ae), fe = fe.concat(ae);
        }
        for (let ue = 0; ue < _; ue++) {
          let ne = ue / _,
            _e = g * Math.cos(ne * Math.PI / 2),
            Fe = y * Math.sin(ne * Math.PI / 2) + v;
          for (let Ae = 0, et = V.length; Ae < et; Ae++) {
            let We = W(V[Ae], X[Ae], Fe);
            Et(We.x, We.y, -_e);
          }
          for (let Ae = 0, et = z.length; Ae < et; Ae++) {
            let We = z[Ae];
            ae = $[Ae];
            for (let Ve = 0, Tt = We.length; Ve < Tt; Ve++) {
              let Nt = W(We[Ve], ae[Ve], Fe);
              Et(Nt.x, Nt.y, -_e);
            }
          }
        }
        let pe = y + v;
        for (let ue = 0; ue < G; ue++) {
          let ne = p ? W(k[ue], fe[ue], pe) : k[ue];
          T
            ? (P.copy(b.normals[0]).multiplyScalar(ne.x),
              R.copy(b.binormals[0]).multiplyScalar(ne.y),
              C.copy(M[0]).add(P).add(R),
              Et(C.x, C.y, C.z))
            : Et(ne.x, ne.y, 0);
        }
        for (let ue = 1; ue <= d; ue++) {
          for (let ne = 0; ne < G; ne++) {
            let _e = p ? W(k[ne], fe[ne], pe) : k[ne];
            T
              ? (P.copy(b.normals[ue]).multiplyScalar(_e.x),
                R.copy(b.binormals[ue]).multiplyScalar(_e.y),
                C.copy(M[ue]).add(P).add(R),
                Et(C.x, C.y, C.z))
              : Et(_e.x, _e.y, h / d * ue);
          }
        }
        for (let ue = _ - 1; ue >= 0; ue--) {
          let ne = ue / _,
            _e = g * Math.cos(ne * Math.PI / 2),
            Fe = y * Math.sin(ne * Math.PI / 2) + v;
          for (let Ae = 0, et = V.length; Ae < et; Ae++) {
            let We = W(V[Ae], X[Ae], Fe);
            Et(We.x, We.y, h + _e);
          }
          for (let Ae = 0, et = z.length; Ae < et; Ae++) {
            let We = z[Ae];
            ae = $[Ae];
            for (let Ve = 0, Tt = We.length; Ve < Tt; Ve++) {
              let Nt = W(We[Ve], ae[Ve], Fe);
              T
                ? Et(Nt.x, Nt.y + M[d - 1].y, M[d - 1].x + _e)
                : Et(Nt.x, Nt.y, h + _e);
            }
          }
        }
        Pe(), Oe();
        function Pe() {
          let ue = i.length / 3;
          if (p) {
            let ne = 0, _e = G * ne;
            for (let Fe = 0; Fe < re; Fe++) {
              let Ae = le[Fe];
              $e(Ae[2] + _e, Ae[1] + _e, Ae[0] + _e);
            }
            ne = d + _ * 2, _e = G * ne;
            for (let Fe = 0; Fe < re; Fe++) {
              let Ae = le[Fe];
              $e(Ae[0] + _e, Ae[1] + _e, Ae[2] + _e);
            }
          } else {
            for (let ne = 0; ne < re; ne++) {
              let _e = le[ne];
              $e(_e[2], _e[1], _e[0]);
            }
            for (let ne = 0; ne < re; ne++) {
              let _e = le[ne];
              $e(_e[0] + G * d, _e[1] + G * d, _e[2] + G * d);
            }
          }
          r.addGroup(ue, i.length / 3 - ue, 0);
        }
        function Oe() {
          let ue = i.length / 3, ne = 0;
          oe(V, ne), ne += V.length;
          for (let _e = 0, Fe = z.length; _e < Fe; _e++) {
            let Ae = z[_e];
            oe(Ae, ne), ne += Ae.length;
          }
          r.addGroup(ue, i.length / 3 - ue, 1);
        }
        function oe(ue, ne) {
          let _e = ue.length;
          for (; --_e >= 0;) {
            let Fe = _e, Ae = _e - 1;
            Ae < 0 && (Ae = ue.length - 1);
            for (let et = 0, We = d + _ * 2; et < We; et++) {
              let Ve = G * et,
                Tt = G * (et + 1),
                Nt = ne + Fe + Ve,
                O = ne + Ae + Ve,
                N = ne + Ae + Tt,
                J = ne + Fe + Tt;
              Ze(Nt, O, N, J);
            }
          }
        }
        function Et(ue, ne, _e) {
          u.push(ue), u.push(ne), u.push(_e);
        }
        function $e(ue, ne, _e) {
          Se(ue), Se(ne), Se(_e);
          let Fe = i.length / 3,
            Ae = w.generateTopUV(r, i, Fe - 3, Fe - 2, Fe - 1);
          je(Ae[0]), je(Ae[1]), je(Ae[2]);
        }
        function Ze(ue, ne, _e, Fe) {
          Se(ue), Se(ne), Se(Fe), Se(ne), Se(_e), Se(Fe);
          let Ae = i.length / 3,
            et = w.generateSideWallUV(r, i, Ae - 6, Ae - 3, Ae - 2, Ae - 1);
          je(et[0]), je(et[1]), je(et[3]), je(et[1]), je(et[2]), je(et[3]);
        }
        function Se(ue) {
          i.push(u[ue * 3 + 0]), i.push(u[ue * 3 + 1]), i.push(u[ue * 3 + 2]);
        }
        function je(ue) {
          s.push(ue.x), s.push(ue.y);
        }
      }
    }
    toJSON() {
      let e = super.toJSON(),
        t = this.parameters.shapes,
        r = this.parameters.options;
      return E4(t, r, e);
    }
    static fromJSON(e, t) {
      let r = [];
      for (let s = 0, o = e.shapes.length; s < o; s++) {
        let a = t[e.shapes[s]];
        r.push(a);
      }
      let i = e.options.extrudePath;
      return i !== void 0 &&
        (e.options.extrudePath = new B_[i.type]().fromJSON(i)),
        new ac(r, e.options);
    }
  },
  M4 = {
    generateTopUV: function (n, e, t, r, i) {
      let s = e[t * 3],
        o = e[t * 3 + 1],
        a = e[r * 3],
        u = e[r * 3 + 1],
        f = e[i * 3],
        d = e[i * 3 + 1];
      return [new se(s, o), new se(a, u), new se(f, d)];
    },
    generateSideWallUV: function (n, e, t, r, i, s) {
      let o = e[t * 3],
        a = e[t * 3 + 1],
        u = e[t * 3 + 2],
        f = e[r * 3],
        d = e[r * 3 + 1],
        h = e[r * 3 + 2],
        p = e[i * 3],
        g = e[i * 3 + 1],
        y = e[i * 3 + 2],
        v = e[s * 3],
        _ = e[s * 3 + 1],
        S = e[s * 3 + 2];
      return Math.abs(a - d) < Math.abs(o - f)
        ? [
          new se(o, 1 - u),
          new se(f, 1 - h),
          new se(p, 1 - y),
          new se(v, 1 - S),
        ]
        : [
          new se(a, 1 - u),
          new se(d, 1 - h),
          new se(g, 1 - y),
          new se(_, 1 - S),
        ];
    },
  };
function E4(n, e, t) {
  if (t.shapes = [], Array.isArray(n)) {
    for (let r = 0, i = n.length; r < i; r++) {
      let s = n[r];
      t.shapes.push(s.uuid);
    }
  } else t.shapes.push(n.uuid);
  return t.options = Object.assign({}, e),
    e.extrudePath !== void 0 &&
    (t.options.extrudePath = e.extrudePath.toJSON()),
    t;
}
var lc = class extends Ss {
    constructor(e = 1, t = 0) {
      let r = (1 + Math.sqrt(5)) / 2,
        i = [
          -1,
          r,
          0,
          1,
          r,
          0,
          -1,
          -r,
          0,
          1,
          -r,
          0,
          0,
          -1,
          r,
          0,
          1,
          r,
          0,
          -1,
          -r,
          0,
          1,
          -r,
          r,
          0,
          -1,
          r,
          0,
          1,
          -r,
          0,
          -1,
          -r,
          0,
          1,
        ],
        s = [
          0,
          11,
          5,
          0,
          5,
          1,
          0,
          1,
          7,
          0,
          7,
          10,
          0,
          10,
          11,
          1,
          5,
          9,
          5,
          11,
          4,
          11,
          10,
          2,
          10,
          7,
          6,
          7,
          1,
          8,
          3,
          9,
          4,
          3,
          4,
          2,
          3,
          2,
          6,
          3,
          6,
          8,
          3,
          8,
          9,
          4,
          9,
          5,
          2,
          4,
          11,
          6,
          2,
          10,
          8,
          6,
          7,
          9,
          8,
          1,
        ];
      super(i, s, e, t);
      this.type = "IcosahedronGeometry",
        this.parameters = { radius: e, detail: t };
    }
    static fromJSON(e) {
      return new lc(e.radius, e.detail);
    }
  },
  _l = class extends Ss {
    constructor(e = 1, t = 0) {
      let r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
        i = [
          0,
          2,
          4,
          0,
          4,
          3,
          0,
          3,
          5,
          0,
          5,
          2,
          1,
          2,
          5,
          1,
          5,
          3,
          1,
          3,
          4,
          1,
          4,
          2,
        ];
      super(r, i, e, t);
      this.type = "OctahedronGeometry",
        this.parameters = { radius: e, detail: t };
    }
    static fromJSON(e) {
      return new _l(e.radius, e.detail);
    }
  },
  uc = class extends Ye {
    constructor(e = .5, t = 1, r = 8, i = 1, s = 0, o = Math.PI * 2) {
      super();
      this.type = "RingGeometry",
        this.parameters = {
          innerRadius: e,
          outerRadius: t,
          thetaSegments: r,
          phiSegments: i,
          thetaStart: s,
          thetaLength: o,
        },
        r = Math.max(3, r),
        i = Math.max(1, i);
      let a = [],
        u = [],
        f = [],
        d = [],
        h = e,
        p = (t - e) / i,
        g = new I(),
        y = new se();
      for (let v = 0; v <= i; v++) {
        for (let _ = 0; _ <= r; _++) {
          let S = s + _ / r * o;
          g.x = h * Math.cos(S),
            g.y = h * Math.sin(S),
            u.push(g.x, g.y, g.z),
            f.push(0, 0, 1),
            y.x = (g.x / t + 1) / 2,
            y.y = (g.y / t + 1) / 2,
            d.push(y.x, y.y);
        }
        h += p;
      }
      for (let v = 0; v < i; v++) {
        let _ = v * (r + 1);
        for (let S = 0; S < r; S++) {
          let w = S + _, M = w, T = w + r + 1, b = w + r + 2, R = w + 1;
          a.push(M, T, R), a.push(T, b, R);
        }
      }
      this.setIndex(a),
        this.setAttribute("position", new ke(u, 3)),
        this.setAttribute("normal", new ke(f, 3)),
        this.setAttribute("uv", new ke(d, 2));
    }
    static fromJSON(e) {
      return new uc(
        e.innerRadius,
        e.outerRadius,
        e.thetaSegments,
        e.phiSegments,
        e.thetaStart,
        e.thetaLength,
      );
    }
  },
  cc = class extends Ye {
    constructor(
      e = new ca([new se(0, .5), new se(-.5, -.5), new se(.5, -.5)]),
      t = 12,
    ) {
      super();
      this.type = "ShapeGeometry",
        this.parameters = { shapes: e, curveSegments: t };
      let r = [], i = [], s = [], o = [], a = 0, u = 0;
      if (Array.isArray(e) === !1) f(e);
      else {for (let d = 0; d < e.length; d++) {
          f(e[d]), this.addGroup(a, u, d), a += u, u = 0;
        }}
      this.setIndex(r),
        this.setAttribute("position", new ke(i, 3)),
        this.setAttribute("normal", new ke(s, 3)),
        this.setAttribute("uv", new ke(o, 2));
      function f(d) {
        let h = i.length / 3, p = d.extractPoints(t), g = p.shape, y = p.holes;
        es.isClockWise(g) === !1 && (g = g.reverse());
        for (let _ = 0, S = y.length; _ < S; _++) {
          let w = y[_];
          es.isClockWise(w) === !0 && (y[_] = w.reverse());
        }
        let v = es.triangulateShape(g, y);
        for (let _ = 0, S = y.length; _ < S; _++) {
          let w = y[_];
          g = g.concat(w);
        }
        for (let _ = 0, S = g.length; _ < S; _++) {
          let w = g[_];
          i.push(w.x, w.y, 0), s.push(0, 0, 1), o.push(w.x, w.y);
        }
        for (let _ = 0, S = v.length; _ < S; _++) {
          let w = v[_], M = w[0] + h, T = w[1] + h, b = w[2] + h;
          r.push(M, T, b), u += 3;
        }
      }
    }
    toJSON() {
      let e = super.toJSON(), t = this.parameters.shapes;
      return T4(t, e);
    }
    static fromJSON(e, t) {
      let r = [];
      for (let i = 0, s = e.shapes.length; i < s; i++) {
        let o = t[e.shapes[i]];
        r.push(o);
      }
      return new cc(r, e.curveSegments);
    }
  };
function T4(n, e) {
  if (e.shapes = [], Array.isArray(n)) {
    for (let t = 0, r = n.length; t < r; t++) {
      let i = n[t];
      e.shapes.push(i.uuid);
    }
  } else e.shapes.push(n.uuid);
  return e;
}
var no = class extends Ye {
    constructor(
      e = 1,
      t = 32,
      r = 16,
      i = 0,
      s = Math.PI * 2,
      o = 0,
      a = Math.PI,
    ) {
      super();
      this.type = "SphereGeometry",
        this.parameters = {
          radius: e,
          widthSegments: t,
          heightSegments: r,
          phiStart: i,
          phiLength: s,
          thetaStart: o,
          thetaLength: a,
        },
        t = Math.max(3, Math.floor(t)),
        r = Math.max(2, Math.floor(r));
      let u = Math.min(o + a, Math.PI),
        f = 0,
        d = [],
        h = new I(),
        p = new I(),
        g = [],
        y = [],
        v = [],
        _ = [];
      for (let S = 0; S <= r; S++) {
        let w = [], M = S / r, T = 0;
        S == 0 && o == 0 ? T = .5 / t : S == r && u == Math.PI && (T = -.5 / t);
        for (let b = 0; b <= t; b++) {
          let R = b / t;
          h.x = -e * Math.cos(i + R * s) * Math.sin(o + M * a),
            h.y = e * Math.cos(o + M * a),
            h.z = e * Math.sin(i + R * s) * Math.sin(o + M * a),
            y.push(h.x, h.y, h.z),
            p.copy(h).normalize(),
            v.push(p.x, p.y, p.z),
            _.push(R + T, 1 - M),
            w.push(f++);
        }
        d.push(w);
      }
      for (let S = 0; S < r; S++) {
        for (let w = 0; w < t; w++) {
          let M = d[S][w + 1],
            T = d[S][w],
            b = d[S + 1][w],
            R = d[S + 1][w + 1];
          (S !== 0 || o > 0) && g.push(M, T, R),
            (S !== r - 1 || u < Math.PI) && g.push(T, b, R);
        }
      }
      this.setIndex(g),
        this.setAttribute("position", new ke(y, 3)),
        this.setAttribute("normal", new ke(v, 3)),
        this.setAttribute("uv", new ke(_, 2));
    }
    static fromJSON(e) {
      return new no(
        e.radius,
        e.widthSegments,
        e.heightSegments,
        e.phiStart,
        e.phiLength,
        e.thetaStart,
        e.thetaLength,
      );
    }
  },
  fc = class extends Ss {
    constructor(e = 1, t = 0) {
      let r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
        i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
      super(r, i, e, t);
      this.type = "TetrahedronGeometry",
        this.parameters = { radius: e, detail: t };
    }
    static fromJSON(e) {
      return new fc(e.radius, e.detail);
    }
  },
  dc = class extends Ye {
    constructor(e = 1, t = .4, r = 8, i = 6, s = Math.PI * 2) {
      super();
      this.type = "TorusGeometry",
        this.parameters = {
          radius: e,
          tube: t,
          radialSegments: r,
          tubularSegments: i,
          arc: s,
        },
        r = Math.floor(r),
        i = Math.floor(i);
      let o = [], a = [], u = [], f = [], d = new I(), h = new I(), p = new I();
      for (let g = 0; g <= r; g++) {
        for (let y = 0; y <= i; y++) {
          let v = y / i * s, _ = g / r * Math.PI * 2;
          h.x = (e + t * Math.cos(_)) * Math.cos(v),
            h.y = (e + t * Math.cos(_)) * Math.sin(v),
            h.z = t * Math.sin(_),
            a.push(h.x, h.y, h.z),
            d.x = e * Math.cos(v),
            d.y = e * Math.sin(v),
            p.subVectors(h, d).normalize(),
            u.push(p.x, p.y, p.z),
            f.push(y / i),
            f.push(g / r);
        }
      }
      for (let g = 1; g <= r; g++) {
        for (let y = 1; y <= i; y++) {
          let v = (i + 1) * g + y - 1,
            _ = (i + 1) * (g - 1) + y - 1,
            S = (i + 1) * (g - 1) + y,
            w = (i + 1) * g + y;
          o.push(v, _, w), o.push(_, S, w);
        }
      }
      this.setIndex(o),
        this.setAttribute("position", new ke(a, 3)),
        this.setAttribute("normal", new ke(u, 3)),
        this.setAttribute("uv", new ke(f, 2));
    }
    static fromJSON(e) {
      return new dc(
        e.radius,
        e.tube,
        e.radialSegments,
        e.tubularSegments,
        e.arc,
      );
    }
  },
  hc = class extends Ye {
    constructor(e = 1, t = .4, r = 64, i = 8, s = 2, o = 3) {
      super();
      this.type = "TorusKnotGeometry",
        this.parameters = {
          radius: e,
          tube: t,
          tubularSegments: r,
          radialSegments: i,
          p: s,
          q: o,
        },
        r = Math.floor(r),
        i = Math.floor(i);
      let a = [],
        u = [],
        f = [],
        d = [],
        h = new I(),
        p = new I(),
        g = new I(),
        y = new I(),
        v = new I(),
        _ = new I(),
        S = new I();
      for (let M = 0; M <= r; ++M) {
        let T = M / r * s * Math.PI * 2;
        w(T, s, o, e, g),
          w(T + .01, s, o, e, y),
          _.subVectors(y, g),
          S.addVectors(y, g),
          v.crossVectors(_, S),
          S.crossVectors(v, _),
          v.normalize(),
          S.normalize();
        for (let b = 0; b <= i; ++b) {
          let R = b / i * Math.PI * 2,
            P = -t * Math.cos(R),
            C = t * Math.sin(R);
          h.x = g.x + (P * S.x + C * v.x),
            h.y = g.y + (P * S.y + C * v.y),
            h.z = g.z + (P * S.z + C * v.z),
            u.push(h.x, h.y, h.z),
            p.subVectors(h, g).normalize(),
            f.push(p.x, p.y, p.z),
            d.push(M / r),
            d.push(b / i);
        }
      }
      for (let M = 1; M <= r; M++) {
        for (let T = 1; T <= i; T++) {
          let b = (i + 1) * (M - 1) + (T - 1),
            R = (i + 1) * M + (T - 1),
            P = (i + 1) * M + T,
            C = (i + 1) * (M - 1) + T;
          a.push(b, R, C), a.push(R, P, C);
        }
      }
      this.setIndex(a),
        this.setAttribute("position", new ke(u, 3)),
        this.setAttribute("normal", new ke(f, 3)),
        this.setAttribute("uv", new ke(d, 2));
      function w(M, T, b, R, P) {
        let C = Math.cos(M), L = Math.sin(M), k = b / T * M, z = Math.cos(k);
        P.x = R * (2 + z) * .5 * C,
          P.y = R * (2 + z) * L * .5,
          P.z = R * Math.sin(k) * .5;
      }
    }
    static fromJSON(e) {
      return new hc(
        e.radius,
        e.tube,
        e.tubularSegments,
        e.radialSegments,
        e.p,
        e.q,
      );
    }
  },
  pc = class extends Ye {
    constructor(
      e = new Zm(new I(-1, -1, 0), new I(-1, 1, 0), new I(1, 1, 0)),
      t = 64,
      r = 1,
      i = 8,
      s = !1,
    ) {
      super();
      this.type = "TubeGeometry",
        this.parameters = {
          path: e,
          tubularSegments: t,
          radius: r,
          radialSegments: i,
          closed: s,
        };
      let o = e.computeFrenetFrames(t, s);
      this.tangents = o.tangents,
        this.normals = o.normals,
        this.binormals = o.binormals;
      let a = new I(),
        u = new I(),
        f = new se(),
        d = new I(),
        h = [],
        p = [],
        g = [],
        y = [];
      v(),
        this.setIndex(y),
        this.setAttribute("position", new ke(h, 3)),
        this.setAttribute("normal", new ke(p, 3)),
        this.setAttribute("uv", new ke(g, 2));
      function v() {
        for (let M = 0; M < t; M++) _(M);
        _(s === !1 ? t : 0), w(), S();
      }
      function _(M) {
        d = e.getPointAt(M / t, d);
        let T = o.normals[M], b = o.binormals[M];
        for (let R = 0; R <= i; R++) {
          let P = R / i * Math.PI * 2, C = Math.sin(P), L = -Math.cos(P);
          u.x = L * T.x + C * b.x,
            u.y = L * T.y + C * b.y,
            u.z = L * T.z + C * b.z,
            u.normalize(),
            p.push(u.x, u.y, u.z),
            a.x = d.x + r * u.x,
            a.y = d.y + r * u.y,
            a.z = d.z + r * u.z,
            h.push(a.x, a.y, a.z);
        }
      }
      function S() {
        for (let M = 1; M <= t; M++) {
          for (let T = 1; T <= i; T++) {
            let b = (i + 1) * (M - 1) + (T - 1),
              R = (i + 1) * M + (T - 1),
              P = (i + 1) * M + T,
              C = (i + 1) * (M - 1) + T;
            y.push(b, R, C), y.push(R, P, C);
          }
        }
      }
      function w() {
        for (let M = 0; M <= t; M++) {
          for (let T = 0; T <= i; T++) {
            f.x = M / t, f.y = T / i, g.push(f.x, f.y);
          }
        }
      }
    }
    toJSON() {
      let e = super.toJSON();
      return e.path = this.parameters.path.toJSON(), e;
    }
    static fromJSON(e) {
      return new pc(
        new B_[e.path.type]().fromJSON(e.path),
        e.tubularSegments,
        e.radius,
        e.radialSegments,
        e.closed,
      );
    }
  },
  W_ = class extends Ye {
    constructor(e = null) {
      super();
      if (
        this.type = "WireframeGeometry",
          this.parameters = { geometry: e },
          e !== null
      ) {
        let t = [], r = new Set(), i = new I(), s = new I();
        if (e.index !== null) {
          let o = e.attributes.position, a = e.index, u = e.groups;
          u.length === 0 &&
            (u = [{ start: 0, count: a.count, materialIndex: 0 }]);
          for (let f = 0, d = u.length; f < d; ++f) {
            let h = u[f], p = h.start, g = h.count;
            for (let y = p, v = p + g; y < v; y += 3) {
              for (let _ = 0; _ < 3; _++) {
                let S = a.getX(y + _), w = a.getX(y + (_ + 1) % 3);
                i.fromBufferAttribute(o, S),
                  s.fromBufferAttribute(o, w),
                  Zb(i, s, r) === !0 &&
                  (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z));
              }
            }
          }
        } else {
          let o = e.attributes.position;
          for (let a = 0, u = o.count / 3; a < u; a++) {
            for (let f = 0; f < 3; f++) {
              let d = 3 * a + f, h = 3 * a + (f + 1) % 3;
              i.fromBufferAttribute(o, d),
                s.fromBufferAttribute(o, h),
                Zb(i, s, r) === !0 &&
                (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z));
            }
          }
        }
        this.setAttribute("position", new ke(t, 3));
      }
    }
  };
function Zb(n, e, t) {
  let r = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
    i = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(r) === !0 || t.has(i) === !0 ? !1 : (t.add(r), t.add(i), !0);
}
var Kb = Object.freeze({
    __proto__: null,
    BoxGeometry: ei,
    BoxBufferGeometry: ei,
    CapsuleGeometry: nc,
    CapsuleBufferGeometry: nc,
    CircleGeometry: rc,
    CircleBufferGeometry: rc,
    ConeGeometry: ic,
    ConeBufferGeometry: ic,
    CylinderGeometry: ua,
    CylinderBufferGeometry: ua,
    DodecahedronGeometry: sc,
    DodecahedronBufferGeometry: sc,
    EdgesGeometry: H_,
    ExtrudeGeometry: ac,
    ExtrudeBufferGeometry: ac,
    IcosahedronGeometry: lc,
    IcosahedronBufferGeometry: lc,
    LatheGeometry: xl,
    LatheBufferGeometry: xl,
    OctahedronGeometry: _l,
    OctahedronBufferGeometry: _l,
    PlaneGeometry: cl,
    PlaneBufferGeometry: cl,
    PolyhedronGeometry: Ss,
    PolyhedronBufferGeometry: Ss,
    RingGeometry: uc,
    RingBufferGeometry: uc,
    ShapeGeometry: cc,
    ShapeBufferGeometry: cc,
    SphereGeometry: no,
    SphereBufferGeometry: no,
    TetrahedronGeometry: fc,
    TetrahedronBufferGeometry: fc,
    TorusGeometry: dc,
    TorusBufferGeometry: dc,
    TorusKnotGeometry: hc,
    TorusKnotBufferGeometry: hc,
    TubeGeometry: pc,
    TubeBufferGeometry: pc,
    WireframeGeometry: W_,
  }),
  X_ = class extends $t {
    constructor(e) {
      super();
      this.isShadowMaterial = !0,
        this.type = "ShadowMaterial",
        this.color = new ve(0),
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
    }
  },
  q_ = class extends sr {
    constructor(e) {
      super(e);
      this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
    }
  },
  In = class extends $t {
    constructor(e) {
      super();
      this.isMeshStandardMaterial = !0,
        this.defines = { STANDARD: "" },
        this.type = "MeshStandardMaterial",
        this.color = new ve(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new ve(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Zs,
        this.normalScale = new se(1, 1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e);
    }
    copy(e) {
      return super.copy(e),
        this.defines = { STANDARD: "" },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this;
    }
  },
  Xn = class extends In {
    constructor(e) {
      super();
      this.isMeshPhysicalMaterial = !0,
        this.defines = { STANDARD: "", PHYSICAL: "" },
        this.type = "MeshPhysicalMaterial",
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new se(1, 1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
          get: function () {
            return yn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
          },
          set: function (t) {
            this.ior = (1 + .4 * t) / (1 - .4 * t);
          },
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new ve(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 0,
        this.attenuationColor = new ve(1, 1, 1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new ve(1, 1, 1),
        this.specularColorMap = null,
        this._sheen = 0,
        this._clearcoat = 0,
        this._iridescence = 0,
        this._transmission = 0,
        this.setValues(e);
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(e) {
      this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(e) {
      this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
    }
    get iridescence() {
      return this._iridescence;
    }
    set iridescence(e) {
      this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(e) {
      this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
    }
    copy(e) {
      return super.copy(e),
        this.defines = { STANDARD: "", PHYSICAL: "" },
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.ior = e.ior,
        this.iridescence = e.iridescence,
        this.iridescenceMap = e.iridescenceMap,
        this.iridescenceIOR = e.iridescenceIOR,
        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this;
    }
  },
  ro = class extends $t {
    constructor(e) {
      super();
      this.isMeshPhongMaterial = !0,
        this.type = "MeshPhongMaterial",
        this.color = new ve(16777215),
        this.specular = new ve(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new ve(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Zs,
        this.normalScale = new se(1, 1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Bf,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e);
    }
    copy(e) {
      return super.copy(e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this;
    }
  },
  Sl = class extends $t {
    constructor(e) {
      super();
      this.isMeshToonMaterial = !0,
        this.defines = { TOON: "" },
        this.type = "MeshToonMaterial",
        this.color = new ve(16777215),
        this.map = null,
        this.gradientMap = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new ve(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Zs,
        this.normalScale = new se(1, 1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e);
    }
    copy(e) {
      return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.gradientMap = e.gradientMap,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this;
    }
  },
  mc = class extends $t {
    constructor(e) {
      super();
      this.isMeshNormalMaterial = !0,
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Zs,
        this.normalScale = new se(1, 1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.flatShading = !1,
        this.setValues(e);
    }
    copy(e) {
      return super.copy(e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.flatShading = e.flatShading,
        this;
    }
  },
  wl = class extends $t {
    constructor(e) {
      super();
      this.isMeshLambertMaterial = !0,
        this.type = "MeshLambertMaterial",
        this.color = new ve(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new ve(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Bf,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e);
    }
    copy(e) {
      return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this;
    }
  },
  hd = class extends $t {
    constructor(e) {
      super();
      this.isMeshMatcapMaterial = !0,
        this.defines = { MATCAP: "" },
        this.type = "MeshMatcapMaterial",
        this.color = new ve(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Zs,
        this.normalScale = new se(1, 1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e);
    }
    copy(e) {
      return super.copy(e),
        this.defines = { MATCAP: "" },
        this.color.copy(e.color),
        this.matcap = e.matcap,
        this.map = e.map,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this;
    }
  },
  Y_ = class extends Un {
    constructor(e) {
      super();
      this.isLineDashedMaterial = !0,
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(e);
    }
    copy(e) {
      return super.copy(e),
        this.scale = e.scale,
        this.dashSize = e.dashSize,
        this.gapSize = e.gapSize,
        this;
    }
  },
  Wt = {
    arraySlice: function (n, e, t) {
      return Wt.isTypedArray(n)
        ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length))
        : n.slice(e, t);
    },
    convertArray: function (n, e, t) {
      return !n || !t && n.constructor === e
        ? n
        : typeof e.BYTES_PER_ELEMENT == "number"
        ? new e(n)
        : Array.prototype.slice.call(n);
    },
    isTypedArray: function (n) {
      return ArrayBuffer.isView(n) && !(n instanceof DataView);
    },
    getKeyframeOrder: function (n) {
      function e(i, s) {
        return n[i] - n[s];
      }
      let t = n.length, r = new Array(t);
      for (let i = 0; i !== t; ++i) r[i] = i;
      return r.sort(e), r;
    },
    sortedArray: function (n, e, t) {
      let r = n.length, i = new n.constructor(r);
      for (let s = 0, o = 0; o !== r; ++s) {
        let a = t[s] * e;
        for (let u = 0; u !== e; ++u) i[o++] = n[a + u];
      }
      return i;
    },
    flattenJSON: function (n, e, t, r) {
      let i = 1, s = n[0];
      for (; s !== void 0 && s[r] === void 0;) s = n[i++];
      if (s === void 0) return;
      let o = s[r];
      if (o !== void 0) {
        if (Array.isArray(o)) {
          do o = s[r],
            o !== void 0 && (e.push(s.time), t.push.apply(t, o)),
            s = n[i++]; while (s !== void 0);
        } else if (o.toArray !== void 0) {
          do o = s[r],
            o !== void 0 && (e.push(s.time), o.toArray(t, t.length)),
            s = n[i++]; while (s !== void 0);
        } else {do o = s[r],
            o !== void 0 && (e.push(s.time), t.push(o)),
            s = n[i++]; while (s !== void 0);}
      }
    },
    subclip: function (n, e, t, r, i = 30) {
      let s = n.clone();
      s.name = e;
      let o = [];
      for (let u = 0; u < s.tracks.length; ++u) {
        let f = s.tracks[u], d = f.getValueSize(), h = [], p = [];
        for (let g = 0; g < f.times.length; ++g) {
          let y = f.times[g] * i;
          if (!(y < t || y >= r)) {
            h.push(f.times[g]);
            for (let v = 0; v < d; ++v) p.push(f.values[g * d + v]);
          }
        }
        h.length !== 0 &&
          (f.times = Wt.convertArray(h, f.times.constructor),
            f.values = Wt.convertArray(p, f.values.constructor),
            o.push(f));
      }
      s.tracks = o;
      let a = 1 / 0;
      for (let u = 0; u < s.tracks.length; ++u) {
        a > s.tracks[u].times[0] && (a = s.tracks[u].times[0]);
      }
      for (let u = 0; u < s.tracks.length; ++u) s.tracks[u].shift(-1 * a);
      return s.resetDuration(), s;
    },
    makeClipAdditive: function (n, e = 0, t = n, r = 30) {
      r <= 0 && (r = 30);
      let i = t.tracks.length, s = e / r;
      for (let o = 0; o < i; ++o) {
        let a = t.tracks[o], u = a.ValueTypeName;
        if (u === "bool" || u === "string") continue;
        let f = n.tracks.find(function (S) {
          return S.name === a.name && S.ValueTypeName === u;
        });
        if (f === void 0) continue;
        let d = 0, h = a.getValueSize();
        a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
          (d = h / 3);
        let p = 0, g = f.getValueSize();
        f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
          (p = g / 3);
        let y = a.times.length - 1, v;
        if (s <= a.times[0]) {
          let S = d, w = h - d;
          v = Wt.arraySlice(a.values, S, w);
        } else if (s >= a.times[y]) {
          let S = y * h + d, w = S + h - d;
          v = Wt.arraySlice(a.values, S, w);
        } else {
          let S = a.createInterpolant(), w = d, M = h - d;
          S.evaluate(s), v = Wt.arraySlice(S.resultBuffer, w, M);
        }
        u === "quaternion" &&
          new Pn().fromArray(v).normalize().conjugate().toArray(v);
        let _ = f.times.length;
        for (let S = 0; S < _; ++S) {
          let w = S * g + p;
          if (u === "quaternion") {
            Pn.multiplyQuaternionsFlat(f.values, w, v, 0, f.values, w);
          } else {
            let M = g - p * 2;
            for (let T = 0; T < M; ++T) f.values[w + T] -= v[T];
          }
        }
      }
      return n.blendMode = Ux, n;
    },
  },
  da = class {
    constructor(e, t, r, i) {
      this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = i !== void 0 ? i : new t.constructor(r),
        this.sampleValues = t,
        this.valueSize = r,
        this.settings = null,
        this.DefaultSettings_ = {};
    }
    evaluate(e) {
      let t = this.parameterPositions,
        r = this._cachedIndex,
        i = t[r],
        s = t[r - 1];
      e: {
        t: {
          let o;
          n: {
            r: if (!(e < i)) {
              for (let a = r + 2;;) {
                if (i === void 0) {
                  if (e < s) break r;
                  return r = t.length,
                    this._cachedIndex = r,
                    this.copySampleValue_(r - 1);
                }
                if (r === a) break;
                if (s = i, i = t[++r], e < i) break t;
              }
              o = t.length;
              break n;
            }
            if (!(e >= s)) {
              let a = t[1];
              e < a && (r = 2, s = a);
              for (let u = r - 2;;) {
                if (s === void 0) {
                  return this._cachedIndex = 0, this.copySampleValue_(0);
                }
                if (r === u) break;
                if (i = s, s = t[--r - 1], e >= s) break t;
              }
              o = r, r = 0;
              break n;
            }
            break e;
          }
          for (; r < o;) {
            let a = r + o >>> 1;
            e < t[a] ? o = a : r = a + 1;
          }
          if (i = t[r], s = t[r - 1], s === void 0) {
            return this._cachedIndex = 0, this.copySampleValue_(0);
          }
          if (i === void 0) {
            return r = t.length,
              this._cachedIndex = r,
              this.copySampleValue_(r - 1);
          }
        }
        this._cachedIndex = r, this.intervalChanged_(r, s, i);
      }
      return this.interpolate_(r, s, e, i);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(e) {
      let t = this.resultBuffer,
        r = this.sampleValues,
        i = this.valueSize,
        s = e * i;
      for (let o = 0; o !== i; ++o) t[o] = r[s + o];
      return t;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {}
  },
  Z_ = class extends da {
    constructor(e, t, r, i) {
      super(e, t, r, i);
      this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = { endingStart: nl, endingEnd: nl };
    }
    intervalChanged_(e, t, r) {
      let i = this.parameterPositions, s = e - 2, o = e + 1, a = i[s], u = i[o];
      if (a === void 0) {
        switch (this.getSettings_().endingStart) {
          case rl:
            s = e, a = 2 * t - r;
            break;
          case Hf:
            s = i.length - 2, a = t + i[s] - i[s + 1];
            break;
          default:
            s = e, a = r;
        }
      }
      if (u === void 0) {
        switch (this.getSettings_().endingEnd) {
          case rl:
            o = e, u = 2 * r - t;
            break;
          case Hf:
            o = 1, u = r + i[1] - i[0];
            break;
          default:
            o = e - 1, u = t;
        }
      }
      let f = (r - t) * .5, d = this.valueSize;
      this._weightPrev = f / (t - a),
        this._weightNext = f / (u - r),
        this._offsetPrev = s * d,
        this._offsetNext = o * d;
    }
    interpolate_(e, t, r, i) {
      let s = this.resultBuffer,
        o = this.sampleValues,
        a = this.valueSize,
        u = e * a,
        f = u - a,
        d = this._offsetPrev,
        h = this._offsetNext,
        p = this._weightPrev,
        g = this._weightNext,
        y = (r - t) / (i - t),
        v = y * y,
        _ = v * y,
        S = -p * _ + 2 * p * v - p * y,
        w = (1 + p) * _ + (-1.5 - 2 * p) * v + (-.5 + p) * y + 1,
        M = (-1 - g) * _ + (1.5 + g) * v + .5 * y,
        T = g * _ - g * v;
      for (let b = 0; b !== a; ++b) {
        s[b] = S * o[d + b] + w * o[f + b] + M * o[u + b] + T * o[h + b];
      }
      return s;
    }
  },
  rg = class extends da {
    constructor(e, t, r, i) {
      super(e, t, r, i);
    }
    interpolate_(e, t, r, i) {
      let s = this.resultBuffer,
        o = this.sampleValues,
        a = this.valueSize,
        u = e * a,
        f = u - a,
        d = (r - t) / (i - t),
        h = 1 - d;
      for (let p = 0; p !== a; ++p) s[p] = o[f + p] * h + o[u + p] * d;
      return s;
    }
  },
  K_ = class extends da {
    constructor(e, t, r, i) {
      super(e, t, r, i);
    }
    interpolate_(e) {
      return this.copySampleValue_(e - 1);
    }
  },
  bi = class {
    constructor(e, t, r, i) {
      if (e === void 0) {
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      }
      if (t === void 0 || t.length === 0) {
        throw new Error(
          "THREE.KeyframeTrack: no keyframes in track named " + e,
        );
      }
      this.name = e,
        this.times = Wt.convertArray(t, this.TimeBufferType),
        this.values = Wt.convertArray(r, this.ValueBufferType),
        this.setInterpolation(i || this.DefaultInterpolation);
    }
    static toJSON(e) {
      let t = e.constructor, r;
      if (t.toJSON !== this.toJSON) r = t.toJSON(e);
      else {
        r = {
          name: e.name,
          times: Wt.convertArray(e.times, Array),
          values: Wt.convertArray(e.values, Array),
        };
        let i = e.getInterpolation();
        i !== e.DefaultInterpolation && (r.interpolation = i);
      }
      return r.type = e.ValueTypeName, r;
    }
    InterpolantFactoryMethodDiscrete(e) {
      return new K_(this.times, this.values, this.getValueSize(), e);
    }
    InterpolantFactoryMethodLinear(e) {
      return new rg(this.times, this.values, this.getValueSize(), e);
    }
    InterpolantFactoryMethodSmooth(e) {
      return new Z_(this.times, this.values, this.getValueSize(), e);
    }
    setInterpolation(e) {
      let t;
      switch (e) {
        case qs:
          t = this.InterpolantFactoryMethodDiscrete;
          break;
        case xs:
          t = this.InterpolantFactoryMethodLinear;
          break;
        case tm:
          t = this.InterpolantFactoryMethodSmooth;
          break;
      }
      if (t === void 0) {
        let r = "unsupported interpolation for " + this.ValueTypeName +
          " keyframe track named " + this.name;
        if (this.createInterpolant === void 0) {
          if (e !== this.DefaultInterpolation) {
            this.setInterpolation(this.DefaultInterpolation);
          } else throw new Error(r);
        }
        return console.warn("THREE.KeyframeTrack:", r), this;
      }
      return this.createInterpolant = t, this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return qs;
        case this.InterpolantFactoryMethodLinear:
          return xs;
        case this.InterpolantFactoryMethodSmooth:
          return tm;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(e) {
      if (e !== 0) {
        let t = this.times;
        for (let r = 0, i = t.length; r !== i; ++r) t[r] += e;
      }
      return this;
    }
    scale(e) {
      if (e !== 1) {
        let t = this.times;
        for (let r = 0, i = t.length; r !== i; ++r) t[r] *= e;
      }
      return this;
    }
    trim(e, t) {
      let r = this.times, i = r.length, s = 0, o = i - 1;
      for (; s !== i && r[s] < e;) ++s;
      for (; o !== -1 && r[o] > t;) --o;
      if (++o, s !== 0 || o !== i) {
        s >= o && (o = Math.max(o, 1), s = o - 1);
        let a = this.getValueSize();
        this.times = Wt.arraySlice(r, s, o),
          this.values = Wt.arraySlice(this.values, s * a, o * a);
      }
      return this;
    }
    validate() {
      let e = !0, t = this.getValueSize();
      t - Math.floor(t) != 0 &&
        (console.error(
          "THREE.KeyframeTrack: Invalid value size in track.",
          this,
        ),
          e = !1);
      let r = this.times, i = this.values, s = r.length;
      s === 0 &&
        (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
      let o = null;
      for (let a = 0; a !== s; a++) {
        let u = r[a];
        if (typeof u == "number" && isNaN(u)) {
          console.error(
            "THREE.KeyframeTrack: Time is not a valid number.",
            this,
            a,
            u,
          ), e = !1;
          break;
        }
        if (o !== null && o > u) {
          console.error(
            "THREE.KeyframeTrack: Out of order keys.",
            this,
            a,
            u,
            o,
          ), e = !1;
          break;
        }
        o = u;
      }
      if (i !== void 0 && Wt.isTypedArray(i)) {
        for (let a = 0, u = i.length; a !== u; ++a) {
          let f = i[a];
          if (isNaN(f)) {
            console.error(
              "THREE.KeyframeTrack: Value is not a valid number.",
              this,
              a,
              f,
            ), e = !1;
            break;
          }
        }
      }
      return e;
    }
    optimize() {
      let e = Wt.arraySlice(this.times),
        t = Wt.arraySlice(this.values),
        r = this.getValueSize(),
        i = this.getInterpolation() === tm,
        s = e.length - 1,
        o = 1;
      for (let a = 1; a < s; ++a) {
        let u = !1, f = e[a], d = e[a + 1];
        if (f !== d && (a !== 1 || f !== e[0])) {
          if (i) u = !0;
          else {
            let h = a * r, p = h - r, g = h + r;
            for (let y = 0; y !== r; ++y) {
              let v = t[h + y];
              if (v !== t[p + y] || v !== t[g + y]) {
                u = !0;
                break;
              }
            }
          }
        }
        if (u) {
          if (a !== o) {
            e[o] = e[a];
            let h = a * r, p = o * r;
            for (let g = 0; g !== r; ++g) t[p + g] = t[h + g];
          }
          ++o;
        }
      }
      if (s > 0) {
        e[o] = e[s];
        for (let a = s * r, u = o * r, f = 0; f !== r; ++f) t[u + f] = t[a + f];
        ++o;
      }
      return o !== e.length
        ? (this.times = Wt.arraySlice(e, 0, o),
          this.values = Wt.arraySlice(t, 0, o * r))
        : (this.times = e, this.values = t),
        this;
    }
    clone() {
      let e = Wt.arraySlice(this.times, 0),
        t = Wt.arraySlice(this.values, 0),
        r = this.constructor,
        i = new r(this.name, e, t);
      return i.createInterpolant = this.createInterpolant, i;
    }
  };
bi.prototype.TimeBufferType = Float32Array;
bi.prototype.ValueBufferType = Float32Array;
bi.prototype.DefaultInterpolation = xs;
var ha = class extends bi {};
ha.prototype.ValueTypeName = "bool";
ha.prototype.ValueBufferType = Array;
ha.prototype.DefaultInterpolation = qs;
ha.prototype.InterpolantFactoryMethodLinear = void 0;
ha.prototype.InterpolantFactoryMethodSmooth = void 0;
var ig = class extends bi {};
ig.prototype.ValueTypeName = "color";
var pa = class extends bi {};
pa.prototype.ValueTypeName = "number";
var J_ = class extends da {
    constructor(e, t, r, i) {
      super(e, t, r, i);
    }
    interpolate_(e, t, r, i) {
      let s = this.resultBuffer,
        o = this.sampleValues,
        a = this.valueSize,
        u = (r - t) / (i - t),
        f = e * a;
      for (let d = f + a; f !== d; f += 4) {
        Pn.slerpFlat(s, 0, o, f - a, o, f, u);
      }
      return s;
    }
  },
  ws = class extends bi {
    InterpolantFactoryMethodLinear(e) {
      return new J_(this.times, this.values, this.getValueSize(), e);
    }
  };
ws.prototype.ValueTypeName = "quaternion";
ws.prototype.DefaultInterpolation = xs;
ws.prototype.InterpolantFactoryMethodSmooth = void 0;
var ma = class extends bi {};
ma.prototype.ValueTypeName = "string";
ma.prototype.ValueBufferType = Array;
ma.prototype.DefaultInterpolation = qs;
ma.prototype.InterpolantFactoryMethodLinear = void 0;
ma.prototype.InterpolantFactoryMethodSmooth = void 0;
var ga = class extends bi {};
ga.prototype.ValueTypeName = "vector";
var va = class {
  constructor(e, t = -1, r, i = nm) {
    this.name = e,
      this.tracks = r,
      this.duration = t,
      this.blendMode = i,
      this.uuid = Kr(),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    let t = [], r = e.tracks, i = 1 / (e.fps || 1);
    for (let o = 0, a = r.length; o !== a; ++o) t.push(C4(r[o]).scale(i));
    let s = new this(e.name, e.duration, t, e.blendMode);
    return s.uuid = e.uuid, s;
  }
  static toJSON(e) {
    let t = [],
      r = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, o = r.length; s !== o; ++s) t.push(bi.toJSON(r[s]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, r, i) {
    let s = t.length, o = [];
    for (let a = 0; a < s; a++) {
      let u = [], f = [];
      u.push((a + s - 1) % s, a, (a + 1) % s), f.push(0, 1, 0);
      let d = Wt.getKeyframeOrder(u);
      u = Wt.sortedArray(u, 1, d),
        f = Wt.sortedArray(f, 1, d),
        !i && u[0] === 0 && (u.push(s), f.push(f[0])),
        o.push(
          new pa(".morphTargetInfluences[" + t[a].name + "]", u, f).scale(
            1 / r,
          ),
        );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let r = e;
    if (!Array.isArray(e)) {
      let i = e;
      r = i.geometry && i.geometry.animations || i.animations;
    }
    for (let i = 0; i < r.length; i++) if (r[i].name === t) return r[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, r) {
    let i = {}, s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, u = e.length; a < u; a++) {
      let f = e[a], d = f.name.match(s);
      if (d && d.length > 1) {
        let h = d[1], p = i[h];
        p || (i[h] = p = []), p.push(f);
      }
    }
    let o = [];
    for (let a in i) o.push(this.CreateFromMorphTargetSequence(a, i[a], t, r));
    return o;
  }
  static parseAnimation(e, t) {
    if (!e) {
      return console.error(
        "THREE.AnimationClip: No animation in JSONLoader data.",
      ),
        null;
    }
    let r = function (h, p, g, y, v) {
        if (g.length !== 0) {
          let _ = [], S = [];
          Wt.flattenJSON(g, _, S, y), _.length !== 0 && v.push(new h(p, _, S));
        }
      },
      i = [],
      s = e.name || "default",
      o = e.fps || 30,
      a = e.blendMode,
      u = e.length || -1,
      f = e.hierarchy || [];
    for (let h = 0; h < f.length; h++) {
      let p = f[h].keys;
      if (!(!p || p.length === 0)) {
        if (p[0].morphTargets) {
          let g = {}, y;
          for (y = 0; y < p.length; y++) {
            if (p[y].morphTargets) {
              for (
                let v = 0; v < p[y].morphTargets.length; v++
              ) g[p[y].morphTargets[v]] = -1;
            }
          }
          for (let v in g) {
            let _ = [], S = [];
            for (let w = 0; w !== p[y].morphTargets.length; ++w) {
              let M = p[y];
              _.push(M.time), S.push(M.morphTarget === v ? 1 : 0);
            }
            i.push(new pa(".morphTargetInfluence[" + v + "]", _, S));
          }
          u = g.length * o;
        } else {
          let g = ".bones[" + t[h].name + "]";
          r(ga, g + ".position", p, "pos", i),
            r(ws, g + ".quaternion", p, "rot", i),
            r(ga, g + ".scale", p, "scl", i);
        }
      }
    }
    return i.length === 0 ? null : new this(s, u, i, a);
  }
  resetDuration() {
    let e = this.tracks, t = 0;
    for (let r = 0, i = e.length; r !== i; ++r) {
      let s = this.tracks[r];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++) {
      this.tracks[e].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++) {
      e = e && this.tracks[t].validate();
    }
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    let e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
};
function A4(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return pa;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return ga;
    case "color":
      return ig;
    case "quaternion":
      return ws;
    case "bool":
    case "boolean":
      return ha;
    case "string":
      return ma;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function C4(n) {
  if (n.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  let e = A4(n.type);
  if (n.times === void 0) {
    let t = [], r = [];
    Wt.flattenJSON(n.keys, t, r, "value"), n.times = t, n.values = r;
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation);
}
var Ml = {
    enabled: !1,
    files: {},
    add: function (n, e) {
      this.enabled !== !1 && (this.files[n] = e);
    },
    get: function (n) {
      if (this.enabled !== !1) return this.files[n];
    },
    remove: function (n) {
      delete this.files[n];
    },
    clear: function () {
      this.files = {};
    },
  },
  sg = class {
    constructor(e, t, r) {
      let i = this, s = !1, o = 0, a = 0, u, f = [];
      this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = r,
        this.itemStart = function (d) {
          a++, s === !1 && i.onStart !== void 0 && i.onStart(d, o, a), s = !0;
        },
        this.itemEnd = function (d) {
          o++,
            i.onProgress !== void 0 && i.onProgress(d, o, a),
            o === a && (s = !1, i.onLoad !== void 0 && i.onLoad());
        },
        this.itemError = function (d) {
          i.onError !== void 0 && i.onError(d);
        },
        this.resolveURL = function (d) {
          return u ? u(d) : d;
        },
        this.setURLModifier = function (d) {
          return u = d, this;
        },
        this.addHandler = function (d, h) {
          return f.push(d, h), this;
        },
        this.removeHandler = function (d) {
          let h = f.indexOf(d);
          return h !== -1 && f.splice(h, 2), this;
        },
        this.getHandler = function (d) {
          for (let h = 0, p = f.length; h < p; h += 2) {
            let g = f[h], y = f[h + 1];
            if (g.global && (g.lastIndex = 0), g.test(d)) return y;
          }
          return null;
        };
    }
  },
  Jb = new sg(),
  or = class {
    constructor(e) {
      this.manager = e !== void 0 ? e : Jb,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {};
    }
    load() {}
    loadAsync(e, t) {
      let r = this;
      return new Promise(function (i, s) {
        r.load(e, i, t, s);
      });
    }
    parse() {}
    setCrossOrigin(e) {
      return this.crossOrigin = e, this;
    }
    setWithCredentials(e) {
      return this.withCredentials = e, this;
    }
    setPath(e) {
      return this.path = e, this;
    }
    setResourcePath(e) {
      return this.resourcePath = e, this;
    }
    setRequestHeader(e) {
      return this.requestHeader = e, this;
    }
  },
  io = {},
  ni = class extends or {
    constructor(e) {
      super(e);
    }
    load(e, t, r, i) {
      e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
      let s = Ml.get(e);
      if (s !== void 0) {
        return this.manager.itemStart(e),
          setTimeout(() => {
            t && t(s), this.manager.itemEnd(e);
          }, 0),
          s;
      }
      if (io[e] !== void 0) {
        io[e].push({ onLoad: t, onProgress: r, onError: i });
        return;
      }
      io[e] = [], io[e].push({ onLoad: t, onProgress: r, onError: i });
      let o = new Request(e, {
          headers: new Headers(this.requestHeader),
          credentials: this.withCredentials ? "include" : "same-origin",
        }),
        a = this.mimeType,
        u = this.responseType;
      fetch(o).then((f) => {
        if (f.status === 200 || f.status === 0) {
          if (
            f.status === 0 &&
            console.warn("THREE.FileLoader: HTTP Status 0 received."),
              typeof ReadableStream == "undefined" || f.body === void 0 ||
              f.body.getReader === void 0
          ) return f;
          let d = io[e],
            h = f.body.getReader(),
            p = f.headers.get("Content-Length"),
            g = p ? parseInt(p) : 0,
            y = g !== 0,
            v = 0,
            _ = new ReadableStream({
              start(S) {
                w();
                function w() {
                  h.read().then(({ done: M, value: T }) => {
                    if (M) S.close();
                    else {
                      v += T.byteLength;
                      let b = new ProgressEvent("progress", {
                        lengthComputable: y,
                        loaded: v,
                        total: g,
                      });
                      for (let R = 0, P = d.length; R < P; R++) {
                        let C = d[R];
                        C.onProgress && C.onProgress(b);
                      }
                      S.enqueue(T), w();
                    }
                  });
                }
              },
            });
          return new Response(_);
        } else {throw Error(
            `fetch for "${f.url}" responded with ${f.status}: ${f.statusText}`,
          );}
      }).then((f) => {
        switch (u) {
          case "arraybuffer":
            return f.arrayBuffer();
          case "blob":
            return f.blob();
          case "document":
            return f.text().then((d) => new DOMParser().parseFromString(d, a));
          case "json":
            return f.json();
          default:
            if (a === void 0) return f.text();
            {
              let h = /charset="?([^;"\s]*)"?/i.exec(a),
                p = h && h[1] ? h[1].toLowerCase() : void 0,
                g = new TextDecoder(p);
              return f.arrayBuffer().then((y) => g.decode(y));
            }
        }
      }).then((f) => {
        Ml.add(e, f);
        let d = io[e];
        delete io[e];
        for (let h = 0, p = d.length; h < p; h++) {
          let g = d[h];
          g.onLoad && g.onLoad(f);
        }
      }).catch((f) => {
        let d = io[e];
        if (d === void 0) throw this.manager.itemError(e), f;
        delete io[e];
        for (let h = 0, p = d.length; h < p; h++) {
          let g = d[h];
          g.onError && g.onError(f);
        }
        this.manager.itemError(e);
      }).finally(() => {
        this.manager.itemEnd(e);
      }),
        this.manager.itemStart(e);
    }
    setResponseType(e) {
      return this.responseType = e, this;
    }
    setMimeType(e) {
      return this.mimeType = e, this;
    }
  },
  Qb = class extends or {
    constructor(e) {
      super(e);
    }
    load(e, t, r, i) {
      let s = this, o = new ni(this.manager);
      o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(
          e,
          function (a) {
            try {
              t(s.parse(JSON.parse(a)));
            } catch (u) {
              i ? i(u) : console.error(u), s.manager.itemError(e);
            }
          },
          r,
          i,
        );
    }
    parse(e) {
      let t = [];
      for (let r = 0; r < e.length; r++) {
        let i = va.parse(e[r]);
        t.push(i);
      }
      return t;
    }
  },
  $b = class extends or {
    constructor(e) {
      super(e);
    }
    load(e, t, r, i) {
      let s = this, o = [], a = new L_(), u = new ni(this.manager);
      u.setPath(this.path),
        u.setResponseType("arraybuffer"),
        u.setRequestHeader(this.requestHeader),
        u.setWithCredentials(s.withCredentials);
      let f = 0;
      function d(h) {
        u.load(
          e[h],
          function (p) {
            let g = s.parse(p, !0);
            o[h] = {
              width: g.width,
              height: g.height,
              format: g.format,
              mipmaps: g.mipmaps,
            },
              f += 1,
              f === 6 &&
              (g.mipmapCount === 1 && (a.minFilter = kt),
                a.image = o,
                a.format = g.format,
                a.needsUpdate = !0,
                t && t(a));
          },
          r,
          i,
        );
      }
      if (Array.isArray(e)) { for (let h = 0, p = e.length; h < p; ++h) d(h); }
      else {u.load(
          e,
          function (h) {
            let p = s.parse(h, !0);
            if (p.isCubemap) {
              let g = p.mipmaps.length / p.mipmapCount;
              for (let y = 0; y < g; y++) {
                o[y] = { mipmaps: [] };
                for (let v = 0; v < p.mipmapCount; v++) {
                  o[y].mipmaps.push(p.mipmaps[y * p.mipmapCount + v]),
                    o[y].format = p.format,
                    o[y].width = p.width,
                    o[y].height = p.height;
                }
              }
              a.image = o;
            } else {a.image.width = p.width,
                a.image.height = p.height,
                a.mipmaps = p.mipmaps;}
            p.mipmapCount === 1 && (a.minFilter = kt),
              a.format = p.format,
              a.needsUpdate = !0,
              t && t(a);
          },
          r,
          i,
        );}
      return a;
    }
  },
  gc = class extends or {
    constructor(e) {
      super(e);
    }
    load(e, t, r, i) {
      this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
      let s = this, o = Ml.get(e);
      if (o !== void 0) {
        return s.manager.itemStart(e),
          setTimeout(function () {
            t && t(o), s.manager.itemEnd(e);
          }, 0),
          o;
      }
      let a = Xf("img");
      function u() {
        d(), Ml.add(e, this), t && t(this), s.manager.itemEnd(e);
      }
      function f(h) {
        d(), i && i(h), s.manager.itemError(e), s.manager.itemEnd(e);
      }
      function d() {
        a.removeEventListener("load", u, !1),
          a.removeEventListener("error", f, !1);
      }
      return a.addEventListener("load", u, !1),
        a.addEventListener("error", f, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
        s.manager.itemStart(e),
        a.src = e,
        a;
    }
  },
  e2 = class extends or {
    constructor(e) {
      super(e);
    }
    load(e, t, r, i) {
      let s = new Gu(), o = new gc(this.manager);
      o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
      let a = 0;
      function u(f) {
        o.load(
          e[f],
          function (d) {
            s.images[f] = d, a++, a === 6 && (s.needsUpdate = !0, t && t(s));
          },
          void 0,
          i,
        );
      }
      for (let f = 0; f < e.length; ++f) u(f);
      return s;
    }
  },
  t2 = class extends or {
    constructor(e) {
      super(e);
    }
    load(e, t, r, i) {
      let s = this, o = new ml(), a = new ni(this.manager);
      return a.setResponseType("arraybuffer"),
        a.setRequestHeader(this.requestHeader),
        a.setPath(this.path),
        a.setWithCredentials(s.withCredentials),
        a.load(
          e,
          function (u) {
            let f = s.parse(u);
            !f || (f.image !== void 0
              ? o.image = f.image
              : f.data !== void 0 &&
                (o.image.width = f.width,
                  o.image.height = f.height,
                  o.image.data = f.data),
              o.wrapS = f.wrapS !== void 0 ? f.wrapS : Rn,
              o.wrapT = f.wrapT !== void 0 ? f.wrapT : Rn,
              o.magFilter = f.magFilter !== void 0 ? f.magFilter : kt,
              o.minFilter = f.minFilter !== void 0 ? f.minFilter : kt,
              o.anisotropy = f.anisotropy !== void 0 ? f.anisotropy : 1,
              f.encoding !== void 0 && (o.encoding = f.encoding),
              f.flipY !== void 0 && (o.flipY = f.flipY),
              f.format !== void 0 && (o.format = f.format),
              f.type !== void 0 && (o.type = f.type),
              f.mipmaps !== void 0 && (o.mipmaps = f.mipmaps, o.minFilter = Mi),
              f.mipmapCount === 1 && (o.minFilter = kt),
              f.generateMipmaps !== void 0 &&
              (o.generateMipmaps = f.generateMipmaps),
              o.needsUpdate = !0,
              t && t(o, f));
          },
          r,
          i,
        ),
        o;
    }
  },
  og = class extends or {
    constructor(e) {
      super(e);
    }
    load(e, t, r, i) {
      let s = new Qt(), o = new gc(this.manager);
      return o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(
          e,
          function (a) {
            s.image = a, s.needsUpdate = !0, t !== void 0 && t(s);
          },
          r,
          i,
        ),
        s;
    }
  },
  so = class extends ct {
    constructor(e, t = 1) {
      super();
      this.isLight = !0,
        this.type = "Light",
        this.color = new ve(e),
        this.intensity = t;
    }
    dispose() {}
    copy(e, t) {
      return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this;
    }
    toJSON(e) {
      let t = super.toJSON(e);
      return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        t;
    }
  },
  Q_ = class extends so {
    constructor(e, t, r) {
      super(e, r);
      this.isHemisphereLight = !0,
        this.type = "HemisphereLight",
        this.position.copy(ct.DefaultUp),
        this.updateMatrix(),
        this.groundColor = new ve(t);
    }
    copy(e, t) {
      return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
    }
  },
  n2 = new Ge(),
  r2 = new I(),
  i2 = new I(),
  ag = class {
    constructor(e) {
      this.camera = e,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new se(512, 512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new Ge(),
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new Jf(),
        this._frameExtents = new se(1, 1),
        this._viewportCount = 1,
        this._viewports = [new Lt(0, 0, 1, 1)];
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(e) {
      let t = this.camera, r = this.matrix;
      r2.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(r2),
        i2.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(i2),
        t.updateMatrixWorld(),
        n2.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(n2),
        r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        r.multiply(t.projectionMatrix),
        r.multiply(t.matrixWorldInverse);
    }
    getViewport(e) {
      return this._viewports[e];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(e) {
      return this.camera = e.camera.clone(),
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      let e = {};
      return this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e;
    }
  },
  s2 = class extends ag {
    constructor() {
      super(new ln(50, 1, .5, 500));
      this.isSpotLightShadow = !0, this.focus = 1;
    }
    updateMatrices(e) {
      let t = this.camera,
        r = Gf * 2 * e.angle * this.focus,
        i = this.mapSize.width / this.mapSize.height,
        s = e.distance || t.far;
      (r !== t.fov || i !== t.aspect || s !== t.far) &&
      (t.fov = r, t.aspect = i, t.far = s, t.updateProjectionMatrix()),
        super.updateMatrices(e);
    }
    copy(e) {
      return super.copy(e), this.focus = e.focus, this;
    }
  },
  ya = class extends so {
    constructor(e, t, r = 0, i = Math.PI / 3, s = 0, o = 1) {
      super(e, t);
      this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(ct.DefaultUp),
        this.updateMatrix(),
        this.target = new ct(),
        this.distance = r,
        this.angle = i,
        this.penumbra = s,
        this.decay = o,
        this.shadow = new s2();
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(e) {
      this.intensity = e / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e, t) {
      return super.copy(e, t),
        this.distance = e.distance,
        this.angle = e.angle,
        this.penumbra = e.penumbra,
        this.decay = e.decay,
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this;
    }
  },
  o2 = new Ge(),
  pd = new I(),
  $_ = new I(),
  a2 = class extends ag {
    constructor() {
      super(new ln(90, 1, .5, 500));
      this.isPointLightShadow = !0,
        this._frameExtents = new se(4, 2),
        this._viewportCount = 6,
        this._viewports = [
          new Lt(2, 1, 1, 1),
          new Lt(0, 1, 1, 1),
          new Lt(3, 1, 1, 1),
          new Lt(1, 1, 1, 1),
          new Lt(3, 0, 1, 1),
          new Lt(1, 0, 1, 1),
        ],
        this._cubeDirections = [
          new I(1, 0, 0),
          new I(-1, 0, 0),
          new I(0, 0, 1),
          new I(0, 0, -1),
          new I(0, 1, 0),
          new I(0, -1, 0),
        ],
        this._cubeUps = [
          new I(0, 1, 0),
          new I(0, 1, 0),
          new I(0, 1, 0),
          new I(0, 1, 0),
          new I(0, 0, 1),
          new I(0, 0, -1),
        ];
    }
    updateMatrices(e, t = 0) {
      let r = this.camera, i = this.matrix, s = e.distance || r.far;
      s !== r.far && (r.far = s, r.updateProjectionMatrix()),
        pd.setFromMatrixPosition(e.matrixWorld),
        r.position.copy(pd),
        $_.copy(r.position),
        $_.add(this._cubeDirections[t]),
        r.up.copy(this._cubeUps[t]),
        r.lookAt($_),
        r.updateMatrixWorld(),
        i.makeTranslation(-pd.x, -pd.y, -pd.z),
        o2.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(o2);
    }
  },
  oo = class extends so {
    constructor(e, t, r = 0, i = 1) {
      super(e, t);
      this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = r,
        this.decay = i,
        this.shadow = new a2();
    }
    get power() {
      return this.intensity * 4 * Math.PI;
    }
    set power(e) {
      this.intensity = e / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e, t) {
      return super.copy(e, t),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this;
    }
  },
  l2 = class extends ag {
    constructor() {
      super(new $i(-5, 5, 5, -5, .5, 500));
      this.isDirectionalLightShadow = !0;
    }
  },
  ao = class extends so {
    constructor(e, t) {
      super(e, t);
      this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(ct.DefaultUp),
        this.updateMatrix(),
        this.target = new ct(),
        this.shadow = new l2();
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e) {
      return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this;
    }
  },
  eS = class extends so {
    constructor(e, t) {
      super(e, t);
      this.isAmbientLight = !0, this.type = "AmbientLight";
    }
  },
  tS = class extends so {
    constructor(e, t, r = 10, i = 10) {
      super(e, t);
      this.isRectAreaLight = !0,
        this.type = "RectAreaLight",
        this.width = r,
        this.height = i;
    }
    get power() {
      return this.intensity * this.width * this.height * Math.PI;
    }
    set power(e) {
      this.intensity = e / (this.width * this.height * Math.PI);
    }
    copy(e) {
      return super.copy(e), this.width = e.width, this.height = e.height, this;
    }
    toJSON(e) {
      let t = super.toJSON(e);
      return t.object.width = this.width, t.object.height = this.height, t;
    }
  },
  nS = class {
    constructor() {
      this.isSphericalHarmonics3 = !0, this.coefficients = [];
      for (let e = 0; e < 9; e++) this.coefficients.push(new I());
    }
    set(e) {
      for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
      return this;
    }
    zero() {
      for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
      return this;
    }
    getAt(e, t) {
      let r = e.x, i = e.y, s = e.z, o = this.coefficients;
      return t.copy(o[0]).multiplyScalar(.282095),
        t.addScaledVector(o[1], .488603 * i),
        t.addScaledVector(o[2], .488603 * s),
        t.addScaledVector(o[3], .488603 * r),
        t.addScaledVector(o[4], 1.092548 * (r * i)),
        t.addScaledVector(o[5], 1.092548 * (i * s)),
        t.addScaledVector(o[6], .315392 * (3 * s * s - 1)),
        t.addScaledVector(o[7], 1.092548 * (r * s)),
        t.addScaledVector(o[8], .546274 * (r * r - i * i)),
        t;
    }
    getIrradianceAt(e, t) {
      let r = e.x, i = e.y, s = e.z, o = this.coefficients;
      return t.copy(o[0]).multiplyScalar(.886227),
        t.addScaledVector(o[1], 2 * .511664 * i),
        t.addScaledVector(o[2], 2 * .511664 * s),
        t.addScaledVector(o[3], 2 * .511664 * r),
        t.addScaledVector(o[4], 2 * .429043 * r * i),
        t.addScaledVector(o[5], 2 * .429043 * i * s),
        t.addScaledVector(o[6], .743125 * s * s - .247708),
        t.addScaledVector(o[7], 2 * .429043 * r * s),
        t.addScaledVector(o[8], .429043 * (r * r - i * i)),
        t;
    }
    add(e) {
      for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
      return this;
    }
    addScaledSH(e, t) {
      for (let r = 0; r < 9; r++) {
        this.coefficients[r].addScaledVector(e.coefficients[r], t);
      }
      return this;
    }
    scale(e) {
      for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
      return this;
    }
    lerp(e, t) {
      for (let r = 0; r < 9; r++) {
        this.coefficients[r].lerp(e.coefficients[r], t);
      }
      return this;
    }
    equals(e) {
      for (let t = 0; t < 9; t++) {
        if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
      }
      return !0;
    }
    copy(e) {
      return this.set(e.coefficients);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(e, t = 0) {
      let r = this.coefficients;
      for (let i = 0; i < 9; i++) r[i].fromArray(e, t + i * 3);
      return this;
    }
    toArray(e = [], t = 0) {
      let r = this.coefficients;
      for (let i = 0; i < 9; i++) r[i].toArray(e, t + i * 3);
      return e;
    }
    static getBasisAt(e, t) {
      let r = e.x, i = e.y, s = e.z;
      t[0] = .282095,
        t[1] = .488603 * i,
        t[2] = .488603 * s,
        t[3] = .488603 * r,
        t[4] = 1.092548 * r * i,
        t[5] = 1.092548 * i * s,
        t[6] = .315392 * (3 * s * s - 1),
        t[7] = 1.092548 * r * s,
        t[8] = .546274 * (r * r - i * i);
    }
  },
  md = class extends so {
    constructor(e = new nS(), t = 1) {
      super(void 0, t);
      this.isLightProbe = !0, this.sh = e;
    }
    copy(e) {
      return super.copy(e), this.sh.copy(e.sh), this;
    }
    fromJSON(e) {
      return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
    }
    toJSON(e) {
      let t = super.toJSON(e);
      return t.object.sh = this.sh.toArray(), t;
    }
  },
  gd = class extends or {
    constructor(e) {
      super(e);
      this.textures = {};
    }
    load(e, t, r, i) {
      let s = this, o = new ni(s.manager);
      o.setPath(s.path),
        o.setRequestHeader(s.requestHeader),
        o.setWithCredentials(s.withCredentials),
        o.load(
          e,
          function (a) {
            try {
              t(s.parse(JSON.parse(a)));
            } catch (u) {
              i ? i(u) : console.error(u), s.manager.itemError(e);
            }
          },
          r,
          i,
        );
    }
    parse(e) {
      let t = this.textures;
      function r(s) {
        return t[s] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", s),
          t[s];
      }
      let i = gd.createMaterialFromType(e.type);
      if (
        e.uuid !== void 0 && (i.uuid = e.uuid),
          e.name !== void 0 && (i.name = e.name),
          e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color),
          e.roughness !== void 0 && (i.roughness = e.roughness),
          e.metalness !== void 0 && (i.metalness = e.metalness),
          e.sheen !== void 0 && (i.sheen = e.sheen),
          e.sheenColor !== void 0 &&
          (i.sheenColor = new ve().setHex(e.sheenColor)),
          e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness),
          e.emissive !== void 0 && i.emissive !== void 0 &&
          i.emissive.setHex(e.emissive),
          e.specular !== void 0 && i.specular !== void 0 &&
          i.specular.setHex(e.specular),
          e.specularIntensity !== void 0 &&
          (i.specularIntensity = e.specularIntensity),
          e.specularColor !== void 0 && i.specularColor !== void 0 &&
          i.specularColor.setHex(e.specularColor),
          e.shininess !== void 0 && (i.shininess = e.shininess),
          e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
          e.clearcoatRoughness !== void 0 &&
          (i.clearcoatRoughness = e.clearcoatRoughness),
          e.iridescence !== void 0 && (i.iridescence = e.iridescence),
          e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR),
          e.iridescenceThicknessRange !== void 0 &&
          (i.iridescenceThicknessRange = e.iridescenceThicknessRange),
          e.transmission !== void 0 && (i.transmission = e.transmission),
          e.thickness !== void 0 && (i.thickness = e.thickness),
          e.attenuationDistance !== void 0 &&
          (i.attenuationDistance = e.attenuationDistance),
          e.attenuationColor !== void 0 && i.attenuationColor !== void 0 &&
          i.attenuationColor.setHex(e.attenuationColor),
          e.fog !== void 0 && (i.fog = e.fog),
          e.flatShading !== void 0 && (i.flatShading = e.flatShading),
          e.blending !== void 0 && (i.blending = e.blending),
          e.combine !== void 0 && (i.combine = e.combine),
          e.side !== void 0 && (i.side = e.side),
          e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
          e.opacity !== void 0 && (i.opacity = e.opacity),
          e.transparent !== void 0 && (i.transparent = e.transparent),
          e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
          e.depthTest !== void 0 && (i.depthTest = e.depthTest),
          e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
          e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
          e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
          e.stencilWriteMask !== void 0 &&
          (i.stencilWriteMask = e.stencilWriteMask),
          e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
          e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
          e.stencilFuncMask !== void 0 &&
          (i.stencilFuncMask = e.stencilFuncMask),
          e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
          e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
          e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
          e.wireframe !== void 0 && (i.wireframe = e.wireframe),
          e.wireframeLinewidth !== void 0 &&
          (i.wireframeLinewidth = e.wireframeLinewidth),
          e.wireframeLinecap !== void 0 &&
          (i.wireframeLinecap = e.wireframeLinecap),
          e.wireframeLinejoin !== void 0 &&
          (i.wireframeLinejoin = e.wireframeLinejoin),
          e.rotation !== void 0 && (i.rotation = e.rotation),
          e.linewidth !== 1 && (i.linewidth = e.linewidth),
          e.dashSize !== void 0 && (i.dashSize = e.dashSize),
          e.gapSize !== void 0 && (i.gapSize = e.gapSize),
          e.scale !== void 0 && (i.scale = e.scale),
          e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset),
          e.polygonOffsetFactor !== void 0 &&
          (i.polygonOffsetFactor = e.polygonOffsetFactor),
          e.polygonOffsetUnits !== void 0 &&
          (i.polygonOffsetUnits = e.polygonOffsetUnits),
          e.dithering !== void 0 && (i.dithering = e.dithering),
          e.alphaToCoverage !== void 0 &&
          (i.alphaToCoverage = e.alphaToCoverage),
          e.premultipliedAlpha !== void 0 &&
          (i.premultipliedAlpha = e.premultipliedAlpha),
          e.visible !== void 0 && (i.visible = e.visible),
          e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
          e.userData !== void 0 && (i.userData = e.userData),
          e.vertexColors !== void 0 && (typeof e.vertexColors == "number"
            ? i.vertexColors = e.vertexColors > 0
            : i.vertexColors = e.vertexColors),
          e.uniforms !== void 0
      ) {
        for (let s in e.uniforms) {
          let o = e.uniforms[s];
          switch (i.uniforms[s] = {}, o.type) {
            case "t":
              i.uniforms[s].value = r(o.value);
              break;
            case "c":
              i.uniforms[s].value = new ve().setHex(o.value);
              break;
            case "v2":
              i.uniforms[s].value = new se().fromArray(o.value);
              break;
            case "v3":
              i.uniforms[s].value = new I().fromArray(o.value);
              break;
            case "v4":
              i.uniforms[s].value = new Lt().fromArray(o.value);
              break;
            case "m3":
              i.uniforms[s].value = new vr().fromArray(o.value);
              break;
            case "m4":
              i.uniforms[s].value = new Ge().fromArray(o.value);
              break;
            default:
              i.uniforms[s].value = o.value;
          }
        }
      }
      if (
        e.defines !== void 0 && (i.defines = e.defines),
          e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
          e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader),
          e.extensions !== void 0
      ) { for (let s in e.extensions) i.extensions[s] = e.extensions[s]; }
      if (
        e.shading !== void 0 && (i.flatShading = e.shading === 1),
          e.size !== void 0 && (i.size = e.size),
          e.sizeAttenuation !== void 0 &&
          (i.sizeAttenuation = e.sizeAttenuation),
          e.map !== void 0 && (i.map = r(e.map)),
          e.matcap !== void 0 && (i.matcap = r(e.matcap)),
          e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)),
          e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)),
          e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
          e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)),
          e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType),
          e.normalScale !== void 0
      ) {
        let s = e.normalScale;
        Array.isArray(s) === !1 && (s = [s, s]),
          i.normalScale = new se().fromArray(s);
      }
      return e.displacementMap !== void 0 &&
        (i.displacementMap = r(e.displacementMap)),
        e.displacementScale !== void 0 &&
        (i.displacementScale = e.displacementScale),
        e.displacementBias !== void 0 &&
        (i.displacementBias = e.displacementBias),
        e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)),
        e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)),
        e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)),
        e.emissiveIntensity !== void 0 &&
        (i.emissiveIntensity = e.emissiveIntensity),
        e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)),
        e.specularIntensityMap !== void 0 &&
        (i.specularIntensityMap = r(e.specularIntensityMap)),
        e.specularColorMap !== void 0 &&
        (i.specularColorMap = r(e.specularColorMap)),
        e.envMap !== void 0 && (i.envMap = r(e.envMap)),
        e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity),
        e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
        e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio),
        e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)),
        e.lightMapIntensity !== void 0 &&
        (i.lightMapIntensity = e.lightMapIntensity),
        e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)),
        e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity),
        e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)),
        e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)),
        e.clearcoatRoughnessMap !== void 0 &&
        (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)),
        e.clearcoatNormalMap !== void 0 &&
        (i.clearcoatNormalMap = r(e.clearcoatNormalMap)),
        e.clearcoatNormalScale !== void 0 &&
        (i.clearcoatNormalScale = new se().fromArray(e.clearcoatNormalScale)),
        e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)),
        e.iridescenceThicknessMap !== void 0 &&
        (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)),
        e.transmissionMap !== void 0 &&
        (i.transmissionMap = r(e.transmissionMap)),
        e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)),
        e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)),
        e.sheenRoughnessMap !== void 0 &&
        (i.sheenRoughnessMap = r(e.sheenRoughnessMap)),
        i;
    }
    setTextures(e) {
      return this.textures = e, this;
    }
    static createMaterialFromType(e) {
      let t = {
        ShadowMaterial: X_,
        SpriteMaterial: Om,
        RawShaderMaterial: q_,
        ShaderMaterial: sr,
        PointsMaterial: ec,
        MeshPhysicalMaterial: Xn,
        MeshStandardMaterial: In,
        MeshPhongMaterial: ro,
        MeshToonMaterial: Sl,
        MeshNormalMaterial: mc,
        MeshLambertMaterial: wl,
        MeshDepthMaterial: Yu,
        MeshDistanceMaterial: km,
        MeshBasicMaterial: en,
        MeshMatcapMaterial: hd,
        LineDashedMaterial: Y_,
        LineBasicMaterial: Un,
        Material: $t,
      };
      return new t[e]();
    }
  },
  Ri = class {
    static decodeText(e) {
      if (typeof TextDecoder != "undefined") return new TextDecoder().decode(e);
      let t = "";
      for (let r = 0, i = e.length; r < i; r++) t += String.fromCharCode(e[r]);
      try {
        return decodeURIComponent(escape(t));
      } catch {
        return t;
      }
    }
    static extractUrlBase(e) {
      let t = e.lastIndexOf("/");
      return t === -1 ? "./" : e.slice(0, t + 1);
    }
    static resolveURL(e, t) {
      return typeof e != "string" || e === ""
        ? ""
        : (/^https?:\/\//i.test(t) && /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
          /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) ||
            /^blob:.*$/i.test(e)
            ? e
            : t + e);
    }
  },
  rS = class extends Ye {
    constructor() {
      super();
      this.isInstancedBufferGeometry = !0,
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0;
    }
    copy(e) {
      return super.copy(e), this.instanceCount = e.instanceCount, this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      let e = super.toJSON(this);
      return e.instanceCount = this.instanceCount,
        e.isInstancedBufferGeometry = !0,
        e;
    }
  },
  iS = class extends or {
    constructor(e) {
      super(e);
    }
    load(e, t, r, i) {
      let s = this, o = new ni(s.manager);
      o.setPath(s.path),
        o.setRequestHeader(s.requestHeader),
        o.setWithCredentials(s.withCredentials),
        o.load(
          e,
          function (a) {
            try {
              t(s.parse(JSON.parse(a)));
            } catch (u) {
              i ? i(u) : console.error(u), s.manager.itemError(e);
            }
          },
          r,
          i,
        );
    }
    parse(e) {
      let t = {}, r = {};
      function i(g, y) {
        if (t[y] !== void 0) return t[y];
        let _ = g.interleavedBuffers[y],
          S = s(g, _.buffer),
          w = Cu(_.type, S),
          M = new pl(w, _.stride);
        return M.uuid = _.uuid, t[y] = M, M;
      }
      function s(g, y) {
        if (r[y] !== void 0) return r[y];
        let _ = g.arrayBuffers[y], S = new Uint32Array(_).buffer;
        return r[y] = S, S;
      }
      let o = e.isInstancedBufferGeometry ? new rS() : new Ye(),
        a = e.data.index;
      if (a !== void 0) {
        let g = Cu(a.type, a.array);
        o.setIndex(new pt(g, 1));
      }
      let u = e.data.attributes;
      for (let g in u) {
        let y = u[g], v;
        if (y.isInterleavedBufferAttribute) {
          let _ = i(e.data, y.data);
          v = new Ai(_, y.itemSize, y.offset, y.normalized);
        } else {
          let _ = Cu(y.type, y.array),
            S = y.isInstancedBufferAttribute ? vl : pt;
          v = new S(_, y.itemSize, y.normalized);
        }
        y.name !== void 0 && (v.name = y.name),
          y.usage !== void 0 && v.setUsage(y.usage),
          y.updateRange !== void 0 &&
          (v.updateRange.offset = y.updateRange.offset,
            v.updateRange.count = y.updateRange.count),
          o.setAttribute(g, v);
      }
      let f = e.data.morphAttributes;
      if (f) {
        for (let g in f) {
          let y = f[g], v = [];
          for (let _ = 0, S = y.length; _ < S; _++) {
            let w = y[_], M;
            if (w.isInterleavedBufferAttribute) {
              let T = i(e.data, w.data);
              M = new Ai(T, w.itemSize, w.offset, w.normalized);
            } else {
              let T = Cu(w.type, w.array);
              M = new pt(T, w.itemSize, w.normalized);
            }
            w.name !== void 0 && (M.name = w.name), v.push(M);
          }
          o.morphAttributes[g] = v;
        }
      }
      e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
      let h = e.data.groups || e.data.drawcalls || e.data.offsets;
      if (h !== void 0) {
        for (let g = 0, y = h.length; g !== y; ++g) {
          let v = h[g];
          o.addGroup(v.start, v.count, v.materialIndex);
        }
      }
      let p = e.data.boundingSphere;
      if (p !== void 0) {
        let g = new I();
        p.center !== void 0 && g.fromArray(p.center),
          o.boundingSphere = new Zi(g, p.radius);
      }
      return e.name && (o.name = e.name),
        e.userData && (o.userData = e.userData),
        o;
    }
  },
  u2 = class extends or {
    constructor(e) {
      super(e);
    }
    load(e, t, r, i) {
      let s = this, o = this.path === "" ? Ri.extractUrlBase(e) : this.path;
      this.resourcePath = this.resourcePath || o;
      let a = new ni(this.manager);
      a.setPath(this.path),
        a.setRequestHeader(this.requestHeader),
        a.setWithCredentials(this.withCredentials),
        a.load(
          e,
          function (u) {
            let f = null;
            try {
              f = JSON.parse(u);
            } catch (h) {
              i !== void 0 && i(h),
                console.error(
                  "THREE:ObjectLoader: Can't parse " + e + ".",
                  h.message,
                );
              return;
            }
            let d = f.metadata;
            if (
              d === void 0 || d.type === void 0 ||
              d.type.toLowerCase() === "geometry"
            ) {
              console.error("THREE.ObjectLoader: Can't load " + e);
              return;
            }
            s.parse(f, t);
          },
          r,
          i,
        );
    }
    async loadAsync(e, t) {
      let r = this, i = this.path === "" ? Ri.extractUrlBase(e) : this.path;
      this.resourcePath = this.resourcePath || i;
      let s = new ni(this.manager);
      s.setPath(this.path),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials);
      let o = await s.loadAsync(e, t), a = JSON.parse(o), u = a.metadata;
      if (
        u === void 0 || u.type === void 0 || u.type.toLowerCase() === "geometry"
      ) throw new Error("THREE.ObjectLoader: Can't load " + e);
      return await r.parseAsync(a);
    }
    parse(e, t) {
      let r = this.parseAnimations(e.animations),
        i = this.parseShapes(e.shapes),
        s = this.parseGeometries(e.geometries, i),
        o = this.parseImages(e.images, function () {
          t !== void 0 && t(f);
        }),
        a = this.parseTextures(e.textures, o),
        u = this.parseMaterials(e.materials, a),
        f = this.parseObject(e.object, s, u, a, r),
        d = this.parseSkeletons(e.skeletons, f);
      if (this.bindSkeletons(f, d), t !== void 0) {
        let h = !1;
        for (let p in o) {
          if (o[p].data instanceof HTMLImageElement) {
            h = !0;
            break;
          }
        }
        h === !1 && t(f);
      }
      return f;
    }
    async parseAsync(e) {
      let t = this.parseAnimations(e.animations),
        r = this.parseShapes(e.shapes),
        i = this.parseGeometries(e.geometries, r),
        s = await this.parseImagesAsync(e.images),
        o = this.parseTextures(e.textures, s),
        a = this.parseMaterials(e.materials, o),
        u = this.parseObject(e.object, i, a, o, t),
        f = this.parseSkeletons(e.skeletons, u);
      return this.bindSkeletons(u, f), u;
    }
    parseShapes(e) {
      let t = {};
      if (e !== void 0) {
        for (let r = 0, i = e.length; r < i; r++) {
          let s = new ca().fromJSON(e[r]);
          t[s.uuid] = s;
        }
      }
      return t;
    }
    parseSkeletons(e, t) {
      let r = {}, i = {};
      if (
        t.traverse(function (s) {
          s.isBone && (i[s.uuid] = s);
        }), e !== void 0
      ) {
        for (let s = 0, o = e.length; s < o; s++) {
          let a = new gl().fromJSON(e[s], i);
          r[a.uuid] = a;
        }
      }
      return r;
    }
    parseGeometries(e, t) {
      let r = {};
      if (e !== void 0) {
        let i = new iS();
        for (let s = 0, o = e.length; s < o; s++) {
          let a, u = e[s];
          switch (u.type) {
            case "BufferGeometry":
            case "InstancedBufferGeometry":
              a = i.parse(u);
              break;
            case "Geometry":
              console.error(
                "THREE.ObjectLoader: The legacy Geometry type is no longer supported.",
              );
              break;
            default:
              u.type in Kb
                ? a = Kb[u.type].fromJSON(u, t)
                : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${u.type}"`,
                );
          }
          a.uuid = u.uuid,
            u.name !== void 0 && (a.name = u.name),
            a.isBufferGeometry === !0 && u.userData !== void 0 &&
            (a.userData = u.userData),
            r[u.uuid] = a;
        }
      }
      return r;
    }
    parseMaterials(e, t) {
      let r = {}, i = {};
      if (e !== void 0) {
        let s = new gd();
        s.setTextures(t);
        for (let o = 0, a = e.length; o < a; o++) {
          let u = e[o];
          if (u.type === "MultiMaterial") {
            let f = [];
            for (let d = 0; d < u.materials.length; d++) {
              let h = u.materials[d];
              r[h.uuid] === void 0 && (r[h.uuid] = s.parse(h)),
                f.push(r[h.uuid]);
            }
            i[u.uuid] = f;
          } else {r[u.uuid] === void 0 && (r[u.uuid] = s.parse(u)),
              i[u.uuid] = r[u.uuid];}
        }
      }
      return i;
    }
    parseAnimations(e) {
      let t = {};
      if (e !== void 0) {
        for (let r = 0; r < e.length; r++) {
          let i = e[r], s = va.parse(i);
          t[s.uuid] = s;
        }
      }
      return t;
    }
    parseImages(e, t) {
      let r = this, i = {}, s;
      function o(u) {
        return r.manager.itemStart(u),
          s.load(
            u,
            function () {
              r.manager.itemEnd(u);
            },
            void 0,
            function () {
              r.manager.itemError(u), r.manager.itemEnd(u);
            },
          );
      }
      function a(u) {
        if (typeof u == "string") {
          let f = u,
            d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : r.resourcePath + f;
          return o(d);
        } else {return u.data
            ? { data: Cu(u.type, u.data), width: u.width, height: u.height }
            : null;}
      }
      if (e !== void 0 && e.length > 0) {
        let u = new sg(t);
        s = new gc(u), s.setCrossOrigin(this.crossOrigin);
        for (let f = 0, d = e.length; f < d; f++) {
          let h = e[f], p = h.url;
          if (Array.isArray(p)) {
            let g = [];
            for (let y = 0, v = p.length; y < v; y++) {
              let _ = p[y], S = a(_);
              S !== null &&
                (S instanceof HTMLImageElement
                  ? g.push(S)
                  : g.push(new ml(S.data, S.width, S.height)));
            }
            i[h.uuid] = new Jo(g);
          } else {
            let g = a(h.url);
            i[h.uuid] = new Jo(g);
          }
        }
      }
      return i;
    }
    async parseImagesAsync(e) {
      let t = this, r = {}, i;
      async function s(o) {
        if (typeof o == "string") {
          let a = o,
            u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
          return await i.loadAsync(u);
        } else {return o.data
            ? { data: Cu(o.type, o.data), width: o.width, height: o.height }
            : null;}
      }
      if (e !== void 0 && e.length > 0) {
        i = new gc(this.manager), i.setCrossOrigin(this.crossOrigin);
        for (let o = 0, a = e.length; o < a; o++) {
          let u = e[o], f = u.url;
          if (Array.isArray(f)) {
            let d = [];
            for (let h = 0, p = f.length; h < p; h++) {
              let g = f[h], y = await s(g);
              y !== null &&
                (y instanceof HTMLImageElement
                  ? d.push(y)
                  : d.push(new ml(y.data, y.width, y.height)));
            }
            r[u.uuid] = new Jo(d);
          } else {
            let d = await s(u.url);
            r[u.uuid] = new Jo(d);
          }
        }
      }
      return r;
    }
    parseTextures(e, t) {
      function r(s, o) {
        return typeof s == "number"
          ? s
          : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            s,
          ),
            o[s]);
      }
      let i = {};
      if (e !== void 0) {
        for (let s = 0, o = e.length; s < o; s++) {
          let a = e[s];
          a.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
            t[a.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", a.image);
          let u = t[a.image], f = u.data, d;
          Array.isArray(f)
            ? (d = new Gu(), f.length === 6 && (d.needsUpdate = !0))
            : (f && f.data ? d = new ml() : d = new Qt(),
              f && (d.needsUpdate = !0)),
            d.source = u,
            d.uuid = a.uuid,
            a.name !== void 0 && (d.name = a.name),
            a.mapping !== void 0 && (d.mapping = r(a.mapping, b4)),
            a.offset !== void 0 && d.offset.fromArray(a.offset),
            a.repeat !== void 0 && d.repeat.fromArray(a.repeat),
            a.center !== void 0 && d.center.fromArray(a.center),
            a.rotation !== void 0 && (d.rotation = a.rotation),
            a.wrap !== void 0 &&
            (d.wrapS = r(a.wrap[0], c2), d.wrapT = r(a.wrap[1], c2)),
            a.format !== void 0 && (d.format = a.format),
            a.type !== void 0 && (d.type = a.type),
            a.encoding !== void 0 && (d.encoding = a.encoding),
            a.minFilter !== void 0 && (d.minFilter = r(a.minFilter, f2)),
            a.magFilter !== void 0 && (d.magFilter = r(a.magFilter, f2)),
            a.anisotropy !== void 0 && (d.anisotropy = a.anisotropy),
            a.flipY !== void 0 && (d.flipY = a.flipY),
            a.premultiplyAlpha !== void 0 &&
            (d.premultiplyAlpha = a.premultiplyAlpha),
            a.unpackAlignment !== void 0 &&
            (d.unpackAlignment = a.unpackAlignment),
            a.userData !== void 0 && (d.userData = a.userData),
            i[a.uuid] = d;
        }
      }
      return i;
    }
    parseObject(e, t, r, i, s) {
      let o;
      function a(p) {
        return t[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", p),
          t[p];
      }
      function u(p) {
        if (p !== void 0) {
          if (Array.isArray(p)) {
            let g = [];
            for (let y = 0, v = p.length; y < v; y++) {
              let _ = p[y];
              r[_] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", _),
                g.push(r[_]);
            }
            return g;
          }
          return r[p] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", p),
            r[p];
        }
      }
      function f(p) {
        return i[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", p),
          i[p];
      }
      let d, h;
      switch (e.type) {
        case "Scene":
          o = new hl(),
            e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? o.background = new ve(e.background)
              : o.background = f(e.background)),
            e.environment !== void 0 && (o.environment = f(e.environment)),
            e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? o.fog = new td(e.fog.color, e.fog.near, e.fog.far)
              : e.fog.type === "FogExp2" &&
                (o.fog = new ed(e.fog.color, e.fog.density)));
          break;
        case "PerspectiveCamera":
          o = new ln(e.fov, e.aspect, e.near, e.far),
            e.focus !== void 0 && (o.focus = e.focus),
            e.zoom !== void 0 && (o.zoom = e.zoom),
            e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
            e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
            e.view !== void 0 && (o.view = Object.assign({}, e.view));
          break;
        case "OrthographicCamera":
          o = new $i(e.left, e.right, e.top, e.bottom, e.near, e.far),
            e.zoom !== void 0 && (o.zoom = e.zoom),
            e.view !== void 0 && (o.view = Object.assign({}, e.view));
          break;
        case "AmbientLight":
          o = new eS(e.color, e.intensity);
          break;
        case "DirectionalLight":
          o = new ao(e.color, e.intensity);
          break;
        case "PointLight":
          o = new oo(e.color, e.intensity, e.distance, e.decay);
          break;
        case "RectAreaLight":
          o = new tS(e.color, e.intensity, e.width, e.height);
          break;
        case "SpotLight":
          o = new ya(
            e.color,
            e.intensity,
            e.distance,
            e.angle,
            e.penumbra,
            e.decay,
          );
          break;
        case "HemisphereLight":
          o = new Q_(e.color, e.groundColor, e.intensity);
          break;
        case "LightProbe":
          o = new md().fromJSON(e);
          break;
        case "SkinnedMesh":
          d = a(e.geometry),
            h = u(e.material),
            o = new aa(d, h),
            e.bindMode !== void 0 && (o.bindMode = e.bindMode),
            e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
            e.skeleton !== void 0 && (o.skeleton = e.skeleton);
          break;
        case "Mesh":
          d = a(e.geometry), h = u(e.material), o = new Ot(d, h);
          break;
        case "InstancedMesh":
          d = a(e.geometry), h = u(e.material);
          let p = e.count, g = e.instanceMatrix, y = e.instanceColor;
          o = new C_(d, h, p),
            o.instanceMatrix = new vl(new Float32Array(g.array), 16),
            y !== void 0 &&
            (o.instanceColor = new vl(new Float32Array(y.array), y.itemSize));
          break;
        case "LOD":
          o = new A_();
          break;
        case "Line":
          o = new Fr(a(e.geometry), u(e.material));
          break;
        case "LineLoop":
          o = new yl(a(e.geometry), u(e.material));
          break;
        case "LineSegments":
          o = new wr(a(e.geometry), u(e.material));
          break;
        case "PointCloud":
        case "Points":
          o = new la(a(e.geometry), u(e.material));
          break;
        case "Sprite":
          o = new T_(u(e.material));
          break;
        case "Group":
          o = new ti();
          break;
        case "Bone":
          o = new $u();
          break;
        default:
          o = new ct();
      }
      if (
        o.uuid = e.uuid,
          e.name !== void 0 && (o.name = e.name),
          e.matrix !== void 0
            ? (o.matrix.fromArray(e.matrix),
              e.matrixAutoUpdate !== void 0 &&
              (o.matrixAutoUpdate = e.matrixAutoUpdate),
              o.matrixAutoUpdate &&
              o.matrix.decompose(o.position, o.quaternion, o.scale))
            : (e.position !== void 0 && o.position.fromArray(e.position),
              e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
              e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
              e.scale !== void 0 && o.scale.fromArray(e.scale)),
          e.castShadow !== void 0 && (o.castShadow = e.castShadow),
          e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
          e.shadow &&
          (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
            e.shadow.normalBias !== void 0 &&
            (o.shadow.normalBias = e.shadow.normalBias),
            e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
            e.shadow.mapSize !== void 0 &&
            o.shadow.mapSize.fromArray(e.shadow.mapSize),
            e.shadow.camera !== void 0 &&
            (o.shadow.camera = this.parseObject(e.shadow.camera))),
          e.visible !== void 0 && (o.visible = e.visible),
          e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
          e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
          e.userData !== void 0 && (o.userData = e.userData),
          e.layers !== void 0 && (o.layers.mask = e.layers),
          e.children !== void 0
      ) {
        let p = e.children;
        for (let g = 0; g < p.length; g++) {
          o.add(this.parseObject(p[g], t, r, i, s));
        }
      }
      if (e.animations !== void 0) {
        let p = e.animations;
        for (let g = 0; g < p.length; g++) {
          let y = p[g];
          o.animations.push(s[y]);
        }
      }
      if (e.type === "LOD") {
        e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
        let p = e.levels;
        for (let g = 0; g < p.length; g++) {
          let y = p[g], v = o.getObjectByProperty("uuid", y.object);
          v !== void 0 && o.addLevel(v, y.distance);
        }
      }
      return o;
    }
    bindSkeletons(e, t) {
      Object.keys(t).length !== 0 && e.traverse(function (r) {
        if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
          let i = t[r.skeleton];
          i === void 0
            ? console.warn(
              "THREE.ObjectLoader: No skeleton found with UUID:",
              r.skeleton,
            )
            : r.bind(i, r.bindMatrix);
        }
      });
    }
    setTexturePath(e) {
      return console.warn(
        "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().",
      ),
        this.setResourcePath(e);
    }
  },
  b4 = {
    UVMapping: Kp,
    CubeReflectionMapping: Ho,
    CubeRefractionMapping: Go,
    EquirectangularReflectionMapping: Uf,
    EquirectangularRefractionMapping: Vf,
    CubeUVReflectionMapping: Au,
  },
  c2 = {
    RepeatWrapping: Wi,
    ClampToEdgeWrapping: Rn,
    MirroredRepeatWrapping: Ws,
  },
  f2 = {
    NearestFilter: Jt,
    NearestMipmapNearestFilter: jo,
    NearestMipmapLinearFilter: Wo,
    LinearFilter: kt,
    LinearMipmapNearestFilter: $a,
    LinearMipmapLinearFilter: Mi,
  },
  lg = class extends or {
    constructor(e) {
      super(e);
      this.isImageBitmapLoader = !0,
        typeof createImageBitmap == "undefined" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported.",
        ),
        typeof fetch == "undefined" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = { premultiplyAlpha: "none" };
    }
    setOptions(e) {
      return this.options = e, this;
    }
    load(e, t, r, i) {
      e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
      let s = this, o = Ml.get(e);
      if (o !== void 0) {
        return s.manager.itemStart(e),
          setTimeout(function () {
            t && t(o), s.manager.itemEnd(e);
          }, 0),
          o;
      }
      let a = {};
      a.credentials = this.crossOrigin === "anonymous"
        ? "same-origin"
        : "include",
        a.headers = this.requestHeader,
        fetch(e, a).then(function (u) {
          return u.blob();
        }).then(function (u) {
          return createImageBitmap(
            u,
            Object.assign(s.options, { colorSpaceConversion: "none" }),
          );
        }).then(function (u) {
          Ml.add(e, u), t && t(u), s.manager.itemEnd(e);
        }).catch(function (u) {
          i && i(u), s.manager.itemError(e), s.manager.itemEnd(e);
        }),
        s.manager.itemStart(e);
    }
  },
  ug,
  sS = {
    getContext: function () {
      return ug === void 0 &&
        (ug = new (window.AudioContext || window.webkitAudioContext)()),
        ug;
    },
    setContext: function (n) {
      ug = n;
    },
  },
  d2 = class extends or {
    constructor(e) {
      super(e);
    }
    load(e, t, r, i) {
      let s = this, o = new ni(this.manager);
      o.setResponseType("arraybuffer"),
        o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(
          e,
          function (a) {
            try {
              let u = a.slice(0);
              sS.getContext().decodeAudioData(u, function (d) {
                t(d);
              });
            } catch (u) {
              i ? i(u) : console.error(u), s.manager.itemError(e);
            }
          },
          r,
          i,
        );
    }
  },
  h2 = class extends md {
    constructor(e, t, r = 1) {
      super(void 0, r);
      this.isHemisphereLightProbe = !0;
      let i = new ve().set(e),
        s = new ve().set(t),
        o = new I(i.r, i.g, i.b),
        a = new I(s.r, s.g, s.b),
        u = Math.sqrt(Math.PI),
        f = u * Math.sqrt(.75);
      this.sh.coefficients[0].copy(o).add(a).multiplyScalar(u),
        this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(f);
    }
  },
  p2 = class extends md {
    constructor(e, t = 1) {
      super(void 0, t);
      this.isAmbientLightProbe = !0;
      let r = new ve().set(e);
      this.sh.coefficients[0].set(r.r, r.g, r.b).multiplyScalar(
        2 * Math.sqrt(Math.PI),
      );
    }
  },
  m2 = new Ge(),
  g2 = new Ge(),
  El = new Ge(),
  v2 = class {
    constructor() {
      this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new ln(),
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new ln(),
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1,
        this._cache = {
          focus: null,
          fov: null,
          aspect: null,
          near: null,
          far: null,
          zoom: null,
          eyeSep: null,
        };
    }
    update(e) {
      let t = this._cache;
      if (
        t.focus !== e.focus || t.fov !== e.fov ||
        t.aspect !== e.aspect * this.aspect || t.near !== e.near ||
        t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep
      ) {
        t.focus = e.focus,
          t.fov = e.fov,
          t.aspect = e.aspect * this.aspect,
          t.near = e.near,
          t.far = e.far,
          t.zoom = e.zoom,
          t.eyeSep = this.eyeSep,
          El.copy(e.projectionMatrix);
        let i = t.eyeSep / 2,
          s = i * t.near / t.focus,
          o = t.near * Math.tan(il * t.fov * .5) / t.zoom,
          a,
          u;
        g2.elements[12] = -i,
          m2.elements[12] = i,
          a = -o * t.aspect + s,
          u = o * t.aspect + s,
          El.elements[0] = 2 * t.near / (u - a),
          El.elements[8] = (u + a) / (u - a),
          this.cameraL.projectionMatrix.copy(El),
          a = -o * t.aspect - s,
          u = o * t.aspect - s,
          El.elements[0] = 2 * t.near / (u - a),
          El.elements[8] = (u + a) / (u - a),
          this.cameraR.projectionMatrix.copy(El);
      }
      this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(g2),
        this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(m2);
    }
  },
  cg = class {
    constructor(e = !0) {
      this.autoStart = e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1;
    }
    start() {
      this.startTime = y2(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0;
    }
    stop() {
      this.getElapsedTime(), this.running = !1, this.autoStart = !1;
    }
    getElapsedTime() {
      return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
      let e = 0;
      if (this.autoStart && !this.running) return this.start(), 0;
      if (this.running) {
        let t = y2();
        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
      }
      return e;
    }
  };
function y2() {
  return (typeof performance == "undefined" ? Date : performance).now();
}
var Tl = new I(),
  x2 = new Pn(),
  R4 = new I(),
  Al = new I(),
  _2 = class extends ct {
    constructor() {
      super();
      this.type = "AudioListener",
        this.context = sS.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0,
        this._clock = new cg();
    }
    getInput() {
      return this.gain;
    }
    removeFilter() {
      return this.filter !== null &&
        (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination),
          this.gain.connect(this.context.destination),
          this.filter = null),
        this;
    }
    getFilter() {
      return this.filter;
    }
    setFilter(e) {
      return this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
        this.filter = e,
        this.gain.connect(this.filter),
        this.filter.connect(this.context.destination),
        this;
    }
    getMasterVolume() {
      return this.gain.gain.value;
    }
    setMasterVolume(e) {
      return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this;
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e);
      let t = this.context.listener, r = this.up;
      if (
        this.timeDelta = this._clock.getDelta(),
          this.matrixWorld.decompose(Tl, x2, R4),
          Al.set(0, 0, -1).applyQuaternion(x2),
          t.positionX
      ) {
        let i = this.context.currentTime + this.timeDelta;
        t.positionX.linearRampToValueAtTime(Tl.x, i),
          t.positionY.linearRampToValueAtTime(Tl.y, i),
          t.positionZ.linearRampToValueAtTime(Tl.z, i),
          t.forwardX.linearRampToValueAtTime(Al.x, i),
          t.forwardY.linearRampToValueAtTime(Al.y, i),
          t.forwardZ.linearRampToValueAtTime(Al.z, i),
          t.upX.linearRampToValueAtTime(r.x, i),
          t.upY.linearRampToValueAtTime(r.y, i),
          t.upZ.linearRampToValueAtTime(r.z, i);
      } else {t.setPosition(Tl.x, Tl.y, Tl.z),
          t.setOrientation(Al.x, Al.y, Al.z, r.x, r.y, r.z);}
    }
  },
  oS = class extends ct {
    constructor(e) {
      super();
      this.type = "Audio",
        this.listener = e,
        this.context = e.context,
        this.gain = this.context.createGain(),
        this.gain.connect(e.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.loopStart = 0,
        this.loopEnd = 0,
        this.offset = 0,
        this.duration = void 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.source = null,
        this.sourceType = "empty",
        this._startedAt = 0,
        this._progress = 0,
        this._connected = !1,
        this.filters = [];
    }
    getOutput() {
      return this.gain;
    }
    setNodeSource(e) {
      return this.hasPlaybackControl = !1,
        this.sourceType = "audioNode",
        this.source = e,
        this.connect(),
        this;
    }
    setMediaElementSource(e) {
      return this.hasPlaybackControl = !1,
        this.sourceType = "mediaNode",
        this.source = this.context.createMediaElementSource(e),
        this.connect(),
        this;
    }
    setMediaStreamSource(e) {
      return this.hasPlaybackControl = !1,
        this.sourceType = "mediaStreamNode",
        this.source = this.context.createMediaStreamSource(e),
        this.connect(),
        this;
    }
    setBuffer(e) {
      return this.buffer = e,
        this.sourceType = "buffer",
        this.autoplay && this.play(),
        this;
    }
    play(e = 0) {
      if (this.isPlaying === !0) {
        console.warn("THREE.Audio: Audio is already playing.");
        return;
      }
      if (this.hasPlaybackControl === !1) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this._startedAt = this.context.currentTime + e;
      let t = this.context.createBufferSource();
      return t.buffer = this.buffer,
        t.loop = this.loop,
        t.loopStart = this.loopStart,
        t.loopEnd = this.loopEnd,
        t.onended = this.onEnded.bind(this),
        t.start(this._startedAt, this._progress + this.offset, this.duration),
        this.isPlaying = !0,
        this.source = t,
        this.setDetune(this.detune),
        this.setPlaybackRate(this.playbackRate),
        this.connect();
    }
    pause() {
      if (this.hasPlaybackControl === !1) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      return this.isPlaying === !0 &&
        (this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate,
          this.loop === !0 &&
          (this._progress = this._progress %
            (this.duration || this.buffer.duration)),
          this.source.stop(),
          this.source.onended = null,
          this.isPlaying = !1),
        this;
    }
    stop() {
      if (this.hasPlaybackControl === !1) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      return this._progress = 0,
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1,
        this;
    }
    connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++) {
          this.filters[e - 1].connect(this.filters[e]);
        }
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else this.source.connect(this.getOutput());
      return this._connected = !0, this;
    }
    disconnect() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++) {
          this.filters[e - 1].disconnect(this.filters[e]);
        }
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return this._connected = !1, this;
    }
    getFilters() {
      return this.filters;
    }
    setFilters(e) {
      return e || (e = []),
        this._connected === !0
          ? (this.disconnect(), this.filters = e.slice(), this.connect())
          : this.filters = e.slice(),
        this;
    }
    setDetune(e) {
      if (this.detune = e, this.source.detune !== void 0) {
        return this.isPlaying === !0 &&
          this.source.detune.setTargetAtTime(
            this.detune,
            this.context.currentTime,
            .01,
          ),
          this;
      }
    }
    getDetune() {
      return this.detune;
    }
    getFilter() {
      return this.getFilters()[0];
    }
    setFilter(e) {
      return this.setFilters(e ? [e] : []);
    }
    setPlaybackRate(e) {
      if (this.hasPlaybackControl === !1) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      return this.playbackRate = e,
        this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          .01,
        ),
        this;
    }
    getPlaybackRate() {
      return this.playbackRate;
    }
    onEnded() {
      this.isPlaying = !1;
    }
    getLoop() {
      return this.hasPlaybackControl === !1
        ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
        : this.loop;
    }
    setLoop(e) {
      if (this.hasPlaybackControl === !1) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      return this.loop = e,
        this.isPlaying === !0 && (this.source.loop = this.loop),
        this;
    }
    setLoopStart(e) {
      return this.loopStart = e, this;
    }
    setLoopEnd(e) {
      return this.loopEnd = e, this;
    }
    getVolume() {
      return this.gain.gain.value;
    }
    setVolume(e) {
      return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this;
    }
  },
  Cl = new I(),
  S2 = new Pn(),
  L4 = new I(),
  bl = new I(),
  w2 = class extends oS {
    constructor(e) {
      super(e);
      this.panner = this.context.createPanner(),
        this.panner.panningModel = "HRTF",
        this.panner.connect(this.gain);
    }
    disconnect() {
      super.disconnect(), this.panner.disconnect(this.gain);
    }
    getOutput() {
      return this.panner;
    }
    getRefDistance() {
      return this.panner.refDistance;
    }
    setRefDistance(e) {
      return this.panner.refDistance = e, this;
    }
    getRolloffFactor() {
      return this.panner.rolloffFactor;
    }
    setRolloffFactor(e) {
      return this.panner.rolloffFactor = e, this;
    }
    getDistanceModel() {
      return this.panner.distanceModel;
    }
    setDistanceModel(e) {
      return this.panner.distanceModel = e, this;
    }
    getMaxDistance() {
      return this.panner.maxDistance;
    }
    setMaxDistance(e) {
      return this.panner.maxDistance = e, this;
    }
    setDirectionalCone(e, t, r) {
      return this.panner.coneInnerAngle = e,
        this.panner.coneOuterAngle = t,
        this.panner.coneOuterGain = r,
        this;
    }
    updateMatrixWorld(e) {
      if (
        super.updateMatrixWorld(e),
          this.hasPlaybackControl === !0 && this.isPlaying === !1
      ) return;
      this.matrixWorld.decompose(Cl, S2, L4),
        bl.set(0, 0, 1).applyQuaternion(S2);
      let t = this.panner;
      if (t.positionX) {
        let r = this.context.currentTime + this.listener.timeDelta;
        t.positionX.linearRampToValueAtTime(Cl.x, r),
          t.positionY.linearRampToValueAtTime(Cl.y, r),
          t.positionZ.linearRampToValueAtTime(Cl.z, r),
          t.orientationX.linearRampToValueAtTime(bl.x, r),
          t.orientationY.linearRampToValueAtTime(bl.y, r),
          t.orientationZ.linearRampToValueAtTime(bl.z, r);
      } else {t.setPosition(Cl.x, Cl.y, Cl.z),
          t.setOrientation(bl.x, bl.y, bl.z);}
    }
  },
  M2 = class {
    constructor(e, t = 2048) {
      this.analyser = e.context.createAnalyser(),
        this.analyser.fftSize = t,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        e.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
      return this.analyser.getByteFrequencyData(this.data), this.data;
    }
    getAverageFrequency() {
      let e = 0, t = this.getFrequencyData();
      for (let r = 0; r < t.length; r++) e += t[r];
      return e / t.length;
    }
  },
  aS = class {
    constructor(e, t, r) {
      this.binding = e, this.valueSize = r;
      let i, s, o;
      switch (t) {
        case "quaternion":
          i = this._slerp,
            s = this._slerpAdditive,
            o = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(r * 6),
            this._workIndex = 5;
          break;
        case "string":
        case "bool":
          i = this._select,
            s = this._select,
            o = this._setAdditiveIdentityOther,
            this.buffer = new Array(r * 5);
          break;
        default:
          i = this._lerp,
            s = this._lerpAdditive,
            o = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(r * 5);
      }
      this._mixBufferRegion = i,
        this._mixBufferRegionAdditive = s,
        this._setIdentity = o,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0;
    }
    accumulate(e, t) {
      let r = this.buffer,
        i = this.valueSize,
        s = e * i + i,
        o = this.cumulativeWeight;
      if (o === 0) {
        for (let a = 0; a !== i; ++a) r[s + a] = r[a];
        o = t;
      } else {
        o += t;
        let a = t / o;
        this._mixBufferRegion(r, s, 0, a, i);
      }
      this.cumulativeWeight = o;
    }
    accumulateAdditive(e) {
      let t = this.buffer, r = this.valueSize, i = r * this._addIndex;
      this.cumulativeWeightAdditive === 0 && this._setIdentity(),
        this._mixBufferRegionAdditive(t, i, 0, e, r),
        this.cumulativeWeightAdditive += e;
    }
    apply(e) {
      let t = this.valueSize,
        r = this.buffer,
        i = e * t + t,
        s = this.cumulativeWeight,
        o = this.cumulativeWeightAdditive,
        a = this.binding;
      if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
        let u = t * this._origIndex;
        this._mixBufferRegion(r, i, u, 1 - s, t);
      }
      o > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * t, 1, t);
      for (let u = t, f = t + t; u !== f; ++u) {
        if (r[u] !== r[u + t]) {
          a.setValue(r, i);
          break;
        }
      }
    }
    saveOriginalState() {
      let e = this.binding,
        t = this.buffer,
        r = this.valueSize,
        i = r * this._origIndex;
      e.getValue(t, i);
      for (let s = r, o = i; s !== o; ++s) t[s] = t[i + s % r];
      this._setIdentity(),
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0;
    }
    restoreOriginalState() {
      let e = this.valueSize * 3;
      this.binding.setValue(this.buffer, e);
    }
    _setAdditiveIdentityNumeric() {
      let e = this._addIndex * this.valueSize, t = e + this.valueSize;
      for (let r = e; r < t; r++) this.buffer[r] = 0;
    }
    _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric(),
        this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
      let e = this._origIndex * this.valueSize,
        t = this._addIndex * this.valueSize;
      for (let r = 0; r < this.valueSize; r++) {
        this.buffer[t + r] = this.buffer[e + r];
      }
    }
    _select(e, t, r, i, s) {
      if (i >= .5) { for (let o = 0; o !== s; ++o) e[t + o] = e[r + o]; }
    }
    _slerp(e, t, r, i) {
      Pn.slerpFlat(e, t, e, t, e, r, i);
    }
    _slerpAdditive(e, t, r, i, s) {
      let o = this._workIndex * s;
      Pn.multiplyQuaternionsFlat(e, o, e, t, e, r),
        Pn.slerpFlat(e, t, e, t, e, o, i);
    }
    _lerp(e, t, r, i, s) {
      let o = 1 - i;
      for (let a = 0; a !== s; ++a) {
        let u = t + a;
        e[u] = e[u] * o + e[r + a] * i;
      }
    }
    _lerpAdditive(e, t, r, i, s) {
      for (let o = 0; o !== s; ++o) {
        let a = t + o;
        e[a] = e[a] + e[r + o] * i;
      }
    }
  },
  lS = "\\[\\]\\.:\\/",
  P4 = new RegExp("[" + lS + "]", "g"),
  uS = "[^" + lS + "]",
  I4 = "[^" + lS.replace("\\.", "") + "]",
  N4 = /((?:WC+[\/:])*)/.source.replace("WC", uS),
  D4 = /(WCOD+)?/.source.replace("WCOD", I4),
  k4 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", uS),
  F4 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", uS),
  O4 = new RegExp("^" + N4 + D4 + k4 + F4 + "$"),
  z4 = ["material", "materials", "bones"],
  E2 = class {
    constructor(e, t, r) {
      let i = r || st.parseTrackName(t);
      this._targetGroup = e, this._bindings = e.subscribe_(t, i);
    }
    getValue(e, t) {
      this.bind();
      let r = this._targetGroup.nCachedObjects_, i = this._bindings[r];
      i !== void 0 && i.getValue(e, t);
    }
    setValue(e, t) {
      let r = this._bindings;
      for (
        let i = this._targetGroup.nCachedObjects_, s = r.length; i !== s; ++i
      ) r[i].setValue(e, t);
    }
    bind() {
      let e = this._bindings;
      for (
        let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t
      ) e[t].bind();
    }
    unbind() {
      let e = this._bindings;
      for (
        let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t
      ) e[t].unbind();
    }
  },
  st = class {
    constructor(e, t, r) {
      this.path = t,
        this.parsedPath = r || st.parseTrackName(t),
        this.node = st.findNode(e, this.parsedPath.nodeName) || e,
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound;
    }
    static create(e, t, r) {
      return e && e.isAnimationObjectGroup
        ? new st.Composite(e, t, r)
        : new st(e, t, r);
    }
    static sanitizeNodeName(e) {
      return e.replace(/\s/g, "_").replace(P4, "");
    }
    static parseTrackName(e) {
      let t = O4.exec(e);
      if (t === null) {
        throw new Error("PropertyBinding: Cannot parse trackName: " + e);
      }
      let r = {
          nodeName: t[2],
          objectName: t[3],
          objectIndex: t[4],
          propertyName: t[5],
          propertyIndex: t[6],
        },
        i = r.nodeName && r.nodeName.lastIndexOf(".");
      if (i !== void 0 && i !== -1) {
        let s = r.nodeName.substring(i + 1);
        z4.indexOf(s) !== -1 &&
          (r.nodeName = r.nodeName.substring(0, i), r.objectName = s);
      }
      if (r.propertyName === null || r.propertyName.length === 0) {
        throw new Error(
          "PropertyBinding: can not parse propertyName from trackName: " + e,
        );
      }
      return r;
    }
    static findNode(e, t) {
      if (
        t === void 0 || t === "" || t === "." || t === -1 || t === e.name ||
        t === e.uuid
      ) return e;
      if (e.skeleton) {
        let r = e.skeleton.getBoneByName(t);
        if (r !== void 0) return r;
      }
      if (e.children) {
        let r = function (s) {
            for (let o = 0; o < s.length; o++) {
              let a = s[o];
              if (a.name === t || a.uuid === t) return a;
              let u = r(a.children);
              if (u) return u;
            }
            return null;
          },
          i = r(e.children);
        if (i) return i;
      }
      return null;
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
      e[t] = this.targetObject[this.propertyName];
    }
    _getValue_array(e, t) {
      let r = this.resolvedProperty;
      for (let i = 0, s = r.length; i !== s; ++i) e[t++] = r[i];
    }
    _getValue_arrayElement(e, t) {
      e[t] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(e, t) {
      this.resolvedProperty.toArray(e, t);
    }
    _setValue_direct(e, t) {
      this.targetObject[this.propertyName] = e[t];
    }
    _setValue_direct_setNeedsUpdate(e, t) {
      this.targetObject[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
      this.targetObject[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _setValue_array(e, t) {
      let r = this.resolvedProperty;
      for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[t++];
    }
    _setValue_array_setNeedsUpdate(e, t) {
      let r = this.resolvedProperty;
      for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[t++];
      this.targetObject.needsUpdate = !0;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
      let r = this.resolvedProperty;
      for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[t++];
      this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _setValue_arrayElement(e, t) {
      this.resolvedProperty[this.propertyIndex] = e[t];
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
      this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
      this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _setValue_fromArray(e, t) {
      this.resolvedProperty.fromArray(e, t);
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
      this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
      this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _getValue_unbound(e, t) {
      this.bind(), this.getValue(e, t);
    }
    _setValue_unbound(e, t) {
      this.bind(), this.setValue(e, t);
    }
    bind() {
      let e = this.node,
        t = this.parsedPath,
        r = t.objectName,
        i = t.propertyName,
        s = t.propertyIndex;
      if (
        e ||
        (e = st.findNode(this.rootNode, t.nodeName) || this.rootNode,
          this.node = e),
          this.getValue = this._getValue_unavailable,
          this.setValue = this._setValue_unavailable,
          !e
      ) {
        console.error(
          "THREE.PropertyBinding: Trying to update node for track: " +
            this.path + " but it wasn't found.",
        );
        return;
      }
      if (r) {
        let f = t.objectIndex;
        switch (r) {
          case "materials":
            if (!e.material) {
              console.error(
                "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                this,
              );
              return;
            }
            if (!e.material.materials) {
              console.error(
                "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                this,
              );
              return;
            }
            e = e.material.materials;
            break;
          case "bones":
            if (!e.skeleton) {
              console.error(
                "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                this,
              );
              return;
            }
            e = e.skeleton.bones;
            for (let d = 0; d < e.length; d++) {
              if (e[d].name === f) {
                f = d;
                break;
              }
            }
            break;
          default:
            if (e[r] === void 0) {
              console.error(
                "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                this,
              );
              return;
            }
            e = e[r];
        }
        if (f !== void 0) {
          if (e[f] === void 0) {
            console.error(
              "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
              this,
              e,
            );
            return;
          }
          e = e[f];
        }
      }
      let o = e[i];
      if (o === void 0) {
        let f = t.nodeName;
        console.error(
          "THREE.PropertyBinding: Trying to update property for track: " + f +
            "." + i + " but it wasn't found.",
          e,
        );
        return;
      }
      let a = this.Versioning.None;
      this.targetObject = e,
        e.needsUpdate !== void 0
          ? a = this.Versioning.NeedsUpdate
          : e.matrixWorldNeedsUpdate !== void 0 &&
            (a = this.Versioning.MatrixWorldNeedsUpdate);
      let u = this.BindingType.Direct;
      if (s !== void 0) {
        if (i === "morphTargetInfluences") {
          if (!e.geometry) {
            console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
              this,
            );
            return;
          }
          if (!e.geometry.morphAttributes) {
            console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
              this,
            );
            return;
          }
          e.morphTargetDictionary[s] !== void 0 &&
            (s = e.morphTargetDictionary[s]);
        }
        u = this.BindingType.ArrayElement,
          this.resolvedProperty = o,
          this.propertyIndex = s;
      } else {o.fromArray !== void 0 && o.toArray !== void 0
          ? (u = this.BindingType.HasFromToArray, this.resolvedProperty = o)
          : Array.isArray(o)
          ? (u = this.BindingType.EntireArray, this.resolvedProperty = o)
          : this.propertyName = i;}
      this.getValue = this.GetterByBindingType[u],
        this.setValue = this.SetterByBindingTypeAndVersioning[u][a];
    }
    unbind() {
      this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound;
    }
  };
st.Composite = E2;
st.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
st.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
st.prototype.GetterByBindingType = [
  st.prototype._getValue_direct,
  st.prototype._getValue_array,
  st.prototype._getValue_arrayElement,
  st.prototype._getValue_toArray,
];
st.prototype.SetterByBindingTypeAndVersioning = [[
  st.prototype._setValue_direct,
  st.prototype._setValue_direct_setNeedsUpdate,
  st.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
], [
  st.prototype._setValue_array,
  st.prototype._setValue_array_setNeedsUpdate,
  st.prototype._setValue_array_setMatrixWorldNeedsUpdate,
], [
  st.prototype._setValue_arrayElement,
  st.prototype._setValue_arrayElement_setNeedsUpdate,
  st.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
], [
  st.prototype._setValue_fromArray,
  st.prototype._setValue_fromArray_setNeedsUpdate,
  st.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
]];
var T2 = class {
    constructor() {
      this.isAnimationObjectGroup = !0,
        this.uuid = Kr(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
      let e = {};
      this._indicesByUUID = e;
      for (let r = 0, i = arguments.length; r !== i; ++r) {
        e[arguments[r].uuid] = r;
      }
      this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
      let t = this;
      this.stats = {
        objects: {
          get total() {
            return t._objects.length;
          },
          get inUse() {
            return this.total - t.nCachedObjects_;
          },
        },
        get bindingsPerObject() {
          return t._bindings.length;
        },
      };
    }
    add() {
      let e = this._objects,
        t = this._indicesByUUID,
        r = this._paths,
        i = this._parsedPaths,
        s = this._bindings,
        o = s.length,
        a,
        u = e.length,
        f = this.nCachedObjects_;
      for (let d = 0, h = arguments.length; d !== h; ++d) {
        let p = arguments[d], g = p.uuid, y = t[g];
        if (y === void 0) {
          y = u++, t[g] = y, e.push(p);
          for (let v = 0, _ = o; v !== _; ++v) s[v].push(new st(p, r[v], i[v]));
        } else if (y < f) {
          a = e[y];
          let v = --f, _ = e[v];
          t[_.uuid] = y, e[y] = _, t[g] = v, e[v] = p;
          for (let S = 0, w = o; S !== w; ++S) {
            let M = s[S], T = M[v], b = M[y];
            M[y] = T, b === void 0 && (b = new st(p, r[S], i[S])), M[v] = b;
          }
        } else {e[y] !== a &&
            console.error(
              "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.",
            );}
      }
      this.nCachedObjects_ = f;
    }
    remove() {
      let e = this._objects,
        t = this._indicesByUUID,
        r = this._bindings,
        i = r.length,
        s = this.nCachedObjects_;
      for (let o = 0, a = arguments.length; o !== a; ++o) {
        let u = arguments[o], f = u.uuid, d = t[f];
        if (d !== void 0 && d >= s) {
          let h = s++, p = e[h];
          t[p.uuid] = d, e[d] = p, t[f] = h, e[h] = u;
          for (let g = 0, y = i; g !== y; ++g) {
            let v = r[g], _ = v[h], S = v[d];
            v[d] = _, v[h] = S;
          }
        }
      }
      this.nCachedObjects_ = s;
    }
    uncache() {
      let e = this._objects,
        t = this._indicesByUUID,
        r = this._bindings,
        i = r.length,
        s = this.nCachedObjects_,
        o = e.length;
      for (let a = 0, u = arguments.length; a !== u; ++a) {
        let f = arguments[a], d = f.uuid, h = t[d];
        if (h !== void 0) {
          if (delete t[d], h < s) {
            let p = --s, g = e[p], y = --o, v = e[y];
            t[g.uuid] = h, e[h] = g, t[v.uuid] = p, e[p] = v, e.pop();
            for (let _ = 0, S = i; _ !== S; ++_) {
              let w = r[_], M = w[p], T = w[y];
              w[h] = M, w[p] = T, w.pop();
            }
          } else {
            let p = --o, g = e[p];
            p > 0 && (t[g.uuid] = h), e[h] = g, e.pop();
            for (let y = 0, v = i; y !== v; ++y) {
              let _ = r[y];
              _[h] = _[p], _.pop();
            }
          }
        }
      }
      this.nCachedObjects_ = s;
    }
    subscribe_(e, t) {
      let r = this._bindingsIndicesByPath, i = r[e], s = this._bindings;
      if (i !== void 0) return s[i];
      let o = this._paths,
        a = this._parsedPaths,
        u = this._objects,
        f = u.length,
        d = this.nCachedObjects_,
        h = new Array(f);
      i = s.length, r[e] = i, o.push(e), a.push(t), s.push(h);
      for (let p = d, g = u.length; p !== g; ++p) {
        let y = u[p];
        h[p] = new st(y, e, t);
      }
      return h;
    }
    unsubscribe_(e) {
      let t = this._bindingsIndicesByPath, r = t[e];
      if (r !== void 0) {
        let i = this._paths,
          s = this._parsedPaths,
          o = this._bindings,
          a = o.length - 1,
          u = o[a],
          f = e[a];
        t[f] = r, o[r] = u, o.pop(), s[r] = s[a], s.pop(), i[r] = i[a], i.pop();
      }
    }
  },
  A2 = class {
    constructor(e, t, r = null, i = t.blendMode) {
      this._mixer = e, this._clip = t, this._localRoot = r, this.blendMode = i;
      let s = t.tracks,
        o = s.length,
        a = new Array(o),
        u = { endingStart: nl, endingEnd: nl };
      for (let f = 0; f !== o; ++f) {
        let d = s[f].createInterpolant(null);
        a[f] = d, d.settings = u;
      }
      this._interpolantSettings = u,
        this._interpolants = a,
        this._propertyBindings = new Array(o),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = cC,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0;
    }
    play() {
      return this._mixer._activateAction(this), this;
    }
    stop() {
      return this._mixer._deactivateAction(this), this.reset();
    }
    reset() {
      return this.paused = !1,
        this.enabled = !0,
        this.time = 0,
        this._loopCount = -1,
        this._startTime = null,
        this.stopFading().stopWarping();
    }
    isRunning() {
      return this.enabled && !this.paused && this.timeScale !== 0 &&
        this._startTime === null && this._mixer._isActiveAction(this);
    }
    isScheduled() {
      return this._mixer._isActiveAction(this);
    }
    startAt(e) {
      return this._startTime = e, this;
    }
    setLoop(e, t) {
      return this.loop = e, this.repetitions = t, this;
    }
    setEffectiveWeight(e) {
      return this.weight = e,
        this._effectiveWeight = this.enabled ? e : 0,
        this.stopFading();
    }
    getEffectiveWeight() {
      return this._effectiveWeight;
    }
    fadeIn(e) {
      return this._scheduleFading(e, 0, 1);
    }
    fadeOut(e) {
      return this._scheduleFading(e, 1, 0);
    }
    crossFadeFrom(e, t, r) {
      if (e.fadeOut(t), this.fadeIn(t), r) {
        let i = this._clip.duration, s = e._clip.duration, o = s / i, a = i / s;
        e.warp(1, o, t), this.warp(a, 1, t);
      }
      return this;
    }
    crossFadeTo(e, t, r) {
      return e.crossFadeFrom(this, t, r);
    }
    stopFading() {
      let e = this._weightInterpolant;
      return e !== null &&
        (this._weightInterpolant = null,
          this._mixer._takeBackControlInterpolant(e)),
        this;
    }
    setEffectiveTimeScale(e) {
      return this.timeScale = e,
        this._effectiveTimeScale = this.paused ? 0 : e,
        this.stopWarping();
    }
    getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
    setDuration(e) {
      return this.timeScale = this._clip.duration / e, this.stopWarping();
    }
    syncWith(e) {
      return this.time = e.time,
        this.timeScale = e.timeScale,
        this.stopWarping();
    }
    halt(e) {
      return this.warp(this._effectiveTimeScale, 0, e);
    }
    warp(e, t, r) {
      let i = this._mixer,
        s = i.time,
        o = this.timeScale,
        a = this._timeScaleInterpolant;
      a === null &&
        (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a);
      let u = a.parameterPositions, f = a.sampleValues;
      return u[0] = s, u[1] = s + r, f[0] = e / o, f[1] = t / o, this;
    }
    stopWarping() {
      let e = this._timeScaleInterpolant;
      return e !== null &&
        (this._timeScaleInterpolant = null,
          this._mixer._takeBackControlInterpolant(e)),
        this;
    }
    getMixer() {
      return this._mixer;
    }
    getClip() {
      return this._clip;
    }
    getRoot() {
      return this._localRoot || this._mixer._root;
    }
    _update(e, t, r, i) {
      if (!this.enabled) {
        this._updateWeight(e);
        return;
      }
      let s = this._startTime;
      if (s !== null) {
        let u = (e - s) * r;
        if (u < 0 || r === 0) return;
        this._startTime = null, t = r * u;
      }
      t *= this._updateTimeScale(e);
      let o = this._updateTime(t), a = this._updateWeight(e);
      if (a > 0) {
        let u = this._interpolants, f = this._propertyBindings;
        switch (this.blendMode) {
          case Ux:
            for (let d = 0, h = u.length; d !== h; ++d) {
              u[d].evaluate(o), f[d].accumulateAdditive(a);
            }
            break;
          case nm:
          default:
            for (let d = 0, h = u.length; d !== h; ++d) {
              u[d].evaluate(o), f[d].accumulate(i, a);
            }
        }
      }
    }
    _updateWeight(e) {
      let t = 0;
      if (this.enabled) {
        t = this.weight;
        let r = this._weightInterpolant;
        if (r !== null) {
          let i = r.evaluate(e)[0];
          t *= i,
            e > r.parameterPositions[1] &&
            (this.stopFading(), i === 0 && (this.enabled = !1));
        }
      }
      return this._effectiveWeight = t, t;
    }
    _updateTimeScale(e) {
      let t = 0;
      if (!this.paused) {
        t = this.timeScale;
        let r = this._timeScaleInterpolant;
        r !== null &&
          (t *= r.evaluate(e)[0],
            e > r.parameterPositions[1] &&
            (this.stopWarping(),
              t === 0 ? this.paused = !0 : this.timeScale = t));
      }
      return this._effectiveTimeScale = t, t;
    }
    _updateTime(e) {
      let t = this._clip.duration,
        r = this.loop,
        i = this.time + e,
        s = this._loopCount,
        o = r === fC;
      if (e === 0) return s === -1 ? i : o && (s & 1) == 1 ? t - i : i;
      if (r === uC) {
        s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
        e: {
          if (i >= t) i = t;
          else if (i < 0) i = 0;
          else {
            this.time = i;
            break e;
          }
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
            this.time = i,
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e < 0 ? -1 : 1,
            });
        }
      } else {
        if (
          s === -1 && (e >= 0
            ? (s = 0, this._setEndings(!0, this.repetitions === 0, o))
            : this._setEndings(this.repetitions === 0, !0, o)), i >= t || i < 0
        ) {
          let a = Math.floor(i / t);
          i -= t * a, s += Math.abs(a);
          let u = this.repetitions - s;
          if (u <= 0) {
            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
              i = e > 0 ? t : 0,
              this.time = i,
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: e > 0 ? 1 : -1,
              });
          } else {
            if (u === 1) {
              let f = e < 0;
              this._setEndings(f, !f, o);
            } else this._setEndings(!1, !1, o);
            this._loopCount = s,
              this.time = i,
              this._mixer.dispatchEvent({
                type: "loop",
                action: this,
                loopDelta: a,
              });
          }
        } else this.time = i;
        if (o && (s & 1) == 1) return t - i;
      }
      return i;
    }
    _setEndings(e, t, r) {
      let i = this._interpolantSettings;
      r
        ? (i.endingStart = rl, i.endingEnd = rl)
        : (e
          ? i.endingStart = this.zeroSlopeAtStart ? rl : nl
          : i.endingStart = Hf,
          t ? i.endingEnd = this.zeroSlopeAtEnd ? rl : nl : i.endingEnd = Hf);
    }
    _scheduleFading(e, t, r) {
      let i = this._mixer, s = i.time, o = this._weightInterpolant;
      o === null &&
        (o = i._lendControlInterpolant(), this._weightInterpolant = o);
      let a = o.parameterPositions, u = o.sampleValues;
      return a[0] = s, u[0] = t, a[1] = s + e, u[1] = r, this;
    }
  },
  B4 = new Float32Array(1),
  C2 = class extends Xi {
    constructor(e) {
      super();
      this._root = e,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1;
    }
    _bindAction(e, t) {
      let r = e._localRoot || this._root,
        i = e._clip.tracks,
        s = i.length,
        o = e._propertyBindings,
        a = e._interpolants,
        u = r.uuid,
        f = this._bindingsByRootAndName,
        d = f[u];
      d === void 0 && (d = {}, f[u] = d);
      for (let h = 0; h !== s; ++h) {
        let p = i[h], g = p.name, y = d[g];
        if (y !== void 0) ++y.referenceCount, o[h] = y;
        else {
          if (y = o[h], y !== void 0) {
            y._cacheIndex === null &&
              (++y.referenceCount, this._addInactiveBinding(y, u, g));
            continue;
          }
          let v = t && t._propertyBindings[h].binding.parsedPath;
          y = new aS(st.create(r, g, v), p.ValueTypeName, p.getValueSize()),
            ++y.referenceCount,
            this._addInactiveBinding(y, u, g),
            o[h] = y;
        }
        a[h].resultBuffer = y.buffer;
      }
    }
    _activateAction(e) {
      if (!this._isActiveAction(e)) {
        if (e._cacheIndex === null) {
          let r = (e._localRoot || this._root).uuid,
            i = e._clip.uuid,
            s = this._actionsByClip[i];
          this._bindAction(e, s && s.knownActions[0]),
            this._addInactiveAction(e, i, r);
        }
        let t = e._propertyBindings;
        for (let r = 0, i = t.length; r !== i; ++r) {
          let s = t[r];
          s.useCount++ == 0 && (this._lendBinding(s), s.saveOriginalState());
        }
        this._lendAction(e);
      }
    }
    _deactivateAction(e) {
      if (this._isActiveAction(e)) {
        let t = e._propertyBindings;
        for (let r = 0, i = t.length; r !== i; ++r) {
          let s = t[r];
          --s.useCount == 0 &&
            (s.restoreOriginalState(), this._takeBackBinding(s));
        }
        this._takeBackAction(e);
      }
    }
    _initMemoryManager() {
      this._actions = [],
        this._nActiveActions = 0,
        this._actionsByClip = {},
        this._bindings = [],
        this._nActiveBindings = 0,
        this._bindingsByRootAndName = {},
        this._controlInterpolants = [],
        this._nActiveControlInterpolants = 0;
      let e = this;
      this.stats = {
        actions: {
          get total() {
            return e._actions.length;
          },
          get inUse() {
            return e._nActiveActions;
          },
        },
        bindings: {
          get total() {
            return e._bindings.length;
          },
          get inUse() {
            return e._nActiveBindings;
          },
        },
        controlInterpolants: {
          get total() {
            return e._controlInterpolants.length;
          },
          get inUse() {
            return e._nActiveControlInterpolants;
          },
        },
      };
    }
    _isActiveAction(e) {
      let t = e._cacheIndex;
      return t !== null && t < this._nActiveActions;
    }
    _addInactiveAction(e, t, r) {
      let i = this._actions, s = this._actionsByClip, o = s[t];
      if (o === void 0) {
        o = { knownActions: [e], actionByRoot: {} },
          e._byClipCacheIndex = 0,
          s[t] = o;
      } else {
        let a = o.knownActions;
        e._byClipCacheIndex = a.length, a.push(e);
      }
      e._cacheIndex = i.length, i.push(e), o.actionByRoot[r] = e;
    }
    _removeInactiveAction(e) {
      let t = this._actions, r = t[t.length - 1], i = e._cacheIndex;
      r._cacheIndex = i, t[i] = r, t.pop(), e._cacheIndex = null;
      let s = e._clip.uuid,
        o = this._actionsByClip,
        a = o[s],
        u = a.knownActions,
        f = u[u.length - 1],
        d = e._byClipCacheIndex;
      f._byClipCacheIndex = d, u[d] = f, u.pop(), e._byClipCacheIndex = null;
      let h = a.actionByRoot, p = (e._localRoot || this._root).uuid;
      delete h[p],
        u.length === 0 && delete o[s],
        this._removeInactiveBindingsForAction(e);
    }
    _removeInactiveBindingsForAction(e) {
      let t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        let s = t[r];
        --s.referenceCount == 0 && this._removeInactiveBinding(s);
      }
    }
    _lendAction(e) {
      let t = this._actions,
        r = e._cacheIndex,
        i = this._nActiveActions++,
        s = t[i];
      e._cacheIndex = i, t[i] = e, s._cacheIndex = r, t[r] = s;
    }
    _takeBackAction(e) {
      let t = this._actions,
        r = e._cacheIndex,
        i = --this._nActiveActions,
        s = t[i];
      e._cacheIndex = i, t[i] = e, s._cacheIndex = r, t[r] = s;
    }
    _addInactiveBinding(e, t, r) {
      let i = this._bindingsByRootAndName, s = this._bindings, o = i[t];
      o === void 0 && (o = {}, i[t] = o),
        o[r] = e,
        e._cacheIndex = s.length,
        s.push(e);
    }
    _removeInactiveBinding(e) {
      let t = this._bindings,
        r = e.binding,
        i = r.rootNode.uuid,
        s = r.path,
        o = this._bindingsByRootAndName,
        a = o[i],
        u = t[t.length - 1],
        f = e._cacheIndex;
      u._cacheIndex = f,
        t[f] = u,
        t.pop(),
        delete a[s],
        Object.keys(a).length === 0 && delete o[i];
    }
    _lendBinding(e) {
      let t = this._bindings,
        r = e._cacheIndex,
        i = this._nActiveBindings++,
        s = t[i];
      e._cacheIndex = i, t[i] = e, s._cacheIndex = r, t[r] = s;
    }
    _takeBackBinding(e) {
      let t = this._bindings,
        r = e._cacheIndex,
        i = --this._nActiveBindings,
        s = t[i];
      e._cacheIndex = i, t[i] = e, s._cacheIndex = r, t[r] = s;
    }
    _lendControlInterpolant() {
      let e = this._controlInterpolants,
        t = this._nActiveControlInterpolants++,
        r = e[t];
      return r === void 0 &&
        (r = new rg(new Float32Array(2), new Float32Array(2), 1, B4),
          r.__cacheIndex = t,
          e[t] = r),
        r;
    }
    _takeBackControlInterpolant(e) {
      let t = this._controlInterpolants,
        r = e.__cacheIndex,
        i = --this._nActiveControlInterpolants,
        s = t[i];
      e.__cacheIndex = i, t[i] = e, s.__cacheIndex = r, t[r] = s;
    }
    clipAction(e, t, r) {
      let i = t || this._root,
        s = i.uuid,
        o = typeof e == "string" ? va.findByName(i, e) : e,
        a = o !== null ? o.uuid : e,
        u = this._actionsByClip[a],
        f = null;
      if (
        r === void 0 && (o !== null ? r = o.blendMode : r = nm), u !== void 0
      ) {
        let h = u.actionByRoot[s];
        if (h !== void 0 && h.blendMode === r) return h;
        f = u.knownActions[0], o === null && (o = f._clip);
      }
      if (o === null) return null;
      let d = new A2(this, o, t, r);
      return this._bindAction(d, f), this._addInactiveAction(d, a, s), d;
    }
    existingAction(e, t) {
      let r = t || this._root,
        i = r.uuid,
        s = typeof e == "string" ? va.findByName(r, e) : e,
        o = s ? s.uuid : e,
        a = this._actionsByClip[o];
      return a !== void 0 && a.actionByRoot[i] || null;
    }
    stopAllAction() {
      let e = this._actions, t = this._nActiveActions;
      for (let r = t - 1; r >= 0; --r) e[r].stop();
      return this;
    }
    update(e) {
      e *= this.timeScale;
      let t = this._actions,
        r = this._nActiveActions,
        i = this.time += e,
        s = Math.sign(e),
        o = this._accuIndex ^= 1;
      for (let f = 0; f !== r; ++f) t[f]._update(i, e, s, o);
      let a = this._bindings, u = this._nActiveBindings;
      for (let f = 0; f !== u; ++f) a[f].apply(o);
      return this;
    }
    setTime(e) {
      this.time = 0;
      for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
      return this.update(e);
    }
    getRoot() {
      return this._root;
    }
    uncacheClip(e) {
      let t = this._actions, r = e.uuid, i = this._actionsByClip, s = i[r];
      if (s !== void 0) {
        let o = s.knownActions;
        for (let a = 0, u = o.length; a !== u; ++a) {
          let f = o[a];
          this._deactivateAction(f);
          let d = f._cacheIndex, h = t[t.length - 1];
          f._cacheIndex = null,
            f._byClipCacheIndex = null,
            h._cacheIndex = d,
            t[d] = h,
            t.pop(),
            this._removeInactiveBindingsForAction(f);
        }
        delete i[r];
      }
    }
    uncacheRoot(e) {
      let t = e.uuid, r = this._actionsByClip;
      for (let o in r) {
        let a = r[o].actionByRoot, u = a[t];
        u !== void 0 &&
          (this._deactivateAction(u), this._removeInactiveAction(u));
      }
      let i = this._bindingsByRootAndName, s = i[t];
      if (s !== void 0) {
        for (let o in s) {
          let a = s[o];
          a.restoreOriginalState(), this._removeInactiveBinding(a);
        }
      }
    }
    uncacheAction(e, t) {
      let r = this.existingAction(e, t);
      r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
    }
  },
  fg = class {
    constructor(e) {
      typeof e == "string" &&
      (console.warn("THREE.Uniform: Type parameter is no longer needed."),
        e = arguments[1]), this.value = e;
    }
    clone() {
      return new fg(
        this.value.clone === void 0 ? this.value : this.value.clone(),
      );
    }
  },
  b2 = class extends pl {
    constructor(e, t, r = 1) {
      super(e, t);
      this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = r;
    }
    copy(e) {
      return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
    }
    clone(e) {
      let t = super.clone(e);
      return t.meshPerAttribute = this.meshPerAttribute, t;
    }
    toJSON(e) {
      let t = super.toJSON(e);
      return t.isInstancedInterleavedBuffer = !0,
        t.meshPerAttribute = this.meshPerAttribute,
        t;
    }
  },
  R2 = class {
    constructor(e, t, r, i, s) {
      this.isGLBufferAttribute = !0,
        this.buffer = e,
        this.type = t,
        this.itemSize = r,
        this.elementSize = i,
        this.count = s,
        this.version = 0;
    }
    set needsUpdate(e) {
      e === !0 && this.version++;
    }
    setBuffer(e) {
      return this.buffer = e, this;
    }
    setType(e, t) {
      return this.type = e, this.elementSize = t, this;
    }
    setItemSize(e) {
      return this.itemSize = e, this;
    }
    setCount(e) {
      return this.count = e, this;
    }
  },
  cS = class {
    constructor(e, t, r = 0, i = 1 / 0) {
      this.ray = new Nu(e, t),
        this.near = r,
        this.far = i,
        this.camera = null,
        this.layers = new na(),
        this.params = {
          Mesh: {},
          Line: { threshold: 1 },
          LOD: {},
          Points: { threshold: 1 },
          Sprite: {},
        };
    }
    set(e, t) {
      this.ray.set(e, t);
    }
    setFromCamera(e, t) {
      t.isPerspectiveCamera
        ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
          this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin)
            .normalize(),
          this.camera = t)
        : t.isOrthographicCamera
        ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
          this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
          this.camera = t)
        : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
    }
    intersectObject(e, t = !0, r = []) {
      return fS(e, this, r, t), r.sort(L2), r;
    }
    intersectObjects(e, t = !0, r = []) {
      for (let i = 0, s = e.length; i < s; i++) fS(e[i], this, r, t);
      return r.sort(L2), r;
    }
  };
function L2(n, e) {
  return n.distance - e.distance;
}
function fS(n, e, t, r) {
  if (n.layers.test(e.layers) && n.raycast(e, t), r === !0) {
    let i = n.children;
    for (let s = 0, o = i.length; s < o; s++) fS(i[s], e, t, !0);
  }
}
var P2 = class {
    constructor(e = 1, t = 0, r = 0) {
      return this.radius = e, this.phi = t, this.theta = r, this;
    }
    set(e, t, r) {
      return this.radius = e, this.phi = t, this.theta = r, this;
    }
    copy(e) {
      return this.radius = e.radius,
        this.phi = e.phi,
        this.theta = e.theta,
        this;
    }
    makeSafe() {
      let e = 1e-6;
      return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this;
    }
    setFromVector3(e) {
      return this.setFromCartesianCoords(e.x, e.y, e.z);
    }
    setFromCartesianCoords(e, t, r) {
      return this.radius = Math.sqrt(e * e + t * t + r * r),
        this.radius === 0
          ? (this.theta = 0, this.phi = 0)
          : (this.theta = Math.atan2(e, r),
            this.phi = Math.acos(yn(t / this.radius, -1, 1))),
        this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  },
  I2 = class {
    constructor(e = 1, t = 0, r = 0) {
      return this.radius = e, this.theta = t, this.y = r, this;
    }
    set(e, t, r) {
      return this.radius = e, this.theta = t, this.y = r, this;
    }
    copy(e) {
      return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
    }
    setFromVector3(e) {
      return this.setFromCartesianCoords(e.x, e.y, e.z);
    }
    setFromCartesianCoords(e, t, r) {
      return this.radius = Math.sqrt(e * e + r * r),
        this.theta = Math.atan2(e, r),
        this.y = t,
        this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  },
  N2 = new se(),
  D2 = class {
    constructor(e = new se(1 / 0, 1 / 0), t = new se(-1 / 0, -1 / 0)) {
      this.isBox2 = !0, this.min = e, this.max = t;
    }
    set(e, t) {
      return this.min.copy(e), this.max.copy(t), this;
    }
    setFromPoints(e) {
      this.makeEmpty();
      for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
      return this;
    }
    setFromCenterAndSize(e, t) {
      let r = N2.copy(t).multiplyScalar(.5);
      return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.min.copy(e.min), this.max.copy(e.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = 1 / 0,
        this.max.x = this.max.y = -1 / 0,
        this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(e) {
      return this.isEmpty()
        ? e.set(0, 0)
        : e.addVectors(this.min, this.max).multiplyScalar(.5);
    }
    getSize(e) {
      return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
    }
    expandByPoint(e) {
      return this.min.min(e), this.max.max(e), this;
    }
    expandByVector(e) {
      return this.min.sub(e), this.max.add(e), this;
    }
    expandByScalar(e) {
      return this.min.addScalar(-e), this.max.addScalar(e), this;
    }
    containsPoint(e) {
      return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y ||
        e.y > this.max.y);
    }
    containsBox(e) {
      return this.min.x <= e.min.x && e.max.x <= this.max.x &&
        this.min.y <= e.min.y && e.max.y <= this.max.y;
    }
    getParameter(e, t) {
      return t.set(
        (e.x - this.min.x) / (this.max.x - this.min.x),
        (e.y - this.min.y) / (this.max.y - this.min.y),
      );
    }
    intersectsBox(e) {
      return !(e.max.x < this.min.x || e.min.x > this.max.x ||
        e.max.y < this.min.y || e.min.y > this.max.y);
    }
    clampPoint(e, t) {
      return t.copy(e).clamp(this.min, this.max);
    }
    distanceToPoint(e) {
      return N2.copy(e).clamp(this.min, this.max).sub(e).length();
    }
    intersect(e) {
      return this.min.max(e.min), this.max.min(e.max), this;
    }
    union(e) {
      return this.min.min(e.min), this.max.max(e.max), this;
    }
    translate(e) {
      return this.min.add(e), this.max.add(e), this;
    }
    equals(e) {
      return e.min.equals(this.min) && e.max.equals(this.max);
    }
  },
  k2 = new I(),
  dg = new I(),
  F2 = class {
    constructor(e = new I(), t = new I()) {
      this.start = e, this.end = t;
    }
    set(e, t) {
      return this.start.copy(e), this.end.copy(t), this;
    }
    copy(e) {
      return this.start.copy(e.start), this.end.copy(e.end), this;
    }
    getCenter(e) {
      return e.addVectors(this.start, this.end).multiplyScalar(.5);
    }
    delta(e) {
      return e.subVectors(this.end, this.start);
    }
    distanceSq() {
      return this.start.distanceToSquared(this.end);
    }
    distance() {
      return this.start.distanceTo(this.end);
    }
    at(e, t) {
      return this.delta(t).multiplyScalar(e).add(this.start);
    }
    closestPointToPointParameter(e, t) {
      k2.subVectors(e, this.start), dg.subVectors(this.end, this.start);
      let r = dg.dot(dg), s = dg.dot(k2) / r;
      return t && (s = yn(s, 0, 1)), s;
    }
    closestPointToPoint(e, t, r) {
      let i = this.closestPointToPointParameter(e, t);
      return this.delta(r).multiplyScalar(i).add(this.start);
    }
    applyMatrix4(e) {
      return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
    }
    equals(e) {
      return e.start.equals(this.start) && e.end.equals(this.end);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  },
  O2 = new I(),
  z2 = class extends ct {
    constructor(e, t) {
      super();
      this.light = e,
        this.light.updateMatrixWorld(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = t;
      let r = new Ye(),
        i = [
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          -1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          0,
          0,
          0,
          -1,
          1,
        ];
      for (let o = 0, a = 1, u = 32; o < u; o++, a++) {
        let f = o / u * Math.PI * 2, d = a / u * Math.PI * 2;
        i.push(Math.cos(f), Math.sin(f), 1, Math.cos(d), Math.sin(d), 1);
      }
      r.setAttribute("position", new ke(i, 3));
      let s = new Un({ fog: !1, toneMapped: !1 });
      this.cone = new wr(r, s), this.add(this.cone), this.update();
    }
    dispose() {
      this.cone.geometry.dispose(), this.cone.material.dispose();
    }
    update() {
      this.light.updateMatrixWorld();
      let e = this.light.distance ? this.light.distance : 1e3,
        t = e * Math.tan(this.light.angle);
      this.cone.scale.set(t, t, e),
        O2.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt(O2),
        this.color !== void 0
          ? this.cone.material.color.set(this.color)
          : this.cone.material.color.copy(this.light.color);
    }
  },
  xa = new I(),
  hg = new Ge(),
  dS = new Ge(),
  B2 = class extends wr {
    constructor(e) {
      let t = U2(e),
        r = new Ye(),
        i = [],
        s = [],
        o = new ve(0, 0, 1),
        a = new ve(0, 1, 0);
      for (let f = 0; f < t.length; f++) {
        let d = t[f];
        d.parent && d.parent.isBone &&
          (i.push(0, 0, 0),
            i.push(0, 0, 0),
            s.push(o.r, o.g, o.b),
            s.push(a.r, a.g, a.b));
      }
      r.setAttribute("position", new ke(i, 3)),
        r.setAttribute("color", new ke(s, 3));
      let u = new Un({
        vertexColors: !0,
        depthTest: !1,
        depthWrite: !1,
        toneMapped: !1,
        transparent: !0,
      });
      super(r, u);
      this.isSkeletonHelper = !0,
        this.type = "SkeletonHelper",
        this.root = e,
        this.bones = t,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1;
    }
    updateMatrixWorld(e) {
      let t = this.bones, r = this.geometry, i = r.getAttribute("position");
      dS.copy(this.root.matrixWorld).invert();
      for (let s = 0, o = 0; s < t.length; s++) {
        let a = t[s];
        a.parent && a.parent.isBone && (hg.multiplyMatrices(dS, a.matrixWorld),
          xa.setFromMatrixPosition(hg),
          i.setXYZ(o, xa.x, xa.y, xa.z),
          hg.multiplyMatrices(dS, a.parent.matrixWorld),
          xa.setFromMatrixPosition(hg),
          i.setXYZ(o + 1, xa.x, xa.y, xa.z),
          o += 2);
      }
      r.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
    }
  };
function U2(n) {
  let e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++) {
    e.push.apply(e, U2(n.children[t]));
  }
  return e;
}
var V2 = class extends Ot {
    constructor(e, t, r) {
      let i = new no(t, 4, 2),
        s = new en({ wireframe: !0, fog: !1, toneMapped: !1 });
      super(i, s);
      this.light = e,
        this.light.updateMatrixWorld(),
        this.color = r,
        this.type = "PointLightHelper",
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update();
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
    update() {
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
    }
  },
  U4 = new I(),
  H2 = new ve(),
  G2 = new ve(),
  j2 = class extends ct {
    constructor(e, t, r) {
      super();
      this.light = e,
        this.light.updateMatrixWorld(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = r;
      let i = new _l(t);
      i.rotateY(Math.PI * .5),
        this.material = new en({ wireframe: !0, fog: !1, toneMapped: !1 }),
        this.color === void 0 && (this.material.vertexColors = !0);
      let s = i.getAttribute("position"), o = new Float32Array(s.count * 3);
      i.setAttribute("color", new pt(o, 3)),
        this.add(new Ot(i, this.material)),
        this.update();
    }
    dispose() {
      this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }
    update() {
      let e = this.children[0];
      if (this.color !== void 0) this.material.color.set(this.color);
      else {
        let t = e.geometry.getAttribute("color");
        H2.copy(this.light.color), G2.copy(this.light.groundColor);
        for (let r = 0, i = t.count; r < i; r++) {
          let s = r < i / 2 ? H2 : G2;
          t.setXYZ(r, s.r, s.g, s.b);
        }
        t.needsUpdate = !0;
      }
      e.lookAt(U4.setFromMatrixPosition(this.light.matrixWorld).negate());
    }
  },
  W2 = class extends wr {
    constructor(e = 10, t = 10, r = 4473924, i = 8947848) {
      r = new ve(r), i = new ve(i);
      let s = t / 2, o = e / t, a = e / 2, u = [], f = [];
      for (let p = 0, g = 0, y = -a; p <= t; p++, y += o) {
        u.push(-a, 0, y, a, 0, y), u.push(y, 0, -a, y, 0, a);
        let v = p === s ? r : i;
        v.toArray(f, g),
          g += 3,
          v.toArray(f, g),
          g += 3,
          v.toArray(f, g),
          g += 3,
          v.toArray(f, g),
          g += 3;
      }
      let d = new Ye();
      d.setAttribute("position", new ke(u, 3)),
        d.setAttribute("color", new ke(f, 3));
      let h = new Un({ vertexColors: !0, toneMapped: !1 });
      super(d, h);
      this.type = "GridHelper";
    }
  },
  X2 = class extends wr {
    constructor(e = 10, t = 16, r = 8, i = 64, s = 4473924, o = 8947848) {
      s = new ve(s), o = new ve(o);
      let a = [], u = [];
      for (let h = 0; h <= t; h++) {
        let p = h / t * (Math.PI * 2), g = Math.sin(p) * e, y = Math.cos(p) * e;
        a.push(0, 0, 0), a.push(g, 0, y);
        let v = h & 1 ? s : o;
        u.push(v.r, v.g, v.b), u.push(v.r, v.g, v.b);
      }
      for (let h = 0; h <= r; h++) {
        let p = h & 1 ? s : o, g = e - e / r * h;
        for (let y = 0; y < i; y++) {
          let v = y / i * (Math.PI * 2),
            _ = Math.sin(v) * g,
            S = Math.cos(v) * g;
          a.push(_, 0, S),
            u.push(p.r, p.g, p.b),
            v = (y + 1) / i * (Math.PI * 2),
            _ = Math.sin(v) * g,
            S = Math.cos(v) * g,
            a.push(_, 0, S),
            u.push(p.r, p.g, p.b);
        }
      }
      let f = new Ye();
      f.setAttribute("position", new ke(a, 3)),
        f.setAttribute("color", new ke(u, 3));
      let d = new Un({ vertexColors: !0, toneMapped: !1 });
      super(f, d);
      this.type = "PolarGridHelper";
    }
  },
  q2 = new I(),
  pg = new I(),
  Y2 = new I(),
  Z2 = class extends ct {
    constructor(e, t, r) {
      super();
      this.light = e,
        this.light.updateMatrixWorld(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = r,
        t === void 0 && (t = 1);
      let i = new Ye();
      i.setAttribute(
        "position",
        new ke([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3),
      );
      let s = new Un({ fog: !1, toneMapped: !1 });
      this.lightPlane = new Fr(i, s),
        this.add(this.lightPlane),
        i = new Ye(),
        i.setAttribute("position", new ke([0, 0, 0, 0, 0, 1], 3)),
        this.targetLine = new Fr(i, s),
        this.add(this.targetLine),
        this.update();
    }
    dispose() {
      this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose();
    }
    update() {
      q2.setFromMatrixPosition(this.light.matrixWorld),
        pg.setFromMatrixPosition(this.light.target.matrixWorld),
        Y2.subVectors(pg, q2),
        this.lightPlane.lookAt(pg),
        this.color !== void 0
          ? (this.lightPlane.material.color.set(this.color),
            this.targetLine.material.color.set(this.color))
          : (this.lightPlane.material.color.copy(this.light.color),
            this.targetLine.material.color.copy(this.light.color)),
        this.targetLine.lookAt(pg),
        this.targetLine.scale.z = Y2.length();
    }
  },
  mg = new I(),
  hn = new oa(),
  K2 = class extends wr {
    constructor(e) {
      let t = new Ye(),
        r = new Un({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
        i = [],
        s = [],
        o = {};
      a("n1", "n2"),
        a("n2", "n4"),
        a("n4", "n3"),
        a("n3", "n1"),
        a("f1", "f2"),
        a("f2", "f4"),
        a("f4", "f3"),
        a("f3", "f1"),
        a("n1", "f1"),
        a("n2", "f2"),
        a("n3", "f3"),
        a("n4", "f4"),
        a("p", "n1"),
        a("p", "n2"),
        a("p", "n3"),
        a("p", "n4"),
        a("u1", "u2"),
        a("u2", "u3"),
        a("u3", "u1"),
        a("c", "t"),
        a("p", "c"),
        a("cn1", "cn2"),
        a("cn3", "cn4"),
        a("cf1", "cf2"),
        a("cf3", "cf4");
      function a(y, v) {
        u(y), u(v);
      }
      function u(y) {
        i.push(0, 0, 0),
          s.push(0, 0, 0),
          o[y] === void 0 && (o[y] = []),
          o[y].push(i.length / 3 - 1);
      }
      t.setAttribute("position", new ke(i, 3)),
        t.setAttribute("color", new ke(s, 3));
      super(t, r);
      this.type = "CameraHelper",
        this.camera = e,
        this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = o,
        this.update();
      let f = new ve(16755200),
        d = new ve(16711680),
        h = new ve(43775),
        p = new ve(16777215),
        g = new ve(3355443);
      this.setColors(f, d, h, p, g);
    }
    setColors(e, t, r, i, s) {
      let a = this.geometry.getAttribute("color");
      a.setXYZ(0, e.r, e.g, e.b),
        a.setXYZ(1, e.r, e.g, e.b),
        a.setXYZ(2, e.r, e.g, e.b),
        a.setXYZ(3, e.r, e.g, e.b),
        a.setXYZ(4, e.r, e.g, e.b),
        a.setXYZ(5, e.r, e.g, e.b),
        a.setXYZ(6, e.r, e.g, e.b),
        a.setXYZ(7, e.r, e.g, e.b),
        a.setXYZ(8, e.r, e.g, e.b),
        a.setXYZ(9, e.r, e.g, e.b),
        a.setXYZ(10, e.r, e.g, e.b),
        a.setXYZ(11, e.r, e.g, e.b),
        a.setXYZ(12, e.r, e.g, e.b),
        a.setXYZ(13, e.r, e.g, e.b),
        a.setXYZ(14, e.r, e.g, e.b),
        a.setXYZ(15, e.r, e.g, e.b),
        a.setXYZ(16, e.r, e.g, e.b),
        a.setXYZ(17, e.r, e.g, e.b),
        a.setXYZ(18, e.r, e.g, e.b),
        a.setXYZ(19, e.r, e.g, e.b),
        a.setXYZ(20, e.r, e.g, e.b),
        a.setXYZ(21, e.r, e.g, e.b),
        a.setXYZ(22, e.r, e.g, e.b),
        a.setXYZ(23, e.r, e.g, e.b),
        a.setXYZ(24, t.r, t.g, t.b),
        a.setXYZ(25, t.r, t.g, t.b),
        a.setXYZ(26, t.r, t.g, t.b),
        a.setXYZ(27, t.r, t.g, t.b),
        a.setXYZ(28, t.r, t.g, t.b),
        a.setXYZ(29, t.r, t.g, t.b),
        a.setXYZ(30, t.r, t.g, t.b),
        a.setXYZ(31, t.r, t.g, t.b),
        a.setXYZ(32, r.r, r.g, r.b),
        a.setXYZ(33, r.r, r.g, r.b),
        a.setXYZ(34, r.r, r.g, r.b),
        a.setXYZ(35, r.r, r.g, r.b),
        a.setXYZ(36, r.r, r.g, r.b),
        a.setXYZ(37, r.r, r.g, r.b),
        a.setXYZ(38, i.r, i.g, i.b),
        a.setXYZ(39, i.r, i.g, i.b),
        a.setXYZ(40, s.r, s.g, s.b),
        a.setXYZ(41, s.r, s.g, s.b),
        a.setXYZ(42, s.r, s.g, s.b),
        a.setXYZ(43, s.r, s.g, s.b),
        a.setXYZ(44, s.r, s.g, s.b),
        a.setXYZ(45, s.r, s.g, s.b),
        a.setXYZ(46, s.r, s.g, s.b),
        a.setXYZ(47, s.r, s.g, s.b),
        a.setXYZ(48, s.r, s.g, s.b),
        a.setXYZ(49, s.r, s.g, s.b),
        a.needsUpdate = !0;
    }
    update() {
      let e = this.geometry, t = this.pointMap, r = 1, i = 1;
      hn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
        xn("c", t, e, hn, 0, 0, -1),
        xn("t", t, e, hn, 0, 0, 1),
        xn("n1", t, e, hn, -r, -i, -1),
        xn("n2", t, e, hn, r, -i, -1),
        xn("n3", t, e, hn, -r, i, -1),
        xn("n4", t, e, hn, r, i, -1),
        xn("f1", t, e, hn, -r, -i, 1),
        xn("f2", t, e, hn, r, -i, 1),
        xn("f3", t, e, hn, -r, i, 1),
        xn("f4", t, e, hn, r, i, 1),
        xn("u1", t, e, hn, r * .7, i * 1.1, -1),
        xn("u2", t, e, hn, -r * .7, i * 1.1, -1),
        xn("u3", t, e, hn, 0, i * 2, -1),
        xn("cf1", t, e, hn, -r, 0, 1),
        xn("cf2", t, e, hn, r, 0, 1),
        xn("cf3", t, e, hn, 0, -i, 1),
        xn("cf4", t, e, hn, 0, i, 1),
        xn("cn1", t, e, hn, -r, 0, -1),
        xn("cn2", t, e, hn, r, 0, -1),
        xn("cn3", t, e, hn, 0, -i, -1),
        xn("cn4", t, e, hn, 0, i, -1),
        e.getAttribute("position").needsUpdate = !0;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  };
function xn(n, e, t, r, i, s, o) {
  mg.set(i, s, o).unproject(r);
  let a = e[n];
  if (a !== void 0) {
    let u = t.getAttribute("position");
    for (let f = 0, d = a.length; f < d; f++) u.setXYZ(a[f], mg.x, mg.y, mg.z);
  }
}
var gg = new Yi(),
  J2 = class extends wr {
    constructor(e, t = 16776960) {
      let r = new Uint16Array([
          0,
          1,
          1,
          2,
          2,
          3,
          3,
          0,
          4,
          5,
          5,
          6,
          6,
          7,
          7,
          4,
          0,
          4,
          1,
          5,
          2,
          6,
          3,
          7,
        ]),
        i = new Float32Array(8 * 3),
        s = new Ye();
      s.setIndex(new pt(r, 1)), s.setAttribute("position", new pt(i, 3));
      super(s, new Un({ color: t, toneMapped: !1 }));
      this.object = e,
        this.type = "BoxHelper",
        this.matrixAutoUpdate = !1,
        this.update();
    }
    update(e) {
      if (
        e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
          this.object !== void 0 && gg.setFromObject(this.object),
          gg.isEmpty()
      ) return;
      let t = gg.min,
        r = gg.max,
        i = this.geometry.attributes.position,
        s = i.array;
      s[0] = r.x,
        s[1] = r.y,
        s[2] = r.z,
        s[3] = t.x,
        s[4] = r.y,
        s[5] = r.z,
        s[6] = t.x,
        s[7] = t.y,
        s[8] = r.z,
        s[9] = r.x,
        s[10] = t.y,
        s[11] = r.z,
        s[12] = r.x,
        s[13] = r.y,
        s[14] = t.z,
        s[15] = t.x,
        s[16] = r.y,
        s[17] = t.z,
        s[18] = t.x,
        s[19] = t.y,
        s[20] = t.z,
        s[21] = r.x,
        s[22] = t.y,
        s[23] = t.z,
        i.needsUpdate = !0,
        this.geometry.computeBoundingSphere();
    }
    setFromObject(e) {
      return this.object = e, this.update(), this;
    }
    copy(e, t) {
      return super.copy(e, t), this.object = e.object, this;
    }
  },
  Q2 = class extends wr {
    constructor(e, t = 16776960) {
      let r = new Uint16Array([
          0,
          1,
          1,
          2,
          2,
          3,
          3,
          0,
          4,
          5,
          5,
          6,
          6,
          7,
          7,
          4,
          0,
          4,
          1,
          5,
          2,
          6,
          3,
          7,
        ]),
        i = [
          1,
          1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          -1,
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          -1,
          -1,
          -1,
          1,
          -1,
          -1,
        ],
        s = new Ye();
      s.setIndex(new pt(r, 1)), s.setAttribute("position", new ke(i, 3));
      super(s, new Un({ color: t, toneMapped: !1 }));
      this.box = e,
        this.type = "Box3Helper",
        this.geometry.computeBoundingSphere();
    }
    updateMatrixWorld(e) {
      let t = this.box;
      t.isEmpty() ||
        (t.getCenter(this.position),
          t.getSize(this.scale),
          this.scale.multiplyScalar(.5),
          super.updateMatrixWorld(e));
    }
  },
  $2 = class extends Fr {
    constructor(e, t = 1, r = 16776960) {
      let i = r,
        s = [
          1,
          -1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          -1,
          1,
          1,
          1,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
        ],
        o = new Ye();
      o.setAttribute("position", new ke(s, 3)), o.computeBoundingSphere();
      super(o, new Un({ color: i, toneMapped: !1 }));
      this.type = "PlaneHelper", this.plane = e, this.size = t;
      let a = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
        u = new Ye();
      u.setAttribute("position", new ke(a, 3)),
        u.computeBoundingSphere(),
        this.add(
          new Ot(
            u,
            new en({
              color: i,
              opacity: .2,
              transparent: !0,
              depthWrite: !1,
              toneMapped: !1,
            }),
          ),
        );
    }
    updateMatrixWorld(e) {
      let t = -this.plane.constant;
      Math.abs(t) < 1e-8 && (t = 1e-8),
        this.scale.set(.5 * this.size, .5 * this.size, t),
        this.children[0].material.side = t < 0 ? mr : Gs,
        this.lookAt(this.plane.normal),
        super.updateMatrixWorld(e);
    }
  },
  e3 = new I(),
  vg,
  hS,
  t3 = class extends ct {
    constructor(
      e = new I(0, 0, 1),
      t = new I(0, 0, 0),
      r = 1,
      i = 16776960,
      s = r * .2,
      o = s * .2,
    ) {
      super();
      this.type = "ArrowHelper",
        vg === void 0 &&
        (vg = new Ye(),
          vg.setAttribute("position", new ke([0, 0, 0, 0, 1, 0], 3)),
          hS = new ua(0, .5, 1, 5, 1),
          hS.translate(0, -.5, 0)),
        this.position.copy(t),
        this.line = new Fr(vg, new Un({ color: i, toneMapped: !1 })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new Ot(hS, new en({ color: i, toneMapped: !1 })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(e),
        this.setLength(r, s, o);
    }
    setDirection(e) {
      if (e.y > .99999) this.quaternion.set(0, 0, 0, 1);
      else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
      else {
        e3.set(e.z, 0, -e.x).normalize();
        let t = Math.acos(e.y);
        this.quaternion.setFromAxisAngle(e3, t);
      }
    }
    setLength(e, t = e * .2, r = t * .2) {
      this.line.scale.set(1, Math.max(1e-4, e - t), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(r, t, r),
        this.cone.position.y = e,
        this.cone.updateMatrix();
    }
    setColor(e) {
      this.line.material.color.set(e), this.cone.material.color.set(e);
    }
    copy(e) {
      return super.copy(e, !1),
        this.line.copy(e.line),
        this.cone.copy(e.cone),
        this;
    }
  },
  n3 = class extends wr {
    constructor(e = 1) {
      let t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
        r = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
        i = new Ye();
      i.setAttribute("position", new ke(t, 3)),
        i.setAttribute("color", new ke(r, 3));
      let s = new Un({ vertexColors: !0, toneMapped: !1 });
      super(i, s);
      this.type = "AxesHelper";
    }
    setColors(e, t, r) {
      let i = new ve(), s = this.geometry.attributes.color.array;
      return i.set(e),
        i.toArray(s, 0),
        i.toArray(s, 3),
        i.set(t),
        i.toArray(s, 6),
        i.toArray(s, 9),
        i.set(r),
        i.toArray(s, 12),
        i.toArray(s, 15),
        this.geometry.attributes.color.needsUpdate = !0,
        this;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  },
  r3 = class {
    constructor() {
      this.type = "ShapePath",
        this.color = new ve(),
        this.subPaths = [],
        this.currentPath = null;
    }
    moveTo(e, t) {
      return this.currentPath = new tc(),
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(e, t),
        this;
    }
    lineTo(e, t) {
      return this.currentPath.lineTo(e, t), this;
    }
    quadraticCurveTo(e, t, r, i) {
      return this.currentPath.quadraticCurveTo(e, t, r, i), this;
    }
    bezierCurveTo(e, t, r, i, s, o) {
      return this.currentPath.bezierCurveTo(e, t, r, i, s, o), this;
    }
    splineThru(e) {
      return this.currentPath.splineThru(e), this;
    }
    toShapes(e, t) {
      function r(w) {
        let M = [];
        for (let T = 0, b = w.length; T < b; T++) {
          let R = w[T], P = new ca();
          P.curves = R.curves, M.push(P);
        }
        return M;
      }
      function i(w, M) {
        let T = M.length, b = !1;
        for (let R = T - 1, P = 0; P < T; R = P++) {
          let C = M[R], L = M[P], k = L.x - C.x, z = L.y - C.y;
          if (Math.abs(z) > Number.EPSILON) {
            if (
              z < 0 && (C = M[P], k = -k, L = M[R], z = -z),
                w.y < C.y || w.y > L.y
            ) continue;
            if (w.y === C.y) { if (w.x === C.x) return !0; }
            else {
              let Y = z * (w.x - C.x) - k * (w.y - C.y);
              if (Y === 0) return !0;
              if (Y < 0) continue;
              b = !b;
            }
          } else {
            if (w.y !== C.y) continue;
            if (L.x <= w.x && w.x <= C.x || C.x <= w.x && w.x <= L.x) return !0;
          }
        }
        return b;
      }
      let s = es.isClockWise, o = this.subPaths;
      if (o.length === 0) return [];
      if (t === !0) return r(o);
      let a, u, f, d = [];
      if (o.length === 1) {
        return u = o[0], f = new ca(), f.curves = u.curves, d.push(f), d;
      }
      let h = !s(o[0].getPoints());
      h = e ? !h : h;
      let p = [], g = [], y = [], v = 0, _;
      g[v] = void 0, y[v] = [];
      for (let w = 0, M = o.length; w < M; w++) {
        u = o[w],
          _ = u.getPoints(),
          a = s(_),
          a = e ? !a : a,
          a
            ? (!h && g[v] && v++,
              g[v] = { s: new ca(), p: _ },
              g[v].s.curves = u.curves,
              h && v++,
              y[v] = [])
            : y[v].push({ h: u, p: _[0] });
      }
      if (!g[0]) return r(o);
      if (g.length > 1) {
        let w = !1, M = 0;
        for (let T = 0, b = g.length; T < b; T++) p[T] = [];
        for (let T = 0, b = g.length; T < b; T++) {
          let R = y[T];
          for (let P = 0; P < R.length; P++) {
            let C = R[P], L = !0;
            for (let k = 0; k < g.length; k++) {
              i(C.p, g[k].p) &&
                (T !== k && M++, L ? (L = !1, p[k].push(C)) : w = !0);
            }
            L && p[T].push(C);
          }
        }
        M > 0 && w === !1 && (y = p);
      }
      let S;
      for (let w = 0, M = g.length; w < M; w++) {
        f = g[w].s, d.push(f), S = y[w];
        for (let T = 0, b = S.length; T < b; T++) f.holes.push(S[T].h);
      }
      return d;
    }
  },
  {
    floatView: i3,
    uint32View: s3,
    baseTable: V4,
    shiftTable: H4,
    mantissaTable: G4,
    exponentTable: j4,
    offsetTable: W4,
  } = X4();
function X4() {
  let n = new ArrayBuffer(4),
    e = new Float32Array(n),
    t = new Uint32Array(n),
    r = new Uint32Array(512),
    i = new Uint32Array(512);
  for (let u = 0; u < 256; ++u) {
    let f = u - 127;
    f < -27
      ? (r[u] = 0, r[u | 256] = 32768, i[u] = 24, i[u | 256] = 24)
      : f < -14
      ? (r[u] = 1024 >> -f - 14,
        r[u | 256] = 1024 >> -f - 14 | 32768,
        i[u] = -f - 1,
        i[u | 256] = -f - 1)
      : f <= 15
      ? (r[u] = f + 15 << 10,
        r[u | 256] = f + 15 << 10 | 32768,
        i[u] = 13,
        i[u | 256] = 13)
      : f < 128
      ? (r[u] = 31744, r[u | 256] = 64512, i[u] = 24, i[u | 256] = 24)
      : (r[u] = 31744, r[u | 256] = 64512, i[u] = 13, i[u | 256] = 13);
  }
  let s = new Uint32Array(2048),
    o = new Uint32Array(64),
    a = new Uint32Array(64);
  for (let u = 1; u < 1024; ++u) {
    let f = u << 13, d = 0;
    for (; (f & 8388608) == 0;) f <<= 1, d -= 8388608;
    f &= ~8388608, d += 947912704, s[u] = f | d;
  }
  for (let u = 1024; u < 2048; ++u) s[u] = 939524096 + (u - 1024 << 13);
  for (let u = 1; u < 31; ++u) o[u] = u << 23;
  o[31] = 1199570944, o[32] = 2147483648;
  for (let u = 33; u < 63; ++u) o[u] = 2147483648 + (u - 32 << 23);
  o[63] = 3347054592;
  for (let u = 1; u < 64; ++u) u !== 32 && (a[u] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: r,
    shiftTable: i,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: a,
  };
}
function q4(n) {
  Math.abs(n) > 65504 &&
  console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    n = yn(n, -65504, 65504),
    i3[0] = n;
  let e = s3[0], t = e >> 23 & 511;
  return V4[t] + ((e & 8388607) >> H4[t]);
}
function Y4(n) {
  let e = n >> 10;
  return s3[0] = G4[W4[e] + (n & 1023)] + j4[e], i3[0];
}
var Z4 = Object.freeze({ __proto__: null, toHalfFloat: q4, fromHalfFloat: Y4 }),
  o3 = class extends Ye {
    constructor() {
      console.error(
        "THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js",
      );
      super();
    }
  },
  a3 = class extends Ye {
    constructor() {
      console.error(
        "THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js",
      );
      super();
    }
  };
function K4() {
  console.error(
    "THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js",
  );
}
function J4() {
  console.error(
    "THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js",
  );
}
function Q4() {
  console.error("THREE.ImmediateRenderObject has been removed.");
}
var l3 = class extends yr {
    constructor(e, t, r) {
      console.error(
        'THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.',
      );
      super(e, t, r);
      this.samples = 4;
    }
  },
  u3 = class extends Ru {
    constructor(e, t, r, i) {
      console.warn(
        "THREE.DataTexture2DArray has been renamed to DataArrayTexture.",
      );
      super(e, t, r, i);
    }
  },
  c3 = class extends qf {
    constructor(e, t, r, i) {
      console.warn("THREE.DataTexture3D has been renamed to Data3DTexture.");
      super(e, t, r, i);
    }
  };
typeof __THREE_DEVTOOLS__ != "undefined" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: qp } }),
  );
typeof window != "undefined" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : window.__THREE__ = qp);
var f3 = (n) => {
    let e = (0, Li.useRef)();
    return (0, Li.useEffect)(() => {
      if (n && e.current && e.current.matrix) {
        let t = new Ge();
        t.set(...n),
          t.transpose(),
          e.current.matrix.identity(),
          e.current.applyMatrix4(t);
      }
    }, [n]),
      e;
  },
  d3 = (n) => {
    let e = (0, Li.useRef)();
    return (0, Li.useLayoutEffect)(() => {
      let t = new Ge();
      t.set(...n), e.current.matrix = t;
    }, [n]),
      e;
  },
  h3 = (n) =>
    (0, Li.useMemo)(() => {
      let { vertices: t, faces: r } = n,
        i = ([u, f, d]) => {
          let h = new I().subVectors(f, u), p = new I().subVectors(d, u);
          return new I().crossVectors(h, p).normalize();
        },
        s = [],
        o = [];
      r.forEach((u) => {
        let f = u.vertices.map((g) => t[g]), { x: d, y: h, z: p } = i(f);
        f.forEach(({ x: g, y, z: v }) => {
          s.push(g, y, v), o.push(d, h, p);
        });
      });
      let a = new Ye();
      return a.setAttribute("position", new ke(s, 3)),
        a.setAttribute("normal", new ke(o, 3)),
        a.computeBoundingSphere(),
        a;
    }, [n]),
  p3 = () => {
    let [n, e] = (0, Li.useState)(!1);
    return (0, Li.useEffect)(() => {
      let t = window.navigator.xr;
      t && t.isSessionSupported("immersive-vr").then((r) => e(r));
    }, []),
      n;
  };
var Cd = rn(An());
var xt = rn(An());
var tn = rn(An()), Es = rn(pS());
var Mr = rn(An());
function $4(n) {
  let e,
    t = new Set(),
    r = (f, d) => {
      let h = typeof f == "function" ? f(e) : f;
      if (h !== e) {
        let p = e;
        e = d ? h : Object.assign({}, e, h), t.forEach((g) => g(e, p));
      }
    },
    i = () => e,
    s = (f, d = i, h = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware",
      );
      let p = d(e);
      function g() {
        let y = d(e);
        if (!h(p, y)) {
          let v = p;
          f(p = y, v);
        }
      }
      return t.add(g), () => t.delete(g);
    },
    u = {
      setState: r,
      getState: i,
      subscribe: (f, d, h) =>
        d || h ? s(f, d, h) : (t.add(f), () => t.delete(f)),
      destroy: () => t.clear(),
    };
  return e = n(r, i, u), u;
}
var eB = typeof window == "undefined" || !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  v3 = eB ? Mr.useEffect : Mr.useLayoutEffect;
function y3(n) {
  let e = typeof n == "function" ? $4(n) : n,
    t = (r = e.getState, i = Object.is) => {
      let [, s] = (0, Mr.useReducer)((_) => _ + 1, 0),
        o = e.getState(),
        a = (0, Mr.useRef)(o),
        u = (0, Mr.useRef)(r),
        f = (0, Mr.useRef)(i),
        d = (0, Mr.useRef)(!1),
        h = (0, Mr.useRef)();
      h.current === void 0 && (h.current = r(o));
      let p, g = !1;
      (a.current !== o || u.current !== r || f.current !== i || d.current) &&
      (p = r(o), g = !i(h.current, p)),
        v3(() => {
          g && (h.current = p),
            a.current = o,
            u.current = r,
            f.current = i,
            d.current = !1;
        });
      let y = (0, Mr.useRef)(o);
      v3(() => {
        let _ = () => {
            try {
              let w = e.getState(), M = u.current(w);
              f.current(h.current, M) || (a.current = w, h.current = M, s());
            } catch {
              d.current = !0, s();
            }
          },
          S = e.subscribe(_);
        return e.getState() !== y.current && _(), S;
      }, []);
      let v = g ? p : h.current;
      return (0, Mr.useDebugValue)(v), v;
    };
  return Object.assign(t, e),
    t[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4",
      );
      let r = [t, e];
      return {
        next() {
          let i = r.length <= 0;
          return { value: r.shift(), done: i };
        },
      };
    },
    t;
}
var z3 = rn(ES()), Eg = rn(Mg());
function N3(n, e, t = (r, i) => r === i) {
  if (n === e) return !0;
  if (!n || !e) return !1;
  let r = n.length;
  if (e.length !== r) return !1;
  for (let i = 0; i < r; i++) if (!t(n[i], e[i])) return !1;
  return !0;
}
var lo = [];
function D3(n, e, t = !1, r = {}) {
  for (let s of lo) {
    if (N3(e, s.keys, s.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error;
      if (Object.prototype.hasOwnProperty.call(s, "response")) {
        return s.response;
      }
      if (!t) throw s.promise;
    }
  }
  let i = {
    keys: e,
    equal: r.equal,
    promise: n(...e).then((s) => i.response = s).then(() => {
      r.lifespan && r.lifespan > 0 && setTimeout(() => {
        let s = lo.indexOf(i);
        s !== -1 && lo.splice(s, 1);
      }, r.lifespan);
    }).catch((s) => i.error = s),
  };
  if (lo.push(i), !t) throw i.promise;
}
var k3 = (n, e, t) => D3(n, e, !1, t), F3 = (n, e, t) => void D3(n, e, !0, t);
var O3 = (n) => {
  if (n === void 0 || n.length === 0) lo.splice(0, lo.length);
  else {
    let e = lo.find((t) => N3(n, t.keys, t.equal));
    if (e) {
      let t = lo.indexOf(e);
      t !== -1 && lo.splice(t, 1);
    }
  }
};
var B3,
  U3,
  V3 = (n) => n && n.isOrthographicCamera,
  H3 = (n) => n && n.hasOwnProperty("current"),
  vc =
    typeof window != "undefined" &&
      ((B3 = window.document) != null && B3.createElement ||
        ((U3 = window.navigator) == null ? void 0 : U3.product) ===
          "ReactNative")
      ? tn.useLayoutEffect
      : tn.useEffect;
function TS(n) {
  let e = tn.useRef(n);
  return vc(() => void (e.current = n), [n]), e;
}
function G3({ set: n }) {
  return vc(() => (n(new Promise(() => null)), () => n(!1)), [n]), null;
}
var Tg = class extends tn.Component {
  constructor(...e) {
    super(...e);
    this.state = { error: !1 };
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
};
Tg.getDerivedStateFromError = () => ({ error: !0 });
var j3 = "__default", nB = (n) => n && !!n.memoized && !!n.changes;
function W3(n) {
  let e = typeof window != "undefined" ? window.devicePixelRatio : 1;
  return Array.isArray(n) ? Math.min(Math.max(n[0], e), n[1]) : n;
}
var yc = (n) => {
    var e;
    return (e = n.__r3f) == null ? void 0 : e.root.getState();
  },
  cn = {
    obj: (n) => n === Object(n) && !cn.arr(n) && typeof n != "function",
    fun: (n) => typeof n == "function",
    str: (n) => typeof n == "string",
    num: (n) => typeof n == "number",
    boo: (n) => typeof n == "boolean",
    und: (n) => n === void 0,
    arr: (n) => Array.isArray(n),
    equ(
      n,
      e,
      { arrays: t = "shallow", objects: r = "reference", strict: i = !0 } = {},
    ) {
      if (typeof n != typeof e || !!n != !!e) return !1;
      if (cn.str(n) || cn.num(n)) return n === e;
      let s = cn.obj(n);
      if (s && r === "reference") return n === e;
      let o = cn.arr(n);
      if (o && t === "reference") return n === e;
      if ((o || s) && n === e) return !0;
      let a;
      for (a in n) if (!(a in e)) return !1;
      for (a in i ? e : n) if (n[a] !== e[a]) return !1;
      if (cn.und(a)) {
        if (
          o && n.length === 0 && e.length === 0 ||
          s && Object.keys(n).length === 0 && Object.keys(e).length === 0
        ) return !0;
        if (n !== e) return !1;
      }
      return !0;
    },
  };
function rB(n) {
  let e = { nodes: {}, materials: {} };
  return n && n.traverse((t) => {
    t.name && (e.nodes[t.name] = t),
      t.material && !e.materials[t.material.name] &&
      (e.materials[t.material.name] = t.material);
  }),
    e;
}
function X3(n) {
  n.dispose && n.type !== "Scene" && n.dispose();
  for (let e in n) e.dispose == null || e.dispose(), delete n[e];
}
function xc(n, e) {
  let t = n;
  return (e != null && e.primitive || !t.__r3f) &&
    (t.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    n;
}
function AS(n, e) {
  let t = n;
  if (e.includes("-")) {
    let r = e.split("-"), i = r.pop();
    return t = r.reduce((s, o) => s[o], n), { target: t, key: i };
  } else return { target: t, key: e };
}
var q3 = /-\d+$/;
function CS(n, e, t) {
  if (cn.str(t)) {
    if (q3.test(t)) {
      let s = t.replace(q3, ""), { target: o, key: a } = AS(n, s);
      Array.isArray(o[a]) || (o[a] = []);
    }
    let { target: r, key: i } = AS(n, t);
    e.__r3f.previousAttach = r[i], r[i] = e;
  } else e.__r3f.previousAttach = t(n, e);
}
function Y3(n, e, t) {
  var r, i;
  if (cn.str(t)) {
    let { target: s, key: o } = AS(n, t), a = e.__r3f.previousAttach;
    a === void 0 ? delete s[o] : s[o] = a;
  } else {(r = e.__r3f) == null || r.previousAttach == null ||
      r.previousAttach(n, e);}
  (i = e.__r3f) == null || delete i.previousAttach;
}
function Z3(
  n,
  { children: e, key: t, ref: r, ...i },
  { children: s, key: o, ref: a, ...u } = {},
  f = !1,
) {
  var d;
  let h = (d = n == null ? void 0 : n.__r3f) != null ? d : {},
    p = Object.entries(i),
    g = [];
  if (f) {
    let v = Object.keys(u);
    for (let _ = 0; _ < v.length; _++) {
      i.hasOwnProperty(v[_]) || p.unshift([v[_], j3 + "remove"]);
    }
  }
  p.forEach(([v, _]) => {
    var S;
    if (
      (S = n.__r3f) != null && S.primitive && v === "object" || cn.equ(_, u[v])
    ) return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(v)) {
      return g.push([v, _, !0, []]);
    }
    let w = [];
    v.includes("-") && (w = v.split("-")), g.push([v, _, !1, w]);
    for (let M in i) {
      let T = i[M];
      M.startsWith(`${v}-`) && g.push([M, T, !1, M.split("-")]);
    }
  });
  let y = { ...i };
  return h.memoizedProps && h.memoizedProps.args &&
    (y.args = h.memoizedProps.args),
    h.memoizedProps && h.memoizedProps.attach &&
    (y.attach = h.memoizedProps.attach),
    { memoized: y, changes: g };
}
function bS(n, e) {
  var t, r, i;
  let s = (t = n.__r3f) != null ? t : {},
    o = s.root,
    a = (r = o == null || o.getState == null ? void 0 : o.getState()) != null
      ? r
      : {},
    { memoized: u, changes: f } = nB(e) ? e : Z3(n, e),
    d = s.eventCount;
  n.__r3f && (n.__r3f.memoizedProps = u);
  for (let g = 0; g < f.length; g++) {
    let [y, v, _, S] = f[g], w = n, M = w[y];
    if (S.length && (M = S.reduce((T, b) => T[b], n), !(M && M.set))) {
      let [T, ...b] = S.reverse();
      w = b.reverse().reduce((R, P) => R[P], n), y = T;
    }
    if (v === j3 + "remove") {
      if (M && M.constructor) {
        var h;
        v = new M.constructor(...(h = u.args) != null ? h : []);
      } else if (w.constructor) {
        var p;
        let T = new w.constructor(
          ...(p = w.__r3f.memoizedProps.args) != null ? p : [],
        );
        v = T[M], T.dispose && T.dispose();
      } else v = 0;
    }
    if (_) {
      v ? s.handlers[y] = v : delete s.handlers[y],
        s.eventCount = Object.keys(s.handlers).length;
    } else if (M && M.set && (M.copy || M instanceof na)) {
      if (Array.isArray(v)) {
        M.fromArray ? M.fromArray(v) : M.set(...v);
      } else if (
        M.copy && v && v.constructor &&
        M.constructor.name === v.constructor.name
      ) M.copy(v);
      else if (v !== void 0) {
        let T = M instanceof ve;
        !T && M.setScalar
          ? M.setScalar(v)
          : M instanceof na && v instanceof na
          ? M.mask = v.mask
          : M.set(v),
          !("ColorManagement" in Rl) && !a.linear && T &&
          M.convertSRGBToLinear();
      }
    } else w[y] = v, !a.linear && w[y] instanceof Qt && (w[y].encoding = yt);
    _c(n);
  }
  if (s.parent && a.internal && n.raycast && d !== s.eventCount) {
    let g = a.internal.interaction.indexOf(n);
    g > -1 && a.internal.interaction.splice(g, 1),
      s.eventCount && a.internal.interaction.push(n);
  }
  return f.length && (i = n.__r3f) != null && i.parent && RS(n), n;
}
function _c(n) {
  var e, t;
  let r = (e = n.__r3f) == null || (t = e.root) == null || t.getState == null
    ? void 0
    : t.getState();
  r && r.internal.frames === 0 && r.invalidate();
}
function RS(n) {
  n.onUpdate == null || n.onUpdate(n);
}
function iB(n, e) {
  n.manual ||
    (V3(n)
      ? (n.left = e.width / -2,
        n.right = e.width / 2,
        n.top = e.height / 2,
        n.bottom = e.height / -2)
      : n.aspect = e.width / e.height,
      n.updateProjectionMatrix(),
      n.updateMatrixWorld());
}
function sB(n, e, t) {
  let r = t.pop(), i = t.reduce((s, o) => s[o], n);
  return i[r] = e;
}
function Ag(n) {
  return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId;
}
function oB() {
  var n;
  let e = typeof self != "undefined" && self ||
    typeof window != "undefined" && window;
  if (!e) return Es.DefaultEventPriority;
  switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return Es.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return Es.ContinuousEventPriority;
    default:
      return Es.DefaultEventPriority;
  }
}
function K3(n, e, t, r) {
  let i = t.get(e);
  i &&
    (t.delete(e),
      t.size === 0 && (n.delete(r), i.target.releasePointerCapture(r)));
}
function aB(n, e) {
  let { internal: t } = n.getState();
  t.interaction = t.interaction.filter((r) => r !== e),
    t.initialHits = t.initialHits.filter((r) => r !== e),
    t.hovered.forEach((r, i) => {
      (r.eventObject === e || r.object === e) && t.hovered.delete(i);
    }),
    t.capturedMap.forEach((r, i) => {
      K3(t.capturedMap, e, r, i);
    });
}
function LS(n) {
  function e(u) {
    let { internal: f } = n.getState(),
      d = u.offsetX - f.initialClick[0],
      h = u.offsetY - f.initialClick[1];
    return Math.round(Math.sqrt(d * d + h * h));
  }
  function t(u) {
    return u.filter((f) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((d) => {
        var h;
        return (h = f.__r3f) == null ? void 0 : h.handlers["onPointer" + d];
      })
    );
  }
  function r(u, f) {
    let d = n.getState(),
      h = new Set(),
      p = [],
      g = f ? f(d.internal.interaction) : d.internal.interaction;
    for (let S = 0; S < g.length; S++) {
      let w = yc(g[S]);
      w && (w.raycaster.camera = void 0);
    }
    d.previousRoot || d.events.compute == null || d.events.compute(u, d);
    function y(S) {
      let w = yc(S);
      if (!w || !w.events.enabled || w.raycaster.camera === null) return [];
      if (w.raycaster.camera === void 0) {
        var M;
        w.events.compute == null ||
        w.events.compute(
          u,
          w,
          (M = w.previousRoot) == null ? void 0 : M.getState(),
        ), w.raycaster.camera === void 0 && (w.raycaster.camera = null);
      }
      return w.raycaster.camera ? w.raycaster.intersectObject(S, !0) : [];
    }
    let v = g.flatMap(y).sort((S, w) => {
      let M = yc(S.object), T = yc(w.object);
      return !M || !T
        ? S.distance - w.distance
        : T.events.priority - M.events.priority || S.distance - w.distance;
    }).filter((S) => {
      let w = Ag(S);
      return h.has(w) ? !1 : (h.add(w), !0);
    });
    d.events.filter && (v = d.events.filter(v, d));
    for (let S of v) {
      let w = S.object;
      for (; w;) {
        var _;
        (_ = w.__r3f) != null && _.eventCount &&
        p.push({ ...S, eventObject: w }), w = w.parent;
      }
    }
    if ("pointerId" in u && d.internal.capturedMap.has(u.pointerId)) {
      for (let S of d.internal.capturedMap.get(u.pointerId).values()) {
        h.has(Ag(S.intersection)) || p.push(S.intersection);
      }
    }
    return p;
  }
  function i(u, f, d, h) {
    let p = n.getState();
    if (u.length) {
      let g = { stopped: !1 };
      for (let y of u) {
        let v = yc(y.object) || p,
          { raycaster: _, pointer: S, camera: w, internal: M } = v,
          T = new I(S.x, S.y, 0).unproject(w),
          b = (k) => {
            var z, Y;
            return (z = (Y = M.capturedMap.get(k)) == null
                ? void 0
                : Y.has(y.eventObject)) != null
              ? z
              : !1;
          },
          R = (k) => {
            let z = { intersection: y, target: f.target };
            M.capturedMap.has(k)
              ? M.capturedMap.get(k).set(y.eventObject, z)
              : M.capturedMap.set(k, new Map([[y.eventObject, z]])),
              f.target.setPointerCapture(k);
          },
          P = (k) => {
            let z = M.capturedMap.get(k);
            z && K3(M.capturedMap, y.eventObject, z, k);
          },
          C = {};
        for (let k in f) {
          let z = f[k];
          typeof z != "function" && (C[k] = z);
        }
        let L = {
          ...y,
          ...C,
          pointer: S,
          intersections: u,
          stopped: g.stopped,
          delta: d,
          unprojectedPoint: T,
          ray: _.ray,
          camera: w,
          stopPropagation() {
            let k = "pointerId" in f && M.capturedMap.get(f.pointerId);
            if (
              (!k || k.has(y.eventObject)) &&
              (L.stopped = g.stopped = !0,
                M.hovered.size && Array.from(M.hovered.values()).find((z) =>
                  z.eventObject === y.eventObject
                ))
            ) {
              let z = u.slice(0, u.indexOf(y));
              s([...z, y]);
            }
          },
          target: {
            hasPointerCapture: b,
            setPointerCapture: R,
            releasePointerCapture: P,
          },
          currentTarget: {
            hasPointerCapture: b,
            setPointerCapture: R,
            releasePointerCapture: P,
          },
          nativeEvent: f,
        };
        if (h(L), g.stopped === !0) break;
      }
    }
    return u;
  }
  function s(u) {
    let { internal: f } = n.getState();
    for (let d of f.hovered.values()) {
      if (
        !u.length || !u.find((h) =>
          h.object === d.object && h.index === d.index &&
          h.instanceId === d.instanceId
        )
      ) {
        let p = d.eventObject.__r3f, g = p == null ? void 0 : p.handlers;
        if (f.hovered.delete(Ag(d)), p != null && p.eventCount) {
          let y = { ...d, intersections: u };
          g.onPointerOut == null || g.onPointerOut(y),
            g.onPointerLeave == null || g.onPointerLeave(y);
        }
      }
    }
  }
  function o(u, f) {
    for (let d = 0; d < f.length; d++) {
      let h = f[d].__r3f;
      h == null || h.handlers.onPointerMissed == null ||
        h.handlers.onPointerMissed(u);
    }
  }
  function a(u) {
    switch (u) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
      case "onLostPointerCapture":
        return (f) => {
          let { internal: d } = n.getState();
          "pointerId" in f && d.capturedMap.has(f.pointerId) &&
            (d.capturedMap.delete(f.pointerId), s([]));
        };
    }
    return function (d) {
      let { onPointerMissed: h, internal: p } = n.getState();
      p.lastEvent.current = d;
      let g = u === "onPointerMove",
        y = u === "onClick" || u === "onContextMenu" || u === "onDoubleClick",
        _ = r(d, g ? t : void 0),
        S = y ? e(d) : 0;
      u === "onPointerDown" &&
      (p.initialClick = [d.offsetX, d.offsetY],
        p.initialHits = _.map((M) => M.eventObject)),
        y && !_.length && S <= 2 && (o(d, p.interaction), h && h(d)),
        g && s(_);
      function w(M) {
        let T = M.eventObject, b = T.__r3f, R = b == null ? void 0 : b.handlers;
        if (!!(b != null && b.eventCount)) {
          if (g) {
            if (
              R.onPointerOver || R.onPointerEnter || R.onPointerOut ||
              R.onPointerLeave
            ) {
              let P = Ag(M), C = p.hovered.get(P);
              C
                ? C.stopped && M.stopPropagation()
                : (p.hovered.set(P, M),
                  R.onPointerOver == null || R.onPointerOver(M),
                  R.onPointerEnter == null || R.onPointerEnter(M));
            }
            R.onPointerMove == null || R.onPointerMove(M);
          } else {
            let P = R[u];
            P
              ? (!y || p.initialHits.includes(T)) &&
                (o(d, p.interaction.filter((C) => !p.initialHits.includes(C))),
                  P(M))
              : y && p.initialHits.includes(T) &&
                o(d, p.interaction.filter((C) => !p.initialHits.includes(C)));
          }
        }
      }
      i(_, d, S, w);
    };
  }
  return { handlePointer: a };
}
var PS = {}, IS = (n) => void (PS = { ...PS, ...n });
function lB(n, e) {
  function t(d, { args: h = [], attach: p, ...g }, y) {
    let v = `${d[0].toUpperCase()}${d.slice(1)}`, _;
    if (d === "primitive") {
      if (g.object === void 0) {
        throw new Error("R3F: Primitives without 'object' are invalid!");
      }
      let S = g.object;
      _ = xc(S, { type: d, root: y, attach: p, primitive: !0 });
    } else {
      let S = PS[v];
      if (!S) {
        throw new Error(
          `R3F: ${v} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`,
        );
      }
      if (!Array.isArray(h)) {
        throw new Error("R3F: The args prop must be an array!");
      }
      _ = xc(new S(...h), {
        type: d,
        root: y,
        attach: p,
        memoizedProps: { args: h },
      });
    }
    return _.__r3f.attach === void 0 &&
      (_ instanceof Ye
        ? _.__r3f.attach = "geometry"
        : _ instanceof $t && (_.__r3f.attach = "material")),
      v !== "inject" && bS(_, g),
      _;
  }
  function r(d, h) {
    let p = !1;
    if (h) {
      var g, y;
      (g = h.__r3f) != null && g.attach
        ? CS(d, h, h.__r3f.attach)
        : h.isObject3D && d.isObject3D && (d.add(h), p = !0),
        p || (y = d.__r3f) == null || y.objects.push(h),
        h.__r3f || xc(h, {}),
        h.__r3f.parent = d,
        RS(h),
        _c(h);
    }
  }
  function i(d, h, p) {
    let g = !1;
    if (h) {
      var y, v;
      if ((y = h.__r3f) != null && y.attach) CS(d, h, h.__r3f.attach);
      else if (h.isObject3D && d.isObject3D) {
        h.parent = d, h.dispatchEvent({ type: "added" });
        let _ = d.children.filter((w) => w !== h), S = _.indexOf(p);
        d.children = [..._.slice(0, S), h, ..._.slice(S)], g = !0;
      }
      g || (v = d.__r3f) == null || v.objects.push(h),
        h.__r3f || xc(h, {}),
        h.__r3f.parent = d,
        RS(h),
        _c(h);
    }
  }
  function s(d, h, p = !1) {
    d && [...d].forEach((g) => o(h, g, p));
  }
  function o(d, h, p) {
    if (h) {
      var g, y, v;
      if (
        h.__r3f && (h.__r3f.parent = null),
          (g = d.__r3f) != null && g.objects &&
          (d.__r3f.objects = d.__r3f.objects.filter((T) => T !== h)),
          (y = h.__r3f) != null && y.attach
      ) Y3(d, h, h.__r3f.attach);
      else if (h.isObject3D && d.isObject3D) {
        var _;
        d.remove(h), (_ = h.__r3f) != null && _.root && aB(h.__r3f.root, h);
      }
      let w = (v = h.__r3f) == null ? void 0 : v.primitive,
        M = p === void 0 ? h.dispose !== null && !w : p;
      if (!w) {
        var S;
        s((S = h.__r3f) == null ? void 0 : S.objects, h, M),
          s(h.children, h, M);
      }
      h.__r3f &&
      (delete h.__r3f.root,
        delete h.__r3f.objects,
        delete h.__r3f.handlers,
        delete h.__r3f.memoizedProps,
        w || delete h.__r3f),
        M && h.dispose && h.type !== "Scene" &&
        (0, Eg.unstable_scheduleCallback)(Eg.unstable_IdlePriority, () => {
          try {
            h.dispose();
          } catch {}
        }),
        _c(d);
    }
  }
  function a(d, h, p, g) {
    var y;
    let v = (y = d.__r3f) == null ? void 0 : y.parent;
    if (!v) return;
    let _ = t(h, p, d.__r3f.root);
    if (d.children) {
      for (let S of d.children) S.__r3f && r(_, S);
      d.children = d.children.filter((S) => !S.__r3f);
    }
    d.__r3f.objects.forEach((S) => r(_, S)),
      d.__r3f.objects = [],
      d.__r3f.autoRemovedBeforeAppend || o(v, d),
      _.parent && (_.__r3f.autoRemovedBeforeAppend = !0),
      r(v, _),
      _.raycast && _.__r3f.eventCount &&
      _.__r3f.root.getState().internal.interaction.push(_),
      [g, g.alternate].forEach((S) => {
        S !== null &&
          (S.stateNode = _,
            S.ref &&
            (typeof S.ref == "function" ? S.ref(_) : S.ref.current = _));
      });
  }
  let u = () =>
    console.warn(
      "Text is not allowed in the R3F tree! This could be stray whitespace or characters.",
    );
  return {
    reconciler: (0, z3.default)({
      createInstance: t,
      removeChild: o,
      appendChild: r,
      appendInitialChild: r,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (d, h) => {
        if (!h) return;
        let p = d.getState().scene;
        !p.__r3f || (p.__r3f.root = d, r(p, h));
      },
      removeChildFromContainer: (d, h) => {
        !h || o(d.getState().scene, h);
      },
      insertInContainerBefore: (d, h, p) => {
        if (!h || !p) return;
        let g = d.getState().scene;
        !g.__r3f || i(g, h, p);
      },
      getRootHostContext: () => null,
      getChildHostContext: (d) => d,
      finalizeInitialChildren(d) {
        var h;
        let p = (h = d == null ? void 0 : d.__r3f) != null ? h : {};
        return Boolean(p.handlers);
      },
      prepareUpdate(d, h, p, g) {
        if (d.__r3f.primitive && g.object && g.object !== d) return [!0];
        {
          let { args: y = [], children: v, ..._ } = g,
            { args: S = [], children: w, ...M } = p;
          if (!Array.isArray(y)) {
            throw new Error("R3F: the args prop must be an array!");
          }
          if (y.some((b, R) => b !== S[R])) return [!0];
          let T = Z3(d, _, M, !0);
          return T.changes.length ? [!1, T] : null;
        }
      },
      commitUpdate(d, [h, p], g, y, v, _) {
        h ? a(d, g, v, _) : bS(d, p);
      },
      commitMount(d, h, p, g) {
        var y;
        let v = (y = d.__r3f) != null ? y : {};
        d.raycast && v.handlers && v.eventCount &&
          d.__r3f.root.getState().internal.interaction.push(d);
      },
      getPublicInstance: (d) => d,
      prepareForCommit: () => null,
      preparePortalMount: (d) => xc(d.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(d) {
        var h;
        let { attach: p, parent: g } = (h = d.__r3f) != null ? h : {};
        p && g && Y3(g, d, p), d.isObject3D && (d.visible = !1), _c(d);
      },
      unhideInstance(d, h) {
        var p;
        let { attach: g, parent: y } = (p = d.__r3f) != null ? p : {};
        g && y && CS(y, d, g),
          (d.isObject3D && h.visible == null || h.visible) && (d.visible = !0),
          _c(d);
      },
      createTextInstance: u,
      hideTextInstance: u,
      unhideTextInstance: u,
      getCurrentEventPriority: () => e ? e() : Es.DefaultEventPriority,
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now: typeof performance != "undefined" && cn.fun(performance.now)
        ? performance.now
        : cn.fun(Date.now)
        ? Date.now
        : () => 0,
      scheduleTimeout: cn.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: cn.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: bS,
  };
}
var J3 = (n) => !!(n != null && n.render),
  NS = tn.createContext(null),
  uB = (n, e) => {
    let t = y3((a, u) => {
        let f = new I(), d = new I(), h = new I();
        function p(S = u().camera, w = d, M = u().size) {
          let { width: T, height: b, top: R, left: P } = M, C = T / b;
          w instanceof I ? h.copy(w) : h.set(...w);
          let L = S.getWorldPosition(f).distanceTo(h);
          if (V3(S)) {
            return {
              width: T / S.zoom,
              height: b / S.zoom,
              top: R,
              left: P,
              factor: 1,
              distance: L,
              aspect: C,
            };
          }
          {
            let k = S.fov * Math.PI / 180,
              z = 2 * Math.tan(k / 2) * L,
              Y = z * (T / b);
            return {
              width: Y,
              height: z,
              top: R,
              left: P,
              factor: T / Y,
              distance: L,
              aspect: C,
            };
          }
        }
        let g,
          y = (S) =>
            a((w) => ({ performance: { ...w.performance, current: S } })),
          v = new se();
        return {
          set: a,
          get: u,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          invalidate: (S = 1) => n(u(), S),
          advance: (S, w) => e(S, w, u()),
          legacy: !1,
          linear: !1,
          flat: !1,
          scene: xc(new hl()),
          controls: null,
          clock: new cg(),
          pointer: v,
          mouse: v,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: .5,
            max: 1,
            debounce: 200,
            regress: () => {
              let S = u();
              g && clearTimeout(g),
                S.performance.current !== S.performance.min &&
                y(S.performance.min),
                g = setTimeout(
                  () => y(u().performance.max),
                  S.performance.debounce,
                );
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: p,
          },
          setEvents: (S) => a((w) => ({ ...w, events: { ...w.events, ...S } })),
          setSize: (S, w, M, T, b) => {
            let R = u().camera,
              P = {
                width: S,
                height: w,
                top: T || 0,
                left: b || 0,
                updateStyle: M,
              };
            a((C) => ({ size: P, viewport: { ...C.viewport, ...p(R, d, P) } }));
          },
          setDpr: (S) =>
            a((w) => {
              let M = W3(S);
              return {
                viewport: {
                  ...w.viewport,
                  dpr: M,
                  initialDpr: w.viewport.initialDpr || M,
                },
              };
            }),
          setFrameloop: (S = "always") => {
            let w = u().clock;
            w.stop(),
              w.elapsedTime = 0,
              S !== "never" && (w.start(), w.elapsedTime = 0),
              a(() => ({ frameloop: S }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: tn.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (S, w, M) => {
              let T = u().internal;
              return T.priority = T.priority + (w > 0 ? 1 : 0),
                T.subscribers.push({ ref: S, priority: w, store: M }),
                T.subscribers = T.subscribers.sort((b, R) =>
                  b.priority - R.priority
                ),
                () => {
                  let b = u().internal;
                  b != null && b.subscribers &&
                    (b.priority = b.priority - (w > 0 ? 1 : 0),
                      b.subscribers = b.subscribers.filter((R) => R.ref !== S));
                };
            },
          },
        };
      }),
      r = t.getState(),
      i = r.size,
      s = r.viewport.dpr,
      o = r.camera;
    return t.subscribe(() => {
      let { camera: a, size: u, viewport: f, gl: d, set: h } = t.getState();
      (u !== i || f.dpr !== s) &&
      (i = u,
        s = f.dpr,
        iB(a, u),
        d.setPixelRatio(f.dpr),
        d.setSize(u.width, u.height, u.updateStyle)),
        a !== o &&
        (o = a,
          h((p) => ({
            viewport: { ...p.viewport, ...p.viewport.getCurrentViewport(a) },
          })));
    }),
      t.subscribe((a) => n(a)),
      t;
  };
var Cg, cB = new Set(), fB = new Set(), dB = new Set();
function DS(n, e) {
  if (!!n.size) { for (let { callback: t } of n.values()) t(e); }
}
function Sc(n, e) {
  switch (n) {
    case "before":
      return DS(cB, e);
    case "after":
      return DS(fB, e);
    case "tail":
      return DS(dB, e);
  }
}
var kS, FS;
function OS(n, e, t) {
  let r = e.clock.getDelta();
  for (
    e.frameloop === "never" && typeof n == "number" &&
    (r = n - e.clock.elapsedTime,
      e.clock.oldTime = e.clock.elapsedTime,
      e.clock.elapsedTime = n),
      kS = e.internal.subscribers,
      Cg = 0;
    Cg < kS.length;
    Cg++
  ) FS = kS[Cg], FS.ref.current(FS.store.getState(), r, t);
  return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    e.internal.frames = Math.max(0, e.internal.frames - 1),
    e.frameloop === "always" ? 1 : e.internal.frames;
}
function hB(n) {
  let e = !1, t, r, i;
  function s(u) {
    r = requestAnimationFrame(s), e = !0, t = 0, Sc("before", u);
    for (let d of n.values()) {
      var f;
      i = d.store.getState(),
        i.internal.active &&
        (i.frameloop === "always" || i.internal.frames > 0) &&
        !((f = i.gl.xr) != null && f.isPresenting) && (t += OS(u, i));
    }
    if (Sc("after", u), t === 0) {
      return Sc("tail", u), e = !1, cancelAnimationFrame(r);
    }
  }
  function o(u, f = 1) {
    var d;
    if (!u) return n.forEach((h) => o(h.store.getState()), f);
    (d = u.gl.xr) != null && d.isPresenting || !u.internal.active ||
      u.frameloop === "never" ||
      (u.internal.frames = Math.min(60, u.internal.frames + f),
        e || (e = !0, requestAnimationFrame(s)));
  }
  function a(u, f = !0, d, h) {
    if (f && Sc("before", u), d) OS(u, d, h);
    else for (let p of n.values()) OS(u, p.store.getState());
    f && Sc("after", u);
  }
  return { loop: s, invalidate: o, advance: a };
}
function zS() {
  let n = tn.useContext(NS);
  if (!n) {
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  }
  return n;
}
function Nn(n = (t) => t, e) {
  return zS()(n, e);
}
function Or(n, e = 0) {
  let t = zS(), r = t.getState().internal.subscribe, i = TS(n);
  return vc(() => r(i, e, t), [e, r, t]), null;
}
function Q3(n, e) {
  return function (t, ...r) {
    let i = new t();
    return n && n(i),
      Promise.all(r.map((s) =>
        new Promise((o, a) =>
          i.load(
            s,
            (u) => {
              u.scene && Object.assign(u, rB(u.scene)), o(u);
            },
            e,
            (u) => a(new Error(`Could not load ${s}: ${u.message})`)),
          )
        )
      ));
  };
}
function BS(n, e, t, r) {
  let i = Array.isArray(e) ? e : [e],
    s = k3(Q3(t, r), [n, ...i], { equal: cn.equ });
  return Array.isArray(e) ? s : s[0];
}
BS.preload = function (n, e, t) {
  let r = Array.isArray(e) ? e : [e];
  return F3(Q3(t), [n, ...r]);
};
BS.clear = function (n, e) {
  let t = Array.isArray(e) ? e : [e];
  return O3([n, ...t]);
};
var Il = new Map(),
  { invalidate: US, advance: VS } = hB(Il),
  { reconciler: _d, applyProps: Sd } = lB(Il, oB),
  wd = { objects: "shallow", strict: !1 },
  pB = (n, e) => {
    let t = typeof n == "function" ? n(e) : n;
    return J3(t)
      ? t
      : new w_({
        powerPreference: "high-performance",
        canvas: e,
        antialias: !0,
        alpha: !0,
        ...n,
      });
  };
function mB(n) {
  return n instanceof HTMLCanvasElement;
}
function gB(n, e) {
  if (e) return e;
  if (mB(n) && n.parentElement) {
    let { width: t, height: r, top: i, left: s } = n.parentElement
      .getBoundingClientRect();
    return { width: t, height: r, top: i, left: s };
  }
  return { width: 0, height: 0, top: 0, left: 0 };
}
function HS(n) {
  let e = Il.get(n),
    t = e == null ? void 0 : e.fiber,
    r = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  let i = typeof reportError == "function" ? reportError : console.error,
    s = r || uB(US, VS),
    o = t ||
      _d.createContainer(s, Es.ConcurrentRoot, null, !1, null, "", i, null);
  e || Il.set(n, { fiber: o, store: s });
  let a, u = !1;
  return {
    configure(f = {}) {
      let {
          gl: d,
          size: h,
          events: p,
          onCreated: g,
          shadows: y = !1,
          linear: v = !1,
          flat: _ = !1,
          legacy: S = !1,
          orthographic: w = !1,
          frameloop: M = "always",
          dpr: T = [1, 2],
          performance: b,
          raycaster: R,
          camera: P,
          onPointerMissed: C,
        } = f,
        L = s.getState(),
        k = L.gl;
      L.gl || L.set({ gl: k = pB(d, n) });
      let z = L.raycaster;
      z || L.set({ raycaster: z = new cS() });
      let { params: Y, ...le } = R || {};
      if (
        cn.equ(le, z, wd) || Sd(z, { ...le }),
          cn.equ(Y, z.params, wd) || Sd(z, { params: { ...z.params, ...Y } }),
          !L.camera
      ) {
        let ie = P instanceof oa,
          X = ie ? P : w ? new $i(0, 0, 0, 0, .1, 1e3) : new ln(75, 0, .1, 1e3);
        ie ||
        (X.position.z = 5,
          P && Sd(X, P),
          P != null && P.rotation || X.lookAt(0, 0, 0)), L.set({ camera: X });
      }
      if (!L.xr) {
        let ie = (ae, fe) => {
            let pe = s.getState();
            pe.frameloop !== "never" && VS(ae, !0, pe, fe);
          },
          X = () => {
            let ae = s.getState();
            ae.gl.xr.enabled = ae.gl.xr.isPresenting,
              ae.gl.xr.setAnimationLoop(ae.gl.xr.isPresenting ? ie : null),
              ae.gl.xr.isPresenting || US(ae);
          },
          $ = {
            connect() {
              let ae = s.getState().gl;
              ae.xr.addEventListener("sessionstart", X),
                ae.xr.addEventListener("sessionend", X);
            },
            disconnect() {
              let ae = s.getState().gl;
              ae.xr.removeEventListener("sessionstart", X),
                ae.xr.removeEventListener("sessionend", X);
            },
          };
        k.xr && $.connect(), L.set({ xr: $ });
      }
      if (k.shadowMap) {
        let ie = k.shadowMap.enabled, X = k.shadowMap.type;
        if (k.shadowMap.enabled = !!y, cn.boo(y)) k.shadowMap.type = zf;
        else if (cn.str(y)) {
          var V;
          let $ = { basic: SA, percentage: Yp, soft: zf, variance: Ka };
          k.shadowMap.type = (V = $[y]) != null ? V : zf;
        } else cn.obj(y) && Object.assign(k.shadowMap, y);
        (ie !== k.shadowMap.enabled || X !== k.shadowMap.type) &&
          (k.shadowMap.needsUpdate = !0);
      }
      "ColorManagement" in Rl && sB(Rl, S, ["ColorManagement", "legacyMode"]);
      let W = v ? Ys : yt, G = _ ? ji : vx;
      k.outputEncoding !== W && (k.outputEncoding = W),
        k.toneMapping !== G && (k.toneMapping = G),
        L.legacy !== S && L.set(() => ({ legacy: S })),
        L.linear !== v && L.set(() => ({ linear: v })),
        L.flat !== _ && L.set(() => ({ flat: _ })),
        d && !cn.fun(d) && !J3(d) && !cn.equ(d, k, wd) && Sd(k, d),
        p && !L.events.handlers && L.set({ events: p(s) }),
        T && L.viewport.dpr !== W3(T) && L.setDpr(T);
      let re = gB(n, h);
      return cn.equ(re, L.size, wd) ||
        L.setSize(re.width, re.height, re.updateStyle, re.top, re.left),
        L.frameloop !== M && L.setFrameloop(M),
        L.onPointerMissed || L.set({ onPointerMissed: C }),
        b && !cn.equ(b, L.performance, wd) &&
        L.set((ie) => ({ performance: { ...ie.performance, ...b } })),
        a = g,
        u = !0,
        this;
    },
    render(f) {
      return u || this.configure(),
        _d.updateContainer(
          tn.createElement(vB, {
            store: s,
            children: f,
            onCreated: a,
            rootElement: n,
          }),
          o,
          null,
          () => {},
        ),
        s;
    },
    unmount() {
      bg(n);
    },
  };
}
function vB({ store: n, children: e, onCreated: t, rootElement: r }) {
  return vc(() => {
    let i = n.getState();
    i.set((s) => ({ internal: { ...s.internal, active: !0 } })),
      t && t(i),
      n.getState().events.connected || i.events.connect == null ||
      i.events.connect(r);
  }, []),
    tn.createElement(NS.Provider, { value: n }, e);
}
function bg(n, e) {
  let t = Il.get(n), r = t == null ? void 0 : t.fiber;
  if (r) {
    let i = t == null ? void 0 : t.store.getState();
    i && (i.internal.active = !1),
      _d.updateContainer(null, r, null, () => {
        i && setTimeout(() => {
          try {
            var s, o, a, u;
            i.events.disconnect == null || i.events.disconnect(),
              (s = i.gl) == null || (o = s.renderLists) == null ||
              o.dispose == null || o.dispose(),
              (a = i.gl) == null || a.forceContextLoss == null ||
              a.forceContextLoss(),
              (u = i.gl) != null && u.xr && i.xr.disconnect(),
              X3(i),
              Il.delete(n),
              e && e(n);
          } catch {}
        }, 500);
      });
  }
}
_d.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: tn.version,
});
function zr() {
  return zr = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) {
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
    }
    return n;
  },
    zr.apply(this, arguments);
}
var Ft = rn(An());
var ri = rn(An()), jS = rn(eR());
function Rg(n) {
  let { debounce: e, scroll: t, polyfill: r, offsetSize: i } = n === void 0
      ? { debounce: 0, scroll: !1, offsetSize: !1 }
      : n,
    s = r || (typeof window == "undefined" ? class {} : window.ResizeObserver);
  if (!s) {
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills",
    );
  }
  let [o, a] = (0, ri.useState)({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    u = (0, ri.useRef)({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: o,
    }),
    f = e ? typeof e == "number" ? e : e.scroll : null,
    d = e ? typeof e == "number" ? e : e.resize : null,
    h = (0, ri.useRef)(!1);
  (0, ri.useEffect)(() => (h.current = !0, () => void (h.current = !1)));
  let [p, g, y] = (0, ri.useMemo)(() => {
    let w = () => {
      if (!u.current.element) return;
      let {
          left: M,
          top: T,
          width: b,
          height: R,
          bottom: P,
          right: C,
          x: L,
          y: k,
        } = u.current.element.getBoundingClientRect(),
        z = {
          left: M,
          top: T,
          width: b,
          height: R,
          bottom: P,
          right: C,
          x: L,
          y: k,
        };
      u.current.element instanceof HTMLElement && i &&
      (z.height = u.current.element.offsetHeight,
        z.width = u.current.element.offsetWidth),
        Object.freeze(z),
        h.current && !SB(u.current.lastBounds, z) &&
        a(u.current.lastBounds = z);
    };
    return [w, d ? (0, jS.default)(w, d) : w, f ? (0, jS.default)(w, f) : w];
  }, [a, i, f, d]);
  function v() {
    u.current.scrollContainers &&
    (u.current.scrollContainers.forEach((w) =>
      w.removeEventListener("scroll", y, !0)
    ),
      u.current.scrollContainers = null),
      u.current.resizeObserver &&
      (u.current.resizeObserver.disconnect(), u.current.resizeObserver = null);
  }
  function _() {
    !u.current.element || (u.current.resizeObserver = new s(y),
      u.current.resizeObserver.observe(u.current.element),
      t && u.current.scrollContainers &&
      u.current.scrollContainers.forEach((w) =>
        w.addEventListener("scroll", y, { capture: !0, passive: !0 })
      ));
  }
  let S = (w) => {
    !w || w === u.current.element ||
      (v(), u.current.element = w, u.current.scrollContainers = tR(w), _());
  };
  return xB(y, Boolean(t)),
    yB(g),
    (0, ri.useEffect)(() => {
      v(), _();
    }, [t, y, g]),
    (0, ri.useEffect)(() => v, []),
    [S, o, p];
}
function yB(n) {
  (0, ri.useEffect)(() => {
    let e = n;
    return window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e);
  }, [n]);
}
function xB(n, e) {
  (0, ri.useEffect)(() => {
    if (e) {
      let t = n;
      return window.addEventListener("scroll", t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", t, !0);
    }
  }, [n, e]);
}
function tR(n) {
  let e = [];
  if (!n || n === document.body) return e;
  let { overflow: t, overflowX: r, overflowY: i } = window.getComputedStyle(n);
  return [t, r, i].some((s) => s === "auto" || s === "scroll") && e.push(n),
    [...e, ...tR(n.parentElement)];
}
var _B = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  SB = (n, e) => _B.every((t) => n[t] === e[t]);
var pn = rn(An()),
  wB = Object.defineProperty,
  MB = Object.defineProperties,
  EB = Object.getOwnPropertyDescriptors,
  nR = Object.getOwnPropertySymbols,
  TB = Object.prototype.hasOwnProperty,
  AB = Object.prototype.propertyIsEnumerable,
  rR = (n, e, t) =>
    e in n
      ? wB(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : n[e] = t,
  iR = (n, e) => {
    for (var t in e || (e = {})) TB.call(e, t) && rR(n, t, e[t]);
    if (nR) { for (var t of nR(e)) AB.call(e, t) && rR(n, t, e[t]); }
    return n;
  },
  CB = (n, e) => MB(n, EB(e));
function sR(n, e, t) {
  if (!n) return;
  if (t(n) === !0) return n;
  let r = e ? n.return : n.child;
  for (; r;) {
    let i = sR(r, e, t);
    if (i) return i;
    r = e ? null : r.sibling;
  }
}
function oR(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return n;
  }
}
var WS = oR(pn.createContext(null)),
  Lg = class extends pn.Component {
    render() {
      return pn.createElement(
        WS.Provider,
        { value: this._reactInternals },
        this.props.children,
      );
    }
  },
  { ReactCurrentOwner: bB, ReactCurrentDispatcher: RB } =
    pn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function LB() {
  let n = pn.useContext(WS);
  if (!n) {
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!",
    );
  }
  let e = pn.useId();
  return pn.useMemo(() => {
    var r;
    return (r = bB.current) != null ? r : sR(n, !1, (i) => {
      let s = i.memoizedState;
      for (; s;) {
        if (s.memoizedState === e) return !0;
        s = s.next;
      }
    });
  }, [n, e]);
}
function aR() {
  var n, e;
  let t = LB(), [r] = pn.useState(() => new Map());
  r.clear();
  let i = t;
  for (; i;) {
    let s = (n = i.type) == null ? void 0 : n._context;
    s && s !== WS && !r.has(s) &&
    r.set(s, (e = RB.current) == null ? void 0 : e.readContext(oR(s))),
      i = i.return;
  }
  return pn.useMemo(
    () =>
      Array.from(r.keys()).reduce((s, o) => (a) =>
        pn.createElement(
          s,
          null,
          pn.createElement(o.Provider, CB(iR({}, a), { value: r.get(o) })),
        ), (s) =>
        pn.createElement(Lg, iR({}, s))),
    [r],
  );
}
var o5 = rn(pS());
var a5 = rn(ES()), l5 = rn(Mg());
var XS = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function PB(n) {
  let { handlePointer: e } = LS(n);
  return {
    priority: 1,
    enabled: !0,
    compute(t, r, i) {
      r.pointer.set(
        t.offsetX / r.size.width * 2 - 1,
        -(t.offsetY / r.size.height) * 2 + 1,
      ), r.raycaster.setFromCamera(r.pointer, r.camera);
    },
    connected: void 0,
    handlers: Object.keys(XS).reduce((t, r) => ({ ...t, [r]: e(r) }), {}),
    connect: (t) => {
      var r;
      let { set: i, events: s } = n.getState();
      s.disconnect == null || s.disconnect(),
        i((o) => ({ events: { ...o.events, connected: t } })),
        Object.entries((r = s.handlers) != null ? r : []).forEach(([o, a]) => {
          let [u, f] = XS[o];
          t.addEventListener(u, a, { passive: f });
        });
    },
    disconnect: () => {
      let { set: t, events: r } = n.getState();
      if (r.connected) {
        var i;
        Object.entries((i = r.handlers) != null ? i : []).forEach(([s, o]) => {
          if (r && r.connected instanceof HTMLElement) {
            let [a] = XS[s];
            r.connected.removeEventListener(a, o);
          }
        }),
          t((s) => ({ events: { ...s.events, connected: void 0 } }));
      }
    },
  };
}
var IB = Ft.forwardRef(function ({
    children: e,
    fallback: t,
    resize: r,
    style: i,
    gl: s,
    events: o = PB,
    eventSource: a,
    eventPrefix: u,
    shadows: f,
    linear: d,
    flat: h,
    legacy: p,
    orthographic: g,
    frameloop: y,
    dpr: v,
    performance: _,
    raycaster: S,
    camera: w,
    onPointerMissed: M,
    onCreated: T,
    ...b
  }, R) {
    Ft.useMemo(() => IS(Rl), []);
    let P = aR(),
      [C, L] = Rg({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...r }),
      k = Ft.useRef(null),
      z = Ft.useRef(null),
      [Y, le] = Ft.useState(null);
    Ft.useImperativeHandle(R, () => k.current);
    let V = TS(M), [W, G] = Ft.useState(!1), [re, ie] = Ft.useState(!1);
    if (W) throw W;
    if (re) throw re;
    let X = Ft.useRef(null);
    return L.width > 0 && L.height > 0 && Y &&
      (X.current || (X.current = HS(Y)),
        X.current.configure({
          gl: s,
          events: o,
          shadows: f,
          linear: d,
          flat: h,
          legacy: p,
          orthographic: g,
          frameloop: y,
          dpr: v,
          performance: _,
          raycaster: S,
          camera: w,
          size: L,
          onPointerMissed: (...ae) =>
            V.current == null ? void 0 : V.current(...ae),
          onCreated: (ae) => {
            ae.events.connect == null ||
            ae.events.connect(a ? H3(a) ? a.current : a : z.current),
              u && ae.setEvents({
                compute: (fe, pe) => {
                  let Pe = fe[u + "X"], Oe = fe[u + "Y"];
                  pe.pointer.set(
                    Pe / pe.size.width * 2 - 1,
                    -(Oe / pe.size.height) * 2 + 1,
                  ), pe.raycaster.setFromCamera(pe.pointer, pe.camera);
                },
              }),
              T == null || T(ae);
          },
        }),
        X.current.render(
          Ft.createElement(
            P,
            null,
            Ft.createElement(
              Tg,
              { set: ie },
              Ft.createElement(Ft.Suspense, {
                fallback: Ft.createElement(G3, { set: G }),
              }, e),
            ),
          ),
        )),
      vc(() => {
        le(k.current);
      }, []),
      Ft.useEffect(() => {
        if (Y) return () => bg(Y);
      }, [Y]),
      Ft.createElement(
        "div",
        zr({
          ref: z,
          style: {
            position: "relative",
            width: "100%",
            height: "100%",
            overflow: "hidden",
            pointerEvents: a ? "none" : "auto",
            ...i,
          },
        }, b),
        Ft.createElement(
          "div",
          { ref: C, style: { width: "100%", height: "100%" } },
          Ft.createElement(
            "canvas",
            { ref: k, style: { display: "block" } },
            t,
          ),
        ),
      );
  }),
  Pg = Ft.forwardRef(function (e, t) {
    return Ft.createElement(
      Lg,
      null,
      Ft.createElement(IB, zr({}, e, { ref: t })),
    );
  });
var Mt = rn(An()), It = rn(An());
function NB(n) {
  return function (e) {
    n.forEach(function (t) {
      typeof t == "function" ? t(e) : t != null && (t.current = e);
    });
  };
}
var Ig = NB;
var wc = class {
  constructor() {
    ce(this, "pluginCallbacks", void 0),
      this.pluginCallbacks = [],
      this.register(function (e) {
        return new dR(e);
      }),
      this.register(function (e) {
        return new hR(e);
      }),
      this.register(function (e) {
        return new pR(e);
      }),
      this.register(function (e) {
        return new mR(e);
      }),
      this.register(function (e) {
        return new gR(e);
      });
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 &&
      this.pluginCallbacks.push(e),
      this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 &&
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this;
  }
  parse(e, t, r) {
    let i = new fR(), s = [];
    for (let o = 0, a = this.pluginCallbacks.length; o < a; o++) {
      s.push(this.pluginCallbacks[o](i));
    }
    i.setPlugins(s), i.write(e, t, r);
  }
};
ce(wc, "Utils", {
  insertKeyframe: function (n, e) {
    let t = .001,
      r = n.getValueSize(),
      i = new n.TimeBufferType(n.times.length + 1),
      s = new n.ValueBufferType(n.values.length + r),
      o = n.createInterpolant(new n.ValueBufferType(r)),
      a;
    if (n.times.length === 0) {
      i[0] = e;
      for (let u = 0; u < r; u++) s[u] = 0;
      a = 0;
    } else if (e < n.times[0]) {
      if (Math.abs(n.times[0] - e) < t) return 0;
      i[0] = e,
        i.set(n.times, 1),
        s.set(o.evaluate(e), 0),
        s.set(n.values, r),
        a = 0;
    } else if (e > n.times[n.times.length - 1]) {
      if (Math.abs(n.times[n.times.length - 1] - e) < t) {
        return n.times.length - 1;
      }
      i[i.length - 1] = e,
        i.set(n.times, 0),
        s.set(n.values, 0),
        s.set(o.evaluate(e), n.values.length),
        a = i.length - 1;
    } else {for (let u = 0; u < n.times.length; u++) {
        if (Math.abs(n.times[u] - e) < t) return u;
        if (n.times[u] < e && n.times[u + 1] > e) {
          i.set(n.times.slice(0, u + 1), 0),
            i[u + 1] = e,
            i.set(n.times.slice(u + 1), u + 2),
            s.set(n.values.slice(0, (u + 1) * r), 0),
            s.set(o.evaluate(e), (u + 1) * r),
            s.set(n.values.slice((u + 1) * r), (u + 2) * r),
            a = u + 1;
          break;
        }
      }}
    return n.times = i, n.values = s, a;
  },
  mergeMorphTargetTracks: function (n, e) {
    let t = [], r = {}, i = n.tracks;
    for (let s = 0; s < i.length; ++s) {
      let o = i[s],
        a = st.parseTrackName(o.name),
        u = st.findNode(e, a.nodeName);
      if (
        a.propertyName !== "morphTargetInfluences" || a.propertyIndex === void 0
      ) {
        t.push(o);
        continue;
      }
      if (
        o.createInterpolant !== o.InterpolantFactoryMethodDiscrete &&
        o.createInterpolant !== o.InterpolantFactoryMethodLinear
      ) {
        if (o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          throw new Error(
            "THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.",
          );
        }
        console.warn(
          "THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.",
        ),
          o = o.clone(),
          o.setInterpolation(xs);
      }
      let f = u.morphTargetInfluences.length,
        d = u.morphTargetDictionary[a.propertyIndex];
      if (d === void 0) {
        throw new Error(
          "THREE.GLTFExporter: Morph target name not found: " + a.propertyIndex,
        );
      }
      let h;
      if (r[u.uuid] === void 0) {
        h = o.clone();
        let g = new h.ValueBufferType(f * h.times.length);
        for (let y = 0; y < h.times.length; y++) g[y * f + d] = h.values[y];
        h.name = (a.nodeName || "") + ".morphTargetInfluences",
          h.values = g,
          r[u.uuid] = h,
          t.push(h);
        continue;
      }
      let p = o.createInterpolant(new o.ValueBufferType(1));
      h = r[u.uuid];
      for (let g = 0; g < h.times.length; g++) {
        h.values[g * f + d] = p.evaluate(h.times[g]);
      }
      for (let g = 0; g < o.times.length; g++) {
        let y = this.insertKeyframe(h, o.times[g]);
        h.values[y * f + d] = o.values[g];
      }
    }
    return n.tracks = t, n;
  },
});
var zt = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
    FLOAT: 5126,
    UNSIGNED_INT: 5125,
    ARRAY_BUFFER: 34962,
    ELEMENT_ARRAY_BUFFER: 34963,
    NEAREST: 9728,
    LINEAR: 9729,
    NEAREST_MIPMAP_NEAREST: 9984,
    LINEAR_MIPMAP_NEAREST: 9985,
    NEAREST_MIPMAP_LINEAR: 9986,
    LINEAR_MIPMAP_LINEAR: 9987,
    CLAMP_TO_EDGE: 33071,
    MIRRORED_REPEAT: 33648,
    REPEAT: 10497,
  },
  ii = {};
ii[Jt] = zt.NEAREST;
ii[jo] = zt.NEAREST_MIPMAP_NEAREST;
ii[Wo] = zt.NEAREST_MIPMAP_LINEAR;
ii[kt] = zt.LINEAR;
ii[$a] = zt.LINEAR_MIPMAP_NEAREST;
ii[Mi] = zt.LINEAR_MIPMAP_LINEAR;
ii[Rn] = zt.CLAMP_TO_EDGE;
ii[Wi] = zt.REPEAT;
ii[Ws] = zt.MIRRORED_REPEAT;
var lR = {
    scale: "scale",
    position: "translation",
    quaternion: "rotation",
    morphTargetInfluences: "weights",
  },
  uR = 12,
  DB = 1179937895,
  kB = 2,
  cR = 8,
  FB = 1313821514,
  OB = 5130562,
  fR = class {
    constructor() {
      ce(this, "plugins", void 0),
        ce(this, "options", void 0),
        ce(this, "pending", void 0),
        ce(this, "buffers", void 0),
        ce(this, "byteOffset", void 0),
        ce(this, "nodeMap", void 0),
        ce(this, "skins", void 0),
        ce(this, "extensionsUsed", void 0),
        ce(this, "uids", void 0),
        ce(this, "uid", void 0),
        ce(this, "json", void 0),
        ce(this, "cache", void 0),
        ce(this, "cachedCanvas", void 0),
        this.plugins = [],
        this.options = {},
        this.pending = [],
        this.buffers = [],
        this.byteOffset = 0,
        this.nodeMap = new Map(),
        this.skins = [],
        this.extensionsUsed = {},
        this.uids = new Map(),
        this.uid = 0,
        this.json = {
          asset: { version: "2.0", generator: "THREE.GLTFExporter" },
        },
        this.cache = {
          meshes: new Map(),
          attributes: new Map(),
          attributesNormalized: new Map(),
          materials: new Map(),
          textures: new Map(),
          images: new Map(),
        },
        this.cachedCanvas = null;
    }
    setPlugins(e) {
      this.plugins = e;
    }
    write(e, t, r) {
      this.options = Object.assign({}, {
        binary: !1,
        trs: !1,
        onlyVisible: !0,
        truncateDrawRange: !0,
        embedImages: !0,
        maxTextureSize: 1 / 0,
        animations: [],
        includeCustomExtensions: !1,
      }, r),
        this.options.animations !== void 0 &&
        this.options.animations.length > 0 && (this.options.trs = !0),
        this.processInput(e);
      let i = this;
      Promise.all(this.pending).then(() => {
        let s = i.buffers,
          o = i.json,
          a = i.options,
          u = i.extensionsUsed,
          f = new Blob(s, { type: "application/octet-stream" }),
          d = Object.keys(u);
        if (
          d.length > 0 && (o.extensionsUsed = d),
            o.buffers && o.buffers.length > 0 &&
            (o.buffers[0].byteLength = f.size),
            a.binary
        ) {
          let h = new window.FileReader();
          h.readAsArrayBuffer(f),
            h.onloadend = () => {
              if (h.result !== null && typeof h.result != "string") {
                let p = this.getPaddedArrayBuffer(h.result),
                  g = new DataView(new ArrayBuffer(cR));
                g.setUint32(0, p.byteLength, !0), g.setUint32(4, OB, !0);
                let y = this.getPaddedArrayBuffer(
                    this.stringToArrayBuffer(JSON.stringify(o)),
                    32,
                  ),
                  v = new DataView(new ArrayBuffer(cR));
                v.setUint32(0, y.byteLength, !0), v.setUint32(4, FB, !0);
                let _ = new ArrayBuffer(uR), S = new DataView(_);
                S.setUint32(0, DB, !0), S.setUint32(4, kB, !0);
                let w = uR + v.byteLength + y.byteLength + g.byteLength +
                  p.byteLength;
                S.setUint32(8, w, !0);
                let M = new Blob([_, v, y, g, p], {
                    type: "application/octet-stream",
                  }),
                  T = new window.FileReader();
                T.readAsArrayBuffer(M),
                  T.onloadend = function () {
                    T.result !== null && typeof T.result != "string" &&
                      t(T.result);
                  };
              }
            };
        } else if (o.buffers && o.buffers.length > 0) {
          let h = new window.FileReader();
          h.readAsDataURL(f),
            h.onloadend = function () {
              let p = h.result;
              o.buffers !== void 0 && p !== null &&
                (o.buffers[0].uri = p, t(o));
            };
        } else t(o);
      });
    }
    serializeUserData(e, t) {
      if (Object.keys(e.userData).length === 0) return;
      let r = this.options, i = this.extensionsUsed;
      try {
        let s = JSON.parse(JSON.stringify(e.userData));
        if (r.includeCustomExtensions && s.gltfExtensions) {
          t.extensions === void 0 && (t.extensions = {});
          for (let o in s.gltfExtensions) {
            t.extensions[o] = s.gltfExtensions[o], i[o] = !0;
          }
          delete s.gltfExtensions;
        }
        Object.keys(s).length > 0 && (t.extras = s);
      } catch (s) {
        s instanceof Error &&
          console.warn(
            "THREE.GLTFExporter: userData of '" + e.name +
              "' won't be serialized because of JSON.stringify error - " +
              s.message,
          );
      }
    }
    getUID(e) {
      return this.uids.has(e) || this.uids.set(e, this.uid++), this.uids.get(e);
    }
    isNormalizedNormalAttribute(e) {
      if (this.cache.attributesNormalized.has(e)) return !1;
      let r = new I();
      for (let i = 0, s = e.count; i < s; i++) {
        if (Math.abs(r.fromBufferAttribute(e, i).length() - 1) > 5e-4) {
          return !1;
        }
      }
      return !0;
    }
    createNormalizedNormalAttribute(e) {
      let t = this.cache;
      if (t.attributesNormalized.has(e)) return t.attributesNormalized.get(e);
      let r = e.clone(), i = new I();
      for (let s = 0, o = r.count; s < o; s++) {
        i.fromBufferAttribute(r, s),
          i.x === 0 && i.y === 0 && i.z === 0 ? i.setX(1) : i.normalize(),
          r.setXYZ(s, i.x, i.y, i.z);
      }
      return t.attributesNormalized.set(e, r), r;
    }
    applyTextureTransform(e, t) {
      let r = !1, i = {};
      (t.offset.x !== 0 || t.offset.y !== 0) &&
      (i.offset = t.offset.toArray(), r = !0),
        t.rotation !== 0 && (i.rotation = t.rotation, r = !0),
        (t.repeat.x !== 1 || t.repeat.y !== 1) &&
        (i.scale = t.repeat.toArray(), r = !0),
        r &&
        (e.extensions = e.extensions || {},
          e.extensions.KHR_texture_transform = i,
          this.extensionsUsed.KHR_texture_transform = !0);
    }
    processBuffer(e) {
      let t = this.json, r = this.buffers;
      return t.buffers || (t.buffers = [{ byteLength: 0 }]), r.push(e), 0;
    }
    processBufferView(e, t, r, i, s) {
      let o = this.json;
      o.bufferViews || (o.bufferViews = []);
      let a;
      t === zt.UNSIGNED_BYTE ? a = 1 : t === zt.UNSIGNED_SHORT ? a = 2 : a = 4;
      let u = this.getPaddedBufferSize(i * e.itemSize * a),
        f = new DataView(new ArrayBuffer(u)),
        d = 0;
      for (let g = r; g < r + i; g++) {
        for (let y = 0; y < e.itemSize; y++) {
          let v;
          e.itemSize > 4
            ? v = e.array[g * e.itemSize + y]
            : y === 0
            ? v = e.getX(g)
            : y === 1
            ? v = e.getY(g)
            : y === 2
            ? v = e.getZ(g)
            : y === 3 && (v = e.getW(g)),
            v !== void 0 && (t === zt.FLOAT
              ? f.setFloat32(d, v, !0)
              : t === zt.UNSIGNED_INT
              ? f.setUint32(d, v, !0)
              : t === zt.UNSIGNED_SHORT
              ? f.setUint16(d, v, !0)
              : t === zt.UNSIGNED_BYTE && f.setUint8(d, v)),
            d += a;
        }
      }
      let h = {
        buffer: this.processBuffer(f.buffer),
        byteOffset: this.byteOffset,
        byteLength: u,
      };
      return s !== void 0 && (h.target = s),
        s === zt.ARRAY_BUFFER && (h.byteStride = e.itemSize * a),
        this.byteOffset += u,
        o.bufferViews.push(h),
        { id: o.bufferViews.length - 1, byteLength: 0 };
    }
    processBufferViewImage(e) {
      let t = this, r = t.json;
      return r.bufferViews || (r.bufferViews = []),
        new Promise((i) => {
          let s = new window.FileReader();
          s.readAsArrayBuffer(e),
            s.onloadend = () => {
              if (
                s.result !== null && typeof s.result != "string" &&
                r.bufferViews !== void 0
              ) {
                let o = this.getPaddedArrayBuffer(s.result),
                  a = {
                    buffer: t.processBuffer(o),
                    byteOffset: t.byteOffset,
                    byteLength: o.byteLength,
                  };
                t.byteOffset += o.byteLength, i(r.bufferViews.push(a) - 1);
              }
            };
        });
    }
    processAccessor(e, t, r, i) {
      let s = this.options,
        o = this.json,
        a = { 1: "SCALAR", 2: "VEC2", 3: "VEC3", 4: "VEC4", 16: "MAT4" },
        u;
      if (e.array.constructor === Float32Array) u = zt.FLOAT;
      else if (e.array.constructor === Uint32Array) u = zt.UNSIGNED_INT;
      else if (e.array.constructor === Uint16Array) u = zt.UNSIGNED_SHORT;
      else if (e.array.constructor === Uint8Array) u = zt.UNSIGNED_BYTE;
      else {throw new Error(
          "THREE.GLTFExporter: Unsupported bufferAttribute component type.",
        );}
      if (
        r === void 0 && (r = 0),
          i === void 0 && (i = e.count),
          s.truncateDrawRange && t !== void 0 && t.index === null
      ) {
        let h = r + i,
          p = t.drawRange.count === 1 / 0
            ? e.count
            : t.drawRange.start + t.drawRange.count;
        r = Math.max(r, t.drawRange.start),
          i = Math.min(h, p) - r,
          i < 0 && (i = 0);
      }
      if (i === 0) return null;
      let f = this.getMinMax(e, r, i), d;
      if (
        t !== void 0 &&
        (d = e === t.index ? zt.ELEMENT_ARRAY_BUFFER : zt.ARRAY_BUFFER),
          d !== void 0
      ) {
        let h = this.processBufferView(e, u, r, i, d),
          p = {
            bufferView: h.id,
            byteOffset: h.byteOffset,
            componentType: u,
            count: i,
            max: f.max,
            min: f.min,
            type: a[e.itemSize],
          };
        return e.normalized && (p.normalized = !0),
          o.accessors || (o.accessors = []),
          o.accessors.push(p) - 1;
      }
    }
    processImage(e, t, r) {
      let i = this, s = i.cache, o = i.json, a = i.options, u = i.pending;
      s.images.has(e) || s.images.set(e, {});
      let f = s.images.get(e),
        d = t === gr ? "image/png" : "image/jpeg",
        h = d + ":flipY/" + r.toString();
      if (f !== void 0 && f[h] !== void 0) return f[h];
      o.images || (o.images = []);
      let p = { mimeType: d };
      if (a.embedImages && a.maxTextureSize !== void 0) {
        let y = this.cachedCanvas = this.cachedCanvas ||
          document.createElement("canvas");
        y.width = Math.min(e.width, a.maxTextureSize),
          y.height = Math.min(e.height, a.maxTextureSize);
        let v = y.getContext("2d");
        if (
          r &&
          (v == null || v.translate(0, y.height), v == null || v.scale(1, -1)),
            typeof HTMLImageElement != "undefined" &&
              e instanceof HTMLImageElement ||
            typeof HTMLCanvasElement != "undefined" &&
              e instanceof HTMLCanvasElement ||
            typeof OffscreenCanvas != "undefined" &&
              e instanceof OffscreenCanvas ||
            typeof ImageBitmap != "undefined" && e instanceof ImageBitmap
        ) v == null || v.drawImage(e, 0, 0, y.width, y.height);
        else {
          t !== gr &&
          console.error("GLTFExporter: Only RGBA format is supported."),
            (e.width > a.maxTextureSize || e.height > a.maxTextureSize) &&
            console.warn(
              "GLTFExporter: Image size is bigger than maxTextureSize",
              e,
            );
          let _ = new Uint8ClampedArray(e.height * e.width * 4);
          if (e instanceof ImageData) {
            for (let S = 0; S < _.length; S += 4) {
              _[S + 0] = e.data[S + 0],
                _[S + 1] = e.data[S + 1],
                _[S + 2] = e.data[S + 2],
                _[S + 3] = e.data[S + 3];
            }
          }
          v == null ||
            v.putImageData(new ImageData(_, e.width, e.height), 0, 0);
        }
        a.binary
          ? u.push(
            new Promise(function (_) {
              y.toBlob(function (S) {
                S !== null && i.processBufferViewImage(S).then(function (w) {
                  p.bufferView = w, _();
                });
              }, d);
            }),
          )
          : p.uri = y.toDataURL(d);
      } else e instanceof Image && (p.uri = e.src);
      let g = o.images.push(p) - 1;
      return f !== void 0 && (f[h] = g), g;
    }
    processSampler(e) {
      let t = this.json;
      t.samplers || (t.samplers = []);
      let r = {
        magFilter: ii[e.magFilter],
        minFilter: ii[e.minFilter],
        wrapS: ii[e.wrapS],
        wrapT: ii[e.wrapT],
      };
      return t.samplers.push(r) - 1;
    }
    processTexture(e) {
      let t = this.cache, r = this.json;
      if (t.textures.has(e)) return t.textures.get(e);
      r.textures || (r.textures = []);
      let i = {
        sampler: this.processSampler(e),
        source: this.processImage(e.image, e.format, e.flipY),
      };
      e.name && (i.name = e.name),
        this._invokeAll(function (o) {
          o.writeTexture && o.writeTexture(e, i);
        });
      let s = r.textures.push(i) - 1;
      return t.textures.set(e, s), s;
    }
    processMaterial(e) {
      let t = this.cache, r = this.json;
      if (t.materials.has(e)) return t.materials.get(e);
      if (e instanceof sr && e.isShaderMaterial) {
        return console.warn(
          "GLTFExporter: THREE.ShaderMaterial not supported.",
        ),
          null;
      }
      r.materials || (r.materials = []);
      let i = { pbrMetallicRoughness: {} };
      if (
        e instanceof In && e.isMeshStandardMaterial && e instanceof en &&
          e.isMeshBasicMaterial ||
        console.warn(
          "GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.",
        ),
          e instanceof In || e instanceof Xn
      ) {
        let o = e.color.toArray().concat([e.opacity]);
        this.equalArray(o, [1, 1, 1, 1]) ||
          (i.pbrMetallicRoughness.baseColorFactor = o);
      }
      if (
        e instanceof In && e.isMeshStandardMaterial
          ? (i.pbrMetallicRoughness.metallicFactor = e.metalness,
            i.pbrMetallicRoughness.roughnessFactor = e.roughness)
          : (i.pbrMetallicRoughness.metallicFactor = .5,
            i.pbrMetallicRoughness.roughnessFactor = .5),
          e instanceof In && e.metalnessMap || e instanceof In && e.roughnessMap
      ) {
        if (e.metalnessMap === e.roughnessMap && e.metalnessMap !== null) {
          let o = { index: this.processTexture(e.metalnessMap) };
          this.applyTextureTransform(o, e.metalnessMap),
            i.pbrMetallicRoughness.metallicRoughnessTexture = o;
        } else {console.warn(
            "THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.",
          );}
      }
      if ((e instanceof In || e instanceof Xn) && e.map) {
        let o = { index: this.processTexture(e.map) };
        this.applyTextureTransform(o, e.map),
          i.pbrMetallicRoughness.baseColorTexture = o;
      }
      if ((e instanceof In || e instanceof Xn) && e.emissive) {
        let o = e.emissive.clone().multiplyScalar(e.emissiveIntensity),
          a = Math.max(o.r, o.g, o.b);
        if (
          a > 1 &&
          (o.multiplyScalar(1 / a),
            console.warn(
              "THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited",
            )),
            a > 0 && (i.emissiveFactor = o.toArray()),
            e.emissiveMap
        ) {
          let u = { index: this.processTexture(e.emissiveMap) };
          this.applyTextureTransform(u, e.emissiveMap), i.emissiveTexture = u;
        }
      }
      if (
        (e instanceof hd || e instanceof mc || e instanceof ro ||
          e instanceof In || e instanceof Sl) && e.normalMap
      ) {
        let o = { index: this.processTexture(e.normalMap) };
        e.normalScale && e.normalScale.x !== 1 && (o.scale = e.normalScale.x),
          this.applyTextureTransform(o, e.normalMap),
          i.normalTexture = o;
      }
      if (
        (e instanceof en || e instanceof wl || e instanceof ro ||
          e instanceof In || e instanceof Sl) && e.aoMap
      ) {
        let o = { index: this.processTexture(e.aoMap), texCoord: 1 };
        e.aoMapIntensity !== 1 && (o.strength = e.aoMapIntensity),
          this.applyTextureTransform(o, e.aoMap),
          i.occlusionTexture = o;
      }
      e.transparent
        ? i.alphaMode = "BLEND"
        : e.alphaTest > 0 &&
          (i.alphaMode = "MASK", i.alphaCutoff = e.alphaTest),
        e.side === Gi && (i.doubleSided = !0),
        e.name !== "" && (i.name = e.name),
        this.serializeUserData(e, i),
        this._invokeAll(function (o) {
          o.writeMaterial && o.writeMaterial(e, i);
        });
      let s = r.materials.push(i) - 1;
      return t.materials.set(e, s), s;
    }
    processMesh(e) {
      let t = this.cache, r = this.json, i = [e.geometry.uuid];
      if (Array.isArray(e.material)) {
        for (let M = 0, T = e.material.length; M < T; M++) {
          i.push(e.material[M].uuid);
        }
      } else i.push(e.material.uuid);
      let s = i.join(":");
      if (t.meshes.has(s)) return t.meshes.get(s);
      let o = e.geometry, a;
      if (
        e instanceof wr && e.isLineSegments
          ? a = zt.LINES
          : e instanceof yl && e.isLineLoop
          ? a = zt.LINE_LOOP
          : e instanceof Fr && e.isLine
          ? a = zt.LINE_STRIP
          : e instanceof la && e.isPoints
          ? a = zt.POINTS
          : a =
            (e.material instanceof en || e.material instanceof Yu ||
                e.material instanceof wl || e.material instanceof mc ||
                e.material instanceof ro || e.material instanceof In ||
                e.material instanceof Sl || e.material instanceof sr) &&
              e.material.wireframe
              ? zt.LINES
              : zt.TRIANGLES,
          !o.isBufferGeometry
      ) {
        throw new Error(
          "THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.",
        );
      }
      let u = {},
        f = {},
        d = [],
        h = [],
        p = {
          uv: "TEXCOORD_0",
          uv2: "TEXCOORD_1",
          color: "COLOR_0",
          skinWeight: "WEIGHTS_0",
          skinIndex: "JOINTS_0",
        },
        g = o.getAttribute("normal");
      g !== void 0 && !(g instanceof Ai) &&
        !this.isNormalizedNormalAttribute(g) &&
        (console.warn(
          "THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.",
        ),
          o.setAttribute("normal", this.createNormalizedNormalAttribute(g)));
      let y = null;
      for (let M in o.attributes) {
        if (M.substr(0, 5) === "morph") continue;
        let T = o.attributes[M];
        if (
          M = p[M] || M.toUpperCase(),
            /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/
              .test(M) || (M = "_" + M),
            t.attributes.has(this.getUID(T))
        ) {
          f[M] = t.attributes.get(this.getUID(T));
          continue;
        }
        y = null;
        let R = T.array;
        M === "JOINTS_0" && !(R instanceof Uint16Array) &&
          !(R instanceof Uint8Array) &&
          (console.warn(
            'GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.',
          ),
            y = new pt(new Uint16Array(R), T.itemSize, T.normalized));
        let P = y !== null && this.processAccessor(y || T, o);
        P && (f[M] = P, t.attributes.set(this.getUID(T), P));
      }
      if (
        g !== void 0 && o.setAttribute("normal", g), Object.keys(f).length === 0
      ) return null;
      if (
        e.morphTargetInfluences !== void 0 && e.morphTargetInfluences.length > 0
      ) {
        let M = [], T = [], b = {};
        if (e.morphTargetDictionary !== void 0) {
          for (let R in e.morphTargetDictionary) {
            b[e.morphTargetDictionary[R]] = R;
          }
        }
        for (let R = 0; R < e.morphTargetInfluences.length; ++R) {
          let P = {}, C = !1;
          for (let L in o.morphAttributes) {
            if (L !== "position" && L !== "normal") {
              C ||
                (console.warn(
                  "GLTFExporter: Only POSITION and NORMAL morph are supported.",
                ),
                  C = !0);
              continue;
            }
            let k = o.morphAttributes[L][R],
              z = L.toUpperCase(),
              Y = o.attributes[L];
            if (t.attributes.has(this.getUID(k))) {
              P[z] = t.attributes.get(this.getUID(k));
              continue;
            }
            let le = k.clone();
            if (!o.morphTargetsRelative) {
              for (let W = 0, G = k.count; W < G; W++) {
                le.setXYZ(
                  W,
                  k.getX(W) - Y.getX(W),
                  k.getY(W) - Y.getY(W),
                  k.getZ(W) - Y.getZ(W),
                );
              }
            }
            let V = this.processAccessor(le, o);
            V != null && (P[z] = V), t.attributes.set(this.getUID(Y), P[z]);
          }
          h.push(P),
            M.push(e.morphTargetInfluences[R]),
            e.morphTargetDictionary !== void 0 && T.push(b[R]);
        }
        u.weights = M,
          T.length > 0 && (u.extras = {}, u.extras.targetNames = T);
      }
      let v = Array.isArray(e.material);
      if (v && o.groups.length === 0) return null;
      let _ = v ? e.material : [e.material],
        S = v ? o.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
      for (let M = 0, T = S.length; M < T; M++) {
        let b = { mode: a, attributes: f };
        if (
          (o instanceof ct || o instanceof $t) && this.serializeUserData(o, b),
            h.length > 0 && (b.targets = h),
            o.index !== null
        ) {
          let P = this.getUID(o.index);
          (S[M].start !== void 0 || S[M].count !== void 0) &&
          (P += `:${S[M].start}:${S[M].count}`),
            t.attributes.has(P)
              ? b.indices = t.attributes.get(P)
              : (b.indices = this.processAccessor(
                o.index,
                o,
                S[M].start,
                S[M].count,
              ),
                t.attributes.set(P, b.indices)),
            b.indices === null && delete b.indices;
        }
        let R = S[M].materialIndex;
        if (R !== void 0 && Array.isArray(_)) {
          let P = _[R];
          if (!Array.isArray(P)) {
            let C = this.processMaterial(P);
            C !== null && (b.material = C), d.push(b);
          }
        }
      }
      u.primitives = d,
        r.meshes || (r.meshes = []),
        this._invokeAll(function (M) {
          M.writeMesh && M.writeMesh(e, u);
        });
      let w = r.meshes.push(u) - 1;
      return t.meshes.set(s, w), w;
    }
    processCamera(e) {
      let t = this.json;
      t.cameras || (t.cameras = []);
      let r = e instanceof $i && e.isOrthographicCamera,
        i = { type: r ? "orthographic" : "perspective" };
      return e instanceof $i && r
        ? i.orthographic = {
          xmag: e.right * 2,
          ymag: e.top * 2,
          zfar: e.far <= 0 ? .001 : e.far,
          znear: e.near < 0 ? 0 : e.near,
        }
        : e instanceof ln &&
          (i.perspective = {
            aspectRatio: e.aspect,
            yfov: Wf.degToRad(e.fov),
            zfar: e.far <= 0 ? .001 : e.far,
            znear: e.near < 0 ? 0 : e.near,
          }),
        e.name !== "" && (i.name = e.type),
        t.cameras.push(i) - 1;
    }
    processAnimation(e, t) {
      let r = this.json, i = this.nodeMap;
      r.animations || (r.animations = []),
        e = wc.Utils.mergeMorphTargetTracks(e.clone(), t);
      let s = e.tracks, o = [], a = [];
      for (let u = 0; u < s.length; ++u) {
        let f = s[u],
          d = st.parseTrackName(f.name),
          h = st.findNode(t, d.nodeName),
          p = lR[d.propertyName];
        if (
          d.objectName === "bones" && (h.isSkinnedMesh
            ? h = h.skeleton.getBoneByName(d.objectIndex)
            : h = void 0), !h || !p
        ) {
          return console.warn(
            'THREE.GLTFExporter: Could not export animation track "%s".',
            f.name,
          ),
            null;
        }
        let g = 1, y = f.values.length / f.times.length;
        p === lR.morphTargetInfluences && (y /= h.morphTargetInfluences.length);
        let v;
        f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline
          ? (v = "CUBICSPLINE", y /= 3)
          : f.getInterpolation() === qs
          ? v = "STEP"
          : v = "LINEAR",
          a.push({
            input: this.processAccessor(new pt(f.times, g)),
            output: this.processAccessor(new pt(f.values, y)),
            interpolation: v,
          }),
          o.push({
            sampler: a.length - 1,
            target: { node: i.get(h), path: p },
          });
      }
      return r.animations.push({
        name: e.name || "clip_" + r.animations.length,
        samplers: a,
        channels: o,
      }),
        r.animations.length - 1;
    }
    processSkin(e) {
      let t = this.json, r = this.nodeMap;
      if (t.nodes !== void 0 && e instanceof aa) {
        let i = t.nodes[r.get(e)], s = e.skeleton;
        if (s === void 0) return null;
        let o = e.skeleton.bones[0];
        if (o === void 0) return null;
        let a = [], u = new Float32Array(s.bones.length * 16), f = new Ge();
        for (let h = 0; h < s.bones.length; ++h) {
          a.push(r.get(s.bones[h])),
            f.copy(s.boneInverses[h]),
            f.multiply(e.bindMatrix).toArray(u, h * 16);
        }
        return t.skins === void 0 && (t.skins = []),
          t.skins.push({
            inverseBindMatrices: this.processAccessor(new pt(u, 16)),
            joints: a,
            skeleton: r.get(o),
          }),
          i.skin = t.skins.length - 1;
      } else return null;
    }
    processNode(e) {
      let t = this.json, r = this.options, i = this.nodeMap;
      t.nodes || (t.nodes = []);
      let s = {};
      if (r.trs) {
        let a = e.quaternion.toArray(),
          u = e.position.toArray(),
          f = e.scale.toArray();
        this.equalArray(a, [0, 0, 0, 1]) || (s.rotation = a),
          this.equalArray(u, [0, 0, 0]) || (s.translation = u),
          this.equalArray(f, [1, 1, 1]) || (s.scale = f);
      } else {e.matrixAutoUpdate && e.updateMatrix(),
          this.isIdentityMatrix(e.matrix) || (s.matrix = e.matrix.elements);}
      if (
        e.name !== "" && (s.name = String(e.name)),
          this.serializeUserData(e, s),
          (e instanceof Ot && e.isMesh || e instanceof Fr && e.isLine ||
            e instanceof la && e.isPoints) && e instanceof Ot
      ) {
        let a = this.processMesh(e);
        a !== null && (s.mesh = a);
      } else {e instanceof oa && e.isCamera &&
          (s.camera = this.processCamera(e));}
      if (
        e instanceof aa && e.isSkinnedMesh && this.skins.push(e),
          e.children.length > 0
      ) {
        let a = [];
        for (let u = 0, f = e.children.length; u < f; u++) {
          let d = e.children[u];
          if (d.visible || !r.onlyVisible) {
            let h = this.processNode(d);
            h !== null && a.push(h);
          }
        }
        a.length > 0 && (s.children = a);
      }
      this._invokeAll(function (a) {
        a.writeNode && a.writeNode(e, s);
      });
      let o = t.nodes.push(s) - 1;
      return i.set(e, o), o;
    }
    processScene(e) {
      let t = this.json, r = this.options;
      t.scenes || (t.scenes = [], t.scene = 0);
      let i = {};
      e.name !== "" && (i.name = e.name), t.scenes.push(i);
      let s = [];
      for (let o = 0, a = e.children.length; o < a; o++) {
        let u = e.children[o];
        if (u.visible || !r.onlyVisible) {
          let f = this.processNode(u);
          f !== null && s.push(f);
        }
      }
      s.length > 0 && (i.nodes = s), this.serializeUserData(e, i);
    }
    processObjects(e) {
      let t = new hl();
      t.name = "AuxScene";
      for (let r = 0; r < e.length; r++) t.children.push(e[r]);
      this.processScene(t);
    }
    processInput(e) {
      let t = this.options;
      e = e instanceof Array ? e : [e],
        this._invokeAll(function (i) {
          i.beforeParse && i.beforeParse(e);
        });
      let r = [];
      for (let i = 0; i < e.length; i++) {
        let s = e[i];
        s instanceof hl ? this.processScene(s) : r.push(e[i]);
      }
      r.length > 0 && this.processObjects(r);
      for (let i = 0; i < this.skins.length; ++i) {
        this.processSkin(this.skins[i]);
      }
      for (let i = 0; t.animations !== void 0 && i < t.animations.length; ++i) {
        this.processAnimation(t.animations[i], e[0]);
      }
      this._invokeAll(function (i) {
        i.afterParse && i.afterParse(e);
      });
    }
    _invokeAll(e) {
      for (let t = 0, r = this.plugins.length; t < r; t++) e(this.plugins[t]);
    }
    equalArray(e, t) {
      return e.length === t.length && e.every(function (r, i) {
        return r === t[i];
      });
    }
    stringToArrayBuffer(e) {
      if (window.TextEncoder !== void 0) {
        return new TextEncoder().encode(e).buffer;
      }
      let t = new Uint8Array(new ArrayBuffer(e.length));
      for (let r = 0, i = e.length; r < i; r++) {
        let s = e.charCodeAt(r);
        t[r] = s > 255 ? 32 : s;
      }
      return t.buffer;
    }
    isIdentityMatrix(e) {
      return this.equalArray(e.elements, [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
      ]);
    }
    getMinMax(e, t, r) {
      let i = {
        min: new Array(e.itemSize).fill(Number.POSITIVE_INFINITY),
        max: new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY),
      };
      for (let s = t; s < t + r; s++) {
        for (let o = 0; o < e.itemSize; o++) {
          let a;
          e.itemSize > 4
            ? a = e.array[s * e.itemSize + o]
            : o === 0
            ? a = e.getX(s)
            : o === 1
            ? a = e.getY(s)
            : o === 2
            ? a = e.getZ(s)
            : o === 3 && (a = e.getW(s)),
            a !== void 0 &&
            (i.min[o] = Math.min(i.min[o], a),
              i.max[o] = Math.max(i.max[o], a));
        }
      }
      return i;
    }
    getPaddedBufferSize(e) {
      return Math.ceil(e / 4) * 4;
    }
    getPaddedArrayBuffer(e, t = 0) {
      let r = this.getPaddedBufferSize(e.byteLength);
      if (r !== e.byteLength) {
        let i = new Uint8Array(r);
        if (i.set(new Uint8Array(e)), t !== 0) {
          for (let s = e.byteLength; s < r; s++) {
            i[s] = t;
          }
        }
        return i.buffer;
      }
      return e;
    }
  },
  dR = class {
    constructor(e) {
      ce(this, "writer", void 0),
        ce(this, "name", void 0),
        this.writer = e,
        this.name = "KHR_lights_punctual";
    }
    writeNode(e, t) {
      if (!e.isLight) return;
      if (
        !(e instanceof ao && e.isDirectionalLight) &&
        !(e instanceof oo && e.isPointLight) &&
        !(e instanceof ya && e.isSpotLight)
      ) {
        console.warn(
          "THREE.GLTFExporter: Only directional, point, and spot lights are supported.",
          e,
        );
        return;
      }
      let r = this.writer, i = r.json, s = r.extensionsUsed, o = {};
      if (
        e.name && (o.name = e.name),
          o.color = e.color.toArray(),
          o.intensity = e.intensity,
          e instanceof ao && e.isDirectionalLight
            ? o.type = "directional"
            : e instanceof oo && e.isPointLight
            ? (o.type = "point", e.distance > 0 && (o.range = e.distance))
            : e instanceof ya && e.isSpotLight &&
              (o.type = "spot",
                e.distance > 0 && (o.range = e.distance),
                o.spot = {},
                o.spot.innerConeAngle = (e.penumbra - 1) * e.angle * -1,
                o.spot.outerConeAngle = e.angle),
          !(e instanceof ao) && e.decay !== void 0 && e.decay !== 2 &&
          console.warn(
            "THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.",
          ),
          !(e instanceof oo) && e.target &&
          (e.target.parent !== e || e.target.position.x !== 0 ||
            e.target.position.y !== 0 || e.target.position.z !== -1) &&
          console.warn(
            "THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.",
          ),
          s[this.name] ||
          (i.extensions = i.extensions || {},
            i.extensions[this.name] = { lights: [] },
            s[this.name] = !0),
          i.extensions !== void 0
      ) {
        let a = i.extensions[this.name].lights;
        a.push(o),
          t.extensions = t.extensions || {},
          t.extensions[this.name] = { light: a.length - 1 };
      }
    }
  },
  hR = class {
    constructor(e) {
      ce(this, "writer", void 0),
        ce(this, "name", void 0),
        this.writer = e,
        this.name = "KHR_materials_unlit";
    }
    writeMaterial(e, t) {
      if (!(e instanceof en && e.isMeshBasicMaterial)) return;
      let i = this.writer.extensionsUsed;
      t.extensions = t.extensions || {},
        t.extensions[this.name] = {},
        i[this.name] = !0,
        t.pbrMetallicRoughness.metallicFactor = 0,
        t.pbrMetallicRoughness.roughnessFactor = .9;
    }
  },
  pR = class {
    constructor(e) {
      ce(this, "writer", void 0),
        ce(this, "name", void 0),
        this.writer = e,
        this.name = "KHR_materials_pbrSpecularGlossiness";
    }
    writeMaterial(e, t) {
      if (!e.isGLTFSpecularGlossinessMaterial) return;
      let r = this.writer, i = r.extensionsUsed, s = {};
      if (
        t.pbrMetallicRoughness.baseColorFactor &&
        (s.diffuseFactor = t.pbrMetallicRoughness.baseColorFactor),
          e instanceof ro
      ) {
        let o = [1, 1, 1];
        e.specular.toArray(o, 0),
          s.specularFactor = o,
          s.glossinessFactor = e.glossiness;
      }
      if (
        t.pbrMetallicRoughness.baseColorTexture &&
        (s.diffuseTexture = t.pbrMetallicRoughness.baseColorTexture),
          (e instanceof en || e instanceof wl || e instanceof ro) &&
          e.specularMap
      ) {
        let o = { index: r.processTexture(e.specularMap) };
        r.applyTextureTransform(o, e.specularMap),
          s.specularGlossinessTexture = o;
      }
      t.extensions = t.extensions || {},
        t.extensions[this.name] = s,
        i[this.name] = !0;
    }
  },
  mR = class {
    constructor(e) {
      ce(this, "writer", void 0),
        ce(this, "name", void 0),
        this.writer = e,
        this.name = "KHR_materials_transmission";
    }
    writeMaterial(e, t) {
      if (
        !(e instanceof Xn && e.isMeshPhysicalMaterial) || e.transmission === 0
      ) return;
      let r = this.writer, i = r.extensionsUsed, s = {};
      if (s.transmissionFactor = e.transmission, e.transmissionMap) {
        let o = { index: r.processTexture(e.transmissionMap) };
        r.applyTextureTransform(o, e.transmissionMap),
          s.transmissionTexture = o;
      }
      t.extensions = t.extensions || {},
        t.extensions[this.name] = s,
        i[this.name] = !0;
    }
  },
  gR = class {
    constructor(e) {
      ce(this, "writer", void 0),
        ce(this, "name", void 0),
        this.writer = e,
        this.name = "KHR_materials_volume";
    }
    writeMaterial(e, t) {
      if (!(e instanceof Xn && e.isMeshPhysicalMaterial) || e.thickness === 0) {
        return;
      }
      let r = this.writer, i = r.extensionsUsed, s = {};
      if (s.thickness = e.thickness, e.thicknessMap) {
        let o = { index: r.processTexture(e.thicknessMap) };
        r.applyTextureTransform(o, e.thicknessMap), s.thicknessTexture = o;
      }
      s.attenuationDistance = e.attenuationDistance,
        s.attenuationColor = e.attenuationTint.toArray(),
        t.extensions = t.extensions || {},
        t.extensions[this.name] = s,
        i[this.name] = !0;
    }
  };
var ns = class extends Ot {
  constructor() {
    super(new ei(1, 1, 1), ns.material);
  }
};
ce(ns, "SkyShader", {
  uniforms: {
    turbidity: { value: 2 },
    rayleigh: { value: 1 },
    mieCoefficient: { value: .005 },
    mieDirectionalG: { value: .8 },
    sunPosition: { value: new I() },
    up: { value: new I(0, 1, 0) },
  },
  vertexShader: [
    "uniform vec3 sunPosition;",
    "uniform float rayleigh;",
    "uniform float turbidity;",
    "uniform float mieCoefficient;",
    "uniform vec3 up;",
    "varying vec3 vWorldPosition;",
    "varying vec3 vSunDirection;",
    "varying float vSunfade;",
    "varying vec3 vBetaR;",
    "varying vec3 vBetaM;",
    "varying float vSunE;",
    "const float e = 2.71828182845904523536028747135266249775724709369995957;",
    "const float pi = 3.141592653589793238462643383279502884197169;",
    "const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );",
    "const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );",
    "const float v = 4.0;",
    "const vec3 K = vec3( 0.686, 0.678, 0.666 );",
    "const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );",
    "const float cutoffAngle = 1.6110731556870734;",
    "const float steepness = 1.5;",
    "const float EE = 1000.0;",
    "float sunIntensity( float zenithAngleCos ) {",
    "	zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );",
    "	return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );",
    "}",
    "vec3 totalMie( float T ) {",
    "	float c = ( 0.2 * T ) * 10E-18;",
    "	return 0.434 * c * MieConst;",
    "}",
    "void main() {",
    "	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
    "	vWorldPosition = worldPosition.xyz;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "	gl_Position.z = gl_Position.w;",
    "	vSunDirection = normalize( sunPosition );",
    "	vSunE = sunIntensity( dot( vSunDirection, up ) );",
    "	vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );",
    "	float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );",
    "	vBetaR = totalRayleigh * rayleighCoefficient;",
    "	vBetaM = totalMie( turbidity ) * mieCoefficient;",
    "}",
  ].join(`
`),
  fragmentShader: [
    "varying vec3 vWorldPosition;",
    "varying vec3 vSunDirection;",
    "varying float vSunfade;",
    "varying vec3 vBetaR;",
    "varying vec3 vBetaM;",
    "varying float vSunE;",
    "uniform float mieDirectionalG;",
    "uniform vec3 up;",
    "const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );",
    "const float pi = 3.141592653589793238462643383279502884197169;",
    "const float n = 1.0003;",
    "const float N = 2.545E25;",
    "const float rayleighZenithLength = 8.4E3;",
    "const float mieZenithLength = 1.25E3;",
    "const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;",
    "const float THREE_OVER_SIXTEENPI = 0.05968310365946075;",
    "const float ONE_OVER_FOURPI = 0.07957747154594767;",
    "float rayleighPhase( float cosTheta ) {",
    "	return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );",
    "}",
    "float hgPhase( float cosTheta, float g ) {",
    "	float g2 = pow( g, 2.0 );",
    "	float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );",
    "	return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );",
    "}",
    "void main() {",
    "	vec3 direction = normalize( vWorldPosition - cameraPos );",
    "	float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );",
    "	float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );",
    "	float sR = rayleighZenithLength * inverse;",
    "	float sM = mieZenithLength * inverse;",
    "	vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );",
    "	float cosTheta = dot( direction, vSunDirection );",
    "	float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );",
    "	vec3 betaRTheta = vBetaR * rPhase;",
    "	float mPhase = hgPhase( cosTheta, mieDirectionalG );",
    "	vec3 betaMTheta = vBetaM * mPhase;",
    "	vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );",
    "	Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );",
    "	float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]",
    "	float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]",
    "	vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );",
    "	vec3 L0 = vec3( 0.1 ) * Fex;",
    "	float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );",
    "	L0 += ( vSunE * 19000.0 * Fex ) * sundisk;",
    "	vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );",
    "	vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );",
    "	gl_FragColor = vec4( retColor, 1.0 );",
    "#include <tonemapping_fragment>",
    "#include <encodings_fragment>",
    "}",
  ].join(`
`),
});
ce(
  ns,
  "material",
  new sr({
    name: "SkyShader",
    fragmentShader: ns.SkyShader.fragmentShader,
    vertexShader: ns.SkyShader.vertexShader,
    uniforms: Lm.clone(ns.SkyShader.uniforms),
    side: mr,
    depthWrite: !1,
  }),
);
var Ng = class extends Xi {
  constructor(e, t) {
    super();
    ce(this, "enabled", !0),
      ce(this, "screen", { left: 0, top: 0, width: 0, height: 0 }),
      ce(this, "rotateSpeed", 1),
      ce(this, "zoomSpeed", 1.2),
      ce(this, "panSpeed", .3),
      ce(this, "noRotate", !1),
      ce(this, "noZoom", !1),
      ce(this, "noPan", !1),
      ce(this, "staticMoving", !1),
      ce(this, "dynamicDampingFactor", .2),
      ce(this, "minDistance", 0),
      ce(this, "maxDistance", 1 / 0),
      ce(this, "keys", ["KeyA", "KeyS", "KeyD"]),
      ce(this, "mouseButtons", {
        LEFT: Of.ROTATE,
        MIDDLE: Of.DOLLY,
        RIGHT: Of.PAN,
      }),
      ce(this, "object", void 0),
      ce(this, "domElement", void 0),
      ce(this, "cursorZoom", !1),
      ce(this, "target", new I()),
      ce(this, "mousePosition", new se()),
      ce(this, "STATE", {
        NONE: -1,
        ROTATE: 0,
        ZOOM: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_ZOOM_PAN: 4,
      }),
      ce(this, "EPS", 1e-6),
      ce(this, "lastZoom", 1),
      ce(this, "lastPosition", new I()),
      ce(this, "cursorVector", new I()),
      ce(this, "targetVector", new I()),
      ce(this, "_state", this.STATE.NONE),
      ce(this, "_keyState", this.STATE.NONE),
      ce(this, "_eye", new I()),
      ce(this, "_movePrev", new se()),
      ce(this, "_moveCurr", new se()),
      ce(this, "_lastAxis", new I()),
      ce(this, "_lastAngle", 0),
      ce(this, "_zoomStart", new se()),
      ce(this, "_zoomEnd", new se()),
      ce(this, "_touchZoomDistanceStart", 0),
      ce(this, "_touchZoomDistanceEnd", 0),
      ce(this, "_panStart", new se()),
      ce(this, "_panEnd", new se()),
      ce(this, "target0", void 0),
      ce(this, "position0", void 0),
      ce(this, "up0", void 0),
      ce(this, "zoom0", void 0),
      ce(this, "changeEvent", { type: "change" }),
      ce(this, "startEvent", { type: "start" }),
      ce(this, "endEvent", { type: "end" }),
      ce(this, "onScreenVector", new se()),
      ce(
        this,
        "getMouseOnScreen",
        (
          r,
          i,
        ) => (this.onScreenVector.set(
          (r - this.screen.left) / this.screen.width,
          (i - this.screen.top) / this.screen.height,
        ),
          this.onScreenVector),
      ),
      ce(this, "onCircleVector", new se()),
      ce(
        this,
        "getMouseOnCircle",
        (
          r,
          i,
        ) => (this.onCircleVector.set(
          (r - this.screen.width * .5 - this.screen.left) /
            (this.screen.width * .5),
          (this.screen.height + 2 * (this.screen.top - i)) / this.screen.width,
        ),
          this.onCircleVector),
      ),
      ce(this, "axis", new I()),
      ce(this, "quaternion", new Pn()),
      ce(this, "eyeDirection", new I()),
      ce(this, "objectUpDirection", new I()),
      ce(this, "objectSidewaysDirection", new I()),
      ce(this, "moveDirection", new I()),
      ce(this, "angle", 0),
      ce(this, "rotateCamera", () => {
        this.moveDirection.set(
          this._moveCurr.x - this._movePrev.x,
          this._moveCurr.y - this._movePrev.y,
          0,
        ),
          this.angle = this.moveDirection.length(),
          this.angle
            ? (this._eye.copy(this.object.position).sub(this.target),
              this.eyeDirection.copy(this._eye).normalize(),
              this.objectUpDirection.copy(this.object.up).normalize(),
              this.objectSidewaysDirection.crossVectors(
                this.objectUpDirection,
                this.eyeDirection,
              ).normalize(),
              this.objectUpDirection.setLength(
                this._moveCurr.y - this._movePrev.y,
              ),
              this.objectSidewaysDirection.setLength(
                this._moveCurr.x - this._movePrev.x,
              ),
              this.moveDirection.copy(
                this.objectUpDirection.add(this.objectSidewaysDirection),
              ),
              this.axis.crossVectors(this.moveDirection, this._eye).normalize(),
              this.angle *= this.rotateSpeed,
              this.quaternion.setFromAxisAngle(this.axis, this.angle),
              this._eye.applyQuaternion(this.quaternion),
              this.object.up.applyQuaternion(this.quaternion),
              this._lastAxis.copy(this.axis),
              this._lastAngle = this.angle)
            : !this.staticMoving && this._lastAngle &&
              (this._lastAngle *= Math.sqrt(1 - this.dynamicDampingFactor),
                this._eye.copy(this.object.position).sub(this.target),
                this.quaternion.setFromAxisAngle(
                  this._lastAxis,
                  this._lastAngle,
                ),
                this._eye.applyQuaternion(this.quaternion),
                this.object.up.applyQuaternion(this.quaternion)),
          this._movePrev.copy(this._moveCurr);
      }),
      ce(this, "zoomCamera", () => {
        let r;
        if (this._state === this.STATE.TOUCH_ZOOM_PAN) {
          r = this._touchZoomDistanceStart / this._touchZoomDistanceEnd,
            this._touchZoomDistanceStart = this._touchZoomDistanceEnd,
            this.object.isPerspectiveCamera
              ? this._eye.multiplyScalar(r)
              : this.object.isOrthographicCamera
              ? (this.object.zoom /= r, this.object.updateProjectionMatrix())
              : console.warn(
                "THREE.TrackballControls: Unsupported camera type",
              );
        } else {
          if (
            r = 1 + (this._zoomEnd.y - this._zoomStart.y) * this.zoomSpeed,
              Math.abs(r - 1) > this.EPS && r > 0 &&
              (this.object.isPerspectiveCamera
                ? (r > 1 && this._eye.length() >= this.maxDistance - this.EPS &&
                  (r = 1),
                  this._eye.multiplyScalar(r))
                : this.object.isOrthographicCamera
                ? (r > 1 &&
                  this.object.zoom < this.maxDistance * this.maxDistance &&
                  (r = 1),
                  this.object.zoom /= r)
                : console.warn(
                  "THREE.TrackballControls: Unsupported camera type",
                )),
              this.staticMoving
                ? this._zoomStart.copy(this._zoomEnd)
                : this._zoomStart.y += (this._zoomEnd.y - this._zoomStart.y) *
                  this.dynamicDampingFactor,
              this.cursorZoom
          ) {
            this.targetVector.copy(this.target).project(this.object);
            let i = this.cursorVector.set(
              this.mousePosition.x,
              this.mousePosition.y,
              this.targetVector.z,
            ).unproject(this.object);
            this.target.lerpVectors(i, this.target, r);
          }
          this.object.isOrthographicCamera &&
            this.object.updateProjectionMatrix();
        }
      }),
      ce(this, "mouseChange", new se()),
      ce(this, "objectUp", new I()),
      ce(this, "pan", new I()),
      ce(this, "panCamera", () => {
        if (
          !!this.domElement &&
          (this.mouseChange.copy(this._panEnd).sub(this._panStart),
            this.mouseChange.lengthSq() > this.EPS)
        ) {
          if (this.object.isOrthographicCamera) {
            let r = this.object,
              i = (r.right - r.left) / this.object.zoom,
              s = (r.top - r.bottom) / this.object.zoom;
            this.mouseChange.x *= i, this.mouseChange.y *= s;
          } else {this.mouseChange.multiplyScalar(
              this._eye.length() * this.panSpeed,
            );}
          this.pan.copy(this._eye).cross(this.object.up).setLength(
            this.mouseChange.x,
          ),
            this.pan.add(
              this.objectUp.copy(this.object.up).setLength(this.mouseChange.y),
            ),
            this.object.position.add(this.pan),
            this.target.add(this.pan),
            this.staticMoving
              ? this._panStart.copy(this._panEnd)
              : this._panStart.add(
                this.mouseChange.subVectors(this._panEnd, this._panStart)
                  .multiplyScalar(this.dynamicDampingFactor),
              );
        }
      }),
      ce(this, "checkDistances", () => {
        (!this.noZoom || !this.noPan) &&
          (this._eye.lengthSq() > this.maxDistance * this.maxDistance &&
            (this.object.position.addVectors(
              this.target,
              this._eye.setLength(this.maxDistance),
            ),
              this._zoomStart.copy(this._zoomEnd)),
            this._eye.lengthSq() < this.minDistance * this.minDistance &&
            (this.object.position.addVectors(
              this.target,
              this._eye.setLength(this.minDistance),
            ),
              this._zoomStart.copy(this._zoomEnd)));
      }),
      ce(this, "handleResize", () => {
        if (!this.domElement) return;
        let r = this.domElement.getBoundingClientRect(),
          i = this.domElement.ownerDocument.documentElement;
        this.screen.left = r.left + window.pageXOffset - i.clientLeft,
          this.screen.top = r.top + window.pageYOffset - i.clientTop,
          this.screen.width = r.width,
          this.screen.height = r.height;
      }),
      ce(this, "update", () => {
        this._eye.subVectors(this.object.position, this.target),
          this.noRotate || this.rotateCamera(),
          this.noZoom || this.zoomCamera(),
          this.noPan || this.panCamera(),
          this.object.position.addVectors(this.target, this._eye),
          this.object.isPerspectiveCamera
            ? (this.checkDistances(),
              this.object.lookAt(this.target),
              this.lastPosition.distanceToSquared(this.object.position) >
                this.EPS &&
              (this.dispatchEvent(this.changeEvent),
                this.lastPosition.copy(this.object.position)))
            : this.object.isOrthographicCamera
            ? (this.object.lookAt(this.target),
              (this.lastPosition.distanceToSquared(this.object.position) >
                  this.EPS || this.lastZoom !== this.object.zoom) &&
              (this.dispatchEvent(this.changeEvent),
                this.lastPosition.copy(this.object.position),
                this.lastZoom = this.object.zoom))
            : console.warn("THREE.TrackballControls: Unsupported camera type");
      }),
      ce(this, "reset", () => {
        this._state = this.STATE.NONE,
          this._keyState = this.STATE.NONE,
          this.target.copy(this.target0),
          this.object.position.copy(this.position0),
          this.object.up.copy(this.up0),
          this.object.zoom = this.zoom0,
          this.object.updateProjectionMatrix(),
          this._eye.subVectors(this.object.position, this.target),
          this.object.lookAt(this.target),
          this.dispatchEvent(this.changeEvent),
          this.lastPosition.copy(this.object.position),
          this.lastZoom = this.object.zoom;
      }),
      ce(this, "keydown", (r) => {
        this.enabled !== !1 &&
          (window.removeEventListener("keydown", this.keydown),
            this._keyState === this.STATE.NONE &&
            (r.code === this.keys[this.STATE.ROTATE] && !this.noRotate
              ? this._keyState = this.STATE.ROTATE
              : r.code === this.keys[this.STATE.ZOOM] && !this.noZoom
              ? this._keyState = this.STATE.ZOOM
              : r.code === this.keys[this.STATE.PAN] && !this.noPan &&
                (this._keyState = this.STATE.PAN)));
      }),
      ce(this, "onPointerDown", (r) => {
        if (this.enabled !== !1) {
          switch (r.pointerType) {
            case "mouse":
            case "pen":
              this.onMouseDown(r);
              break;
          }
        }
      }),
      ce(this, "onPointerMove", (r) => {
        if (this.enabled !== !1) {
          switch (r.pointerType) {
            case "mouse":
            case "pen":
              this.onMouseMove(r);
              break;
          }
        }
      }),
      ce(this, "onPointerUp", (r) => {
        if (this.enabled !== !1) {
          switch (r.pointerType) {
            case "mouse":
            case "pen":
              this.onMouseUp();
              break;
          }
        }
      }),
      ce(this, "keyup", () => {
        this.enabled !== !1 &&
          (this._keyState = this.STATE.NONE,
            window.addEventListener("keydown", this.keydown));
      }),
      ce(this, "onMouseDown", (r) => {
        if (!this.domElement) return;
        if (this._state === this.STATE.NONE) {
          switch (r.button) {
            case this.mouseButtons.LEFT:
              this._state = this.STATE.ROTATE;
              break;
            case this.mouseButtons.MIDDLE:
              this._state = this.STATE.ZOOM;
              break;
            case this.mouseButtons.RIGHT:
              this._state = this.STATE.PAN;
              break;
            default:
              this._state = this.STATE.NONE;
          }
        }
        let i = this._keyState !== this.STATE.NONE
          ? this._keyState
          : this._state;
        i === this.STATE.ROTATE && !this.noRotate
          ? (this._moveCurr.copy(this.getMouseOnCircle(r.pageX, r.pageY)),
            this._movePrev.copy(this._moveCurr))
          : i === this.STATE.ZOOM && !this.noZoom
          ? (this._zoomStart.copy(this.getMouseOnScreen(r.pageX, r.pageY)),
            this._zoomEnd.copy(this._zoomStart))
          : i === this.STATE.PAN && !this.noPan &&
            (this._panStart.copy(this.getMouseOnScreen(r.pageX, r.pageY)),
              this._panEnd.copy(this._panStart)),
          this.domElement.ownerDocument.addEventListener(
            "pointermove",
            this.onPointerMove,
          ),
          this.domElement.ownerDocument.addEventListener(
            "pointerup",
            this.onPointerUp,
          ),
          this.dispatchEvent(this.startEvent);
      }),
      ce(this, "onMouseMove", (r) => {
        if (this.enabled === !1) return;
        let i = this._keyState !== this.STATE.NONE
          ? this._keyState
          : this._state;
        i === this.STATE.ROTATE && !this.noRotate
          ? (this._movePrev.copy(this._moveCurr),
            this._moveCurr.copy(this.getMouseOnCircle(r.pageX, r.pageY)))
          : i === this.STATE.ZOOM && !this.noZoom
          ? this._zoomEnd.copy(this.getMouseOnScreen(r.pageX, r.pageY))
          : i === this.STATE.PAN && !this.noPan &&
            this._panEnd.copy(this.getMouseOnScreen(r.pageX, r.pageY));
      }),
      ce(this, "onMouseUp", () => {
        !this.domElement ||
          this.enabled !== !1 && (this._state = this.STATE.NONE,
              this.domElement.ownerDocument.removeEventListener(
                "pointermove",
                this.onPointerMove,
              ),
              this.domElement.ownerDocument.removeEventListener(
                "pointerup",
                this.onPointerUp,
              ),
              this.dispatchEvent(this.endEvent));
      }),
      ce(this, "mousewheel", (r) => {
        if (this.enabled !== !1 && this.noZoom !== !0) {
          switch (r.preventDefault(), r.deltaMode) {
            case 2:
              this._zoomStart.y -= r.deltaY * .025;
              break;
            case 1:
              this._zoomStart.y -= r.deltaY * .01;
              break;
            default:
              this._zoomStart.y -= r.deltaY * 25e-5;
              break;
          }
          this.mousePosition.x = r.offsetX / this.screen.width * 2 - 1,
            this.mousePosition.y = -(r.offsetY / this.screen.height) * 2 + 1,
            this.dispatchEvent(this.startEvent),
            this.dispatchEvent(this.endEvent);
        }
      }),
      ce(this, "touchstart", (r) => {
        if (this.enabled !== !1) {
          switch (r.preventDefault(), r.touches.length) {
            case 1:
              this._state = this.STATE.TOUCH_ROTATE,
                this._moveCurr.copy(
                  this.getMouseOnCircle(r.touches[0].pageX, r.touches[0].pageY),
                ),
                this._movePrev.copy(this._moveCurr);
              break;
            default:
              this._state = this.STATE.TOUCH_ZOOM_PAN;
              let i = r.touches[0].pageX - r.touches[1].pageX,
                s = r.touches[0].pageY - r.touches[1].pageY;
              this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math
                .sqrt(i * i + s * s);
              let o = (r.touches[0].pageX + r.touches[1].pageX) / 2,
                a = (r.touches[0].pageY + r.touches[1].pageY) / 2;
              this._panStart.copy(this.getMouseOnScreen(o, a)),
                this._panEnd.copy(this._panStart);
              break;
          }
          this.dispatchEvent(this.startEvent);
        }
      }),
      ce(this, "touchmove", (r) => {
        if (this.enabled !== !1) {
          switch (r.preventDefault(), r.touches.length) {
            case 1:
              this._movePrev.copy(this._moveCurr),
                this._moveCurr.copy(
                  this.getMouseOnCircle(r.touches[0].pageX, r.touches[0].pageY),
                );
              break;
            default:
              let i = r.touches[0].pageX - r.touches[1].pageX,
                s = r.touches[0].pageY - r.touches[1].pageY;
              this._touchZoomDistanceEnd = Math.sqrt(i * i + s * s);
              let o = (r.touches[0].pageX + r.touches[1].pageX) / 2,
                a = (r.touches[0].pageY + r.touches[1].pageY) / 2;
              this._panEnd.copy(this.getMouseOnScreen(o, a));
              break;
          }
        }
      }),
      ce(this, "touchend", (r) => {
        if (this.enabled !== !1) {
          switch (r.touches.length) {
            case 0:
              this._state = this.STATE.NONE;
              break;
            case 1:
              this._state = this.STATE.TOUCH_ROTATE,
                this._moveCurr.copy(
                  this.getMouseOnCircle(r.touches[0].pageX, r.touches[0].pageY),
                ),
                this._movePrev.copy(this._moveCurr);
              break;
          }
          this.dispatchEvent(this.endEvent);
        }
      }),
      ce(this, "contextmenu", (r) => {
        this.enabled !== !1 && r.preventDefault();
      }),
      ce(this, "connect", (r) => {
        r === document &&
        console.error(
          'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.',
        ),
          this.domElement = r,
          this.domElement.addEventListener("contextmenu", this.contextmenu),
          this.domElement.addEventListener("pointerdown", this.onPointerDown),
          this.domElement.addEventListener("wheel", this.mousewheel),
          this.domElement.addEventListener("touchstart", this.touchstart),
          this.domElement.addEventListener("touchend", this.touchend),
          this.domElement.addEventListener("touchmove", this.touchmove),
          this.domElement.ownerDocument.addEventListener(
            "pointermove",
            this.onPointerMove,
          ),
          this.domElement.ownerDocument.addEventListener(
            "pointerup",
            this.onPointerUp,
          ),
          window.addEventListener("keydown", this.keydown),
          window.addEventListener("keyup", this.keyup),
          this.handleResize();
      }),
      ce(this, "dispose", () => {
        !this.domElement ||
          (this.domElement.removeEventListener("contextmenu", this.contextmenu),
            this.domElement.removeEventListener(
              "pointerdown",
              this.onPointerDown,
            ),
            this.domElement.removeEventListener("wheel", this.mousewheel),
            this.domElement.removeEventListener("touchstart", this.touchstart),
            this.domElement.removeEventListener("touchend", this.touchend),
            this.domElement.removeEventListener("touchmove", this.touchmove),
            this.domElement.ownerDocument.removeEventListener(
              "pointermove",
              this.onPointerMove,
            ),
            this.domElement.ownerDocument.removeEventListener(
              "pointerup",
              this.onPointerUp,
            ),
            window.removeEventListener("keydown", this.keydown),
            window.removeEventListener("keyup", this.keyup));
      }),
      this.object = e,
      this.target0 = this.target.clone(),
      this.position0 = this.object.position.clone(),
      this.up0 = this.object.up.clone(),
      this.zoom0 = this.object.zoom,
      t !== void 0 && this.connect(t),
      this.update();
  }
};
var Dg = class extends or {
  constructor(e) {
    super(e);
    this.dracoLoader = null,
      this.ktx2Loader = null,
      this.meshoptDecoder = null,
      this.pluginCallbacks = [],
      this.register(function (t) {
        return new _R(t);
      }),
      this.register(function (t) {
        return new CR(t);
      }),
      this.register(function (t) {
        return new bR(t);
      }),
      this.register(function (t) {
        return new wR(t);
      }),
      this.register(function (t) {
        return new MR(t);
      }),
      this.register(function (t) {
        return new ER(t);
      }),
      this.register(function (t) {
        return new TR(t);
      }),
      this.register(function (t) {
        return new xR(t);
      }),
      this.register(function (t) {
        return new AR(t);
      }),
      this.register(function (t) {
        return new SR(t);
      }),
      this.register(function (t) {
        return new vR(t);
      }),
      this.register(function (t) {
        return new RR(t);
      });
  }
  load(e, t, r, i) {
    let s = this, o;
    this.resourcePath !== ""
      ? o = this.resourcePath
      : this.path !== ""
      ? o = this.path
      : o = Ri.extractUrlBase(e), this.manager.itemStart(e);
    let a = function (f) {
        i ? i(f) : console.error(f),
          s.manager.itemError(e),
          s.manager.itemEnd(e);
      },
      u = new ni(this.manager);
    u.setPath(this.path),
      u.setResponseType("arraybuffer"),
      u.setRequestHeader(this.requestHeader),
      u.setWithCredentials(this.withCredentials),
      u.load(
        e,
        function (f) {
          try {
            s.parse(f, o, function (d) {
              t(d), s.manager.itemEnd(e);
            }, a);
          } catch (d) {
            a(d);
          }
        },
        r,
        a,
      );
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".',
    );
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 &&
      this.pluginCallbacks.push(e),
      this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 &&
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this;
  }
  parse(e, t, r, i) {
    let s, o = {}, a = {};
    if (typeof e == "string") s = e;
    else if (Ri.decodeText(new Uint8Array(e, 0, 4)) === LR) {
      try {
        o[ft.KHR_BINARY_GLTF] = new IR(e);
      } catch (h) {
        i && i(h);
        return;
      }
      s = o[ft.KHR_BINARY_GLTF].content;
    } else s = Ri.decodeText(new Uint8Array(e));
    let u = JSON.parse(s);
    if (u.asset === void 0 || u.asset.version[0] < 2) {
      i &&
        i(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.",
          ),
        );
      return;
    }
    let f = new HR(u, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    f.fileLoader.setRequestHeader(this.requestHeader);
    for (let d = 0; d < this.pluginCallbacks.length; d++) {
      let h = this.pluginCallbacks[d](f);
      a[h.name] = h, o[h.name] = !0;
    }
    if (u.extensionsUsed) {
      for (let d = 0; d < u.extensionsUsed.length; ++d) {
        let h = u.extensionsUsed[d], p = u.extensionsRequired || [];
        switch (h) {
          case ft.KHR_MATERIALS_UNLIT:
            o[h] = new yR();
            break;
          case ft.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            o[h] = new kR();
            break;
          case ft.KHR_DRACO_MESH_COMPRESSION:
            o[h] = new NR(u, this.dracoLoader);
            break;
          case ft.KHR_TEXTURE_TRANSFORM:
            o[h] = new DR();
            break;
          case ft.KHR_MESH_QUANTIZATION:
            o[h] = new FR();
            break;
          default:
            p.indexOf(h) >= 0 && a[h] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".');
        }
      }
    }
    f.setExtensions(o), f.setPlugins(a), f.parse(r, i);
  }
  parseAsync(e, t) {
    let r = this;
    return new Promise(function (i, s) {
      r.parse(e, t, i, s);
    });
  }
};
function zB() {
  let n = {};
  return {
    get: function (e) {
      return n[e];
    },
    add: function (e, t) {
      n[e] = t;
    },
    remove: function (e) {
      delete n[e];
    },
    removeAll: function () {
      n = {};
    },
  };
}
var ft = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
      "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  },
  vR = class {
    constructor(e) {
      this.parser = e,
        this.name = ft.KHR_LIGHTS_PUNCTUAL,
        this.cache = { refs: {}, uses: {} };
    }
    _markDefs() {
      let e = this.parser, t = this.parser.json.nodes || [];
      for (let r = 0, i = t.length; r < i; r++) {
        let s = t[r];
        s.extensions && s.extensions[this.name] &&
          s.extensions[this.name].light !== void 0 &&
          e._addNodeRef(this.cache, s.extensions[this.name].light);
      }
    }
    _loadLight(e) {
      let t = this.parser, r = "light:" + e, i = t.cache.get(r);
      if (i) return i;
      let s = t.json,
        u = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e],
        f,
        d = new ve(16777215);
      u.color !== void 0 && d.fromArray(u.color);
      let h = u.range !== void 0 ? u.range : 0;
      switch (u.type) {
        case "directional":
          f = new ao(d), f.target.position.set(0, 0, -1), f.add(f.target);
          break;
        case "point":
          f = new oo(d), f.distance = h;
          break;
        case "spot":
          f = new ya(d),
            f.distance = h,
            u.spot = u.spot || {},
            u.spot.innerConeAngle = u.spot.innerConeAngle !== void 0
              ? u.spot.innerConeAngle
              : 0,
            u.spot.outerConeAngle = u.spot.outerConeAngle !== void 0
              ? u.spot.outerConeAngle
              : Math.PI / 4,
            f.angle = u.spot.outerConeAngle,
            f.penumbra = 1 - u.spot.innerConeAngle / u.spot.outerConeAngle,
            f.target.position.set(0, 0, -1),
            f.add(f.target);
          break;
        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + u.type);
      }
      return f.position.set(0, 0, 0),
        f.decay = 2,
        u.intensity !== void 0 && (f.intensity = u.intensity),
        f.name = t.createUniqueName(u.name || "light_" + e),
        i = Promise.resolve(f),
        t.cache.add(r, i),
        i;
    }
    createNodeAttachment(e) {
      let t = this,
        r = this.parser,
        s = r.json.nodes[e],
        a = (s.extensions && s.extensions[this.name] || {}).light;
      return a === void 0 ? null : this._loadLight(a).then(function (u) {
        return r._getNodeRef(t.cache, a, u);
      });
    }
  },
  yR = class {
    constructor() {
      this.name = ft.KHR_MATERIALS_UNLIT;
    }
    getMaterialType() {
      return en;
    }
    extendParams(e, t, r) {
      let i = [];
      e.color = new ve(1, 1, 1), e.opacity = 1;
      let s = t.pbrMetallicRoughness;
      if (s) {
        if (Array.isArray(s.baseColorFactor)) {
          let o = s.baseColorFactor;
          e.color.fromArray(o), e.opacity = o[3];
        }
        s.baseColorTexture !== void 0 &&
          i.push(r.assignTexture(e, "map", s.baseColorTexture, yt));
      }
      return Promise.all(i);
    }
  },
  xR = class {
    constructor(e) {
      this.parser = e, this.name = ft.KHR_MATERIALS_EMISSIVE_STRENGTH;
    }
    extendMaterialParams(e, t) {
      let i = this.parser.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      let s = i.extensions[this.name].emissiveStrength;
      return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve();
    }
  },
  _R = class {
    constructor(e) {
      this.parser = e, this.name = ft.KHR_MATERIALS_CLEARCOAT;
    }
    getMaterialType(e) {
      let r = this.parser.json.materials[e];
      return !r.extensions || !r.extensions[this.name] ? null : Xn;
    }
    extendMaterialParams(e, t) {
      let r = this.parser, i = r.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      let s = [], o = i.extensions[this.name];
      if (
        o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
          o.clearcoatTexture !== void 0 &&
          s.push(r.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
          o.clearcoatRoughnessFactor !== void 0 &&
          (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
          o.clearcoatRoughnessTexture !== void 0 &&
          s.push(
            r.assignTexture(
              t,
              "clearcoatRoughnessMap",
              o.clearcoatRoughnessTexture,
            ),
          ),
          o.clearcoatNormalTexture !== void 0 &&
          (s.push(
            r.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture),
          ),
            o.clearcoatNormalTexture.scale !== void 0)
      ) {
        let a = o.clearcoatNormalTexture.scale;
        t.clearcoatNormalScale = new se(a, a);
      }
      return Promise.all(s);
    }
  },
  SR = class {
    constructor(e) {
      this.parser = e, this.name = ft.KHR_MATERIALS_IRIDESCENCE;
    }
    getMaterialType(e) {
      let r = this.parser.json.materials[e];
      return !r.extensions || !r.extensions[this.name] ? null : Xn;
    }
    extendMaterialParams(e, t) {
      let r = this.parser, i = r.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      let s = [], o = i.extensions[this.name];
      return o.iridescenceFactor !== void 0 &&
        (t.iridescence = o.iridescenceFactor),
        o.iridescenceTexture !== void 0 &&
        s.push(r.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
        o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
        t.iridescenceThicknessRange === void 0 &&
        (t.iridescenceThicknessRange = [100, 400]),
        o.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
        o.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
        o.iridescenceThicknessTexture !== void 0 &&
        s.push(
          r.assignTexture(
            t,
            "iridescenceThicknessMap",
            o.iridescenceThicknessTexture,
          ),
        ),
        Promise.all(s);
    }
  },
  wR = class {
    constructor(e) {
      this.parser = e, this.name = ft.KHR_MATERIALS_SHEEN;
    }
    getMaterialType(e) {
      let r = this.parser.json.materials[e];
      return !r.extensions || !r.extensions[this.name] ? null : Xn;
    }
    extendMaterialParams(e, t) {
      let r = this.parser, i = r.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      let s = [];
      t.sheenColor = new ve(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
      let o = i.extensions[this.name];
      return o.sheenColorFactor !== void 0 &&
        t.sheenColor.fromArray(o.sheenColorFactor),
        o.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = o.sheenRoughnessFactor),
        o.sheenColorTexture !== void 0 &&
        s.push(r.assignTexture(t, "sheenColorMap", o.sheenColorTexture, yt)),
        o.sheenRoughnessTexture !== void 0 &&
        s.push(
          r.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture),
        ),
        Promise.all(s);
    }
  },
  MR = class {
    constructor(e) {
      this.parser = e, this.name = ft.KHR_MATERIALS_TRANSMISSION;
    }
    getMaterialType(e) {
      let r = this.parser.json.materials[e];
      return !r.extensions || !r.extensions[this.name] ? null : Xn;
    }
    extendMaterialParams(e, t) {
      let r = this.parser, i = r.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      let s = [], o = i.extensions[this.name];
      return o.transmissionFactor !== void 0 &&
        (t.transmission = o.transmissionFactor),
        o.transmissionTexture !== void 0 &&
        s.push(r.assignTexture(t, "transmissionMap", o.transmissionTexture)),
        Promise.all(s);
    }
  },
  ER = class {
    constructor(e) {
      this.parser = e, this.name = ft.KHR_MATERIALS_VOLUME;
    }
    getMaterialType(e) {
      let r = this.parser.json.materials[e];
      return !r.extensions || !r.extensions[this.name] ? null : Xn;
    }
    extendMaterialParams(e, t) {
      let r = this.parser, i = r.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      let s = [], o = i.extensions[this.name];
      t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0,
        o.thicknessTexture !== void 0 &&
        s.push(r.assignTexture(t, "thicknessMap", o.thicknessTexture)),
        t.attenuationDistance = o.attenuationDistance || 1 / 0;
      let a = o.attenuationColor || [1, 1, 1];
      return t.attenuationColor = new ve(a[0], a[1], a[2]), Promise.all(s);
    }
  },
  TR = class {
    constructor(e) {
      this.parser = e, this.name = ft.KHR_MATERIALS_IOR;
    }
    getMaterialType(e) {
      let r = this.parser.json.materials[e];
      return !r.extensions || !r.extensions[this.name] ? null : Xn;
    }
    extendMaterialParams(e, t) {
      let i = this.parser.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      let s = i.extensions[this.name];
      return t.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve();
    }
  },
  AR = class {
    constructor(e) {
      this.parser = e, this.name = ft.KHR_MATERIALS_SPECULAR;
    }
    getMaterialType(e) {
      let r = this.parser.json.materials[e];
      return !r.extensions || !r.extensions[this.name] ? null : Xn;
    }
    extendMaterialParams(e, t) {
      let r = this.parser, i = r.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      let s = [], o = i.extensions[this.name];
      t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1,
        o.specularTexture !== void 0 &&
        s.push(r.assignTexture(t, "specularIntensityMap", o.specularTexture));
      let a = o.specularColorFactor || [1, 1, 1];
      return t.specularColor = new ve(a[0], a[1], a[2]),
        o.specularColorTexture !== void 0 &&
        s.push(
          r.assignTexture(t, "specularColorMap", o.specularColorTexture, yt),
        ),
        Promise.all(s);
    }
  },
  CR = class {
    constructor(e) {
      this.parser = e, this.name = ft.KHR_TEXTURE_BASISU;
    }
    loadTexture(e) {
      let t = this.parser, r = t.json, i = r.textures[e];
      if (!i.extensions || !i.extensions[this.name]) return null;
      let s = i.extensions[this.name], o = t.options.ktx2Loader;
      if (!o) {
        if (
          r.extensionsRequired && r.extensionsRequired.indexOf(this.name) >= 0
        ) {
          throw new Error(
            "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures",
          );
        }
        return null;
      }
      return t.loadTextureImage(e, s.source, o);
    }
  },
  bR = class {
    constructor(e) {
      this.parser = e, this.name = ft.EXT_TEXTURE_WEBP, this.isSupported = null;
    }
    loadTexture(e) {
      let t = this.name, r = this.parser, i = r.json, s = i.textures[e];
      if (!s.extensions || !s.extensions[t]) return null;
      let o = s.extensions[t], a = i.images[o.source], u = r.textureLoader;
      if (a.uri) {
        let f = r.options.manager.getHandler(a.uri);
        f !== null && (u = f);
      }
      return this.detectSupport().then(function (f) {
        if (f) return r.loadTextureImage(e, o.source, u);
        if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) {
          throw new Error(
            "THREE.GLTFLoader: WebP required by asset but unsupported.",
          );
        }
        return r.loadTexture(e);
      });
    }
    detectSupport() {
      return this.isSupported || (this.isSupported = new Promise(function (e) {
        let t = new Image();
        t.src =
          "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
          t.onload = t.onerror = function () {
            e(t.height === 1);
          };
      })),
        this.isSupported;
    }
  },
  RR = class {
    constructor(e) {
      this.name = ft.EXT_MESHOPT_COMPRESSION, this.parser = e;
    }
    loadBufferView(e) {
      let t = this.parser.json, r = t.bufferViews[e];
      if (r.extensions && r.extensions[this.name]) {
        let i = r.extensions[this.name],
          s = this.parser.getDependency("buffer", i.buffer),
          o = this.parser.options.meshoptDecoder;
        if (!o || !o.supported) {
          if (
            t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0
          ) {
            throw new Error(
              "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files",
            );
          }
          return null;
        }
        return s.then(function (a) {
          let u = i.byteOffset || 0,
            f = i.byteLength || 0,
            d = i.count,
            h = i.byteStride,
            p = new Uint8Array(a, u, f);
          return o.decodeGltfBufferAsync
            ? o.decodeGltfBufferAsync(d, h, p, i.mode, i.filter).then(
              function (g) {
                return g.buffer;
              },
            )
            : o.ready.then(function () {
              let g = new ArrayBuffer(d * h);
              return o.decodeGltfBuffer(
                new Uint8Array(g),
                d,
                h,
                p,
                i.mode,
                i.filter,
              ),
                g;
            });
        });
      } else return null;
    }
  },
  LR = "glTF",
  Md = 12,
  PR = { JSON: 1313821514, BIN: 5130562 },
  IR = class {
    constructor(e) {
      this.name = ft.KHR_BINARY_GLTF, this.content = null, this.body = null;
      let t = new DataView(e, 0, Md);
      if (
        this.header = {
          magic: Ri.decodeText(new Uint8Array(e.slice(0, 4))),
          version: t.getUint32(4, !0),
          length: t.getUint32(8, !0),
        }, this.header.magic !== LR
      ) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      if (this.header.version < 2) {
        throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      }
      let r = this.header.length - Md, i = new DataView(e, Md), s = 0;
      for (; s < r;) {
        let o = i.getUint32(s, !0);
        s += 4;
        let a = i.getUint32(s, !0);
        if (s += 4, a === PR.JSON) {
          let u = new Uint8Array(e, Md + s, o);
          this.content = Ri.decodeText(u);
        } else if (a === PR.BIN) {
          let u = Md + s;
          this.body = e.slice(u, u + o);
        }
        s += o;
      }
      if (this.content === null) {
        throw new Error("THREE.GLTFLoader: JSON content not found.");
      }
    }
  },
  NR = class {
    constructor(e, t) {
      if (!t) {
        throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      }
      this.name = ft.KHR_DRACO_MESH_COMPRESSION,
        this.json = e,
        this.dracoLoader = t,
        this.dracoLoader.preload();
    }
    decodePrimitive(e, t) {
      let r = this.json,
        i = this.dracoLoader,
        s = e.extensions[this.name].bufferView,
        o = e.extensions[this.name].attributes,
        a = {},
        u = {},
        f = {};
      for (let d in o) {
        let h = YS[d] || d.toLowerCase();
        a[h] = o[d];
      }
      for (let d in e.attributes) {
        let h = YS[d] || d.toLowerCase();
        if (o[d] !== void 0) {
          let p = r.accessors[e.attributes[d]], g = Ed[p.componentType];
          f[h] = g.name, u[h] = p.normalized === !0;
        }
      }
      return t.getDependency("bufferView", s).then(function (d) {
        return new Promise(function (h) {
          i.decodeDracoFile(
            d,
            function (p) {
              for (let g in p.attributes) {
                let y = p.attributes[g], v = u[g];
                v !== void 0 && (y.normalized = v);
              }
              h(p);
            },
            a,
            f,
          );
        });
      });
    }
  },
  DR = class {
    constructor() {
      this.name = ft.KHR_TEXTURE_TRANSFORM;
    }
    extendTexture(e, t) {
      return t.texCoord !== void 0 &&
        console.warn(
          'THREE.GLTFLoader: Custom UV sets in "' + this.name +
            '" extension not yet supported.',
        ),
        t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 ||
        (e = e.clone(),
          t.offset !== void 0 && e.offset.fromArray(t.offset),
          t.rotation !== void 0 && (e.rotation = t.rotation),
          t.scale !== void 0 && e.repeat.fromArray(t.scale),
          e.needsUpdate = !0),
        e;
    }
  },
  kg = class extends In {
    constructor(e) {
      super();
      this.isGLTFSpecularGlossinessMaterial = !0;
      let t = [
          "#ifdef USE_SPECULARMAP",
          "	uniform sampler2D specularMap;",
          "#endif",
        ].join(`
`),
        r = [
          "#ifdef USE_GLOSSINESSMAP",
          "	uniform sampler2D glossinessMap;",
          "#endif",
        ].join(`
`),
        i = [
          "vec3 specularFactor = specular;",
          "#ifdef USE_SPECULARMAP",
          "	vec4 texelSpecular = texture2D( specularMap, vUv );",
          "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
          "	specularFactor *= texelSpecular.rgb;",
          "#endif",
        ].join(`
`),
        s = [
          "float glossinessFactor = glossiness;",
          "#ifdef USE_GLOSSINESSMAP",
          "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
          "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
          "	glossinessFactor *= texelGlossiness.a;",
          "#endif",
        ].join(`
`),
        o = [
          "PhysicalMaterial material;",
          "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
          "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
          "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
          "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
          "material.roughness += geometryRoughness;",
          "material.roughness = min( material.roughness, 1.0 );",
          "material.specularColor = specularFactor;",
        ].join(`
`),
        a = {
          specular: { value: new ve().setHex(16777215) },
          glossiness: { value: 1 },
          specularMap: { value: null },
          glossinessMap: { value: null },
        };
      this._extraUniforms = a,
        this.onBeforeCompile = function (u) {
          for (let f in a) u.uniforms[f] = a[f];
          u.fragmentShader = u.fragmentShader.replace(
            "uniform float roughness;",
            "uniform vec3 specular;",
          ).replace("uniform float metalness;", "uniform float glossiness;")
            .replace("#include <roughnessmap_pars_fragment>", t).replace(
              "#include <metalnessmap_pars_fragment>",
              r,
            ).replace("#include <roughnessmap_fragment>", i).replace(
              "#include <metalnessmap_fragment>",
              s,
            ).replace("#include <lights_physical_fragment>", o);
        },
        Object.defineProperties(this, {
          specular: {
            get: function () {
              return a.specular.value;
            },
            set: function (u) {
              a.specular.value = u;
            },
          },
          specularMap: {
            get: function () {
              return a.specularMap.value;
            },
            set: function (u) {
              a.specularMap.value = u,
                u
                  ? this.defines.USE_SPECULARMAP = ""
                  : delete this.defines.USE_SPECULARMAP;
            },
          },
          glossiness: {
            get: function () {
              return a.glossiness.value;
            },
            set: function (u) {
              a.glossiness.value = u;
            },
          },
          glossinessMap: {
            get: function () {
              return a.glossinessMap.value;
            },
            set: function (u) {
              a.glossinessMap.value = u,
                u
                  ? (this.defines.USE_GLOSSINESSMAP = "",
                    this.defines.USE_UV = "")
                  : (delete this.defines.USE_GLOSSINESSMAP,
                    delete this.defines.USE_UV);
            },
          },
        }),
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this.setValues(e);
    }
    copy(e) {
      return super.copy(e),
        this.specularMap = e.specularMap,
        this.specular.copy(e.specular),
        this.glossinessMap = e.glossinessMap,
        this.glossiness = e.glossiness,
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this;
    }
  },
  kR = class {
    constructor() {
      this.name = ft.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
        this.specularGlossinessParams = [
          "color",
          "map",
          "lightMap",
          "lightMapIntensity",
          "aoMap",
          "aoMapIntensity",
          "emissive",
          "emissiveIntensity",
          "emissiveMap",
          "bumpMap",
          "bumpScale",
          "normalMap",
          "normalMapType",
          "displacementMap",
          "displacementScale",
          "displacementBias",
          "specularMap",
          "specular",
          "glossinessMap",
          "glossiness",
          "alphaMap",
          "envMap",
          "envMapIntensity",
          "refractionRatio",
        ];
    }
    getMaterialType() {
      return kg;
    }
    extendParams(e, t, r) {
      let i = t.extensions[this.name];
      e.color = new ve(1, 1, 1), e.opacity = 1;
      let s = [];
      if (Array.isArray(i.diffuseFactor)) {
        let o = i.diffuseFactor;
        e.color.fromArray(o), e.opacity = o[3];
      }
      if (
        i.diffuseTexture !== void 0 &&
        s.push(r.assignTexture(e, "map", i.diffuseTexture, yt)),
          e.emissive = new ve(0, 0, 0),
          e.glossiness = i.glossinessFactor !== void 0 ? i.glossinessFactor : 1,
          e.specular = new ve(1, 1, 1),
          Array.isArray(i.specularFactor) &&
          e.specular.fromArray(i.specularFactor),
          i.specularGlossinessTexture !== void 0
      ) {
        let o = i.specularGlossinessTexture;
        s.push(r.assignTexture(e, "glossinessMap", o)),
          s.push(r.assignTexture(e, "specularMap", o, yt));
      }
      return Promise.all(s);
    }
    createMaterial(e) {
      let t = new kg(e);
      return t.fog = !0,
        t.color = e.color,
        t.map = e.map === void 0 ? null : e.map,
        t.lightMap = null,
        t.lightMapIntensity = 1,
        t.aoMap = e.aoMap === void 0 ? null : e.aoMap,
        t.aoMapIntensity = 1,
        t.emissive = e.emissive,
        t.emissiveIntensity = e.emissiveIntensity === void 0
          ? 1
          : e.emissiveIntensity,
        t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap,
        t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap,
        t.bumpScale = 1,
        t.normalMap = e.normalMap === void 0 ? null : e.normalMap,
        t.normalMapType = Zs,
        e.normalScale && (t.normalScale = e.normalScale),
        t.displacementMap = null,
        t.displacementScale = 1,
        t.displacementBias = 0,
        t.specularMap = e.specularMap === void 0 ? null : e.specularMap,
        t.specular = e.specular,
        t.glossinessMap = e.glossinessMap === void 0 ? null : e.glossinessMap,
        t.glossiness = e.glossiness,
        t.alphaMap = null,
        t.envMap = e.envMap === void 0 ? null : e.envMap,
        t.envMapIntensity = 1,
        t.refractionRatio = .98,
        t;
    }
  },
  FR = class {
    constructor() {
      this.name = ft.KHR_MESH_QUANTIZATION;
    }
  },
  qS = class extends da {
    constructor(e, t, r, i) {
      super(e, t, r, i);
    }
    copySampleValue_(e) {
      let t = this.resultBuffer,
        r = this.sampleValues,
        i = this.valueSize,
        s = e * i * 3 + i;
      for (let o = 0; o !== i; o++) t[o] = r[s + o];
      return t;
    }
    interpolate_(e, t, r, i) {
      let s = this.resultBuffer,
        o = this.sampleValues,
        a = this.valueSize,
        u = a * 2,
        f = a * 3,
        d = i - t,
        h = (r - t) / d,
        p = h * h,
        g = p * h,
        y = e * f,
        v = y - f,
        _ = -2 * g + 3 * p,
        S = g - p,
        w = 1 - _,
        M = S - p + h;
      for (let T = 0; T !== a; T++) {
        let b = o[v + T + a],
          R = o[v + T + u] * d,
          P = o[y + T + a],
          C = o[y + T] * d;
        s[T] = w * b + M * R + _ * P + S * C;
      }
      return s;
    }
  },
  BB = new Pn(),
  OR = class extends qS {
    interpolate_(e, t, r, i) {
      let s = super.interpolate_(e, t, r, i);
      return BB.fromArray(s).normalize().toArray(s), s;
    }
  },
  uo = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  Ed = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  zR = { 9728: Jt, 9729: kt, 9984: jo, 9985: $a, 9986: Wo, 9987: Mi },
  BR = { 33071: Rn, 33648: Ws, 10497: Wi },
  UR = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  YS = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  Sa = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  UB = { CUBICSPLINE: void 0, LINEAR: xs, STEP: qs },
  ZS = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function VB(n) {
  return n.DefaultMaterial === void 0 &&
    (n.DefaultMaterial = new In({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: !1,
      depthTest: !0,
      side: Gs,
    })),
    n.DefaultMaterial;
}
function Td(n, e, t) {
  for (let r in t.extensions) {
    n[r] === void 0 &&
      (e.userData.gltfExtensions = e.userData.gltfExtensions || {},
        e.userData.gltfExtensions[r] = t.extensions[r]);
  }
}
function Nl(n, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(n.userData, e.extras)
      : console.warn(
        "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras,
      ));
}
function HB(n, e, t) {
  let r = !1, i = !1, s = !1;
  for (let f = 0, d = e.length; f < d; f++) {
    let h = e[f];
    if (
      h.POSITION !== void 0 && (r = !0),
        h.NORMAL !== void 0 && (i = !0),
        h.COLOR_0 !== void 0 && (s = !0),
        r && i && s
    ) break;
  }
  if (!r && !i && !s) return Promise.resolve(n);
  let o = [], a = [], u = [];
  for (let f = 0, d = e.length; f < d; f++) {
    let h = e[f];
    if (r) {
      let p = h.POSITION !== void 0
        ? t.getDependency("accessor", h.POSITION)
        : n.attributes.position;
      o.push(p);
    }
    if (i) {
      let p = h.NORMAL !== void 0
        ? t.getDependency("accessor", h.NORMAL)
        : n.attributes.normal;
      a.push(p);
    }
    if (s) {
      let p = h.COLOR_0 !== void 0
        ? t.getDependency("accessor", h.COLOR_0)
        : n.attributes.color;
      u.push(p);
    }
  }
  return Promise.all([Promise.all(o), Promise.all(a), Promise.all(u)]).then(
    function (f) {
      let d = f[0], h = f[1], p = f[2];
      return r && (n.morphAttributes.position = d),
        i && (n.morphAttributes.normal = h),
        s && (n.morphAttributes.color = p),
        n.morphTargetsRelative = !0,
        n;
    },
  );
}
function GB(n, e) {
  if (n.updateMorphTargets(), e.weights !== void 0) {
    for (let t = 0, r = e.weights.length; t < r; t++) {
      n.morphTargetInfluences[t] = e.weights[t];
    }
  }
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    let t = e.extras.targetNames;
    if (n.morphTargetInfluences.length === t.length) {
      n.morphTargetDictionary = {};
      for (let r = 0, i = t.length; r < i; r++) {
        n.morphTargetDictionary[t[r]] = r;
      }
    } else {console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.",
      );}
  }
}
function jB(n) {
  let e = n.extensions && n.extensions[ft.KHR_DRACO_MESH_COMPRESSION], t;
  return e
    ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + VR(e.attributes)
    : t = n.indices + ":" + VR(n.attributes) + ":" + n.mode,
    t;
}
function VR(n) {
  let e = "", t = Object.keys(n).sort();
  for (let r = 0, i = t.length; r < i; r++) e += t[r] + ":" + n[t[r]] + ";";
  return e;
}
function KS(n) {
  switch (n) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type.",
      );
  }
}
function WB(n) {
  return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : "image/png";
}
var HR = class {
  constructor(e = {}, t = {}) {
    var r, i;
    this.json = e,
      this.extensions = {},
      this.plugins = {},
      this.options = t,
      this.cache = new zB(),
      this.associations = new Map(),
      this.primitiveCache = {},
      this.meshCache = { refs: {}, uses: {} },
      this.cameraCache = { refs: {}, uses: {} },
      this.lightCache = { refs: {}, uses: {} },
      this.sourceCache = {},
      this.textureCache = {},
      this.nodeNamesUsed = {};
    let s = typeof navigator != "undefined" &&
        /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0,
      o = typeof navigator != "undefined" &&
        ((r = navigator.userAgent) === null || r === void 0
            ? void 0
            : r.indexOf("Firefox")) > -1,
      a = typeof navigator != "undefined" && o
        ? (i = navigator.userAgent) === null || i === void 0
          ? void 0
          : i.match(/Firefox\/([0-9]+)\./)[1]
        : -1;
    typeof createImageBitmap == "undefined" || s || o && a < 98
      ? this.textureLoader = new og(this.options.manager)
      : this.textureLoader = new lg(this.options.manager),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      this.fileLoader = new ni(this.options.manager),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
      this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    let r = this, i = this.json, s = this.extensions;
    this.cache.removeAll(),
      this._invokeAll(function (o) {
        return o._markDefs && o._markDefs();
      }),
      Promise.all(this._invokeAll(function (o) {
        return o.beforeRoot && o.beforeRoot();
      })).then(function () {
        return Promise.all([
          r.getDependencies("scene"),
          r.getDependencies("animation"),
          r.getDependencies("camera"),
        ]);
      }).then(function (o) {
        let a = {
          scene: o[0][i.scene || 0],
          scenes: o[0],
          animations: o[1],
          cameras: o[2],
          asset: i.asset,
          parser: r,
          userData: {},
        };
        Td(s, a, i),
          Nl(a, i),
          Promise.all(r._invokeAll(function (u) {
            return u.afterRoot && u.afterRoot(a);
          })).then(function () {
            e(a);
          });
      }).catch(t);
  }
  _markDefs() {
    let e = this.json.nodes || [],
      t = this.json.skins || [],
      r = this.json.meshes || [];
    for (let i = 0, s = t.length; i < s; i++) {
      let o = t[i].joints;
      for (let a = 0, u = o.length; a < u; a++) e[o[a]].isBone = !0;
    }
    for (let i = 0, s = e.length; i < s; i++) {
      let o = e[i];
      o.mesh !== void 0 &&
      (this._addNodeRef(this.meshCache, o.mesh),
        o.skin !== void 0 && (r[o.mesh].isSkinnedMesh = !0)),
        o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, r) {
    if (e.refs[t] <= 1) return r;
    let i = r.clone(),
      s = (o, a) => {
        let u = this.associations.get(o);
        u != null && this.associations.set(a, u);
        for (let [f, d] of o.children.entries()) s(d, a.children[f]);
      };
    return s(r, i), i.name += "_instance_" + e.uses[t]++, i;
  }
  _invokeOne(e) {
    let t = Object.values(this.plugins);
    t.push(this);
    for (let r = 0; r < t.length; r++) {
      let i = e(t[r]);
      if (i) return i;
    }
    return null;
  }
  _invokeAll(e) {
    let t = Object.values(this.plugins);
    t.unshift(this);
    let r = [];
    for (let i = 0; i < t.length; i++) {
      let s = e(t[i]);
      s && r.push(s);
    }
    return r;
  }
  getDependency(e, t) {
    let r = e + ":" + t, i = this.cache.get(r);
    if (!i) {
      switch (e) {
        case "scene":
          i = this.loadScene(t);
          break;
        case "node":
          i = this.loadNode(t);
          break;
        case "mesh":
          i = this._invokeOne(function (s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          i = this.loadAccessor(t);
          break;
        case "bufferView":
          i = this._invokeOne(function (s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          i = this.loadBuffer(t);
          break;
        case "material":
          i = this._invokeOne(function (s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          i = this._invokeOne(function (s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          i = this.loadSkin(t);
          break;
        case "animation":
          i = this._invokeOne(function (s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          i = this.loadCamera(t);
          break;
        default:
          throw new Error("Unknown type: " + e);
      }
      this.cache.add(r, i);
    }
    return i;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      let r = this, i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(i.map(function (s, o) {
        return r.getDependency(e, o);
      })), this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    let t = this.json.buffers[e], r = this.fileLoader;
    if (t.type && t.type !== "arraybuffer") {
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported.",
      );
    }
    if (t.uri === void 0 && e === 0) {
      return Promise.resolve(this.extensions[ft.KHR_BINARY_GLTF].body);
    }
    let i = this.options;
    return new Promise(function (s, o) {
      r.load(Ri.resolveURL(t.uri, i.path), s, void 0, function () {
        o(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'),
        );
      });
    });
  }
  loadBufferView(e) {
    let t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (r) {
      let i = t.byteLength || 0, s = t.byteOffset || 0;
      return r.slice(s, s + i);
    });
  }
  loadAccessor(e) {
    let t = this, r = this.json, i = this.json.accessors[e];
    if (i.bufferView === void 0 && i.sparse === void 0) {
      return Promise.resolve(null);
    }
    let s = [];
    return i.bufferView !== void 0
      ? s.push(this.getDependency("bufferView", i.bufferView))
      : s.push(null),
      i.sparse !== void 0 &&
      (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
      Promise.all(s).then(function (o) {
        let a = o[0],
          u = UR[i.type],
          f = Ed[i.componentType],
          d = f.BYTES_PER_ELEMENT,
          h = d * u,
          p = i.byteOffset || 0,
          g = i.bufferView !== void 0
            ? r.bufferViews[i.bufferView].byteStride
            : void 0,
          y = i.normalized === !0,
          v,
          _;
        if (g && g !== h) {
          let S = Math.floor(p / g),
            w = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType +
              ":" + S + ":" + i.count,
            M = t.cache.get(w);
          M ||
          (v = new f(a, S * g, i.count * g / d),
            M = new pl(v, g / d),
            t.cache.add(w, M)), _ = new Ai(M, u, p % g / d, y);
        } else {a === null
            ? v = new f(i.count * u)
            : v = new f(a, p, i.count * u),
            _ = new pt(v, u, y);}
        if (i.sparse !== void 0) {
          let S = UR.SCALAR,
            w = Ed[i.sparse.indices.componentType],
            M = i.sparse.indices.byteOffset || 0,
            T = i.sparse.values.byteOffset || 0,
            b = new w(o[1], M, i.sparse.count * S),
            R = new f(o[2], T, i.sparse.count * u);
          a !== null && (_ = new pt(_.array.slice(), _.itemSize, _.normalized));
          for (let P = 0, C = b.length; P < C; P++) {
            let L = b[P];
            if (
              _.setX(L, R[P * u]),
                u >= 2 && _.setY(L, R[P * u + 1]),
                u >= 3 && _.setZ(L, R[P * u + 2]),
                u >= 4 && _.setW(L, R[P * u + 3]),
                u >= 5
            ) {
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.",
              );
            }
          }
        }
        return _;
      });
  }
  loadTexture(e) {
    let t = this.json,
      r = this.options,
      s = t.textures[e].source,
      o = t.images[s],
      a = this.textureLoader;
    if (o.uri) {
      let u = r.manager.getHandler(o.uri);
      u !== null && (a = u);
    }
    return this.loadTextureImage(e, s, a);
  }
  loadTextureImage(e, t, r) {
    let i = this,
      s = this.json,
      o = s.textures[e],
      a = s.images[t],
      u = (a.uri || a.bufferView) + ":" + o.sampler;
    if (this.textureCache[u]) return this.textureCache[u];
    let f = this.loadImageSource(t, r).then(function (d) {
      d.flipY = !1, o.name && (d.name = o.name);
      let p = (s.samplers || {})[o.sampler] || {};
      return d.magFilter = zR[p.magFilter] || kt,
        d.minFilter = zR[p.minFilter] || Mi,
        d.wrapS = BR[p.wrapS] || Wi,
        d.wrapT = BR[p.wrapT] || Wi,
        i.associations.set(d, { textures: e }),
        d;
    }).catch(function () {
      return null;
    });
    return this.textureCache[u] = f, f;
  }
  loadImageSource(e, t) {
    let r = this, i = this.json, s = this.options;
    if (this.sourceCache[e] !== void 0) {
      return this.sourceCache[e].then((h) => h.clone());
    }
    let o = i.images[e],
      a = self.URL || self.webkitURL,
      u = o.uri || "",
      f = !1;
    if (o.bufferView !== void 0) {
      u = r.getDependency("bufferView", o.bufferView).then(function (h) {
        f = !0;
        let p = new Blob([h], { type: o.mimeType });
        return u = a.createObjectURL(p), u;
      });
    } else if (o.uri === void 0) {
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView",
      );
    }
    let d = Promise.resolve(u).then(function (h) {
      return new Promise(function (p, g) {
        let y = p;
        t.isImageBitmapLoader === !0 && (y = function (v) {
          let _ = new Qt(v);
          _.needsUpdate = !0, p(_);
        }), t.load(Ri.resolveURL(h, s.path), y, void 0, g);
      });
    }).then(function (h) {
      return f === !0 && a.revokeObjectURL(u),
        h.userData.mimeType = o.mimeType || WB(o.uri),
        h;
    }).catch(function (h) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", u), h;
    });
    return this.sourceCache[e] = d, d;
  }
  assignTexture(e, t, r, i) {
    let s = this;
    return this.getDependency("texture", r.index).then(function (o) {
      if (
        r.texCoord !== void 0 && r.texCoord != 0 &&
        !(t === "aoMap" && r.texCoord == 1) &&
        console.warn(
          "THREE.GLTFLoader: Custom UV set " + r.texCoord + " for texture " +
            t + " not yet supported.",
        ),
          s.extensions[ft.KHR_TEXTURE_TRANSFORM]
      ) {
        let a = r.extensions !== void 0
          ? r.extensions[ft.KHR_TEXTURE_TRANSFORM]
          : void 0;
        if (a) {
          let u = s.associations.get(o);
          o = s.extensions[ft.KHR_TEXTURE_TRANSFORM].extendTexture(o, a),
            s.associations.set(o, u);
        }
      }
      return i !== void 0 && (o.encoding = i), e[t] = o, o;
    });
  }
  assignFinalMaterial(e) {
    let t = e.geometry,
      r = e.material,
      i = t.attributes.tangent === void 0,
      s = t.attributes.color !== void 0,
      o = t.attributes.normal === void 0;
    if (e.isPoints) {
      let a = "PointsMaterial:" + r.uuid, u = this.cache.get(a);
      u ||
      (u = new ec(),
        $t.prototype.copy.call(u, r),
        u.color.copy(r.color),
        u.map = r.map,
        u.sizeAttenuation = !1,
        this.cache.add(a, u)), r = u;
    } else if (e.isLine) {
      let a = "LineBasicMaterial:" + r.uuid, u = this.cache.get(a);
      u ||
      (u = new Un(),
        $t.prototype.copy.call(u, r),
        u.color.copy(r.color),
        this.cache.add(a, u)), r = u;
    }
    if (i || s || o) {
      let a = "ClonedMaterial:" + r.uuid + ":";
      r.isGLTFSpecularGlossinessMaterial && (a += "specular-glossiness:"),
        i && (a += "derivative-tangents:"),
        s && (a += "vertex-colors:"),
        o && (a += "flat-shading:");
      let u = this.cache.get(a);
      u || (u = r.clone(),
        s && (u.vertexColors = !0),
        o && (u.flatShading = !0),
        i &&
        (u.normalScale && (u.normalScale.y *= -1),
          u.clearcoatNormalScale && (u.clearcoatNormalScale.y *= -1)),
        this.cache.add(a, u),
        this.associations.set(u, this.associations.get(r))),
        r = u;
    }
    r.aoMap && t.attributes.uv2 === void 0 && t.attributes.uv !== void 0 &&
    t.setAttribute("uv2", t.attributes.uv), e.material = r;
  }
  getMaterialType() {
    return In;
  }
  loadMaterial(e) {
    let t = this,
      r = this.json,
      i = this.extensions,
      s = r.materials[e],
      o,
      a = {},
      u = s.extensions || {},
      f = [];
    if (u[ft.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      let h = i[ft.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      o = h.getMaterialType(), f.push(h.extendParams(a, s, t));
    } else if (u[ft.KHR_MATERIALS_UNLIT]) {
      let h = i[ft.KHR_MATERIALS_UNLIT];
      o = h.getMaterialType(), f.push(h.extendParams(a, s, t));
    } else {
      let h = s.pbrMetallicRoughness || {};
      if (
        a.color = new ve(1, 1, 1),
          a.opacity = 1,
          Array.isArray(h.baseColorFactor)
      ) {
        let p = h.baseColorFactor;
        a.color.fromArray(p), a.opacity = p[3];
      }
      h.baseColorTexture !== void 0 &&
      f.push(t.assignTexture(a, "map", h.baseColorTexture, yt)),
        a.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1,
        a.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1,
        h.metallicRoughnessTexture !== void 0 &&
        (f.push(t.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)),
          f.push(
            t.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture),
          )),
        o = this._invokeOne(function (p) {
          return p.getMaterialType && p.getMaterialType(e);
        }),
        f.push(Promise.all(this._invokeAll(function (p) {
          return p.extendMaterialParams && p.extendMaterialParams(e, a);
        })));
    }
    s.doubleSided === !0 && (a.side = Gi);
    let d = s.alphaMode || ZS.OPAQUE;
    if (
      d === ZS.BLEND
        ? (a.transparent = !0, a.depthWrite = !1)
        : (a.transparent = !1,
          d === ZS.MASK &&
          (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)),
        s.normalTexture !== void 0 && o !== en &&
        (f.push(t.assignTexture(a, "normalMap", s.normalTexture)),
          a.normalScale = new se(1, 1),
          s.normalTexture.scale !== void 0)
    ) {
      let h = s.normalTexture.scale;
      a.normalScale.set(h, h);
    }
    return s.occlusionTexture !== void 0 && o !== en &&
      (f.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 &&
        (a.aoMapIntensity = s.occlusionTexture.strength)),
      s.emissiveFactor !== void 0 && o !== en &&
      (a.emissive = new ve().fromArray(s.emissiveFactor)),
      s.emissiveTexture !== void 0 && o !== en &&
      f.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, yt)),
      Promise.all(f).then(function () {
        let h;
        return o === kg
          ? h = i[ft.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a)
          : h = new o(a),
          s.name && (h.name = s.name),
          Nl(h, s),
          t.associations.set(h, { materials: e }),
          s.extensions && Td(i, h, s),
          h;
      });
  }
  createUniqueName(e) {
    let t = st.sanitizeNodeName(e || ""), r = t;
    for (let i = 1; this.nodeNamesUsed[r]; ++i) r = t + "_" + i;
    return this.nodeNamesUsed[r] = !0, r;
  }
  loadGeometries(e) {
    let t = this, r = this.extensions, i = this.primitiveCache;
    function s(a) {
      return r[ft.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(
        function (u) {
          return jR(u, a, t);
        },
      );
    }
    let o = [];
    for (let a = 0, u = e.length; a < u; a++) {
      let f = e[a], d = jB(f), h = i[d];
      if (h) o.push(h.promise);
      else {
        let p;
        f.extensions && f.extensions[ft.KHR_DRACO_MESH_COMPRESSION]
          ? p = s(f)
          : p = jR(new Ye(), f, t),
          i[d] = { primitive: f, promise: p },
          o.push(p);
      }
    }
    return Promise.all(o);
  }
  loadMesh(e) {
    let t = this,
      r = this.json,
      i = this.extensions,
      s = r.meshes[e],
      o = s.primitives,
      a = [];
    for (let u = 0, f = o.length; u < f; u++) {
      let d = o[u].material === void 0
        ? VB(this.cache)
        : this.getDependency("material", o[u].material);
      a.push(d);
    }
    return a.push(t.loadGeometries(o)),
      Promise.all(a).then(function (u) {
        let f = u.slice(0, u.length - 1), d = u[u.length - 1], h = [];
        for (let g = 0, y = d.length; g < y; g++) {
          let v = d[g], _ = o[g], S, w = f[g];
          if (
            _.mode === uo.TRIANGLES || _.mode === uo.TRIANGLE_STRIP ||
            _.mode === uo.TRIANGLE_FAN || _.mode === void 0
          ) {
            S = s.isSkinnedMesh === !0 ? new aa(v, w) : new Ot(v, w),
              S.isSkinnedMesh === !0 &&
              !S.geometry.attributes.skinWeight.normalized &&
              S.normalizeSkinWeights(),
              _.mode === uo.TRIANGLE_STRIP
                ? S.geometry = WR(S.geometry, Vx)
                : _.mode === uo.TRIANGLE_FAN &&
                  (S.geometry = WR(S.geometry, rm));
          } else if (_.mode === uo.LINES) S = new wr(v, w);
          else if (_.mode === uo.LINE_STRIP) S = new Fr(v, w);
          else if (_.mode === uo.LINE_LOOP) S = new yl(v, w);
          else if (_.mode === uo.POINTS) S = new la(v, w);
          else {throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + _.mode,
            );}
          Object.keys(S.geometry.morphAttributes).length > 0 && GB(S, s),
            S.name = t.createUniqueName(s.name || "mesh_" + e),
            Nl(S, s),
            _.extensions && Td(i, S, _),
            t.assignFinalMaterial(S),
            h.push(S);
        }
        for (let g = 0, y = h.length; g < y; g++) {
          t.associations.set(h[g], { meshes: e, primitives: g });
        }
        if (h.length === 1) return h[0];
        let p = new ti();
        t.associations.set(p, { meshes: e });
        for (let g = 0, y = h.length; g < y; g++) p.add(h[g]);
        return p;
      });
  }
  loadCamera(e) {
    let t, r = this.json.cameras[e], i = r[r.type];
    if (!i) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return r.type === "perspective"
      ? t = new ln(
        Wf.radToDeg(i.yfov),
        i.aspectRatio || 1,
        i.znear || 1,
        i.zfar || 2e6,
      )
      : r.type === "orthographic" &&
        (t = new $i(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
      r.name && (t.name = this.createUniqueName(r.name)),
      Nl(t, r),
      Promise.resolve(t);
  }
  loadSkin(e) {
    let t = this.json.skins[e], r = { joints: t.joints };
    return t.inverseBindMatrices === void 0
      ? Promise.resolve(r)
      : this.getDependency("accessor", t.inverseBindMatrices).then(
        function (i) {
          return r.inverseBindMatrices = i, r;
        },
      );
  }
  loadAnimation(e) {
    let r = this.json.animations[e], i = [], s = [], o = [], a = [], u = [];
    for (let f = 0, d = r.channels.length; f < d; f++) {
      let h = r.channels[f],
        p = r.samplers[h.sampler],
        g = h.target,
        y = g.node,
        v = r.parameters !== void 0 ? r.parameters[p.input] : p.input,
        _ = r.parameters !== void 0 ? r.parameters[p.output] : p.output;
      i.push(this.getDependency("node", y)),
        s.push(this.getDependency("accessor", v)),
        o.push(this.getDependency("accessor", _)),
        a.push(p),
        u.push(g);
    }
    return Promise.all([
      Promise.all(i),
      Promise.all(s),
      Promise.all(o),
      Promise.all(a),
      Promise.all(u),
    ]).then(function (f) {
      let d = f[0], h = f[1], p = f[2], g = f[3], y = f[4], v = [];
      for (let S = 0, w = d.length; S < w; S++) {
        let M = d[S], T = h[S], b = p[S], R = g[S], P = y[S];
        if (M === void 0) continue;
        M.updateMatrix();
        let C;
        switch (Sa[P.path]) {
          case Sa.weights:
            C = pa;
            break;
          case Sa.rotation:
            C = ws;
            break;
          case Sa.position:
          case Sa.scale:
          default:
            C = ga;
            break;
        }
        let L = M.name ? M.name : M.uuid,
          k = R.interpolation !== void 0 ? UB[R.interpolation] : xs,
          z = [];
        Sa[P.path] === Sa.weights
          ? M.traverse(function (le) {
            le.morphTargetInfluences && z.push(le.name ? le.name : le.uuid);
          })
          : z.push(L);
        let Y = b.array;
        if (b.normalized) {
          let le = KS(Y.constructor), V = new Float32Array(Y.length);
          for (let W = 0, G = Y.length; W < G; W++) V[W] = Y[W] * le;
          Y = V;
        }
        for (let le = 0, V = z.length; le < V; le++) {
          let W = new C(z[le] + "." + Sa[P.path], T.array, Y, k);
          R.interpolation === "CUBICSPLINE" &&
          (W.createInterpolant = function (re) {
            let ie = this instanceof ws ? OR : qS;
            return new ie(this.times, this.values, this.getValueSize() / 3, re);
          },
            W.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0),
            v.push(W);
        }
      }
      let _ = r.name ? r.name : "animation_" + e;
      return new va(_, void 0, v);
    });
  }
  createNodeMesh(e) {
    let t = this.json, r = this, i = t.nodes[e];
    return i.mesh === void 0
      ? null
      : r.getDependency("mesh", i.mesh).then(function (s) {
        let o = r._getNodeRef(r.meshCache, i.mesh, s);
        return i.weights !== void 0 && o.traverse(function (a) {
          if (!!a.isMesh) {
            for (let u = 0, f = i.weights.length; u < f; u++) {
              a.morphTargetInfluences[u] = i.weights[u];
            }
          }
        }),
          o;
      });
  }
  loadNode(e) {
    let t = this.json,
      r = this.extensions,
      i = this,
      s = t.nodes[e],
      o = s.name ? i.createUniqueName(s.name) : "";
    return function () {
      let a = [],
        u = i._invokeOne(function (f) {
          return f.createNodeMesh && f.createNodeMesh(e);
        });
      return u && a.push(u),
        s.camera !== void 0 &&
        a.push(
          i.getDependency("camera", s.camera).then(function (f) {
            return i._getNodeRef(i.cameraCache, s.camera, f);
          }),
        ),
        i._invokeAll(function (f) {
          return f.createNodeAttachment && f.createNodeAttachment(e);
        }).forEach(function (f) {
          a.push(f);
        }),
        Promise.all(a);
    }().then(function (a) {
      let u;
      if (
        s.isBone === !0
          ? u = new $u()
          : a.length > 1
          ? u = new ti()
          : a.length === 1
          ? u = a[0]
          : u = new ct(), u !== a[0]
      ) { for (let f = 0, d = a.length; f < d; f++) u.add(a[f]); }
      if (
        s.name && (u.userData.name = s.name, u.name = o),
          Nl(u, s),
          s.extensions && Td(r, u, s),
          s.matrix !== void 0
      ) {
        let f = new Ge();
        f.fromArray(s.matrix), u.applyMatrix4(f);
      } else {s.translation !== void 0 && u.position.fromArray(s.translation),
          s.rotation !== void 0 && u.quaternion.fromArray(s.rotation),
          s.scale !== void 0 && u.scale.fromArray(s.scale);}
      return i.associations.has(u) || i.associations.set(u, {}),
        i.associations.get(u).nodes = e,
        u;
    });
  }
  loadScene(e) {
    let t = this.json,
      r = this.extensions,
      i = this.json.scenes[e],
      s = this,
      o = new ti();
    i.name && (o.name = s.createUniqueName(i.name)),
      Nl(o, i),
      i.extensions && Td(r, o, i);
    let a = i.nodes || [], u = [];
    for (let f = 0, d = a.length; f < d; f++) u.push(GR(a[f], o, t, s));
    return Promise.all(u).then(function () {
      let f = (d) => {
        let h = new Map();
        for (let [p, g] of s.associations) {
          (p instanceof $t || p instanceof Qt) && h.set(p, g);
        }
        return d.traverse((p) => {
          let g = s.associations.get(p);
          g != null && h.set(p, g);
        }),
          h;
      };
      return s.associations = f(o), o;
    });
  }
};
function GR(n, e, t, r) {
  let i = t.nodes[n];
  return r.getDependency("node", n).then(function (s) {
    if (i.skin === void 0) return s;
    let o;
    return r.getDependency("skin", i.skin).then(function (a) {
      o = a;
      let u = [];
      for (let f = 0, d = o.joints.length; f < d; f++) {
        u.push(r.getDependency("node", o.joints[f]));
      }
      return Promise.all(u);
    }).then(function (a) {
      return s.traverse(function (u) {
        if (!u.isMesh) return;
        let f = [], d = [];
        for (let h = 0, p = a.length; h < p; h++) {
          let g = a[h];
          if (g) {
            f.push(g);
            let y = new Ge();
            o.inverseBindMatrices !== void 0 &&
            y.fromArray(o.inverseBindMatrices.array, h * 16), d.push(y);
          } else {console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              o.joints[h],
            );}
        }
        u.bind(new gl(f, d), u.matrixWorld);
      }),
        s;
    });
  }).then(function (s) {
    e.add(s);
    let o = [];
    if (i.children) {
      let a = i.children;
      for (let u = 0, f = a.length; u < f; u++) {
        let d = a[u];
        o.push(GR(d, s, t, r));
      }
    }
    return Promise.all(o);
  });
}
function XB(n, e, t) {
  let r = e.attributes, i = new Yi();
  if (r.POSITION !== void 0) {
    let a = t.json.accessors[r.POSITION], u = a.min, f = a.max;
    if (u !== void 0 && f !== void 0) {
      if (
        i.set(new I(u[0], u[1], u[2]), new I(f[0], f[1], f[2])), a.normalized
      ) {
        let d = KS(Ed[a.componentType]);
        i.min.multiplyScalar(d), i.max.multiplyScalar(d);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION.",
      );
      return;
    }
  } else return;
  let s = e.targets;
  if (s !== void 0) {
    let a = new I(), u = new I();
    for (let f = 0, d = s.length; f < d; f++) {
      let h = s[f];
      if (h.POSITION !== void 0) {
        let p = t.json.accessors[h.POSITION], g = p.min, y = p.max;
        if (g !== void 0 && y !== void 0) {
          if (
            u.setX(Math.max(Math.abs(g[0]), Math.abs(y[0]))),
              u.setY(Math.max(Math.abs(g[1]), Math.abs(y[1]))),
              u.setZ(Math.max(Math.abs(g[2]), Math.abs(y[2]))),
              p.normalized
          ) {
            let v = KS(Ed[p.componentType]);
            u.multiplyScalar(v);
          }
          a.max(u);
        } else {console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION.",
          );}
      }
    }
    i.expandByVector(a);
  }
  n.boundingBox = i;
  let o = new Zi();
  i.getCenter(o.center),
    o.radius = i.min.distanceTo(i.max) / 2,
    n.boundingSphere = o;
}
function jR(n, e, t) {
  let r = e.attributes, i = [];
  function s(o, a) {
    return t.getDependency("accessor", o).then(function (u) {
      n.setAttribute(a, u);
    });
  }
  for (let o in r) {
    let a = YS[o] || o.toLowerCase();
    a in n.attributes || i.push(s(r[o], a));
  }
  if (e.indices !== void 0 && !n.index) {
    let o = t.getDependency("accessor", e.indices).then(function (a) {
      n.setIndex(a);
    });
    i.push(o);
  }
  return Nl(n, e),
    XB(n, e, t),
    Promise.all(i).then(function () {
      return e.targets !== void 0 ? HB(n, e.targets, t) : n;
    });
}
function WR(n, e) {
  let t = n.getIndex();
  if (t === null) {
    let o = [], a = n.getAttribute("position");
    if (a !== void 0) {
      for (let u = 0; u < a.count; u++) o.push(u);
      n.setIndex(o), t = n.getIndex();
    } else {return console.error(
        "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.",
      ),
        n;}
  }
  let r = t.count - 2, i = [];
  if (e === rm) {
    for (let o = 1; o <= r; o++) {
      i.push(t.getX(0)), i.push(t.getX(o)), i.push(t.getX(o + 1));
    }
  } else {for (let o = 0; o < r; o++) {
      o % 2 == 0
        ? (i.push(t.getX(o)), i.push(t.getX(o + 1)), i.push(t.getX(o + 2)))
        : (i.push(t.getX(o + 2)), i.push(t.getX(o + 1)), i.push(t.getX(o)));
    }}
  i.length / 3 !== r &&
    console.error(
      "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.",
    );
  let s = n.clone();
  return s.setIndex(i), s;
}
var XR = class {
    static createButton(e, t = {}) {
      let r = document.createElement("button");
      function i() {
        if (t.domOverlay === void 0) {
          let h = document.createElement("div");
          h.style.display = "none", document.body.appendChild(h);
          let p = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          p.setAttribute("width", 38),
            p.setAttribute("height", 38),
            p.style.position = "absolute",
            p.style.right = "20px",
            p.style.top = "20px",
            p.addEventListener("click", function () {
              u.end();
            }),
            h.appendChild(p);
          let g = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path",
          );
          g.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28"),
            g.setAttribute("stroke", "#fff"),
            g.setAttribute("stroke-width", 2),
            p.appendChild(g),
            t.optionalFeatures === void 0 && (t.optionalFeatures = []),
            t.optionalFeatures.push("dom-overlay"),
            t.domOverlay = { root: h };
        }
        let u = null;
        async function f(h) {
          h.addEventListener("end", d),
            e.xr.setReferenceSpaceType("local"),
            await e.xr.setSession(h),
            r.textContent = "STOP AR",
            t.domOverlay.root.style.display = "",
            u = h;
        }
        function d() {
          u.removeEventListener("end", d),
            r.textContent = "START AR",
            t.domOverlay.root.style.display = "none",
            u = null;
        }
        r.style.display = "",
          r.style.cursor = "pointer",
          r.style.left = "calc(50% - 50px)",
          r.style.width = "100px",
          r.textContent = "START AR",
          r.onmouseenter = function () {
            r.style.opacity = "1.0";
          },
          r.onmouseleave = function () {
            r.style.opacity = "0.5";
          },
          r.onclick = function () {
            u === null
              ? navigator.xr.requestSession("immersive-ar", t).then(f)
              : u.end();
          };
      }
      function s() {
        r.style.display = "",
          r.style.cursor = "auto",
          r.style.left = "calc(50% - 75px)",
          r.style.width = "150px",
          r.onmouseenter = null,
          r.onmouseleave = null,
          r.onclick = null;
      }
      function o() {
        s(), r.textContent = "AR NOT SUPPORTED";
      }
      function a(u) {
        u.style.position = "absolute",
          u.style.bottom = "20px",
          u.style.padding = "12px 6px",
          u.style.border = "1px solid #fff",
          u.style.borderRadius = "4px",
          u.style.background = "rgba(0,0,0,0.1)",
          u.style.color = "#fff",
          u.style.font = "normal 13px sans-serif",
          u.style.textAlign = "center",
          u.style.opacity = "0.5",
          u.style.outline = "none",
          u.style.zIndex = "999";
      }
      if ("xr" in navigator) {
        return r.id = "ARButton",
          r.style.display = "none",
          a(r),
          navigator.xr.isSessionSupported("immersive-ar").then(function (u) {
            u ? i() : o();
          }).catch(o),
          r;
      }
      {
        let u = document.createElement("a");
        return window.isSecureContext === !1
          ? (u.href = document.location.href.replace(/^http:/, "https:"),
            u.innerHTML = "WEBXR NEEDS HTTPS")
          : (u.href = "https://immersiveweb.dev/",
            u.innerHTML = "WEBXR NOT AVAILABLE"),
          u.style.left = "calc(50% - 90px)",
          u.style.width = "180px",
          u.style.textDecoration = "none",
          a(u),
          u;
      }
    }
  },
  qR = class {
    static createButton(e, t = {}) {
      let r = document.createElement("button");
      function i() {
        let u = null;
        async function f(h) {
          h.addEventListener("end", d),
            await e.xr.setSession(h),
            r.textContent = "EXIT VR",
            u = h;
        }
        function d() {
          u.removeEventListener("end", d), r.textContent = "ENTER VR", u = null;
        }
        r.style.display = "",
          r.style.cursor = "pointer",
          r.style.left = "calc(50% - 50px)",
          r.style.width = "100px",
          r.textContent = "ENTER VR",
          r.onmouseenter = function () {
            r.style.opacity = "1.0";
          },
          r.onmouseleave = function () {
            r.style.opacity = "0.5";
          },
          r.onclick = function () {
            if (u === null) {
              let h = [
                t.optionalFeatures,
                "local-floor",
                "bounded-floor",
                "hand-tracking",
              ].flat().filter(Boolean);
              navigator.xr.requestSession("immersive-vr", {
                ...t,
                optionalFeatures: h,
              }).then(f);
            } else u.end();
          };
      }
      function s() {
        r.style.display = "",
          r.style.cursor = "auto",
          r.style.left = "calc(50% - 75px)",
          r.style.width = "150px",
          r.onmouseenter = null,
          r.onmouseleave = null,
          r.onclick = null;
      }
      function o() {
        s(), r.textContent = "VR NOT SUPPORTED";
      }
      function a(u) {
        u.style.position = "absolute",
          u.style.bottom = "20px",
          u.style.padding = "12px 6px",
          u.style.border = "1px solid #fff",
          u.style.borderRadius = "4px",
          u.style.background = "rgba(0,0,0,0.1)",
          u.style.color = "#fff",
          u.style.font = "normal 13px sans-serif",
          u.style.textAlign = "center",
          u.style.opacity = "0.5",
          u.style.outline = "none",
          u.style.zIndex = "999";
      }
      if ("xr" in navigator) {
        return r.id = "VRButton",
          r.style.display = "none",
          a(r),
          navigator.xr.isSessionSupported("immersive-vr").then(function (u) {
            u ? i() : o();
          }),
          r;
      }
      {
        let u = document.createElement("a");
        return window.isSecureContext === !1
          ? (u.href = document.location.href.replace(/^http:/, "https:"),
            u.innerHTML = "WEBXR NEEDS HTTPS")
          : (u.href = "https://immersiveweb.dev/",
            u.innerHTML = "WEBXR NOT AVAILABLE"),
          u.style.left = "calc(50% - 90px)",
          u.style.width = "180px",
          u.style.textDecoration = "none",
          a(u),
          u;
      }
    }
  },
  qB = {
    make: (n, e, t, r) => {
      let i = e.xr.getController(n),
        s = e.xr.getControllerGrip(n),
        o = e.xr.getHand(n),
        a = { inputSource: void 0, grip: s, controller: i, hand: o };
      s.userData.name = "grip",
        i.userData.name = "controller",
        o.userData.name = "hand",
        i.addEventListener("connected", (u) => {
          u.fake || (a.inputSource = u.data, t(a));
        }),
        i.addEventListener("disconnected", (u) => {
          r(a);
        });
    },
  },
  Dl = {
    make: function () {
      return new Map();
    },
    add: function (n, e, t, r) {
      n.has(e) || n.set(e, { key: [r] });
      let i = n.get(e);
      i[t] || (i[t] = []), i[t].push(r);
    },
    delete: function (n, e, t, r) {
      let i = n.get(e);
      !i || !i[t] ||
        (i[t] = i[t].filter((s) => s !== r),
          i[t].length === 0 && delete i[t],
          Object.keys(i).length === 0 && n.delete(e));
    },
    has: function (n, e, t) {
      let r = n.get(e);
      return !!(r && r[t]);
    },
    get: function (n, e, t) {
      let r = n.get(e);
      return r && r[t];
    },
  },
  kl = (n, e, { handedness: t } = {}) => {
    let r = It.default.useRef(e);
    It.default.useEffect(() => {
      r.current = e;
    }, [e]);
    let { controllers: i } = Ad();
    It.default.useEffect(() => {
      let s = t ? i.filter((a) => a.inputSource.handedness === t) : i, o = [];
      return s.forEach((a) => {
        let u = (f) => r.current({ originalEvent: f, controller: a });
        a.controller.addEventListener(n, u),
          o.push(() => a.controller.removeEventListener(n, u));
      }),
        () => o.forEach((a) => a());
    }, [n, i, t]);
  },
  YR = () =>
    console.warn(
      "You must provide a ARCanvas or VRCanvas as a wrapper to use interactions",
    ),
  JS = It.default.createContext({
    hoverState: {},
    addInteraction: YR,
    removeInteraction: YR,
  });
function YB({ children: n }) {
  let e = Nn(),
    { controllers: t } = Ad(),
    [r] = It.default.useState(() => ({
      left: new Map(),
      right: new Map(),
      none: new Map(),
    })),
    [i] = It.default.useState(() => Dl.make()),
    s = It.default.useCallback((d, h, p) => {
      Dl.add(i, d, h, p);
    }, [i]),
    o = It.default.useCallback((d, h, p) => {
      Dl.delete(i, d, h, p);
    }, [i]),
    a = It.default.useCallback((d) => {
      let h = Array.from(i.keys()), p = new Ge();
      return p.identity().extractRotation(d.matrixWorld),
        e.raycaster.ray.origin.setFromMatrixPosition(d.matrixWorld),
        e.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(p),
        e.raycaster.intersectObjects(h, !0);
    }, [i, e.raycaster]);
  Or(() => {
    i.size !== 0 && t.forEach((d) => {
      let { controller: h } = d,
        p = d.inputSource.handedness,
        g = r[p],
        y = new Set(),
        v = a(h);
      if (e.raycaster.filter) v = e.raycaster.filter(v, e);
      else {
        let S = v.find((w) => w == null ? void 0 : w.object);
        S && (v = [S]);
      }
      v.forEach((S) => {
        let w = S.object;
        for (; w;) {
          if (Dl.has(i, w, "onHover") && !g.has(w)) {
            var M;
            (M = Dl.get(i, w, "onHover")) == null ||
              M.forEach((T) => T({ controller: d, intersection: S }));
          }
          g.set(w, S), y.add(w.id), w = w.parent;
        }
      });
      for (let S of g.keys()) {
        if (!y.has(S.id)) {
          var _;
          (_ = Dl.get(i, S, "onBlur")) == null ||
          _.forEach((w) => w({ controller: d })), g.delete(S);
        }
      }
    });
  });
  let u = (d) => (h) => {
    let p = r[h.controller.inputSource.handedness];
    for (let y of p.keys()) {
      var g;
      (g = Dl.get(i, y, d)) == null ||
        g.forEach((v) =>
          v({ controller: h.controller, intersection: p.get(y) })
        );
    }
  };
  kl("select", u("onSelect")),
    kl("selectstart", u("onSelectStart")),
    kl("selectend", u("onSelectEnd")),
    kl("squeeze", u("onSqueeze")),
    kl("squeezeend", u("onSqueezeEnd")),
    kl("squeezestart", u("onSqueezeStart"));
  let f = (0, It.useMemo)(
    () => ({ addInteraction: s, removeInteraction: o, hoverState: r }),
    [s, o, r],
  );
  return It.default.createElement(JS.Provider, { value: f }, n);
}
var wa = (n, e, t) => {
    let { addInteraction: r, removeInteraction: i } = (0, It.useContext)(JS),
      s = t !== void 0,
      o = (0, It.useRef)(t);
    (0, It.useEffect)(() => {
      o.current = t;
    }, [t]),
      (0, It.useEffect)(() => {
        if (!s) return;
        let a = (f) => {
          o.current == null || o.current(f);
        };
        r(n.current, e, a);
        let u = n.current;
        return () => i(u, e, a);
      }, [e, r, i, s, n]);
  },
  ZB = (0, It.forwardRef)((n, e) => {
    let t = (0, It.useRef)();
    return wa(t, "onHover", n.onHover),
      wa(t, "onBlur", n.onBlur),
      wa(t, "onSelectStart", n.onSelectStart),
      wa(t, "onSelectEnd", n.onSelectEnd),
      wa(t, "onSelect", n.onSelect),
      wa(t, "onSqueezeStart", n.onSqueezeStart),
      wa(t, "onSqueezeEnd", n.onSqueezeEnd),
      wa(t, "onSqueeze", n.onSqueeze),
      It.default.createElement("group", { ref: Ig([e, t]) }, n.children);
  });
function ZR({ children: n }) {
  let e = (0, It.useRef)(), t = (0, It.useRef)(), r = (0, It.useRef)(void 0);
  return kl("selectend", (i) => {
    i.controller.controller === e.current &&
      (e.current = void 0, r.current = void 0);
  }),
    Or(() => {
      if (!e.current || !r.current || !t.current) return;
      let i = e.current, s = t.current;
      s.applyMatrix4(r.current),
        s.applyMatrix4(i.matrixWorld),
        s.updateWorldMatrix(!1, !0),
        r.current = i.matrixWorld.clone().invert();
    }),
    It.default.createElement(ZB, {
      ref: t,
      onSelectStart: (i) => {
        e.current = i.controller.controller,
          r.current = i.controller.controller.matrixWorld.clone().invert();
      },
    }, n);
}
var KR = Mt.createContext({}),
  KB = (n) => {
    let { gl: e } = Nn(), [t, r] = Mt.useState([]);
    return Mt.useEffect(() => {
      [0, 1].forEach((s) => {
        qB.make(s, e, (o) => {
          n.add(o.controller),
            n.add(o.grip),
            n.add(o.hand),
            r((a) => [...a, o]);
        }, (o) => {
          n.remove(o.controller),
            n.remove(o.grip),
            n.remove(o.hand),
            r((a) => a.filter((u) => u !== o));
        });
      });
    }, [e, n]),
      t;
  };
function JB({ foveation: n = 0, children: e }) {
  let { gl: t, camera: r } = Nn(),
    [i, s] = Mt.useState(() => t.xr.isPresenting),
    [o, a] = Mt.useState(!1),
    [u] = Mt.useState(() => new ti()),
    f = KB(u);
  Mt.useEffect(() => {
    let h = t.xr, p = () => s(h.isPresenting);
    return h.addEventListener("sessionstart", p),
      h.addEventListener("sessionend", p),
      () => {
        h.removeEventListener("sessionstart", p),
          h.removeEventListener("sessionend", p);
      };
  }, [t]),
    Mt.useEffect(() => {
      let h = t.xr;
      h.setFoveation && h.setFoveation(n);
    }, [t, n]),
    Mt.useEffect(() => {
      var h;
      let p = t.xr.getSession(),
        g = (y) => a(Object.values(y.session.inputSources).some((v) => v.hand));
      return p == null || p.addEventListener("inputsourceschange", g),
        a(
          Object.values(
            (h = p == null ? void 0 : p.inputSources) != null ? h : [],
          ).some((y) => y.hand),
        ),
        () => {
          p == null || p.removeEventListener("inputsourceschange", g);
        };
    }, [i]);
  let d = Mt.useMemo(
    () => ({ controllers: f, isPresenting: i, isHandTracking: o, player: u }),
    [f, i, o, u],
  );
  return Mt.createElement(
    KR.Provider,
    { value: d },
    Mt.createElement(
      "primitive",
      { object: u, dispose: null },
      Mt.createElement("primitive", { object: r, dispose: null }),
    ),
    e,
  );
}
function QB({ foveation: n, children: e, ...t }) {
  return Mt.createElement(
    Pg,
    zr({ vr: !0 }, t),
    Mt.createElement(JB, { foveation: n }, Mt.createElement(YB, null, e)),
  );
}
function $B(n, e, t, r) {
  let i = Mt.useMemo(() => (n === "AR" ? XR : qR).createButton(e, t), [
    n,
    e,
    t,
  ]);
  return Mt.useLayoutEffect(() => {
    var s;
    let o = (s = r == null ? void 0 : r.current) != null ? s : document.body;
    return o.appendChild(i), () => void o.removeChild(i);
  }, [i]),
    i;
}
function eU({ mode: n, sessionInit: e }) {
  let t = Nn((r) => r.gl);
  return $B(n, t, e), null;
}
function JR({ children: n, sessionInit: e, ...t }) {
  return Mt.createElement(
    QB,
    t,
    Mt.createElement(eU, { mode: "VR", sessionInit: e }),
    n,
  );
}
var Ad = () => {
  let n = Mt.useContext(KR), e = Mt.useContext(JS);
  return Mt.useMemo(() => ({ ...n, ...e }), [n, e]);
};
var mn = {
  Handedness: Object.freeze({ NONE: "none", LEFT: "left", RIGHT: "right" }),
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed",
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state",
  }),
  ComponentType: Object.freeze({
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button",
  }),
  ButtonTouchThreshold: .05,
  AxisTouchThreshold: .1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility",
  }),
};
async function QR(n) {
  let e = await fetch(n);
  if (e.ok) return e.json();
  throw new Error(e.statusText);
}
async function tU(n) {
  if (!n) throw new Error("No basePath supplied");
  return await QR(`${n}/profilesList.json`);
}
async function nU(n, e, t = null, r = !0) {
  if (!n) throw new Error("No xrInputSource supplied");
  if (!e) throw new Error("No basePath supplied");
  let i = await tU(e), s;
  if (
    n.profiles.some((u) => {
      let f = i[u];
      return f &&
        (s = {
          profileId: u,
          profilePath: `${e}/${f.path}`,
          deprecated: !!f.deprecated,
        }),
        !!s;
    }), !s
  ) {
    if (!t) throw new Error("No matching profile name found");
    let u = i[t];
    if (!u) {
      throw new Error(
        `No matching profile name found and default profile "${t}" missing.`,
      );
    }
    s = {
      profileId: t,
      profilePath: `${e}/${u.path}`,
      deprecated: !!u.deprecated,
    };
  }
  let o = await QR(s.profilePath), a;
  if (r) {
    let u;
    if (
      n.handedness === "any"
        ? u = o.layouts[Object.keys(o.layouts)[0]]
        : u = o.layouts[n.handedness], !u
    ) {
      throw new Error(
        `No matching handedness, ${n.handedness}, in profile ${s.profileId}`,
      );
    }
    u.assetPath && (a = s.profilePath.replace("profile.json", u.assetPath));
  }
  return { profile: o, assetPath: a };
}
var rU = { xAxis: 0, yAxis: 0, button: 0, state: mn.ComponentState.DEFAULT };
function iU(n = 0, e = 0) {
  let t = n, r = e;
  if (Math.sqrt(n * n + e * e) > 1) {
    let o = Math.atan2(e, n);
    t = Math.cos(o), r = Math.sin(o);
  }
  return { normalizedXAxis: t * .5 + .5, normalizedYAxis: r * .5 + .5 };
}
var $R = class {
    constructor(e) {
      this.componentProperty = e.componentProperty,
        this.states = e.states,
        this.valueNodeName = e.valueNodeName,
        this.valueNodeProperty = e.valueNodeProperty,
        this.valueNodeProperty === mn.VisualResponseProperty.TRANSFORM &&
        (this.minNodeName = e.minNodeName, this.maxNodeName = e.maxNodeName),
        this.value = 0,
        this.updateFromComponent(rU);
    }
    updateFromComponent({ xAxis: e, yAxis: t, button: r, state: i }) {
      let { normalizedXAxis: s, normalizedYAxis: o } = iU(e, t);
      switch (this.componentProperty) {
        case mn.ComponentProperty.X_AXIS:
          this.value = this.states.includes(i) ? s : .5;
          break;
        case mn.ComponentProperty.Y_AXIS:
          this.value = this.states.includes(i) ? o : .5;
          break;
        case mn.ComponentProperty.BUTTON:
          this.value = this.states.includes(i) ? r : 0;
          break;
        case mn.ComponentProperty.STATE:
          this.valueNodeProperty === mn.VisualResponseProperty.VISIBILITY
            ? this.value = this.states.includes(i)
            : this.value = this.states.includes(i) ? 1 : 0;
          break;
        default:
          throw new Error(
            `Unexpected visualResponse componentProperty ${this.componentProperty}`,
          );
      }
    }
  },
  eL = class {
    constructor(e, t) {
      if (
        !e || !t || !t.visualResponses || !t.gamepadIndices ||
        Object.keys(t.gamepadIndices).length === 0
      ) throw new Error("Invalid arguments supplied");
      this.id = e,
        this.type = t.type,
        this.rootNodeName = t.rootNodeName,
        this.touchPointNodeName = t.touchPointNodeName,
        this.visualResponses = {},
        Object.keys(t.visualResponses).forEach((r) => {
          let i = new $R(t.visualResponses[r]);
          this.visualResponses[r] = i;
        }),
        this.gamepadIndices = Object.assign({}, t.gamepadIndices),
        this.values = {
          state: mn.ComponentState.DEFAULT,
          button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
          xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
          yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0,
        };
    }
    get data() {
      return { id: this.id, ...this.values };
    }
    updateFromGamepad(e) {
      if (
        this.values.state = mn.ComponentState.DEFAULT,
          this.gamepadIndices.button !== void 0 &&
          e.buttons.length > this.gamepadIndices.button
      ) {
        let t = e.buttons[this.gamepadIndices.button];
        this.values.button = t.value,
          this.values.button = this.values.button < 0 ? 0 : this.values.button,
          this.values.button = this.values.button > 1 ? 1 : this.values.button,
          t.pressed || this.values.button === 1
            ? this.values.state = mn.ComponentState.PRESSED
            : (t.touched || this.values.button > mn.ButtonTouchThreshold) &&
              (this.values.state = mn.ComponentState.TOUCHED);
      }
      this.gamepadIndices.xAxis !== void 0 &&
      e.axes.length > this.gamepadIndices.xAxis &&
      (this.values.xAxis = e.axes[this.gamepadIndices.xAxis],
        this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis,
        this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis,
        this.values.state === mn.ComponentState.DEFAULT &&
        Math.abs(this.values.xAxis) > mn.AxisTouchThreshold &&
        (this.values.state = mn.ComponentState.TOUCHED)),
        this.gamepadIndices.yAxis !== void 0 &&
        e.axes.length > this.gamepadIndices.yAxis &&
        (this.values.yAxis = e.axes[this.gamepadIndices.yAxis],
          this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis,
          this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis,
          this.values.state === mn.ComponentState.DEFAULT &&
          Math.abs(this.values.yAxis) > mn.AxisTouchThreshold &&
          (this.values.state = mn.ComponentState.TOUCHED)),
        Object.values(this.visualResponses).forEach((t) => {
          t.updateFromComponent(this.values);
        });
    }
  },
  tL = class {
    constructor(e, t, r) {
      if (!e) throw new Error("No xrInputSource supplied");
      if (!t) throw new Error("No profile supplied");
      this.xrInputSource = e,
        this.assetUrl = r,
        this.id = t.profileId,
        this.layoutDescription = t.layouts[e.handedness],
        this.components = {},
        Object.keys(this.layoutDescription.components).forEach((i) => {
          let s = this.layoutDescription.components[i];
          this.components[i] = new eL(i, s);
        }),
        this.updateFromGamepad();
    }
    get gripSpace() {
      return this.xrInputSource.gripSpace;
    }
    get targetRaySpace() {
      return this.xrInputSource.targetRaySpace;
    }
    get data() {
      let e = [];
      return Object.values(this.components).forEach((t) => {
        e.push(t.data);
      }),
        e;
    }
    updateFromGamepad() {
      Object.values(this.components).forEach((e) => {
        e.updateFromGamepad(this.xrInputSource.gamepad);
      });
    }
  },
  sU =
    "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles",
  oU = "generic-trigger",
  nL = class extends ct {
    constructor() {
      super();
      this.motionController = null, this.envMap = null;
    }
    setEnvironmentMap(e) {
      return this.envMap == e ? this : (this.envMap = e,
        this.traverse((t) => {
          t.isMesh &&
            (t.material.envMap = this.envMap, t.material.needsUpdate = !0);
        }),
        this);
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e),
        !!this.motionController && (this.motionController.updateFromGamepad(),
          Object.values(this.motionController.components).forEach((t) => {
            Object.values(t.visualResponses).forEach((r) => {
              let {
                valueNode: i,
                minNode: s,
                maxNode: o,
                value: a,
                valueNodeProperty: u,
              } = r;
              !i ||
                (u === mn.VisualResponseProperty.VISIBILITY
                  ? i.visible = a
                  : u === mn.VisualResponseProperty.TRANSFORM &&
                    (i.quaternion.slerpQuaternions(
                      s.quaternion,
                      o.quaternion,
                      a,
                    ),
                      i.position.lerpVectors(s.position, o.position, a)));
            });
          }));
    }
  };
function aU(n, e) {
  Object.values(n.components).forEach((t) => {
    let { type: r, touchPointNodeName: i, visualResponses: s } = t;
    if (r === mn.ComponentType.TOUCHPAD) {
      if (t.touchPointNode = e.getObjectByName(i), t.touchPointNode) {
        let o = new no(.001), a = new en({ color: 255 }), u = new Ot(o, a);
        t.touchPointNode.add(u);
      } else {console.warn(
          `Could not find touch dot, ${t.touchPointNodeName}, in touchpad component ${t.id}`,
        );}
    }
    Object.values(s).forEach((o) => {
      let {
        valueNodeName: a,
        minNodeName: u,
        maxNodeName: f,
        valueNodeProperty: d,
      } = o;
      if (d === mn.VisualResponseProperty.TRANSFORM) {
        if (
          o.minNode = e.getObjectByName(u),
            o.maxNode = e.getObjectByName(f),
            !o.minNode
        ) {
          console.warn(`Could not find ${u} in the model`);
          return;
        }
        if (!o.maxNode) {
          console.warn(`Could not find ${f} in the model`);
          return;
        }
      }
      o.valueNode = e.getObjectByName(a),
        o.valueNode || console.warn(`Could not find ${a} in the model`);
    });
  });
}
function rL(n, e) {
  aU(n.motionController, e),
    n.envMap && e.traverse((t) => {
      t.isMesh && (t.material.envMap = n.envMap, t.material.needsUpdate = !0);
    }),
    n.add(e);
}
var iL = class {
    constructor(e = null) {
      this.gltfLoader = e,
        this.path = sU,
        this._assetCache = {},
        this.gltfLoader || (this.gltfLoader = new Dg());
    }
    createControllerModel(e) {
      let t = new nL(), r = null;
      return e.addEventListener("connected", (i) => {
        let s = i.data;
        s.targetRayMode !== "tracked-pointer" || !s.gamepad ||
          nU(s, this.path, oU).then(({ profile: o, assetPath: a }) => {
            t.motionController = new tL(s, o, a);
            let u = this._assetCache[t.motionController.assetUrl];
            if (u) r = u.scene.clone(), rL(t, r);
            else {
              if (!this.gltfLoader) throw new Error("GLTFLoader not set.");
              this.gltfLoader.setPath(""),
                this.gltfLoader.load(
                  t.motionController.assetUrl,
                  (f) => {
                    this._assetCache[t.motionController.assetUrl] = f,
                      r = f.scene.clone(),
                      rL(t, r);
                  },
                  null,
                  () => {
                    throw new Error(
                      `Asset ${t.motionController.assetUrl} missing or malformed.`,
                    );
                  },
                );
            }
          }).catch((o) => {
            console.warn(o);
          });
      }),
        e.addEventListener("disconnected", () => {
          t.motionController = null, t.remove(r), r = null;
        }),
        t;
    }
  },
  lU = new iL(),
  QS = new WeakMap();
function sL({ rayMaterial: n = {} }) {
  let { scene: e } = Nn(),
    { controllers: t, hoverState: r } = Ad(),
    [i] = It.default.useState(new Map());
  return Or(() => {
    t.forEach((s) => {
      let o = i.get(s.controller.id);
      if (!o) return;
      let a = r[s.inputSource.handedness].values().next().value;
      if (!a || s.inputSource.handedness === "none") {
        o.visible = !1;
        return;
      }
      let u = a.distance, f = -.01;
      o.visible = !0, o.scale.y = u + f, o.position.z = -u / 2 - f;
    });
  }),
    (0, It.useEffect)(() => {
      let s = [];
      return t.forEach(({ controller: o, grip: a, inputSource: u }) => {
        let f;
        QS.has(o)
          ? f = QS.get(o)
          : (f = lU.createControllerModel(o),
            o.dispatchEvent({ type: "connected", data: u, fake: !0 }),
            QS.set(o, f)), a.add(f);
        let d = new Ot();
        d.rotation.set(Math.PI / 2, 0, 0),
          d.material = new en({
            color: new ve(16777215),
            opacity: .8,
            transparent: !0,
            ...n,
          }),
          d.geometry = new ei(.002, 1, .002),
          i.set(o.id, d),
          o.add(d),
          s.push(() => {
            a.remove(f), o.remove(d), i.delete(o.id);
          });
      }),
        () => {
          s.forEach((o) => o());
        };
    }, [t, e, i, JSON.stringify(n)]),
    null;
}
var Mc = rn(An());
function oL(n, e, t) {
  let { gl: r, size: i, viewport: s } = Nn(),
    o = typeof n == "number" ? n : i.width * s.dpr,
    a = typeof e == "number" ? e : i.height * s.dpr,
    u = (typeof n == "number" ? t : n) || {},
    { samples: f, ...d } = u,
    h = Mc.useMemo(() => {
      let p;
      return p = new yr(o, a, {
        minFilter: kt,
        magFilter: kt,
        encoding: r.outputEncoding,
        type: Yo,
        ...d,
      }),
        p.samples = f,
        p;
    }, []);
  return Mc.useLayoutEffect(() => {
    h.setSize(o, a), f && (h.samples = f);
  }, [f, h, o, a]),
    Mc.useEffect(() => () => h.dispose(), []),
    h;
}
var Er = rn(An());
var uU = (n) => typeof n == "function",
  $S = Er.forwardRef(
    (
      {
        envMap: n,
        resolution: e = 256,
        frames: t = 1 / 0,
        makeDefault: r,
        children: i,
        ...s
      },
      o,
    ) => {
      let a = Nn(({ set: _ }) => _),
        u = Nn(({ camera: _ }) => _),
        f = Nn(({ size: _ }) => _),
        d = Er.useRef(null),
        h = Er.useRef(null),
        p = oL(e);
      Er.useLayoutEffect(() => {
        s.manual || (d.current.aspect = f.width / f.height);
      }, [f, s]),
        Er.useLayoutEffect(() => {
          d.current.updateProjectionMatrix();
        });
      let g = 0, y = null, v = uU(i);
      return Or((_) => {
        v && (t === 1 / 0 || g < t) && (h.current.visible = !1,
          _.gl.setRenderTarget(p),
          y = _.scene.background,
          n && (_.scene.background = n),
          _.gl.render(_.scene, d.current),
          _.scene.background = y,
          _.gl.setRenderTarget(null),
          h.current.visible = !0,
          g++);
      }),
        Er.useLayoutEffect(() => {
          if (r) {
            let _ = u;
            return a(() => ({ camera: d.current })), () =>
              a(() => ({ camera: _ }));
          }
        }, [d, r, a]),
        Er.createElement(
          Er.Fragment,
          null,
          Er.createElement(
            "perspectiveCamera",
            zr({ ref: Ig([d, o]) }, s),
            !v && i,
          ),
          Er.createElement("group", { ref: h }, v && i(p.texture)),
        );
    },
  );
var rs = rn(An());
var e1 = rs.forwardRef(
  (
    {
      makeDefault: n,
      camera: e,
      domElement: t,
      regress: r,
      onChange: i,
      onStart: s,
      onEnd: o,
      ...a
    },
    u,
  ) => {
    let {
        invalidate: f,
        camera: d,
        gl: h,
        events: p,
        set: g,
        get: y,
        performance: v,
        viewport: _,
      } = Nn(),
      S = e || d,
      w = t || p.connected || h.domElement,
      M = rs.useMemo(() => new Ng(S), [S]);
    return Or(() => {
      M.enabled && M.update();
    }, -1),
      rs.useEffect(() => (M.connect(w), () => void M.dispose()), [w, r, M, f]),
      rs.useEffect(() => {
        let T = (b) => {
          f(), r && v.regress(), i && i(b);
        };
        return M.addEventListener("change", T),
          s && M.addEventListener("start", s),
          o && M.addEventListener("end", o),
          () => {
            s && M.removeEventListener("start", s),
              o && M.removeEventListener("end", o),
              M.removeEventListener("change", T);
          };
      }, [i, s, o, M, f]),
      rs.useEffect(() => {
        M.handleResize();
      }, [_]),
      rs.useEffect(() => {
        if (n) {
          let T = y().controls;
          return g({ controls: M }), () => g({ controls: T });
        }
      }, [n, M]),
      rs.createElement("primitive", zr({ ref: u, object: M }, a));
  },
);
var Ma = rn(An());
function aL(n, e, t = new I()) {
  let r = Math.PI * (n - .5), i = 2 * Math.PI * (e - .5);
  return t.x = Math.cos(i), t.y = Math.sin(r), t.z = Math.sin(i), t;
}
var t1 = Ma.forwardRef(
  (
    {
      inclination: n = .6,
      azimuth: e = .1,
      distance: t = 1e3,
      mieCoefficient: r = .005,
      mieDirectionalG: i = .8,
      rayleigh: s = .5,
      turbidity: o = 10,
      sunPosition: a = aL(n, e),
      ...u
    },
    f,
  ) => {
    let d = Ma.useMemo(() => new I().setScalar(t), [t]),
      [h] = Ma.useState(() => new ns());
    return Ma.createElement(
      "primitive",
      zr({
        object: h,
        ref: f,
        "material-uniforms-mieCoefficient-value": r,
        "material-uniforms-mieDirectionalG-value": i,
        "material-uniforms-rayleigh-value": s,
        "material-uniforms-sunPosition-value": a,
        "material-uniforms-turbidity-value": o,
        scale: d,
      }, u),
    );
  },
);
var cU = () =>
    xt.default.createElement(
      "mesh",
      { rotation: [-Math.PI / 2, 0, 0] },
      xt.default.createElement("planeBufferGeometry", {
        attach: "geometry",
        args: [40, 40],
      }),
      xt.default.createElement("meshStandardMaterial", {
        attach: "material",
        color: "#999",
      }),
    ),
  fU = ({ backgroundColor: n, ambientColor: e, directionalLights: t }) => {
    let r = (0, xt.useMemo)(() => new ve(n).convertLinearToSRGB(), [n]);
    Or(({ scene: o }) => {
      o.background = r;
    });
    let { scene: i } = Nn(), s = i.getObjectByName("Center");
    return xt.default.createElement(
      xt.default.Fragment,
      null,
      xt.default.createElement("group", {
        name: "Center",
        position: [0, 0, 0],
        visible: !1,
      }),
      xt.default.createElement("ambientLight", { color: e, intensity: 1.5 }),
      t.map(({ color: o, direction: a }) =>
        xt.default.createElement("directionalLight", {
          key: JSON.stringify(a),
          target: s,
          intensity: 1.7,
          color: o,
          position: a.map((u) => -u),
        })
      ),
    );
  },
  dU = ({ children: n }) => {
    let { controllers: e, isPresenting: t, player: r } = Ad();
    return xt.default.createElement(
      xt.default.Fragment,
      null,
      t && xt.default.createElement(t1, { sunPosition: [0, 1, 0] }),
      t && xt.default.createElement(cU, null),
      xt.default.createElement(
        ZR,
        null,
        xt.default.createElement("group", {
          scale: t ? .025 : 1,
          position: t ? [0, 0, 0] : [0, 1, -1],
        }, n),
      ),
    );
  },
  lL = {
    backgroundColor: "#BBDAED",
    ambientColor: "#555555",
    directionalLights: [{ direction: [1, -1, -.3], color: "#FDFDFD" }, {
      direction: [-1, 0, -.2],
      color: "#B5B5B5",
    }, { direction: [0, 0, -1], color: "#303030" }],
  },
  n1 = (n) => {
    let { x: e, y: t, z: r } = n;
    return [e, t, r];
  },
  uL = (
    {
      forVR: n,
      lighting: e,
      aspect: t,
      sceneCamera: r,
      syncCamera: i,
      trackball: s,
    },
  ) => {
    let [o, a] = (0, xt.useState)(20),
      u = (P) => {
        a(20);
      };
    Or(({ gl: P, scene: C, camera: L }) => {
      o > 0 && (P.render(C, L), a(o - 1));
    }, 1);
    let f = (P) => {
        let C = P.target,
          L = C.object,
          k = n1(L.up),
          z = n1(L.position),
          Y = n1(C.target),
          [le, V, W] = Y.map((fe, pe) => fe - z[pe]),
          G = Math.sqrt(le * le + V * V + W * W),
          re = [le / G, V / G, W / G],
          ie = L.fov * (Math.PI / 180) * L.aspect,
          X = 2 * G * Math.tan(ie / 2),
          $ = L.far,
          ae = L.near;
        i({
          lookAt: Y,
          up: k,
          lookDir: re,
          distance: G,
          width: X,
          far: $,
          near: ae,
        }), a(20);
      },
      {
        near: d,
        far: h,
        width: p,
        distance: g,
        up: y,
        lookAt: v,
        lookDir: _,
        perspective: S,
      } = r,
      M = p / 2 / t,
      T = (0, xt.useMemo)(() => v.map((P, C) => P - g * _[C]), [v, _, g]),
      b = (0, xt.useMemo)(() => 360 * Math.atan(M / g) / Math.PI, [M, g]),
      R = (0, xt.useMemo)(() => ({
        ...lL,
        backgroundColor: e && e.backgroundColor || lL.backgroundColor,
      }));
    return xt.default.createElement(
      xt.default.Fragment,
      null,
      xt.default.createElement($S, {
        makeDefault: !0,
        ...{ fov: b, position: T, up: y },
      }, xt.default.createElement(fU, { ...R })),
      s &&
        xt.default.createElement(e1, {
          onChange: u,
          onEnd: f,
          staticMoving: "true",
          rotateSpeed: 4.5,
          zoomSpeed: 3,
          panSpeed: 1,
          target: v,
        }),
    );
  },
  hU =
    (n) => (n = n || window.event,
      "which" in n ? n.which === 1 : "button" in n ? n.button === 0 : !1),
  cL = (
    {
      lighting: n,
      children: e,
      sceneCamera: t,
      syncCamera: r,
      toolActions: i = {},
      trackball: s = !0,
    },
  ) => {
    let [o, a] = Rg(),
      u = a && a.height ? a.width / a.height : 1,
      { onDrag: f, onDragEnd: d } = i,
      h = (g) => {
        hU(g) && i?.bkgdClick && (g.stopPropagation(), i.bkgdClick());
      };
    return p3()
      ? xt.default.createElement(
        JR,
        { dpr: window.devicePixelRatio, gl: { antialias: !0, alpha: !1 } },
        xt.default.createElement(sL, null),
        xt.default.createElement(uL, {
          forVR: !0,
          ...{ lighting: n, aspect: u, sceneCamera: t, syncCamera: r },
        }),
        xt.default.createElement(dU, null, e),
      )
      : xt.default.createElement(
        Pg,
        {
          ref: o,
          dpr: window.devicePixelRatio,
          gl: { antialias: !0, alpha: !1 },
          onPointerMove: f,
          onPointerUp: d,
          onPointerMissed: h,
        },
        xt.default.createElement(uL, {
          ...{
            lighting: n,
            aspect: u,
            sceneCamera: t,
            syncCamera: r,
            trackball: s,
          },
        }),
        e,
      );
  };
var si = rn(An()), Fg = rn(An());
var pU = (
    {
      id: n,
      position: e,
      rotation: t,
      geometry: r,
      color: i,
      selected: s,
      type: o,
      toolActions: a,
    },
  ) => {
    let u = d3(t),
      { onClick: f, onHover: d, onDragStart: h } = a || {},
      p = (_) => (S) => {
        S.stopPropagation(), d && d(n, e, o, _);
      },
      g = (_) => {
        f && (_.stopPropagation(), f(n, e, o, s));
      },
      y = (_) => {
        h && (_.stopPropagation(), h(n, e, o, s, _));
      },
      v = s ? "#f6f6f6" : "black";
    return si.default.createElement(
      "group",
      { position: e },
      si.default.createElement(
        "mesh",
        {
          matrixAutoUpdate: !1,
          ref: u,
          geometry: r,
          onPointerOver: p(!0),
          onPointerOut: p(!1),
          onClick: g,
          onPointerDown: y,
        },
        si.default.createElement("meshLambertMaterial", {
          attach: "material",
          color: i,
          emissive: v,
        }),
      ),
    );
  },
  mU = ({ shape: n, toolActions: e }) => {
    let t = h3(n);
    return n.instances.length === 0
      ? null
      : si.default.createElement(
        si.default.Fragment,
        null,
        n.instances.map((r) =>
          si.default.createElement(pU, {
            key: r.id,
            ...r,
            geometry: t,
            toolActions: e,
          })
        ),
      );
  },
  fL = (0, Fg.forwardRef)(({ shapes: n, embedding: e, toolActions: t }, r) => {
    let { scene: i } = Nn(), [s, o] = (0, si.useState)(!0);
    Or(({ gl: d, scene: h, camera: p }) => {
      s && (d.render(h, p), o(!1));
    }, 2), (0, si.useEffect)(() => o(!0), [n]);
    let a = {
      exportGltfJson: (d) => {
        new wc().parse(i, (p) => {
          d(JSON.stringify(p, null, 2));
        }, {});
      },
    };
    (0, Fg.useImperativeHandle)(r, () => a);
    let u = () => {}, f = f3(e);
    return n &&
        si.default.createElement(
          "group",
          { matrixAutoUpdate: !1, ref: f, onPointerMissed: u },
          Object.values(n).map((d) =>
            si.default.createElement(mU, {
              key: d.id,
              ...{ shape: d, toolActions: t },
            })
          ),
        ) || null;
  });
var gU = (
    { scene: n, toolActions: e, trackball: t, syncCamera: r, children3d: i },
    s,
  ) =>
    Cd.default.createElement(
      cL,
      {
        lighting: n.lighting,
        sceneCamera: { ...n.camera },
        trackball: t,
        syncCamera: r,
        toolActions: e,
      },
      n.shapes &&
        Cd.default.createElement(fL, {
          ref: s,
          embedding: n.embedding,
          shapes: n.shapes,
          toolActions: e,
        }),
      i,
    ),
  pV = (0, Cd.forwardRef)(gU);
var dL = (n, e) => {
    let t = e + "<" + n.localName;
    for (let { name: i, value: s } of n.attributes) {
      t += " " + i + '="' + s + '"';
    }
    if (n.childElementCount === 0) {
      return t + `/>
`;
    }
    t += `>
`;
    let r = n.textContent;
    if (r) {
      t += e + "  " + r + `
`;
    } else for (let i of n.children) t += dL(i, e + "  ");
    return t += e + "</" + n.localName + `>
`,
      t;
  },
  vU = (n) => {
    let e = dL(n, "");
    return new DOMParser().parseFromString(e, "text/xml").documentElement;
  },
  yU = (n, e) => {
    let t = (a) => {
        let [u, f, d] = [
          parseInt(a.substr(1, 2), 16),
          parseInt(a.substr(3, 2), 16),
          parseInt(a.substr(5, 2), 16),
        ];
        return u + "," + f + "," + d;
      },
      { ambientColor: r, backgroundColor: i, directionalLights: s } = n,
      o = e.createElement("sceneModel");
    o.setAttribute("ambientLight", t(r)), o.setAttribute("background", t(i));
    for (let a of s) {
      let { color: u, direction: f } = a,
        d = e.createElement("directionalLight");
      d.setAttribute("color", t(u)),
        d.setAttribute("x", String(f[0])),
        d.setAttribute("y", String(f[1])),
        d.setAttribute("z", String(f[2])),
        o.appendChild(d);
    }
    return o;
  },
  xU = (n, e) => {
    let {
        near: t,
        far: r,
        width: i,
        distance: s,
        perspective: o,
        lookAt: a,
        lookDir: u,
        up: f,
      } = n,
      d = e.createElement("Viewing"),
      h = e.createElement("ViewModel");
    d.appendChild(h),
      h.setAttribute("distance", String(s)),
      h.setAttribute("far", String(r)),
      h.setAttribute("near", String(t)),
      h.setAttribute("parallel", String(!o)),
      h.setAttribute("stereoAngle", "0.0"),
      h.setAttribute("width", String(i));
    {
      let p = e.createElement("LookAtPoint");
      p.setAttribute("x", String(a[0])),
        p.setAttribute("y", String(a[1])),
        p.setAttribute("z", String(a[2])),
        h.appendChild(p);
    }
    {
      let p = e.createElement("UpDirection");
      p.setAttribute("x", String(f[0])),
        p.setAttribute("y", String(f[1])),
        p.setAttribute("z", String(f[2])),
        h.appendChild(p);
    }
    {
      let p = e.createElement("LookDirection");
      p.setAttribute("x", String(u[0])),
        p.setAttribute("y", String(u[1])),
        p.setAttribute("z", String(u[2])),
        h.appendChild(p);
    }
    return d;
  },
  vV = (n, e, t, r) => {
    let s = new DOMParser().parseFromString(n, "application/xml"),
      o = s.documentElement,
      a = o.getAttribute("field"),
      u = o.childNodes,
      f = document.createElementNS(
        "http://xml.vzome.com/vZome/4.0.0/",
        "vzome:vZome",
      );
    f.setAttribute("field", a),
      f.setAttribute("edition", "online"),
      f.setAttribute("version", "1.0"),
      f.setAttribute("buildNumber", zw),
      f.replaceChildren(...u);
    let d = yU(e, s), h = r.far / r.distance;
    t.far = t.distance * h;
    let p = xU(t, s), g = s.createElement("justToFormat");
    g.appendChild(d), g.appendChild(p);
    let y = vU(g).childNodes;
    f.append(...y), o.replaceWith(f);
    let v = new XMLSerializer();
    return `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
` + v.serializeToString(s);
  },
  yV = (n, e, t) => {
    let r = new Blob([e], { type: t }),
      i = document.createElement("a"),
      s = URL.createObjectURL(r);
    i.setAttribute("href", s),
      i.setAttribute("download", `${n}`),
      i.style.display = "none",
      document.body.appendChild(i),
      i.click(),
      document.body.removeChild(i);
  };
export {
  _U as d,
  An as a,
  e1 as k,
  Ge as i,
  Gi as f,
  I as h,
  MN as e,
  Or as j,
  p3 as l,
  Pn as g,
  pV as m,
  vA as b,
  vV as n,
  yV as o,
  zr as c,
};
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
