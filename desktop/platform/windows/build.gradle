plugins {
  id "edu.sc.seis.launch4j" version "2.4.6"
}

dependencies {
    compile project( ':desktop' )
}

// TODO: By default, this subproject creates a zero byte build\libs\windows-6.0.jar based on the name of the subproject. 
// windows-6.0.jar is not intended to be generated by this project 
// so I want to eventually figure out how to disable generation of it 
// and to avoid distributing it since it's just unnecessary overhead.

// used by launch4j and jre bundling tasks
// The companyName element of versionInfo is supported by launch4j, but not (yet) by the plugin.
ext.companyName = 'Scott Vorthmann'
ext.copyright = "Copyright ${Calendar.getInstance().get(Calendar.YEAR)}, ${companyName}"    // year that generateXmlConfig task is run

ext.l4jCmdPath = project.hasProperty( 'l4jCmdPath' ) ? project.getProperty( 'l4jCmdPath' ) : 'launch4j' // default requires launch4j on the path
ext.l4jxmlFileName = 'launch4j.xml'
ext.l4jOutputBaseFileName = "${rootProject.appName}-Windows-x64-${version}b${rootProject.buildNumber}"
def folderName = "${l4jOutputBaseFileName}"
ext.l4jOutputDir = "launch4j/${folderName}"  // path is relative to buildDir
ext.bundledJrePath = './jre/'               // path is relative to launch4j.outputDir and must start with '.'

// JRE version naming convention based on Oracle's Java version naming convention (e.g. 11.0.5 for Java 11)
ext.jreRevision = 0

// *** THIS IS WHERE THE DEFAULT BUNDLED JRE TARGET VERSION IS CONTROLLED ***
ext.jreBuildNumber = 5 // Default to Java 11.0.5

// allow ext.jreBuildNumber to be overridden by the gradle command line 
// e.g. gradle createExe -PjreBuildOverride=3
//   or gradle distSfx -PjreBuildOverride=3
//   or gradle extraProperties -PjreBuildOverride=3
if( project.hasProperty( 'jreBuildOverride' ) ) {
    project.jreBuildNumber = Integer.parseInt( jreBuildOverride )
}

ext.jreTargetVersion = "${targetCompatibility}.${jreRevision}.${jreBuildNumber}"   // target JRE version   (e.g. 11.0.5)
ext.jrePriorVersion  = "${targetCompatibility}.${jreRevision}.${jreBuildNumber-1}" // target JRE version-1 (e.g. 11.0.5)
// these are used by the zip and distribution tasks after launch4j has run
ext.jreArchiveSourcePath = project.hasProperty( 'jreZips' ) ? project.getProperty( 'jreZips' ) : 'jre/x64' // path is relative to the root of this subproject
ext.jreDistributionPath = "$l4jOutputDir/$bundledJrePath"
ext.win64ZipBaseFileName = "${l4jOutputBaseFileName}"

launch4j {
    xmlFileName = project.l4jxmlFileName
    mainClassName = project.mainClassName
    outputDir = project.l4jOutputDir
    outfile = "${l4jOutputBaseFileName}.exe"
    jar = 'lib/' + project.tasks[JavaPlugin.JAR_TASK_NAME].outputs.files.getSingleFile().name   // path is relative to outputDir
    icon = '../../../../../platform/windows/resources/icons/vZomeLogo.ico'  // path is relative to outputDir
    jreMinVersion = project.jrePriorVersion
    jreMaxVersion = project.jreTargetVersion
    bundledJrePath = project.bundledJrePath // path is relative to launch4j.outputDir
    bundledJre64Bit = true
    jdkPreference = 'jdkOnly' // default is 'preferJre'
    jreRuntimeBits = '64'

    jvmOptions << '-Xmx3072M'
    jvmOptions << '-Dfile.encoding=UTF-8'
    jvmOptions << '-Ddefault.charset=UTF-8'
	// Most of the rootProject.jvmArgs have apple in the name. Exclude those...
	rootProject.project('desktop').jvmArgs.each { entry ->
		if(!entry.key.contains("apple.")) {
			jvmOptions << "-D${entry.key}=${entry.value}"
		}
	}
	cmdLine = ''
	def sp = ''
	rootProject.project('desktop').vzomeArgs.each { entry ->
		cmdLine = cmdLine + "${sp}${entry}"
		sp = ' '
	}

    // Several of the plugin property names don't exactly match the corresponding XML element.
    companyName = project.companyName 
    version = project.version
    textVersion = project.version
    copyright = project.copyright
    fileDescription = 'Generates virtual zome 3D models'
    productName = rootProject.name
    internalName = rootProject.name
}

// msg is only displayed if the gradle logging level is set with command line parameter '--info' or '--debug'
// so use logInfo instead of println
def logInfo(msg) {
    getLogger().info msg
}

task cleanJre {
    outputs.upToDateWhen {
        return !( new File(project.jreDistributionPath).exists() );
    }
    doLast() {
        delete project.jreDistributionPath
        logInfo "Deleting JRE distribution directory: ${jreDistributionPath}"
    }
    group = 'Build'
    description = "Removes the JRE distribution directory."
}
// This dependency is not really needed as long as jreDistributionPath is under $BuildDir but it doesn't hurt.
clean.dependsOn cleanJre

task cleanDistributions {
    def folder = "${buildDir}/distributions"
    outputs.upToDateWhen {
        return !( new File(folder).exists() );
    }
    doLast() {
        delete folder
        logInfo "Deleting installer distribution directory: ${folder}"
    }
    group = 'Build'
    description = "Removes the installer distribution directory."
}
// This dependency is not really needed as long as folder is under $BuildDir but it doesn't hurt.
clean.dependsOn cleanDistributions

task extractWin64Jre(type: Sync) {
    def src = "${jreArchiveSourcePath}/jdk-${jreTargetVersion}.zip"
    def dst = "${buildDir}/${jreDistributionPath}"
    from zipTree(src)
    into dst
    doLast() {
        if(getDidWork()) {
            logInfo "Extracting JRE from $src into $dst"
        }
    }
    group = 'Windows Distribution'
    description = "Unzips the Windows 64-bit JRE from ${src} into the bundled JRE path."
}

task zipWin64Distribution(type: Zip) {
    def src = "${buildDir}/launch4j"
    from src
        exclude "${folderName}/${launch4j.xmlFileName}"
    baseName = win64ZipBaseFileName
    extension = 'zip'
    // explicitly set the archiveName rather than using the default which appends the version
    archiveName = baseName + '.' + extension

    doLast() {
        if(getDidWork()) {
            logInfo "Zipping ${src}\n   into ${archivePath}"
        }
    }
    group = 'Windows Distribution'
    description = 'Generates the 64-bit Windows zip file distribution.'
    dependsOn { [ "createExe", "extractWin64Jre" ] }
}

task createWin64sfxInstaller(type: FileConcatTask) {
    // First source file MUST be unzipsfx-x64.exe which is extracted directly from unzipsfx.zip.
    // Second source file is the output of zipWin64Distribution
    // Note that the zipTree call is wrapped in closure so that configuration is only resolved at execution time.
    source = files(
        ( { zipTree('../../platform/windows/tools/unzipsfx/unzipsfx.zip').matching { include 'unzipsfx-x64.exe' } } ), 
        "${zipWin64Distribution.archivePath}"
    )
    destination = "${zipWin64Distribution.archivePath}".replace('.zip', '.exe')
    doLast() {
        println "Generated self-extracting zip installer ${getDestination()}"
    }
    
    group = 'Windows Distribution'
    description = 'Generates the 64-bit Windows self-extracting installer.'
    dependsOn zipWin64Distribution
}

task distSfx {
    group = 'Windows Distribution'
    description = 'Primary task to be invoked for creating the self-extracting installer with launch4j and subsequent build steps.'
    dependsOn createWin64sfxInstaller
}

class FileConcatTask extends SourceTask {
    private destination
    @OutputFile File getDestination() { project.file(destination) }
    void setDestination(destination) { this.destination = destination }

    @TaskAction
    void doBinaryFileConcat() {
        logInfo 'Concatenating:'
        getDestination().withOutputStream { out ->
            getSource().files.each {
                logInfo("  +-<<--- ${it.name}")
                it.withInputStream { out << it }
            }
        }
        logInfo '  |'
        logInfo "  +--->>> ${getDestination()}"
    }
    
    public void logInfo(String msg) {
        getLogger().info(msg)
    }
}

// extra properties of subprojects are not shown if this task is moved to the root project.
task extraProperties {
    doLast {
        for(Project proj : rootProject.getAllprojects()) {
            if(!proj.ext.properties.isEmpty()) {
                println "[${proj.name}] extra properties:"
                proj.ext.properties.sort( { it.key } ).each { entry ->
                    println "    $entry.key = $entry.value"
                }
            }
        }
    }
    group = 'Help'
    description = "Displays the 'extra' properties of the [${project.name}] project and its parent project(s)."
}
