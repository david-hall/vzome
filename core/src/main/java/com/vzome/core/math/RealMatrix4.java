package com.vzome.core.math;

public class RealMatrix4
{
    private final float m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33;
    
    /**
     * @param m 16 elements in row-major order
     */
    public RealMatrix4( float[] m )
    {
        m00 = m[ 0]; m01 = m[ 1]; m02 = m[ 2]; m03 = m[ 3];
        m10 = m[ 4]; m11 = m[ 5]; m12 = m[ 6]; m13 = m[ 7];
        m20 = m[ 8]; m21 = m[ 9]; m22 = m[10]; m23 = m[11];
        m30 = m[12]; m31 = m[13]; m32 = m[14]; m33 = m[15];
    }
    
    /**
     * @param m 16 elements in column-major order
     */
    public RealMatrix4( float[] m, boolean transpose )
    {
        m00 = m[ 0]; m01 = m[ 4]; m02 = m[ 8]; m03 = m[12];
        m10 = m[ 1]; m11 = m[ 5]; m12 = m[ 9]; m13 = m[13];
        m20 = m[ 2]; m21 = m[ 6]; m22 = m[10]; m23 = m[14];
        m30 = m[ 3]; m31 = m[ 7]; m32 = m[11]; m33 = m[15];
    }

    /**
     * 
     * @param v 4th component treated as 1
     * @return
     */
    public RealVector transform3dPt( RealVector v )
    {
        return new RealVector(
                m00*v.x + m01*v.y + m02*v.z + m03,
                m10*v.x + m11*v.y + m12*v.z + m13,
                m20*v.x + m21*v.y + m22*v.z + m23
                );
    }

    /**
     * 
     * @param v 4th component treated as 0
     * @return
     */
    public RealVector transform3dVec( RealVector v )
    {
        return new RealVector(
                m00*v.x + m01*v.y + m02*v.z,
                m10*v.x + m11*v.y + m12*v.z,
                m20*v.x + m21*v.y + m22*v.z
                );
    }

    public float[] transform4d( float[] v )
    {
        float x = m00*v[0] + m01*v[1] + m02*v[2] + m03*v[3];
        float y = m10*v[0] + m11*v[1] + m12*v[2] + m13*v[3];
        float z = m20*v[0] + m21*v[1] + m22*v[2] + m23*v[3];
        float w = m30*v[0] + m31*v[1] + m32*v[2] + m33*v[3];
        return new float[] { x, y, z, w };
        
    }

    /**
     * Helping function that specifies the position and orientation of a
     * view matrix. The inverse of this transform can be used to control
     * the ViewPlatform object within the scene graph.
     * @param eye the location of the eye
     * @param center a point in the virtual world where the eye is looking
     * @param up an up vector specifying the frustum's up direction
     */
    public static RealMatrix4 lookAt( RealVector eye, RealVector center, RealVector up )
    {
        float forwardx,forwardy,forwardz,invMag;
        float upx,upy,upz;
        float sidex,sidey,sidez;

        forwardx =  eye.x - center.x;
        forwardy =  eye.y - center.y;
        forwardz =  eye.z - center.z;

        invMag = (float) (1.0/Math.sqrt( forwardx*forwardx + forwardy*forwardy + forwardz*forwardz));
        forwardx = forwardx*invMag;
        forwardy = forwardy*invMag;
        forwardz = forwardz*invMag;


        invMag = (float) (1.0/Math.sqrt( up.x*up.x + up.y*up.y + up.z*up.z));
        upx = up.x*invMag;
        upy = up.y*invMag;
        upz = up.z*invMag;

        // side = Up cross forward
        sidex = upy*forwardz-forwardy*upz;
        sidey = upz*forwardx-upx*forwardz;
        sidez = upx*forwardy-upy*forwardx;

        invMag = (float) (1.0/Math.sqrt( sidex*sidex + sidey*sidey + sidez*sidez));
        sidex *= invMag;
        sidey *= invMag;
        sidez *= invMag;

        // recompute up = forward cross side

        upx = forwardy*sidez-sidey*forwardz;
        upy = forwardz*sidex-forwardx*sidez;
        upz = forwardx*sidey-forwardy*sidex;

        // transpose because we calculated the inverse of what we want
        float m00 = sidex;
        float m01 = sidey;
        float m02 = sidez;

        float m10 = upx;
        float m11 = upy;
        float m12 = upz;

        float m20 =  forwardx;
        float m21 =  forwardy;
        float m22 = forwardz;

        float m03 = -eye.x * m00 + -eye.y * m01 + -eye.z * m02;
        float m13 = -eye.x * m10 + -eye.y * m11 + -eye.z * m12;
        float m23 = -eye.x * m20 + -eye.y * m21 + -eye.z * m22;

        return new RealMatrix4( new float[] { m00,m01,m02,m03, m10,m11,m12,m13, m20,m21,m22,m23, 0,0,0,1 } );
    }

    /**
     * Creates a perspective projection transform that mimics a standard,
     * camera-based,
     * view-model.  
     * (From javax.media.j3d.Transform3d.java)
     * This transform maps coordinates from Eye Coordinates (EC)
     * to Clipping Coordinates (CC).  Note that unlike the similar function
     * in OpenGL, the clipping coordinates generated by the resulting
     * transform are in a right-handed coordinate system
     * (as are all other coordinate systems in Java 3D). Also note that the
     * field of view is specified in radians.
     * @param fovx specifies the field of view in the x direction, in radians
     * @param aspect specifies the aspect ratio and thus the field of
     * view in the x direction. The aspect ratio is the ratio of x to y,
     * or width to height.
     * @param zNear the distance to the frustum's near clipping plane.
     * This value must be positive, (the value -zNear is the location of the
     * near clip plane).
     * @param zFar the distance to the frustum's far clipping plane
     */
    public static RealMatrix4 perspective( float fovx, float aspect, float zNear, float zFar )
    {
        float sine, cotangent, deltaZ;
        float half_fov = fovx * 0.5f;

        deltaZ = zFar - zNear;
        sine = (float) Math.sin(half_fov);
        cotangent = (float) (Math.cos(half_fov) / sine);

        float m00 = cotangent;
        float m11 = cotangent * aspect;
        float m22 = (zFar + zNear) / deltaZ;
        float m23 = 2.0f * zNear * zFar / deltaZ;
        float m32 = -1.0f;
        
        return new RealMatrix4( new float[] { m00, 0,0,0,0, m11, 0,0,0,0, m22, m23, 0,0, m32, 0 } );
    }


    /**
     * Creates an orthographic projection transform that mimics a standard,
     * camera-based,
     * view-model.  
     * (From javax.media.j3d.Transform3d.java)
     * This transform maps coordinates from Eye Coordinates (EC)
     * to Clipping Coordinates (CC).  Note that unlike the similar function
     * in OpenGL, the clipping coordinates generated by the resulting
     * transform are in a right-handed coordinate system
     * (as are all other coordinate systems in Java 3D).
     * @param left the vertical line on the left edge of the near
     * clipping plane mapped to the left edge of the graphics window
     * @param right the vertical line on the right edge of the near
     * clipping plane mapped to the right edge of the graphics window
     * @param bottom the horizontal line on the bottom edge of the near
     * clipping plane mapped to the bottom edge of the graphics window
     * @param top the horizontal line on the top edge of the near
     * clipping plane mapped to the top edge of the graphics window
     * @param near the distance to the frustum's near clipping plane
     * (the value -near is the location of the near clip plane)
     * @param far the distance to the frustum's far clipping plane
     */
    public static RealMatrix4 ortho( float left, float right, float bottom,
            float top, float near, float far )
    {
        float deltax = 1/(right - left);
        float deltay = 1/(top - bottom);
        float deltaz = 1/(far - near);

        float m00 = 2.0f * deltax;
        float m03 = -(right + left) * deltax;
        float m11 = 2.0f * deltay;
        float m13 = -(top + bottom) * deltay;
        float m22 = 2.0f * deltaz;
        float m23 = (far + near) * deltaz;
        float m33 = 1;
        return new RealMatrix4( new float[] { m00, 0f, 0f, m03, 0f, m11, 0f, m13, 0f, 0f, m22, m23, 0f, 0f, 0f, m33 } );
    }

    public float[] toArray()
    {
        return new float[] { m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33 };
    }
}
